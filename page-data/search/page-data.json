{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"2025-02-24","fields":{"slug":"/2025-02/"},"frontmatter":{"date":"2025년 02월 24일 22:02","title":"2025년 02월","tags":["2025"]},"rawMarkdownBody":"\n- [[2025-02-24]]"},{"excerpt":"LOG 반년만에 돌아온 TIL. 블친 여러분 안녕하십니까. 자존감 도둑으로 인해 강제로 다시 돌아온 TIL. 처음부터 다시 시작하는 마음으로 해봅시다. 오늘부터 러닝을 시작했다. 첫 날이니 가볍게(?) 20분 뛰었다. 사실 나한텐 안 가벼웠음… 그래도 2.4키로 정도 뛰었던데 생각보다 많이 뛰어서 놀랐음. 작심삼일이 되지 않도록 내일도 파이팅. 패러프레이…","fields":{"slug":"/2025-02-24/"},"frontmatter":{"date":"2025년 02월 24일 21:02","title":"2025년 02월 24일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 반년만에 돌아온 TIL. 블친 여러분 안녕하십니까. 자존감 도둑으로 인해 강제로 다시 돌아온 TIL. 처음부터 다시 시작하는 마음으로 해봅시다.\n- 오늘부터 러닝을 시작했다. 첫 날이니 가볍게(?) 20분 뛰었다. 사실 나한텐 안 가벼웠음… 그래도 2.4키로 정도 뛰었던데 생각보다 많이 뛰어서 놀랐음. 작심삼일이 되지 않도록 내일도 파이팅.\n- 패러프레이징 사이트 만들고 있는데, 오늘 거의 완성한 거 같다. 아직 디자인이 마음에 안 들기는 하지만, 사실상 지금 배포해도 문제는 없다. 고민이 되기는 한다. 그냥 몰래 나 혼자 쓸까… 아니면 일 키워서 홍보도 하고 운영도 할까… 지금은 의욕이 없어서 홍보하기 귀찮다는 마음이 좀 더 큰 거 같다. 뭔지 궁금한 사람은 연락하세요.\n## 배운 것\n\n## 느낀 것\n\n- 남들보다 강건하지 않은 나. 다시 2년 전과 유사한 이유로 TIL 을 다시 쓰게 되었다는 게 나에게 조금 안타깝다. 근데 이제는 TIL 이 치료제(?) 라는 건 아니까 다행인건가 ㅋㅋ\n- 다시 돌아온 인생 노잼 시기. 다들 대체 이런 시기를 어떻게 극복하는 걸까. 나는 이런 생각이 들 때마다 풍랑에 올라탄 조각배 마냥 이리저리 흔들리는데. 알다가도 모를 일이다.\n- 왜 이렇게 무언가를 오랫동안, 꾸준히 좋아하는 게 어려울까. 무언가를 사랑한다는 것은 노력 없이 얻을 수 있는 손 쉬운 결과가 아니다. 내가 사랑하고 싶은 날도, 사랑하고 싶지 않은 날도 꾸준히 사랑해야 얻을 수 있는 거였다. 근데 나는 내 마음이 내키는 날만 사랑하고 싶어서 문제였나 보다. 내가 좋아하던 건데 왜 이렇게 하기 싫을까? 나는 그냥 오늘이 사랑하고 싶지 않은 날이라 그렇다는 결론을 내렸다. 그런 날 마저도, 그런 나 마저도 사랑해야 정말 즐거울 수 있나 보다. 솔직히 안 해봐서 모르겠다. 자신도 없고. 계속 이렇게 안 즐겁고 안 재밌으면 어떡하지, 라는 고민을, 2년 전에 똑같이 했던 고민을, 털어내버렸다 자만했던 그 생각을, 오늘도 똑같이 또 한다. 지긋지긋하다."},{"excerpt":"Garbage Collection 이란? 어떤 객체들이 사용되고, 어떤 객체들이 사용되지 않는지를 확인하고, 사용되지 않는 객체들을 제거하는 힙 메모리 탐색 과정이다. 사용중인 객체란 프로그램이 해당 객체로의 포인트를 관리하고 있음을 의미하고, 사용되지 않는 객체란 프로그램에서 더 이상 참조되지 않는 객체를 의미한다. Marking 첫 번째 과정은 ‘ma…","fields":{"slug":"/garbage-collection/"},"frontmatter":{"date":"2024년 08월 30일 10:08","title":"Garbage Collection in Java","tags":["java"]},"rawMarkdownBody":"\n## Garbage Collection 이란?\n\n어떤 객체들이 사용되고, 어떤 객체들이 사용되지 않는지를 확인하고, 사용되지 않는 객체들을 제거하는 힙 메모리 탐색 과정이다. 사용중인 객체란 프로그램이 해당 객체로의 포인트를 관리하고 있음을 의미하고, 사용되지 않는 객체란 프로그램에서 더 이상 참조되지 않는 객체를 의미한다.\n\n### Marking\n\n첫 번째 과정은 ‘marking’ 이다. GC 가 어떤 메모리 조각이 사용 중이고 어떤 조각이 사용 중이지 않은지를 확인하는 것이다. \n\n![[gc-marking.png]]\n\n시스템의 모든 객체를 스캔해야 하는 경우, 시간이 많이 소요될 수 있다.\n\n### Normal Deletion\n\n참조되지 않은 객체들을 제거하는 과정이다.\n\n![[gc-normal-deletion.png]]\n\n#### Deletion with Compacting\n\n추가적으로 성능을 향상하기 위해, 참조되지 않은 객체들을 제거할 때 남아있는 참조 객체들의 메모리를 압축할 수 있다. 이로써 새로운 메모리 할당이 더욱 쉽고 빨라진다.\n\n![[gc-deletion-with-compacting.png]]\n\n#### Why Generational Garbage Collection?\n\n모든 객체를 한 번에 mark 하고 압축하는 것은 비효율적이다. 그러나 경험적 분석에 따르면 대부분의 객체는 수명이 짧은 것으로 조사되었다. 시간이 지남에 따라 점점 적은 객체들이 할당된 채로 남겨진다. 사실상 대부분의 객체들은 매우 짧은 life time 을 갖는다.\n\n###\n\n## Garbage Collector 는 어디에 위치해 있는가?\n\n\n## Serial Garbage Collector\n\n기본적으로 단일 스레드로 작동하는 가장 간단한 GC 구현이다. 이 GC 는 실행할 때 모든 애플리케이션 스레드를 정지시키므로, 서버 환경과 같은 멀티스레드 애플리케이션에서는 사용하지 않는 것이 좋다.\n\nSerial Garbage Collector 는 일시 정지 시간이 짧고, 클라이언트형 시스템에서 실행되는 대부분의 애플리케이션에서 선택하는 Garbage Collector 이다.\n\n### Mark-Sweep-Compact 알고리즘\n\n- [i] 힙의 가장 앞 부분이란 **메모리 주소의 시작 부분**을 의미한다. Java 의 힙 메모리는 일반적으로 낮은 메모리 주소에서 높은 메모리 주소로 성장하기 때문이다.\n- [!] 객체 할당 시점과는 무관하게 힙 메모리의 물리적인 주소 순서에 따라 객체를 조사하고 처리한다. 실제 객체 할당은 힙 메모리 내에서 어떤 위치에서든 이루어질 수 있고, 메모리 allocator 에 의해 특정 메모리 블록이 할당된다. \n\n## Parallel Garbage Collector\n\nJava 5 부터 Java 8 까지 JVM 의 기본 GC 로, Throughput Collectors 라고도 불린다. 여러 스레드를 사용하여 힙 공간을 관리하지만, GC 를 수행하는 동안 다른 애플리케이션 스레드를 정지시킨다. \n\n## G1 Garbage Collector\n\nGarbage First Garbage Collector 는 메모리 공간이 큰 멀티프로세서 시스템에서 실행되는 애플리케이션을 위해 설계되었다. JDK7 Update 4 이후 release 에서 사용할 수 있다. \n\nG1 수집기는 힙을 동일한 크기의 힙 영역 집합으로 분할하여 각각 인접한 범위의 가상 메모리로 분할한다. GC 를 수행할 때 G1 은 힙 전체에서 객체의 활성도를 결정하기 위해 동시 글로벌 마킹 단계를 표시한다. 마킹 단계가 완료된 후 G1 은 어느 영역이 대부분 비어 있는지 파악하고, 상당한 양의 여유 공간을 확보한다. (swiping)\n\n## Z Garbage Collector\n\nZGC 는 확장 가능한 저지연 GC 로, Java 11 에서 처음 도입되었다. JDK 14 에서는 Windows 및 MacOS 운영체제에서 ZGC 를 도입하였다. Java 15 이후로부터 정식 버전으로 채택되었다.\n\nZGC 는 애플리케이션 스레드 실행을 10ms 이상 중단하지 않고 모든 고비용 작업을 동시에 수행하므로 짧은 지연 시간이 필요한 애플리케이션에 적합하다. 스레드가 실행중일 때, 컬러 포인터가 있는 로드 배리어를 사용하여 동시 작업을 수행하며, 힙 사용량을 추적하는데 사용된다.\n\nReference coloring (color pointer) 는 ZGC 의 핵심 개념으로, 참조의 일부 비트(메타데이터 비트)를 사용하여 객체의 상태를 표시한다. 8MB 에서 16TB 크기의 힙도 처리할 수 있다. 또한 일시 중지 시간이 힙, live set, root set 크기에 따라 증가하지 않는다. \n\n### Multi-Mapping\n\nMulti-Mapping 이란 가상 메모리에 물리적 메모리의 동일한 주소를 가리키는 특정 주소가 있다는 것을 의미한다. 애플리케이션은 가상 메모리를 통해 데이터에 액세스하게 된다.\n\n### Relocation\n\n동적 메모리 할당을 사용할 때, 일반적인 애플리케이션의 메모리는 시간이 지남에 따라 조각화된다. 메모리 중간에 있는 객체를 해제하면 그 자리에 여유 공간이 남기 때문이다.  \n\n이제 중간의 틈을 새로운 객체로 채우려면 메모리에 객체를 저장할 수 있을 만큼 큰 여유 공간이 있는지 스캔해야 한다. 이 작업은 메모리를 할당할 때마다 수행해야 하는 경우 비용이 많이 드는 작업이다. 다른 방법으로는 조각난 메모리 영역에서 빈 공간으로 객체를 자주 재배치하여 더 압축된 형식으로 관리하는 것이다. 보다 효과적인 방법을 위해 메모리 공간을 블록으로 분할하고, 한 블록에 있는 모든 객체를 재배치하거나 전혀 재배치하지 않는다. 이런 방식을 사용하면 메모리에 전체 빈 블록이 있다는 것을 알기 때문에 메모리 할당이 더욱 빨라질 수 있다.\n\n### ZGC Concepts\n\nZGC 는 가능한 한 짧은 stop-the-world 단계를 제공하기 위해, 이러한 일시 중지의 지속 시간이 힙 크기에 따라 증가하지 않는 방식을 사용한다. 따라서 ZGC 는 대용량 힙이 일반적이고 빠른 애플리케이션 응답 시간이 요구되는 서버 애플리케이션에 적합하다.\n\nZGC 는 도달 가능한 객체를 찾는 Marking 을 통해 참조 상태를 참조 비트로 저장하는 ‘Reference coloring’ 을 사용한다. 이때, 객체에 대한 메타데이터를 저장하기 위해 참조 비트를 설정하면 상태 비트가 객체의 위치에 대한 정보를 보유하지 않기 때문에 여러 참조가 동일한 객체를 가리킬 수 있다. ZGC 는 이를 ‘Multi-Mapping’ 으로 해결한다.\n\nZGC 는 메모리 단편화를 줄이기 위해 Relocation 을 사용한다. 힙이 크면 재배치 속도가 느려지는데, 이를 해결하기 위해 대부분의 Relocation 을 애플리케이션과 병렬로 수행한다. 이때, 애플리케이션과 병렬로 GC 를 실행하는 경우에 애플리케이션이 이전 주소를 통해 해당 객체에 접근하려 시도할 수 있다. ZGC 는 이 문제를 ‘Load Barrier’ 를 통해 해결한다. \n\nLoad barrier 는 스레드가 힙에서 참조를 로드할 때 실행된다. 참조의 메타데이터 비트를 확인하여, ZGC 참조를 가져오기 전에 일부 처리를 수행할 수 있다. 즉, 완전히 다른 참조가 생성될 수 있는 것이다. 이를 ‘Remapping’ 이라고 한다.\n\n### Marking\n\n1. stop-the-world: 루트 참조(힙의 객체에 도달하기 위한 시작점)를 찾아서 표시한다. 일반적으로 루트 참조의 수는 적기 때문에, 해당 단계는 짧은 시간 동안 이루어질 수 있다.\n2. concurrent: 루트 참조에서 시작하여 객체 그래프를 횡단하며 도달하는 모든 객체에 marking 을 수행한다. 또한 load barrier 가 표시되지 않은 참조를 감지하면 해당 참조도 표시한다.\n3. 엣지 케이스 처리를 위한 stop-the-world\n\n### Reference Coloring\n\n참조는 가상 메모리의 바이트 위치를 나타낸다. 그러나 이를 위해 참조의 모든 비트를 사용할 필요는 없고, 일부 비트가 참조의 속성을 나타낼 수 있는데 이를 ‘Reference Coloring’ 이라고 한다.\n\n32 bit 로는 4GB 밖에 처리할 수 없기 때문에, ZGC 는 64 bit refrence 를 사용한다. 즉, 64 bit 플랫폼에서만 ZGC 를 사용할 수 있다.\n\nZGC 참조는 주소 자체를 표현하기 위해서는 42 bit 를 사용하는데, 이를 통해 4TB 의 메모리 공간을 주소로 지정할 수 있게 된다. \n\n참조 상태 저장을 위한 비트는 총 4개가 존재한다.\n\n- finalizable bit: 객체가 finalizer 를 통해서만 도달 가능하다.\n- remap bit: 참조는 최신 상태이며, 객체의 현재 위치를 가리킨다.\n- marked0 또는 marke1: 도달 가능한 객체를 표시하는 데 사용한다.\n\n이러한 비트들을 메타데이터 비트라고 한다.\n\n### Relocation\n\nZGC 에서 relocation 은 다음과 같은 과정을 따른다.\n\n1. concurrent phase 에서 이전해야 하는 블록을 찾은 뒤 relocation set 에 넣는다.\n2. stop-the-world phase 는 모든 루트 참조를 relocation set 으로 이전하고, 그들의 참조를 업데이트한다.\n3. relocation set 에 존재하는 객체들을 모두 이전하고, 이전 주소와 새 주소 간의 매핑을 forwarding table 에 저장한다.\n4. 남아있는 참조들의 rewriting 은 다음 marking 단계에서 이루어진다. 이렇게 하면 Object tree 를 두 번 순회할 필요가 없다. 또는 load barrier 를 통해서도 가능하다.\n\n### Remapping and Load Barriers\n\nload barrier 는 remapping 으로 재배치된 객체를 가리키는 참조를 수정한다. 애플리케이션이 참조를 로드하면 load barrier 가 트리거 되고, 다음 단계에 따라 올바른 참조를 반환한다. \n\n1. Remapping bit 가 1로 설정되어 있는지 확인한다. \n\t1. 만약 그렇다면 참조가 최신 상태이므로 안전하게 반환할 수 있다.\n2. 참조된 객체가 relocation set 에 있는지를 확인한다.\n\t1. 만약 그렇지 않다면 remapping 을 원하지 않는다는 뜻이다. 다음에 이 참조를 로드할 때 해당 검사를 피하기 위해 remapping 비트를 1로 설정하고 업데이트된 참조를 반환한다.\n3. 액세스하려는 객체가 재배치 대상임을 알게 되었으니, 재배치 여부를 확인한다.\n\t1. 객체가 재배치되었다면 다음 단계로 건너뛴다.\n\t2. 그렇지 않다면 지금 재배치하고, forwarding 테이블에 항목을 생성하여 재배치된 각 객체의 새 주소를 저장한다.\n4. 이제 오브젝트가 재배치되었음을 알 수 있다. 전달 테이블에서 조회하여 해당 참조를 객체의 새 위치로 업데이트하고, remapping bit 를 설정한 다음 참조를 반환한다.\n\n이런 단계를 거쳐 객체에 액세스하려고 할 때마다 가장 최근의 참조를 가져올 수 있도록 한다. 참조를 로드할 때마다 load barrier 가 트리거되기 때문에, 애플리케이션 성능이 저하될 수 있다. (특히 재배치된 객체에 처음 접근할 때 더욱 저하될 수 있다.) 이것이 짧은 일시 중지 시간을 위한 trade-off 이다. (이런 단계는 비교적 빠르게 처리되므로 애플리케이션 성능에는 큰 영향을 미치지 않을 수 있다.)\n\n## 출처\n\n- https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n- https://www.baeldung.com/jvm-garbage-collectors\n- https://www.oracle.com/java/technologies/javase/gc-tuning-6.html\n- [ZGC OpenJDK wiki](https://wiki.openjdk.org/display/zgc/Main#Main-QuickStart)"},{"excerpt":"LOG 오늘은 친절한 독일 이웃 Max 와 Grace 를 만났다. 친절한 Googler 이웃을 어떻게 만나게 되었는지 나도 의문이다… 저녁으로 터키 음식을 먹으러 갔는데 심지어 사주셨다!!! 다음에 꼭 집에서 저녁을 대접해야겠다고 생각했다. 만나러 갈 때는 무슨 얘기할 지 걱정했는데 이런저런 이야기하면서 되게 재미있게 대화하다 왔던 거 같다. 가는 길에 …","fields":{"slug":"/2024-08-30/"},"frontmatter":{"date":"2024년 08월 30일 09:08","title":"2024년 08월 30일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 오늘은 친절한 독일 이웃 Max 와 Grace 를 만났다. 친절한 Googler 이웃을 어떻게 만나게 되었는지 나도 의문이다… 저녁으로 터키 음식을 먹으러 갔는데 심지어 사주셨다!!! 다음에 꼭 집에서 저녁을 대접해야겠다고 생각했다. 만나러 갈 때는 무슨 얘기할 지 걱정했는데 이런저런 이야기하면서 되게 재미있게 대화하다 왔던 거 같다. 가는 길에 한국에서도 안 해본 병맥주 사서 걸어가기를 해봤다 ㅋㅋㅋ Max 는 도로에 있는 기둥으로 맥주를 딸 줄 안다 ㄷㄷ German 들은 다 잘한다고 하는데 신기하다. 내일 Farmer’s market 에 치즈를 같이 사러 가기로 했는데 기대된다 ㅎㅎ\n- 9월 2일 출근 전에 옷을 샀다. 사실 뭐 입어야 할 지 모르겠지만 그냥 괜찮아보이는 반팔 트위드 자켓을 샀다. 근데 캐주얼하게 입어도 된다고 하기도 하고… 아직 뭐 입을지 잘 모르겠다.\n\n## 오늘의 외국어\n\n- späti: 맥주 파는 편의점. 베를린에서는 24시간 열 수 있다고 한다. 근데 legal 인지는 모르겠음.\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"LOG 인터넷이 돌아왔다 흑흑 오늘의 외국어 배운 것 느낀 것","fields":{"slug":"/2024-08-27/"},"frontmatter":{"date":"2024년 08월 27일 09:08","title":"2024년 08월 27일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 인터넷이 돌아왔다 흑흑\n\n## 오늘의 외국어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"2024-08-20 2024-08-24 2024-08-25 2024-08-26 2024-08-27 2024-08-30","fields":{"slug":"/2024-08/"},"frontmatter":{"date":"2024년 08월 27일 09:08","title":"2024년 08월","tags":["2024"]},"rawMarkdownBody":"\n- [[2024-08-20]]\n- [[2024-08-24]]\n- [[2024-08-25]]\n- [[2024-08-26]]\n- [[2024-08-27]]\n- [[2024-08-30]]"},{"excerpt":"LOG 아침부터 인터넷이 잘 안 됐다. 인터넷에 전적으로 의지하는 사람들로써 굉장히 큰일이다… 처음에는 로봇청소기가 라우터를 건드렸나 의심했는데 (ㅋㅋ) 그 친구는 무죄였다. 지금이 오후 3시인데 아직도 돌아오지 않고 있다. 제발 다시 돌아와ㅏ~~ 인터넷의 여파로 블루투스로 열리는 문이 안 열렸다;;; 우리는 물리 키가 없어서 어쩔 수 없이 이웃 분에게 …","fields":{"slug":"/2024-08-26/"},"frontmatter":{"date":"2024년 08월 26일 13:08","title":"2024년 08월 26일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 아침부터 인터넷이 잘 안 됐다. 인터넷에 전적으로 의지하는 사람들로써 굉장히 큰일이다… 처음에는 로봇청소기가 라우터를 건드렸나 의심했는데 (ㅋㅋ) 그 친구는 무죄였다. 지금이 오후 3시인데 아직도 돌아오지 않고 있다. 제발 다시 돌아와ㅏ~~\n- 인터넷의 여파로 블루투스로 열리는 문이 안 열렸다;;; 우리는 물리 키가 없어서 어쩔 수 없이 이웃 분에게 초인종을 눌러 문을 열어달라고 부탁드렸다. 다행히 누군가가 안에서 나오셔서 열어주셨다. 오늘 진짜 더운 날이었는데 얼른 들어갈 수 있어 다행이다.\n- 아침 겸 점심으로 벼르고 벼르던 카이막 집에 갔다. 독일이라 카이막이 한국보다 조금 덜 비싸지 않을까 하고 갔는데 역시나 비쌌다..ㅋㅋㅋㅋ 그래도 예상한 만큼 맛있었다.\n- 집 근처에 있는 키보드 타건샵에 갔다. 진짜 직이는 키감의 키보드가 있었는데 그 친구는 커스텀 키보드라 보강판부터 사야해서 너무 비쌌다;;; 그래서 그 친구랑 느낌이 거의 비슷한 다른 키보드를 샀는데 너무 마음에 든다. **기종은 Nuphy 의 Halo65**. 축은 안 물어봐서 모르겠는데 느낌이 저소음 적축인 거 같기도 하고. 오빠는 바밀로 Aurora 를 샀다. 아쉽게도 키캡은 남아있는 재고 중에 예쁜게 없어서 못 샀다. 내 키보드 키캡은 마음에 들어서 한동안은 바꾸지 않을 거 같다. 햄보캐\n- tax id 언제 나와!!!!!!\n\n## 오늘의 외국어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"LOG 오랜만에 회고 모임에 참석했다. 독일 이사한 이야기, 독일에 와서 느꼈던 친절함에 대한 이야기를 했다. 마우어파크 플리마켓에 놀러갔다. 그릴 굽는 곳 쪽은 진짜 연기가 매캐해서 숨쉬기 어려웠다 ㅋㅋㅋ 아이스크림도 하나 먹었다. 나중에는 소르베를 먹어봐야지 오늘부터 브이로그를 찍어보기로 했다. 솔직히 꾸준히 올릴 자신은 없는데, 그래도 일단 찍어봤다…","fields":{"slug":"/2024-08-25/"},"frontmatter":{"date":"2024년 08월 25일 12:08","title":"2024년 08월 25일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 오랜만에 회고 모임에 참석했다. 독일 이사한 이야기, 독일에 와서 느꼈던 친절함에 대한 이야기를 했다.\n- 마우어파크 플리마켓에 놀러갔다. 그릴 굽는 곳 쪽은 진짜 연기가 매캐해서 숨쉬기 어려웠다 ㅋㅋㅋ 아이스크림도 하나 먹었다. 나중에는 소르베를 먹어봐야지\n- 오늘부터 브이로그를 찍어보기로 했다. 솔직히 꾸준히 올릴 자신은 없는데, 그래도 일단 찍어봤다. 그런데 편집은 언제 하려나…\n\n## 오늘의 외국어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"코틀린의 싱글톤이란? 코틀린에서는  키워드를 사용하여 다른 객체가 해당 객체의 복사본을 인스턴스화할 수 없도록 하는 싱글톤 객체를 만들 수 있다. 아래와 같이 선언된  객체는 전역적으로 접근할 수 있다. 그런데 해당 클래스를 컴파일 하면 다음과 같은 class 파일을 얻을 수 있다.  함수는  로 선언되었고,","fields":{"slug":"/kotlin-singleton/"},"frontmatter":{"date":"2024년 08월 24일 15:08","title":"코틀린 싱글톤","tags":["kotlin"]},"rawMarkdownBody":"\n## 코틀린의 싱글톤이란?\n\n코틀린에서는 `object` 키워드를 사용하여 다른 객체가 해당 객체의 복사본을 인스턴스화할 수 없도록 하는 싱글톤 객체를 만들 수 있다. 아래와 같이 선언된 `Singleton` 객체는 전역적으로 접근할 수 있다.\n\n```kotlin\nobject Singleton {  \n    fun print() {  \n        println(\"Singleton\")  \n    }  \n}\n```\n\n그런데 해당 클래스를 컴파일 하면 다음과 같은 class 파일을 얻을 수 있다.\n\n```\n// IntelliJ API Decompiler stub source generated from a class file  \n// Implementation of methods is not available  \n  \npublic object Singleton {  \n    public final fun print(): kotlin.Unit { /* compiled code */ }  \n}\n```\n\n`print` 함수는 `final` 로 선언되었고, "},{"excerpt":"2장 코틀린 기초 코틀린의 if 는 statement 가 아니고 expression 이다. 식이 본문인 함수의 반환 타입은 생략할 수 있다.  참조 자체는 불변이더라도 참조가 가리키는 객체의 내부 값은 변경될 수 있다. (Java 와 동일) 여러 클래스를 한 파일에 넣을 수 있고 파일의 이름도 마음대로 정할 수 있다. 어느 디렉터리에 소스코드 파일을 위치…","fields":{"slug":"/kotlin-in-action/"},"frontmatter":{"date":"2024년 08월 24일 13:08","title":"Kotlin In Action","tags":["kotlin","book"]},"rawMarkdownBody":"\n## 2장 코틀린 기초\n\n- 코틀린의 if 는 statement 가 아니고 expression 이다.\n- 식이 본문인 함수의 반환 타입은 생략할 수 있다. \n- `val` 참조 자체는 불변이더라도 참조가 가리키는 객체의 내부 값은 변경될 수 있다. (Java 와 동일)\n- 여러 클래스를 한 파일에 넣을 수 있고 파일의 이름도 마음대로 정할 수 있다. 어느 디렉터리에 소스코드 파일을 위치시키든지 상관없다. (그러나 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다)\n- `when` 문의 분기의 끝에 `break` 를 넣지 않아도 된다.\n- `when` 식의 인자로는 어떤 객체든 사용할 수 있다.\n- 어떤 변수가 원하는 타입인지 검사하고 나면 변수를 원하는 타입으로 캐스팅하지 않아도 원하는 타입으로 선언된다. (스마트 캐스트)\n- `throw`  는 식이다.\n- 체크 예외가 존재하지 않는다.\n\n## 3장 함수 정의와 호출\n\n- 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스다.\n- 유틸리티 클래스 이름 없이 함수를 선언할 수 있다.\n- 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.\n- 확장함수 안에서는 클래스 내부에서만 사용할 수 있는 private 멤버나 protected 멤버를 사용할 수 없다. 단 확장 함수는 단지 정적 메서드 호출에 대한 문법적 편의일 뿐이다.\n\t- 확장 함수가 정적 메서드와 같은 특징을 가지므로 확장 함수를 하위 클래스에서 오버라이드할 수는 없다.\n- 코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다.\n- 함수를 중위 호출에 사용하게 허용하고 싶으면 `infix` 변경자를 함수 선언 앞에 추가해야 한다.\n\n## 4장 클래스, 객체, 인터페이스\n\n- `sealed` 변경자는 클래스 상속을 제한한다.\n- 코틀린에서는 `override` 변경자를 꼭 사용해야 한다.\n- 코틀린의 클래스와 메서드는 기본적으로 `final` 이다.\n- 어떤 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 한다.\n\t- 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메서드는 기본적으로 열려있기 때문에 오버라이드하지 못하게 막으려면 `final` 을 명시해야 한다.\n- 코틀린의 기본 가시성은 `public` 이다.\n- 코틀린의 `protected` 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.\n- `sealed` 클래스는 자동으로 `open` 이다.\n- 부 생성자는 `constructor` 키워드로 시작한다.\n- 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다. 또한 게터와 세터가 있는 프로퍼티를 선언할 수도 있다.\n- == 가 두 객체를 비교하는 기본적인 방법이다. 내부적으로 `equals` 호출함.\n\t- 참조 비교를 위해서는 === 연산자를 사용할 수 있다.\n- 싱글턴을 ‘객체 선언’ 이라는 기능으로 제공한다."},{"excerpt":"LOG 오늘은 택배를 받아야 돼서 밖에 못 나갈 예정이다 ㅋㅋㅋ 그렇지만 이렇게 택배 잘 받을 수 있는 아마존 프라임에 건배 🥂 어제 배달 온 스틸케이스 시리즈 1에 앉아서 글쓰고 있다. 솔직히 말하자면 비싼 의자라고 해서 뭐가 다른지는 잘 모르겠긴 하다…ㅋㅋㅋ 그래도 척추 건강을 위해 투자라고 생각하자 어제 계좌 개설하려고 postident 하러 갔는데…","fields":{"slug":"/2024-08-24/"},"frontmatter":{"date":"2024년 08월 24일 13:08","title":"2024년 08월 24일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 오늘은 택배를 받아야 돼서 밖에 못 나갈 예정이다 ㅋㅋㅋ 그렇지만 이렇게 택배 잘 받을 수 있는 아마존 프라임에 건배 🥂\n- 어제 배달 온 스틸케이스 시리즈 1에 앉아서 글쓰고 있다. 솔직히 말하자면 비싼 의자라고 해서 뭐가 다른지는 잘 모르겠긴 하다…ㅋㅋㅋ 그래도 척추 건강을 위해 투자라고 생각하자\n- 어제 계좌 개설하려고 postident 하러 갔는데 안멜둥 접수 서류도 안 가져가고 여권에 태어난 도시도 안 적혀 있는데 해주셨다 🥹 독일 인종차별 있대서 걱정했는데 여기 도착한 뒤로 친절한 사람들만 만난 것 같아 감사하다.\n- 모니터가 왔다!!!!!!!! 4K 모니터 진짜 좋다 ㄷㄷㄷㄷ\n\n## 오늘의 외국어\n\n## 배운 것\n\n- 오랜만에 공부했다. 예전에 읽던 [[kotlin-in-action]]을 읽기 시작했다.\n\n## 느낀 것"},{"excerpt":"LOG 택배 두 개를 더 받았다. 드디어 선풍기가 왔다…!!! 이제 더위는 안녕 👋🏻 오빠가 안멜둥 테어민을 내일 걸로 잡아서 내일 안멜둥을 하러 간다. 두근두근. 드디어 베를린 거주자가 되는 것인가 오늘의 외국어 schon: already 배운 것 느낀 것","fields":{"slug":"/2024-08-20/"},"frontmatter":{"date":"2024년 08월 20일 10:08","title":"2024년 08월 20일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 택배 두 개를 더 받았다. 드디어 선풍기가 왔다…!!! 이제 더위는 안녕 👋🏻\n- 오빠가 안멜둥 테어민을 내일 걸로 잡아서 내일 안멜둥을 하러 간다. 두근두근. 드디어 베를린 거주자가 되는 것인가\n\n## 오늘의 외국어\n\n- schon: already\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"Web Server HTTP 요청을 받아 정적 컨텐츠들을 제공하는 서버. 단순하게 저장된 웹 리소스들을 클라이언트로 전달하고, 클라이언트로부터 컨텐츠를 전달받아 저장하거나 처리한다. 사용자로부터 동적인 요청이 들어왔을 때, 요청을 Web Application Server 로 보내고 Web Application Server 가 처리한 결과를 클라이언트에게 …","fields":{"slug":"/ws-and-was/"},"frontmatter":{"date":"2024년 07월 03일 11:07","title":"WS vs WAS","tags":null},"rawMarkdownBody":"\n## Web Server\n\nHTTP 요청을 받아 정적 컨텐츠들을 제공하는 서버.  \n\n단순하게 저장된 웹 리소스들을 클라이언트로 전달하고, 클라이언트로부터 컨텐츠를 전달받아 저장하거나 처리한다. 사용자로부터 동적인 요청이 들어왔을 때, 요청을 Web Application Server 로 보내고 Web Application Server 가 처리한 결과를 클라이언트에게 전달한다.\n\n대표적인 웹 서버의 종류로는 Apache, Nginx, IIS 등이 있다.\n\n## Web Application Server\n\n다양한 서버 내 알고리즘, 비즈니스 로직, DB 조회 등 클라이언트 요청에 따라 동적인 컨텐츠를 제공하는 서버, 프로그램.  \n\n웹 서버가 할 수 있는 기능 대부분이 WAS 에서도 처리가 가능하다. \n\n## 차이점\n\nWS 는 정적인 데이터를 처리하는 데 주로 사용된다. 이미지나 단순 html 파일 같은 정적 리소스를 클라이언트에게 전달할 때, WAS 만을 이용할 때보다 빠르고 안정적으로 기능을 수행할 수 있다.  \nWAS 는 동적인 데이터를 주로 처리하는 서비스이다. DB 와 연결되어 사용자와 데이터를 주고받고, 조작이 필요한 경우에 WAS 를 사용한다.\n"},{"excerpt":"2023년 1번 NVCC Thrust  block, shared guided loop variables 2번  12  3번 A  The individual code blocks are distributed over the threads B parallel 블록 내부에서만 접근 가능하다. C  variables are initialized to their …","fields":{"slug":"/multicore-final-exam/"},"frontmatter":{"date":"2024년 06월 17일 08:06","title":"멀티코어 기말고사 문제 풀이","tags":["multicore","school"]},"rawMarkdownBody":"\n## 2023년\n\n### 1번\n\n- NVCC\n- Thrust\n- `omp_get_thread_num`\n- block, shared\n- guided\n- loop variables\n\n### 2번\n\n1. `omp_set_thread_num(NUM)`\n2. 12\n3. `private(x)`\n\n### 3번\n\n#### A\n\n`#pragma omp parallel sections`\n\nThe individual code blocks are distributed over the threads\n\n#### B\n\nparallel 블록 내부에서만 접근 가능하다.\n\n#### C\n\n`firstprivate` variables are initialized to their value before the parallel section\n\n### 4번\n\n### 5번\n\n-  (i) The serious problem:\n\t- **Too many threads**\n\n-  (ii) Why?:\n\t- **Excessive parallelism overwhelms resources**\n\n## 2013\n\n### 1번\n\n1. Synchronization\n2. Conditional Variables\n3. be blocked / wait\n4. independent\n5. divide\n6. merge\n7. data parallel\n8. pthread_join\n9. pthread_exit\n\n### 2번\n\nThere are several ways in which a pthread may be terminated\n- The thread returns from its starting routine (the main routine for the initial thread)\n- The thread is canceled is terminated due to making a call to either the `exec()` or `exit()`\n- The thread makes a call to the `pthread_exit` subroutine\n- If main() finishes first, without calling `pthread_exit` explicitly itself\n\n### 5번\n\n`#pragma omp parallel for reduction(+:sum) private(x)`\n\n## 2018\n\n### 1번\n\n1. warp\n2. `__global__`\n3. void\n4. `__host__`\n5. `__device`\n6. shared memory\n7. block\n8. private\n9. Mutual Exclusion\n10. block\n11. return\n12. `pthread_join`  `pthread_exit`\n\n### 2번\n\n- `parallel for shared(m, n, a, b, c) private(i, j, sum)`\n```cpp\nfor (i = 0; i<m; i++) {\n\tint temp = 0;\n\tfor(j = 0; j<n; j++) {\n\t\ttemp = temp + b[i*N+j] * c[j];\n\t}\n\t a[i] = temp;\n}\n```\n\n### 3번\n\n- blockIdx\n- threadIdx\n- blockDim\n- threadDim\n\n### 4번\n\n- chunk size n 인 round-robin\n- n 개씩 동적으로 \n- chunk size 가 최소 n까지 줄어든다\n\n### 5번\n\n```\n왼쪽 q1 찾기\n오른쪽 q2 binary search\nq3 위치 계산\nA[q3] = T[q1]\nspawn Par-Merge()\nspawn Par-Merge()\nsync\n```\n\n### 6번\n\n- a\n- b: cudaMalloc\n- c: stencil1D\n\n## 2017\n\n### 1번\n\n- General Purpose GPU\n- device\n- host\n- execution configuration (block, thread)\n- SIMD\n- shared\n- loop\n- private\n\n### 2번\n\n- A: thread_id\n- B: pthread status code\n\n### 3번\n\n`reduction(+:sum)`\n\n### 4번\n\n- if n ≤ \bappropriate 숫자 일 때 sorting\n\n### 5번\n\n- prefix\n\n### 6번\n\nCUDA!\n\n## 2016\n\n### 1번\n\n- block\n- shared\n- sections\n- shared\n- loop\n- private\n\n### 2번\n\n### 3번\n\n### 4번\n\n- floor (p1 + r1 / 2)\n```\nif n >= 30\n\tsorting other algorithm\nelse\n\t\n```\n\n### 5번\n\n```\ndouble start = omp_get_wtime()\ndouble end = omp_get_wtime()\n```\n\n## 2015\n\n### 1번\n\n- loop\n- undefined\n- SMID\n- execution configuration\n\t- call by host\n\t- execute in device\n\t- return status void\n- block\n- pthread_join\n- pthread_exit\n\n### 2번\n\n`#pragma parallel for reduction(+:sum)`\n\n### 3번\n\n### 4번\n\n- shared\n- destination, source, size, device memory\n\n### 5번\n\n## 2014\n\n### 1번\n\n- shared memory\n- warp\n- Scalability\n- load balancing\n- a power of two\n- loop variable\n\n### 2번\n\n- \n\n### 3번\n\n"},{"excerpt":"LOG 탑싯 성적은 560점이다 !! 이제 졸업,, 가능해,, 아침 7시 테어민 실패 ㅠ 오늘의 영어 배운 것 느낀 것","fields":{"slug":"/2024-06-17/"},"frontmatter":{"date":"2024년 06월 17일 01:06","title":"2024년 06월 17일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 탑싯 성적은 560점이다 !! 이제 졸업,, 가능해,,\n- 아침 7시 테어민 실패 ㅠ\n\n## 오늘의 영어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"LOG 어제의 테어민 폭풍 서치를 마치고 오늘은 좀 진정이 됐다. 어쩔 수 없지… 내일부터 다시 테어민 도전이다!!!! 아잣자… 오늘의 영어 배운 것 느낀 것","fields":{"slug":"/2024-06-16/"},"frontmatter":{"date":"2024년 06월 16일 09:06","title":"2024년 06월 16일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 어제의 테어민 폭풍 서치를 마치고 오늘은 좀 진정이 됐다. 어쩔 수 없지… 내일부터 다시 테어민 도전이다!!!! 아잣자…\n\n## 오늘의 영어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"2024-06-16","fields":{"slug":"/2024-06/"},"frontmatter":{"date":"2024년 06월 16일 09:06","title":"2024년 06월","tags":["TIL"]},"rawMarkdownBody":"\n- [[2024-06-16]]"},{"excerpt":"Count-To-Infinity 문제 주로 네트워크에서 링크가 끊어지거나 특정 경로가 더 이상 유효하지 않을 때 발생할 수 있다. 이 문제는 벨만-포드 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜에서 잘못된 경로 정보가 무한대로 증가하면서 전파되는 상황이다. 특히, 라우터들이 자신의 경로 정보를 주기적으로 이웃 라우터들과 교환하는 방식에서 발생할 수 있…","fields":{"slug":"/count-to-infinity-problem/"},"frontmatter":{"date":"2024년 05월 28일 07:05","title":"count-to-infinity","tags":["network","school"]},"rawMarkdownBody":"\n## Count-To-Infinity 문제\n\n주로 네트워크에서 링크가 끊어지거나 특정 경로가 더 이상 유효하지 않을 때 발생할 수 있다.  \n이 문제는 벨만-포드 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜에서 잘못된 경로 정보가 무한대로 증가하면서 전파되는 상황이다. 특히, 라우터들이 자신의 경로 정보를 주기적으로 이웃 라우터들과 교환하는 방식에서 발생할 수 있다.\n\n### 시나리오 (given by GPT)\n\n1. **네트워크 설정**:\n- 라우터 A, B, C가 직선 형태로 연결되어 있습니다.\n- 초기 경로는 A - B - C로 구성되며, 각 링크의 가중치는 1입니다.\n2. **링크 실패**:\n- A와 B 사이의 링크가 끊어집니다.\n- B와 C는 여전히 서로 연결되어 있습니다.\n3. **라우터의 동작**:\n- 링크가 끊어진 후, 라우터 A는 B로 가는 경로가 더 이상 유효하지 않다는 것을 인지합니다.\n- 라우터 A는 무한대 값(∞)으로 B로의 경로를 설정합니다.\n4. **라우팅 업데이트**:\n- 라우터 B는 여전히 C로 가는 유효한 경로를 가지고 있으며, A로부터의 경로가 업데이트되지 않았음을 인지하지 못합니다.\n- B는 A로의 경로가 무한대(∞)임을 모르고, C로부터 받은 경로를 사용하여 A로 가는 경로를 업데이트합니다. (A -> B -> C)\n5. **경로 갱신**: \n- 라우터 B는 A에게 자신이 C를 통해 A로 갈 수 있다고 잘못된 정보를 보냅니다.\n- 라우터 A는 B로부터 받은 정보를 기반으로 다시 경로를 업데이트하고, 이 과정이 반복됩니다.\n- 이 과정에서 각 라우터는 잘못된 경로 정보를 가지고 반복적으로 업데이트를 수행하여, 경로 길이가 무한대까지 증가하게 됩니다.\n\n## 해결하기 위한 기법들\n\n### Split Horizon\n\n라우터가 특정 경로 정보를 그 정보를 받은 방향으로 다시 보내지 않도록 한다. 이를 통해 잘못된 경로 정보의 순환을 방지할 수 있다.  \n\n#### Example\n\n- 라우터 A가 B로부터 받은 경로 정보를 다시 B에게 보내지 않는다.\n- A가 C를 통해 B로의 경로 정보를 받았다면, A는 B에게 C를 통해 B로의 경로가 있다고 말하지 않는다.\n\n### Split Horizon with Poison Reverse\n\nSplit Horizon 기법을 강화한 방법이다. 라우터가 특정 경로 정보를 무한대 값으로 설정하여 해당 경로가 유효하지 않음을 명시적으로 알린다. "},{"excerpt":"6in4 IPv6 패킷을 IPv4 패킷으로 캡슐화하여 IPv4 네트워크를 통해 IPv6 트래픽을 전달하는 프로토콜. 정적 터널링 방식으로, 터널의 끝점을 미리 정의하여 사용한다. 터널 소스와 목적지 IP 주소를 수동으로 설정해야 한다. 장점 간단하고 효율적이며, 설정이 쉽다. 단점 터널 끝점이 고정되어 있어 유연하지 않다. Teredo NAT 환경에서 I…","fields":{"slug":"/ipv4-ipv6-tunneling-protocol/"},"frontmatter":{"date":"2024년 05월 24일 07:05","title":"IPv6 트래픽을 IPv4 네트워크를 통해 전송하기 위한 터널링 프로토콜","tags":["network"]},"rawMarkdownBody":"\n## 6in4\n\nIPv6 패킷을 IPv4 패킷으로 캡슐화하여 IPv4 네트워크를 통해 IPv6 트래픽을 전달하는 프로토콜. 정적 터널링 방식으로, 터널의 끝점을 미리 정의하여 사용한다. 터널 소스와 목적지 IP 주소를 수동으로 설정해야 한다. \n\n- 장점\n\t- 간단하고 효율적이며, 설정이 쉽다.\n- 단점\n\t- 터널 끝점이 고정되어 있어 유연하지 않다.\n\n```bash\ninterface Tunnel0\n  ipv6 address 2001:db8::1/64\n  tunnel source 192.0.2.1\n  tunnel destination 198.51.100.1\n  tunnel mode ipv6ip\n```\n\n## Teredo\n\nNAT 환경에서 IPv6 연결을 제공하는 터널링 프로토콜. 공용 IPv4 인터넷을 통해 IPv6 패킷을 터널링한다. IPv6 패킷을 UDP로 캡슐화하여 IPv4 네트워크를 통해 전송한다. NAT 뒤에 있는 호스트가 IPv6 인터넷에 연결해야 할 때 사용할 수 있다. 클라이언트는 Teredo 서버에 연결하여 IPv6 주소를 할당받고, 터널을 설정한다.\n\n클라이언트가 Teredo 서버와 연결하여 공용 IPv4 주소와 포트를 획득하고, Teredo 릴레이를 통해 IPv6 인터넷에 연결한다.\n\n- 장점\n\t- NAT 환경에서 자동으로 작동하여 설정이 간편하다.\n- 단점\n\t- 성능이 낮을 수 있고, 보안 이슈가 있을 수 있다.\n\n## ISATAP (Intra-Site Automatic Tunnel Addressing Protocol)\n\nIPv4 네트워크 내에서 IPv6 트래픽을 자동으로 터널링하는 프로토콜. 내부 네트워크에서 IPv6 호스트 간의 연결을 용이하게 한다. IPv6 패킷을 IPv4 헤더로 감싸서 전송한다. 내부 IPv4 네트워크에서 IPv6 통신을 자동으로 설정할 때 사용할 수 있다. \n\n- 장점\n\t- 자동 구성으로 관리가 용이하다.\n- 단점\n\t- 외부 네트워크로의 연결에는 적합하지 않다.\n\n```bash\ninterface Tunnel0\n  no ip address\n  tunnel source 192.0.2.1\n  tunnel mode ipv6ip isatap\n  ipv6 address 2001:db8::1/64\n```\n\n## GRE (Generic Routing Encapsulation)\n\n다양한 네트워크 계층 프로토콜을 캡슐화할 수 있는 범용 터널링 프로토콜. 멀티 프로토콜 환경에서 사용될 수 있다. 다양한 네트워크 계층 프로토콜을 캡슐화하여 전송한다. 여러 프로토콜을 캡슐화해야 하는 경우, IPv6-over-IPv4 뿐 아니라 다른 프로토콜도 포함한다. 터널 소스와 목적지 IP 주소를 설정해야 한다.\n\n- 장점\n\t- 다목적 사용이 가능하고, 다양한 프로토콜을 지원한다.\n- 단점\n\t- 추가적인 오버헤드가 발생할 수 있다.\n\n```bash\ninterface Tunnel0\n  ip address 10.0.0.1 255.255.255.0\n  tunnel source 192.0.2.1\n  tunnel destination 198.51.100.1\n  tunnel mode gre ip\n  ipv6 address 2001:db8::1/64\n```"},{"excerpt":"Introduction to Multicore Computing Multicore Processor A single computing component with two or more independent cores Core: computing unit that reads / executes program instructions Multiple cores …","fields":{"slug":"/2024-multicore/"},"frontmatter":{"date":"2024년 04월 22일 06:04","title":"멀티코어컴퓨팅","tags":["school"]},"rawMarkdownBody":"\n## Introduction to Multicore Computing\n\n### Multicore Processor\n\n- A single computing component with two or more independent cores\n- Core: computing unit that reads / executes program instructions\n- Multiple cores run multiple instructions at the same time (concurrently)\n- Increase overall program speed (performance)\n- performance gained by multi-core processor\n- desktop PCs, mobile devices, servers\n\n### Manycore processor (GPU)\n\n- multi-core architectures with an especially high number of cores (thounds)\n- CUDA\n\t- Compute Unified Device Architecture\n- OpenCL\n\n### Thread / Process\n\n- Both: independent sequence of execution\n- Process: run in seperate memory space\n- Thread\n\t- run in shared memory space in a process\n\t- One process may have multiple threads\n- Multithreaded Program\n\t- a program running with multiple threads that is executed simultaneously\n\n### What is Parallel Computing?\n\n- Parallel computing\n\t- using multiple processors in parallel to solve problems more quickly than with a single processor\n- Examples of parallel machines:\n\t- A **cluster computer** that contains multiple PCs combined together with a high speed network\n\t- A shared memory multiprocessor by connecting multiple processors to a single memory system\n\t- A chip Multi-Processor (CMP) contains multiple processors (called cores) on a single chip\n- Concurrent execution comes from desire for performance; unlike the inherent concurrency in a multi-user distributed system\n\n### Parallelism vs Concurrency\n\n- Parallel Programming\n\t- Using additional computational resources to produce an answer faster\n\t- Problem of using extra resources effectively?\n\t- Ex. summing up all the numbers in an array with multiple n processors\n- Concurrent Programming\n\t- Correctly and efficiently controlling access by multiple threads to shared resources\n\t- Problem of preventing a bad interleaving of operations from different threads\n- Example\n\t- Implementation of dictionary with hashtable\n\t\t- operations insert, update, lookup, delete occur simultaneously (concurently)\n\t\t- Multiple threads acceess the same hashtable\n\t- Web Visit Counter\n- Often used interchangeably\n- In practice, the distinction between parallelism and concurrency is not absolute\n- Many multithreaded programs have aspects of both\n\n### Parallel Programming Techniques\n\n- Shared Memory\n\t- OpenMP, pthreads\n- Distributed Memory (several computer 로 나눠지지만, processor 는 다른 컴퓨터의 memory 에 직접 접근하지는 못함)\n\t- MPI\n- Distributed / Shared Memory (Share memory 를 가지고 있지만, 직접 접속은 할 수 없음)\n\t- Hybrid (MPI + OpenMP)\n- GPU Parallel Programming\n\t- CUDA Programming\n\t- OpenCL\n\n### Parallel Processing Systems\n\n- Small-Scale Multicore Environment\n\t- Notebook, Workstation, Server\n\t- OS supports multicore\n\t- POSIX threads (pthread), win32 thread\n\t- GPGPU-based supercomputer\n\t- Development of CUDA/OpenCL/GPGPU\n- Large-Scale Multicore Environment\n\t- Supercomputer: more than 10000 cores\n\t- Clusters\n\t- Servers\n\t- Grid Computing\n\n### Parallel Computing vs Distributed Computing\n\n- Parallel Computing\n\t- all processors may have access to a shared memory to exchange information between processors.\n\t- more tightly coupled to multi-threading\n- Distributed Computing\n\t- multiple computers communicate through network\n\t- each processor has its own private memory (distributed memory)\n\t- executing sub-tasks on different machines and then merging the results. (Each computer has a sub-result)\n- Distributed 는 parallel 의 한 종류이다.\n- No Clear Distinction\n\n### Cluster Computing vs Grid Computing\n\n- Cluster Computing\n\t- a set of loosely connected computers that work together so that in many respects they can be viewed as a single system\n\t- good price / performance\n\t- memory not shared\n- Grid Computing\n\t- federation of computer resources from multiple locations to reach a common goal (a large scale distributed system)\n\t- grid tend to be more loosely coupled, heterogeneous, and geographically dispersed\n\n### Cloud Computing\n\n- shares networked computing resources rather than having local servers or personal devices to handle applications\n- “Cloud” is used as a metaphor for “Internet” meaning “a type of Internet-based computing”\n- different services - such as servers, storage and applications - are delivered to an user’s computers and smart phones through the Internet.\n\n### Good Parallel Program\n\n- Writing good parallel programs\n\t- Correct\n\t- Good Performance\n\t- Scalability\n\t- Load Balance\n\t- Portability\n\t- Hardware Specific Utilization\n\n### Characteristics of Distributed System \n-  Resource Sharing: It is the ability to use any Hardware, Software, or Data anywhere in the System. \n- Openness: It is concerned with Extensions and improvements in the system (i.e., How openly the software is developed and shared with others) \n- Concurrency: It is naturally present in Distributed Systems, that deal with the same activity or functionality that can be performed by separate users who are in remote locations. Every local system has its independent Operating Systems and Resources. \n- Scalability: It increases the scale of the system as a number of processors communicate with more users by accommodating to improve the responsiveness of the system. \n- Fault tolerance: It cares about the reliability of the system if there is a failure in Hardware or Software, the system continues to operate properly without degrading the performance of the system\n- Transparency: It hides the complexity of the Distributed Systems to the Users and Application programs as there should be privacy in every system. \n- Heterogeneity: Networks, computer hardware, operating systems, programming languages, and developer implementations can all vary and differ among dispersed system components.\n\n#### Challenges of Distributed Systems \n\n- Network latency: The communication network in a distributed system can introduce latency, which can affect the performance of the system. \n- Distributed coordination: Distributed systems require coordination among the nodes, which can be challenging because of the distributed nature of the system. \n- Data consistency: Maintaining data consistency across multiple nodes in a distributed system can be challenging.\n\n### Advantages \n1. High Performance \n\ta. Distributed systems can outperform centralised systems by utilising the capabilities of several computers to handle the demand.\n2. Reliable \n\ta. In terms of failures, distributed systems are significantly more dependable than single systems. Even if a single node fails, it does not affect the remaining servers. Other nodes can continue to operate normally. \n3. Scalable \n4. Expandability \n5. Availability \n6. Reduced latency (short distance) \n\ta. Low latency is achieved using distributed systems. If a node is closer to the user, the distributed system ensures that traffic from that node reaches the system. As a result, the user may realise that it takes significantly less time to serve them. \n7. Secure \n\ta. Distributed systems include security safeguards that prevent data breaches and illegal access to any data, hardware or software of an organization. \n8. Cost-effectiveness \n\ta. Distributed systems, despite their high expense of implementation, are reasonably cost-effective in the long term. In contrast to a mainframe computer, which is made up of multiple processors, a distributed system is made up of several computers working together. This infrastructure is significantly less expensive than a mainframe system. \n9. Geographic Distribution a. A feature of a distributed system is geographic distribution. It allows companies and organisations to provide users with services in different areas.\n\n#### Disadvantages \n1. High cost. \n2. The problem is finding the fault. \n3. More space is needed. \n4. The increased infrastructure is needed. \n5. In distributed systems, it is challenging to provide adequate security because both the nodes and the connections must be protected.\n\n### Moore’s Law: Review\n\n- Doubling of the number of transistors on integrated circuits roughly every two years.\n- Microprocessors have become smaller, denser, and more powerful.\n- processing speed, memory capacity, sensors and even the number and size of pixels in digital cameras. All of these are improving at (roughly) exponenetial rates\n\n### Computer Hardware Trend\n\n- Chip density is continuing increase ~2x every 2years\n\t- Clock speed is not increasing anymore (in high clock speed, power consumption and heat generation is too high to be tolerated)\n\t- number of cores may double instead\n- No more hidden parallelism to be found\n- Transistor number still rising\n- Clock speed flattening sharply.\n=> Need Multicore programming!\n\n- All computers are now parallel computers.\n- Multi-core processors represent an important new trend in computer architecture.\n\t- Decreased power consumption and heat generation\n\t- Minimized wire lengths and interconnect latencies.\n- They enable tru thread-level parallelism with great energy efficiency and scalability.\n\n## Why writing (fast) parallel programs is hard\n\n### Principles of Parallel Computing\n\n- Finding enough parallelism (Amdahl’s Law)\n- granularity\n- Locality\n- Load balance\n- Coordination and synchronization\n→ All of these things makes parallel programming even harder than sequential programming\n\n### Finding Enough Parallelism\n\n- Suppose only part of an application seems parallel\n- Amdahl’s law\n\t- let s be the fraction of work done sequentially, so (1-s) is fraction parallelizable\n\t- P = number of processors\n\t- $Speedup(P) = Time(1) / Time(P) <= \\frac{1}{s + \\frac{(1-s)}{P}} <= 1/s$\n- Even if the parallel part speeds up perfectly performance is limited by the sequential part\n\n### Overhead of Parallelism\n\n- Given enough parallel work, this is the biggest barrier to getting desired speedup\n- Parallelism overheads include:\n\t- cost of starting a thread or process\n\t- cost of communicating shared data\n\t- cost of synchronizing\n\t- extra (redundant) computation\n- Each of these can be in the range of milliseconds (=millions of flops) on some systems\n- Tradeoff: Algorithm needs sufficiently large units of work to run fast in parallel, but not so large that there is not enough parallel work\n\n### Locality and Parallelism\n\n- Large memories are slow, fast memories are small\n- Storage hierarchies are large and fast on average\n- Parallel processors, collectively, have large, fast cache\n\t- the slow accesses to “remote” edata we call “communication”\n- Algorithm should do most work on local data\n\n### Load imbalance\n\n- Load imbalance is the time that some processors in the system are idle due to\n\t- insufficient parallelism (during that phase)\n\t- unequal size tasks\n- Algoroithm needs to balance load\n\n## Hyper-threading\n\n- Hyper-threading is Intel’s proprietary simultaneous multithreading implementation used to improve parallelization of computations (doing multiple tasks at once) performed on x86 microprocessors.\n\n## Performance of Parallel Programs\n\n### Flynn’s Taxonomy on Parallel Computer\n\n- Classified with two independent dimension\n\t- Instruction stream\n\t- Data stream\n\n### SISD (Single Instruction, Single Data)\n\n- A serial (non-parallel) computer\n- This is the oldest and even today, the most common type of computer\n\n### SIMD (Single Instruction Multiple Data)\n\n- All processing units execute the same instruction at any given clock cycle\n- Best suited for specialized problems characterized by a high degree of regularity, such as graphics/image processing\n\n### MISD (Multiple Instruction, Single Data)\n\n- Each processing unit operates on the data independently via separate instruction streams\n- Few actual examples of this class of parallel computer have ever existed.\n\n### MIMD (Multiple Instruction, Multiple Data)\n\n- Every processor may be executing a different instruction stream\n- Every processor may be working with a different data stream\n- the most common type of parallel computer\n- Most modern supercomputers fall into this category\n\n### Creating a Parallel Program\n\n1. Decomposition\n2. Assignment\n3. Orchestration/Mapping\n\n### Decomposition\n\n- Break up computation into tasks to be divided among processes\n- identify concurrency and decide level at which to exploit it\n\n#### Domain Decomposition\n\n- Data associated with a problem is decomposed.\n- Each parallel task then works on a portion of data.\n\n#### Functional Decomposition\n\n- the focus is on the computation that is to be performed rather than on the data\n- problem is decomposed according to the work that mulst be done.\n- Each task then performs a portion of the overall work.\n\n### Assignment\n\n- Assign tasks to threads\n\t- Balance workload, reduce communication and management cost\n\t- Together with decomposition, also called partitioning\n- Can be performed statically, or dynamically\n- Goal\n\t- Balanced workload\n\t- Reduced communication costs\n\n### Orchestration\n\n- Structuring communication and synchronization\n- Organizing data structures in memory and scheduling tasks temporally\n- Goals\n\t- Reduce cost of communication and synchronization as seen by processors\n\t- Reserve locality of data reference (including data structure organization)\n\n### Mapping\n\n- Mapping threads to execution units (CPU cores)\n- Parallel application treis to use the entire machine\n- Usually a job for OS\n- Mapping decision\n\t- Place related threads (cooperating threads) on the same processor\n\t- maximize locality, data sharing, minimize costs of comm/sync\n\n### Performance of Parallel Programs\n\n- What factors affect the performance?\n\t- Decomposition\n\t\t- Coverage of parallelism in algorithm\n\t- Assignment\n\t\t- Granularity of partitioning among processors\n\t- Orchestration/Mapping\n\t\t- Locality of computation and communication\n\n### Coverage (Amdahl’s Law)\n\n- Potential program speedup is defined by the fraction of code that can be parallelized\n- speed up은 sequential work 의 비율에 달려있다.\n\n### Amdahl’s Law\n\n- p = fraction of work that can be parallelized\n- n = the number of processor\n- s = 1-p\n\n$$speedup = \\frac{1}{{(1 - p) + \\frac{p}{n}}}$$\n\n### Implications of Amdahl’s Law\n\n- Speeedup tends to 1/(1-p) as number of processors tends to infinity\n- Parallel programming is worthwhile when programs have a lot of work that is parallel in nature\n\n### Performance Scalability\n\n- Scalability: the capable of a system to increase total throughput under an increased load when resources (typically hardwares) are added\n\n### Granularity (work units)\n\n- Granularity is a qualitative measure of the ratio of computation to communication\n\t- Coarse: relatively large amounts of computational work are done between communication events\n\t- Fine: relatively small amounts of computational work are done between communication events\n- Computation stages are typically separated from periods of communication by synchronization events\n- Granularity\n\t- the extent to which a system is broken down into small parts\n- Coarse-grained systems\n\t- consist of fewer, larger components than fine-grained systems\n\t- regards large subcomponents\n- Fine-grained systems\n\t- regards smaller components of which the larger ones are composed\n\n### Fine vs Coarse Granularity\n\n- Fine-grain Parallelism\n\t- Low computation to communication ratio\n\t- Small amounts of computational work between communication stages\n\t- High communication overhead\n- Coarse-grain Parallelism\n\t- High computation to communication ratio\n\t- Large amounts of computational work between communication events\n- The most efficient granularity is dependent on the algorithm and the hardware\n- In most cases the over head associated with communications and synchronization is high relative to execution speed so it’s advantageous to have **coarse granularity**.\n- Fine-grain parallelism can help reduce overheads due to load imbalance.\n\n### Load Balancing\n\n- distributing approximately equal amounts of work among tasks so that all tasks are kept busy all of the time.\n- It can be considered a minimization of task idle time.\n- For example, if all tasks are subject to a barrier syncrhonization point, the slowest task will determine the overall performance.\n\n#### General Load Balancing Problem\n\n- The whole work should be completed as fast as possible.\n- As workers are very expensive, they should be kept busy.\n- The work should be distributed fairly. About the same amount of work should be assigned to every worker.\n- There are precedence constraints between different tasks (we can start building the roof only after finishing the walls) Thus we also have to find a clever processing order of the different jobs.\n\n#### Load Balancing Problem\n\n- Processors that finish early have to wait for the processor with the largest amount of work to complete\n\t- Leads to idle time, lowers utilization\n\n#### Static load balancing\n\n- Programmer make decisions and assigns a fixed amount of work to each processing core a priority\n- Low run time overhead\n- Works well for homogeneous multicores\n\t- All core are the same\n\t- Each core has an equal amount of work\n- Not so well for heterogeneous multicores\n\t- Some cores may be faster than others\n\t- Work distribution is uneven\n\n#### Dynamic Load Balancing\n\n- When one core finishes its allocated work, it takes work from a work queue or a core with the heaviest workload\n- Adapt partitioning at run time to balance load\n- High runtime overhead\n- Ideal for codes where work is uneven, unpredictable, and in heterogeneous multicore\n\n### Granularity and Performance Tradeoffs\n\n1. Load balancing\n\t- How well is work distributed among cores?\n2. Synchronization/Communication\n\t- Communication Overhead?\n\n### Communication\n\n- With message passing, programmer has to understand the computation and orchestrate the communication accordingly\n\t- Point to Point\n\t- Broadcast (one to all) and Reduce (all to one)\n\t- All to All (each processor sends its data to all others)\n\t- Scatter (one to several) and Gather (several to one)\n\n#### Factors to consider for communication\n\n- Cost of communications\n\t- Inter-task communication virtually always implies overhead.\n\t- Communications frequently require some type of synchronization between tasks, which can result in tasks spending time ‘waiting’ instead of doing work.\n- Latency vs Bandwidth\n\t- Latency\n\t\t- the time it takes to send a minimal (0 byte) message from point A to point B\n\t- Bandwidth \n\t\t- the amount of data that can be communicated per unit of time.\n\t- Sending many small messages can cause latency to dominate communication overheads\n\t- Often it is more efficient to package small messages into a larger message.\n- Synchronous vs asynchronous\n\t- Synchronous: require some type of handshaking between tasks that share data\n\t- Asynchronous: transfer data independently from one another.\n- Scope of communication\n\t- Point-to-point\n\t- collective\n\n#### MPI: Message Paassing Library\n\n- MPI: portable specification\n\t- Not a language or compiler specification\n\t- Not a specific implementation or product\n\t- SPMD model (same program, multiple data)\n- For parallel computers, clusters, and heterogeneous networks, multicores\n- Multiple communication modes allow precise buffer management\n- Extensive collective operations for scalable global communication\n\n#### Point-to-Point\n\n- Basic method of communication between two processors\n\t- Originating processor “sends” messages to destination processor\n\t- Destination processor then “receives” the message\n- The message commonly includes\n\t- Data or other information\n\t- Length of the message\n\t- Destination address and possibly a tag\n\n#### Synchronous vs Asynchronous Messages\n\n- Synchronous send\n\t- Sender notified when message is received\n- Asynchronous send\n\t- Sender only knows that message is sent\n\n#### Blocking vs Non-Blocking Messages\n\n- Blocking messages\n\t- Sender waits until message is transmitted: buffer is empty\n\t- Receiver waits until message is received: buffer is full\n\t- Potential for deadlock\n- Non-blocking\n\t- Processing continues even if message hasn’t been transmitted\n\t- Avoid idle time and deadlocks\n\n#### Broadcast\n\n- One processor sends the same information to many other processors\n\t- MPI_BCAST\n\n#### Reduction\n\n- Example: every processor starts with a value and needs to know the sum of values stored on all processors\n- A reduction combines data from all processors and returns it to a single process\n\t- MPI_REDUCE\n\t- Can apply any associative operation on gathered data\n\t\t- ADD, OR, AND, MAX, MIN, etc…\n\t- No processor can finish reduction before each processor has contributed a value\n- BCAST/REDUCE can reduce programming complexity and may be more efficient in some programs.\n\n### Synchronization\n\n- Coordination of simultaneous events (threads / processes) in order to obtain correct runtime order and avoid unexpected condition\n- Types of synchronization\n\t- Barrier\n\t\t- Any thread / process must stop at this point (barrier) and cannot proceed until all other threads / processes reach this barrier\n\t- Lock/Semaphore\n\t\t- The first task acquires the lock. This task can then safely (serially) access the protected data or code.\n\t\t- Other tasks can attempt to acquire the lock but must wait until the task that owns the lock releases it.\n\n### Locality\n\n- Algorithm should do most work on local data\n- Need to exploit spatial and temporal locality\n\n#### Locality of memery access (shared memory)\n\n- Parallel computation is serialized due to memory contention and lack of bandwidth\n- Distribute data to relieve contention and increase effective bandwidth\n\n#### Memory Access Latency in Shared Memory Architectures\n\n- Uniform Memory Access (UMA)\n\t- Centrally located memory\n\t- All processors are equidistant (access times)\n- Non-Uniform Access (NUMA)\n\t- Physically partitioned but accessible by all\n\t- Processors have the same address space (Logically large one memory)\n\t- Placement of data affects performance (멀리 떨어진 데이터는 접근할 때 많은 시간이 소요됨)\n\t- CC-NUMA (Cache-Coherent NUMA)\n\n#### Cache Coherence\n\n- the uniformity of shared resource data that ends up stored in multiple local caches\n- Problem: When a processor modifies a shared variable in local cache, different processors may have different value of the variable\n\t- Copies of a variable can be present in multiple caches\n\t- A write by one processor may not beccome visible to others\n\t- They’ll keep accessing stale vaule in their caches\n\t- Need to take actions to ensure visibility or cache coherence\n- Snooping cache coherence\n\t- Send all request for data to all processors\n\t- Works well for small systems\n- Directory-based cache coherence\n\t- Keep track of what is being shared in a directory\n\t- Send point-to-point requests to processors\n\n#### Shared Memory Architecture\n\n- all processors to access all memory as global address space (UMA, NUMA)\n- Advantage\n\t- Global address space provides a user-friendly programming perspective to memory\n\t- Data sharing between tasks is both fast and uniform due to the proximity of memory to CPUs\n- Disadvantages\n\t- Primary disadvantage is the lack of scalability between memory and CPUs\n\t- Programmer responsibility for synchronization\n\t- Expense: it becomes increasingly difficult and expensive to design and produce shared memory machines with ever increasing number of processors.\n\n#### Distributed Memory Architecture\n\n- Characteristics\n\t- Only private(local) memory\n\t- Independent\n\t- require a communication network to connect inter-processor memory\n- Advantages\n\t- Scalable (processors, memory)\n\t- Cost effective\n- Disadvantages\n\t- Programmer responsibility of data communication\n\t- No global memory access\n\t- Non-uniform memory access time\n\n#### Hybrid Architecture\n\n- Advantages / Disadvantages\n\t- Combination of Shared/Distributed architecture\n\t- Scalable\n\t- Increased programmer complexity\n\n#### Ray Tracing\n\n- Shoot a ray into scene through every pixel in image plane\n- Follow their paths\n\t- they bounce around as they strike objects\n\t- they generate new rays: ray tree per input ray\n- Result is color and opacity for that pixel\n- Parallelism across rays\n\n## Java Thread Programming\n\n### Process\n\n- Operating system abstraction to represent what is needed to run a single program\n- a sequential stream of execution in its own address space\n- program in execution\n- 각 프로세스는 0~$2^{64}$ bytes 의 주소를 갖는다. (64비트 운영체제에서)\n- 물리적으로는 제한되지만, 논리적으로는 제한이 없는 메모리를 가지고 있을 수 있다.\n\n#### PCB\n\n- Process Control Block\n- 포함하는 것들\n\t- process state\n\t- process number\n\t- program counter\n\t- registers\n\t- memory limits\n\t- list of open files\n\n#### UNIX process\n\n- Every process, except process 0, is created by the fork() system call\n\t- fork() allocates entry in process table and assigns a unique PID to the child process\n\t- child gets a copy of process image of parent\n\t- both child and parent are executing the same code following fork()\n\n### Threads\n\n- Definition\n\t- single sequential flow of control within a program\n\t- A thread runs within the context of a program’s process and takes advantage of the resources allocated for that process and it’s environment\n- Each thread is comprised of (from OS perspective)\n\t- Program counter\n\t- Register set\n\t- Stack\n- Threads belonging to the same process share\n\t- Code section\n\t- Data section\n\t- OS resources such as open files\n\n### Single and multithreaded program\n\n- code, data, files 는 스레드들 사이에서 공유된다.\n\n### Multi-process vs Multi-thread\n\n- Process\n\t- Child process gets a copy of parents variables\n\t- Relatively expensive to start\n\t- Don’t have to worry about concurrent access to variables\n- Thread\n\t- Child thread shares parent’s variables\n\t- Relatively cheap to start\n\t- Concurrent access to variables is an issue\n\n## Programming Java threads\n\n### JAVA Threading Models\n\n- Java has threads build-in\n- Applications consist of at least one thread\n\t- Often called ‘main’\n- The Java Virtual Machine creates the initial thread which executes the main method of the class passed to the JVM\n- The methods executed by the ‘main’ thread can then create other threads\n\n### Creating Threads : method 1\n\n- A Thread class manages a single sequential thread of control.\n\n```java\nclass MyThread extends Thread {\n\tpublic void run() {\n\t// work to do\n\t}\n}\n```\n\n### Thread Names\n\n- All threads have a name to be printed out\n- The default name is of the format: `Thread-No`\n- User-defined names can be given through constructor\n\t- `Thread myThread = new Thread(“HappyThread”)`\n- Or usinig the `setName(aString)` method.\n- There is a method in Thread class, called `getName()` to obtain a thread’s name\n\n### Creating Threads : method 2\n\n- Since Java does not permit multiple inheritance, we often implement the run() method in a class not derived from Thread from the interface Runnable\n\n```java\npublic inerface Runnable {\n\tpublic abstract void run();\n}\n\nclass MyRun implements Runnable {\n\tpublic void run() {\n\t// work to do\n\t}\n}\n\nThread t = new Thread(new MyRun());\nt.start();\n```\n\n#### Creating & Executing Threads (Runnable)\n\n- Runnable interface has single method\n\t- public void run()\n- Implement a Runnable and define run()\n- Thread’s run() method invokes the Runnable’s run() method\n\n### Thread Life-Cycle\n\n- Created\n\t- start() → Alive\n\t- stop() → Terminated\n- Alive\n\t- stop() or run() returns\n- Terminated\n\n#### Alive States\n\n- Once started, an alivethread has a number of substates\n\t- start() → Running\n\t\t- sleep(), wait() I/O blocking\n\t\t- yield() → Runnable\n\t- Runnable (Ready)\n\t\t- dispatch → Running\n\t- Non-Runnable\n\t\t- notify(), Time expires, I/O completed → Runnable\n\n### Thread Priority\n\n- All Java threads have a priority value, currently between 1 and 10.\n- Priority can be changed at any time\n- Initial priority is that of the creating thread\n- Preemptive scheduling\n\t- JVM gives preference to higher priority threads (Not guaranteed)\n\n### yield\n\n- Release the right of CPU\n- static void yield()\n\t- allows the scheduler to select another runnable thread (of the same priority)\n\t- no guarantees as to which thread\n\n### Thread identity\n\n- `Thread.currentThread()`\n\t- Returns reference to the running thread\n\n### Thread sleep, suspend, resume\n\n- `static void sleep(long millis)`\n\t- Blocks this thread for at least the time specified\n- `void stop(), void suspend(), void resume()`\n\t- Deprecated!\n\n### Thread Waiting & Status Check\n\n- `void join(), void join(long), void join(long, int)`\n\t- One thread (A) can wait for another thread (B) to end\n- `boolean isAlive()`\n\t- returns true if the thread has been started and not stopped\n\n### Thread synchronization\n\n- The advantage of threads is that they allow many things to happen at the same time\n- The problem with threads is that they allow many things to happen at the same time\n- Safety\n\t- Nothing bad ever happens\n\t- no race condition\n- Liveness\n\t- Something eventually happens: no deadlock\n- Concurrent access to shared data in an object\n- Need a way to limit thread’s access to shared data\n\t- Reduce concurrency\n- Mutual Exclusion of Critical Section\n\t- Add a lock to an object\n\t- Any thread must acquire the lock before executing the methods\n\t- If lock is currently unavailable, thread will block\n\n### Synchronized JAVA methods\n\n- We can control access to an object by using the `synchronized` keyword\n- Using the `synchronized` keywork will force the lock on the object to be used\n\n### Synchronized Lock Object\n\n- Every Java object has an associated lock acquired via\n- synchronized statements (block)\n- Only one thread can hold a lock at a time\n- Lock granularity: small critical section is better for concurrency object\n\n### Condition Variables\n\n- lock(syncrhonized)\n\t- control thread access to data\n- condition variable (wait,notify/notifyall)\n\t- synchronization primitives that enable threads to wait until a particular condition occurs\n\t- enable threads to atomically release a lock and enter the sleeping state.\n\t- Without condition variables\n\t\t- the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met\n\t\t- A condition variable is a way to achieve the same goal without polling\n\t- A condition variable is always used in conjunction with a mutex lock\n\n### `wait()` and `notify()`\n\n- `wait()`\n\t- If no interrupt (normal case), current thread is blocked\n\t- The thread is placed into wait set associated with the object\n\t- Synchronization lock for the object is released\n- `notify()`\n\t- One thread, say T, is removed from wait set, if exists.\n\t- T retains the lock for the object\n\t- T is resumed from waiting stauts\n\n## Producer-Consumer Problem\n\n- The problem describes two processes, the producer and the consumer, who share a common, fixed-size buffer used as a queue.\n\t- producer: generate a piece of data, put it into the buffer and start again. At the same time, \n\t- consumer:  consumes the data (i.e., removing it from the buffer) one piece at a time. \n\t- The problem is to make sure that the producer won't try to add data into the buffer if it's full and that the consumer won't try to remove data from an empty buffer.\n- The solution for the producer is to go to sleep if the buffer is full. The next time the consumer removes an item from the buffer, it notifies the producer, who starts to fill the buffer again. \n- In the same way, the consumer can go to sleep if it finds the buffer to be empty. The next time the producer puts data into the buffer, it wakes up the sleeping consumer. \n- generalized to have multiple producers and consumers.\n\nTo motivate condition variables, consider the canonical example of a bounded buffer for sharing work among threads\n\nBounded buffer: A queue with a fixed size\n- (Unbounded still needs a condition variable, but 1 instead of 2)\nFor sharing work – think an assembly line: \n- Producer thread(s) do some work and enqueue result objects\n- Consumer thread(s) dequeue objects and do next stage\n- Must synchronize access to the queue\n\n### Waiting\n\n- enqueue to a full buffer should not raise an exception\n\t- Wait until there is room\n- dequeue from an empty buffer should not raise an exception\n\t- Wait until there is data\n\n### What we want\n\n- Better would be for a thread to _wait_  until it can proceed \n\t- Be _notified_  when it should try again\n\t- In the meantime, let other threads run\n- Like locks, not something you can implement on your own\n\t- Language or library gives it to you, typically implemented with operating-system support\n- An ADT that supports this: condition variable\n\t- Informs waiter(s) when the _condition_ that causes it/them to wait has _varied_\n- Terminology not completely standard; will mostly stick with Java\n\n### Key ideas\n\n- Java weirdness: every object “is” a condition variable (and a lock)\n\t- other languages/libraries often make them separate\n- **wait:** \n\t- “register” running thread as interested in being woken up\n\t- then atomically: release the lock and block\n\t- when execution resumes, _thread again holds the lock_\n- **notify:**\n\t- pick one waiting thread and wake it up\n\t- no guarantee woken up thread runs next, just that it is no longer blocked on the _condition_ – now waiting for the _lock_\n\t- if no thread is waiting, then do nothing\n\n### Bug 1\n\nBetween the time a thread is notified and it re-acquires the lock, the condition can become false again!\n\nGuideline: _Always_  re-check the condition after re-gaining the lock\n- In fact, for obscure reasons, Java is technically allowed to notify a thread _spuriously_  (i.e., for no reason)\n\n### Bug 2\n\n- If multiple threads are waiting, we wake up only one\n\t- Sure only one can do work now, but can’t forget the others!\n\n**notifyAll** wakes up all current waiters on the condition variable\nGuideline: If in any doubt, use **notifyAll** \n- Wasteful waking is better than never waking up\n- So why does **notify** exist?\n- Well, it is faster when correct…\n\n## Java Multithread Programming Exercise\n\n```java\nclass C extends Thread {\n  int i;\n  C(int i) { this.i = i; }\n  public void run() {\n    System.out.println(\"Thread \" + i + \" says hi\");\n    try { \n      sleep(500);\n    } catch (InterruptedException e) {}\n    System.out.println(\"Thread \" + i + \" says bye\");\n  }\n}\n\npublic class ex1 {\n   private static final int NUM_THREAD = 10;\n  public static void main(String[] args) {\n    System.out.println(\"main thread start!\");\n    C[] c = new C[NUM_THREAD];\n    for(int i=0; i < NUM_THREAD; ++i) {\n      c[i] = new C(i);\n      c[i].start();\n    }\n    System.out.println(\"main thread calls join()!\");\n    for(int i=0; i < NUM_THREAD; ++i) {\n      try { \n        c[i].join();\n      } catch (InterruptedException e) {}\n    }\n    System.out.println(\"main thread ends!\");\n  }\n}\n```\n\n```java\npublic class ex2_serial {\n  public static void main(String[] args) {\n    int[] int_arr = new int [10000]; \n    int i,s;\n    for (i=0;i<10000;i++) int_arr[i]=i+1;\n    s=sum(int_arr);\n    System.out.println(\"sum=\" + s +\"\\n\");\n  }\n\n  static int sum(int[] arr) {\n    int i;\n    int s=0;\n    for (i=0;i<arr.length;i++) s+=arr[i];\n    return s;\n  }\n}\n```\n\n```java\nclass SumThread extends Thread {\n  int lo; // fields for communicating inputs\n  int hi;\n  int[] arr;\n  int ans = 0; // for communicating result\n  SumThread(int[] a, int l, int h) {\n    lo=l; hi=h; arr=a;\n  }\n  public void run() { // overriding, must have this type\n    for(int i=lo; i<hi; i++)\n      ans += arr[i];\n  }\n}\n\nclass ex2 {\n\n  private static int NUM_END=10000;\n  private static int NUM_THREAD=4;\n\n  public static void main(String[] args) {\n    if (args.length==2) {\n      NUM_THREAD = Integer.parseInt(args[0]);\n      NUM_END = Integer.parseInt(args[1]);\n    } \n    System.out.println(\"number of threads:\"+NUM_THREAD);\n    System.out.println(\"sum from 1 to \"+NUM_END+\"=\");\n\n    int[] int_arr = new int [NUM_END]; \n    int i,s;\n    \n    for (i=0;i<NUM_END;i++) int_arr[i]=i+1;\n    s=sum(int_arr);\n    System.out.println(s);\n  }\n\n  static int sum(int[] arr) {\n    int len = arr.length;\n    int ans = 0;\n    SumThread[] ts = new SumThread[NUM_THREAD];\n    for(int i=0; i < NUM_THREAD; i++) {\n      ts[i] = new SumThread(arr,(i*len)/NUM_THREAD,((i+1)*len)/NUM_THREAD);\n      ts[i].start();\n    }\n    try {\n      for(int i=0; i < NUM_THREAD; i++) {\n        ts[i].join();\n        ans += ts[i].ans;\n      }\n    } catch (InterruptedException IntExp) {\n    }\n\n    return ans;\n  }\n}\n```\n\nex2 는 naive 한 solution 이다. 결국은 thread 개수만큼 for 문을 돌면서 더해줘야 하기 때문이다. \n\n```java\nclass IntThread extends Thread {\n  int my_id; // fields for communicating inputs\n  int num_steps;\n  int num_threads;\n  double sum;\n\n  IntThread(int id, int numSteps, int numThreads) {\n    my_id=id; num_steps=numSteps; num_threads=numThreads;\n    sum=0.0;\n  }\n  public void run() { \n    double x;\n    int i;\n    int i_start = my_id * (num_steps/num_threads);\n    int i_end = i_start + (num_steps/num_threads);\n    double step = 1.0/(double)num_steps;\n    for (i=i_start;i<i_end;i++) { \n      x=(i+0.5)*step;\n      sum=sum+4.0/(1.0+x*x);\n    }\n    sum = sum*step;\n    System.out.println(\"myid\"+my_id+\", sum=\" + sum);\n  }\n  public double getSum() { return sum; }\n}\n\nclass ex3 {\n  private static int NUM_THREAD = 4;\n  private static int NUM_STEP = 1000000000;\n\n  public static void main(String[] args) {\n    int i;\n    double sum=0.0;\n\n    if (args.length==2) {\n      NUM_THREAD = Integer.parseInt(args[0]);\n      NUM_STEP = Integer.parseInt(args[1]);\n    } \n\n    long start = System.currentTimeMillis();\n    IntThread[] ts = new IntThread[NUM_THREAD];\n    for(i=0; i < NUM_THREAD; i++) {\n      ts[i] = new IntThread(i,NUM_STEP,NUM_THREAD);\n      ts[i].start();\n    }\n     \n    try {\n      for (i=0;i<NUM_THREAD;i++) {\n        ts[i].join();\n        sum += ts[i].getSum();\n      }\n    } catch (InterruptedException e) {}\n    long finish = System.currentTimeMillis();\n\n    System.out.println(\"integration result=\" + sum +\"\\n\");\n    System.out.println(\"Execution time (\" + NUM_THREAD + \"): \"+(finish-start)+\"ms\");\n  }\n\n}\n```\n\n## Parallelism for summation\n\n- Example: Sum elements of a large array\n- Idea: Have 4 threads simultaneously sum 1/4 of the array\n\t- Warning: This is an inferior first approach\n\n- Create 4 thread objects, each given a portion of the work\n- Call **start()** on each thread object to actually run it in parallel\n- Wait for threads to finish using **join()**\n- Add together their 4 answers for the final result\n- Problems? : processor utilization, subtask size\n\n### A better Approach\n\nSolution is to use lots of threads, far more than the number of processors\n\n1. reusable and efficient across platforms \n2. Use processors “available to you now” : \n\t- Hand out “work chunks” as you go\n3. Load balance\n\t- in general subproblems may take significantly different amounts of time\n\n### Naive algorithm is poor\n\nSuppose we create 1 thread to process every 1000 elements\n\nThen combining results will have **arr.length / 1000**  additions \n- Linear in size of array (with constant factor 1/1000)\n- Previously we had only 4 pieces (constant in size of array)\n\nIn the extreme, if we create 1 thread for every 1 element, the loop to combine results has length-of-array iterations\n- Just like the original sequential algorithm\n\n### A better idea: devide-and-conquer\n\nThis is straightforward to implement using divide-and-conquer\n- Parallelism for the recursive calls\n- The key is divide-and-conquer parallelizes the result-combining\n- If you have enough processors, total time is height of the tree: O(**log** n) (optimal, exponentially faster than sequential O(n))\n- We will write all our parallel algorithms in this style\n\n```java\nclass SumThread extends java.lang.Thread {\n\n  int lo; int hi; int[] arr; // arguments\n  int ans = 0; // result\n  SumThread(int[] a, int l, int h) { … }\n\n  public void run(){ // override\n    if(hi – lo < SEQUENTIAL_CUTOFF)\n      for(int i=lo; i < hi; i++)\n        ans += arr[i];\n    else {\n      SumThread left = new SumThread(arr,lo,(hi+lo)/2);\n      SumThread right= new SumThread(arr,(hi+lo)/2,hi);\n      left.start();\n      right.start();\n      left.join(); // don’t move this up a line – why?\n      right.join();\n      ans = left.ans + right.ans;\n    }\n  }\n}\n\nint sum(int[] arr){ \n   SumThread t = new SumThread(arr,0,arr.length);\n   t.run();\n   return t.ans;\n}\n```\n\n### Being realistic\n\n- In theory, you can divide down to single elements, do all your result-combining in parallel and get optimal speedup\n\t- Total time O(n/numProcessors  + **log** n)\n- In practice, creating all those threads and communicating swamps the savings, so:\n\t- Use a sequential cutoff, typically around 500-1000\n\t\t- Eliminates almost all the recursive thread creation (bottom levels of tree)\n\t\t- Exactly like quicksort switching to insertion sort for small subproblems, but more important here\n\t- Do not create two recursive threads; create one and do the other “yourself”\n\t\t- Cuts the number of threads created by another 2x\n\n## Concurrent Programming\n\n### What is concurrency?\n\n- What is a sequential program?\n\t- A single thread of control that executes one instruction and when it is finished execute the next logical instruction\n- What is a concurrent program?\n\t- A collection of autonomous sequential threads, executing (logically) in parallel\n- The implementation of a collection of threads can be:\n\t- Multiprogramming\n\t\t- Threads multiplex their executions on a single processor\n\t- Multiprocessing\n\t\t- Threads multiplex their executions on a multiprocessor or a multicore system\n\t- Distributed Processing\n\t\t- Processes multiplex their executions on several different machines\n\n### Concurrency and Parallelism\n\n- Concurrency is not parallelism\n- Interleaved Concurrency\n\t- Logically simultaneous processing\n\t- Interleaved execution on a single processor\n- Parallelism\n\t- Physically simultaneous processing\n\t- Requires a multiprocessors or a multicore system\n\n### Why use Concurrent Programming?\n\n- Natural Application Structure\n\t- The world is not sequential! Easier to program multiple independent and concurrent activities.\n- Increased application throughput and responsiveness\n\t- Not blocking the entire application due to blocking I/O\n- Performance from multiprocessor/multicore hardware\n\t- Parallel execution\n- Distributed systems\n\t- Single application on multiple machines\n\t- Client/Server type or peer-to-peer systems\n\n### Synchronization\n\n- All the interleavings of the threads are NOT acceptable correct programs\n- Java provides synchronization mechanism to restrict the interleavings\n- Synchronization serves two purposes:\n\t- Ensure safety for shared updates\n\t\t- Avoid race conditions\n\t- Coordinate actions of threads\n\t\t- Parallel computation\n\t\t- Event notification\n\n### Safety\n\n- Multiple threads access shared resource simultaneously\n- Safe only if:\n\t- All accesses have no effect on resource,\n\t- All accesses idempotent\n\t- Only one access at a time: mutual exclusion\n\n### Mutual Exclusion\n\n- Prevent more than one thread from accessing critical section at a given time\n\t- Once a thread is in the critical section, no other thread can enter that critical section until the first thread has left the critical section\n\t- No interleavings of threads within the critical section\n\t- Serializes access to section\n\n### Atomicity\n\n- Synchronized methods execute the body as an atomic unit\n- May need to execute a code region as the atomic unit\n- Block Synchronization is a mechanism where a region of code can be labeled as synchronized\n- The synchronized keyword takes as a parameter an object whose lock the system needs to obtain before it can continue\n\n### Avoiding Deadlock\n\n- Cycle in locking graph = deadlock\n- Standard solution: canonical order for locks\n\t- Acquire in increasing order\n\t- Release in decreasing order\n- Ensures deadlock-freedom, but not always easy to do\n\n### Races\n\n- Race conditions - insidious bugs\n\t- Non-deterministic, timing dependent\n\t- Cause data corruption, crashes\n\t- Difficult to detect, reproduce, eliminate\n- Many programs contain races\n\t- Inadvertent programming errors\n\t- Failure to observe locking displine\n\n#### Data Races\n\n- A data race happens when two threads access a variable simultaneously, and one access is a write\n- Problem with data races: non-determinism\n\t- Depends on interleaving of threads\n- Usual way to avoid data races: mutual exclusion\n\t- Ensures serialized access of all the shared objects\n\n### Potential Concurrency Problems\n\n- Deadlock\n\t- Two or more threads stop and wait for each other\n- Livelock\n\t- Two or more threads continue to execute, but make no progress toward the ultimate goal.\n- Starvation\n\t- Some thread gets deffered forever.\n- Lack of fairness\n\t- Each thread gets a turn to make progress.\n- Race Condition\n\t- Some possible interleaving of threads results in an undesired computation result\n\n## Important Concepts in Concurrent Programming (from wikipedia)\n\n- Concurrency / Parallelism: logically / physically simultaneous processing\n- Synchronization\n\t- coordication of simultaneous events (threads / processes) in order to obtain correct run time order and void unexpected race condition.\n- Mutual Exclusion\n\t- ensuring that no two processes ro threads are in their critical section at the same time\n- Critical Section\n\t- a piece of code that accesses a shared resource (data structure or device) that must not be concurrently accessed by more than one thread of execution\n- Race Condition\n\t- a type of flaw in an electronic or software system where the output is dependent on the sequence or timing of other uncontrollable events.\n- Semaphore\n\t- a synchronization object that maintains a count between zero and a specified maximum value. The count is decremented each time a thread completes a wait for the semaphore object and incremented each time a thread releases the semaphore. When the count reaches zero, no more threads can successfully wait for the semaphore object state to become signaled.\n- concurrent hash map\n\t- a hash table supporting full concurrency of retrievals and adjustable expected concurrency for updates.\n- copy on write arrays\n\t- CopyOnWriteArrayList behaves as a List implementation that allows multiple concurrent reads, and for reads to occur concurrently with a write. The way it does this is to make a brand new copy of the list every time it is altered.\n- Barrier\n\t- a type of synchronization method. A barrier for a group of threads or processes in the source code means any thread/process must stop at this point and cannot proceed until all other threads / processes reach this barrier.\n\n## Pthread Programming\n\n### What is Thread?\n\n- Independent stream of instructions executed simultaneously by OS\n- Multithreaded program\n\t- A main program contains a number of procedures that are scheduled to run simultaneously and independently by OS\n\n### Processes and Threads\n\n- Threads share resources of a process\n\t- Changes made by one thread affect other threads\n\t- Two pointers having the same value point to the same data\n\t- Reading and writing to the same memory location is possible\n- Processes don’t share resources\n\n### Thread Properties\n\n- Exists within a process and uses the process resources\n- Has its own independent flow of control as long as its parent process exists and the OS supports it.\n- Duplicates only the essential resources it needs to be independently schedulable (like stack, register)\n- May share the process resources with other threads that act equally independently\n- Dies if the parent process dies - or something similar\n- Is “lightweight” because most of the overhead has already been accomplished through the creation of its process\n- All threads within a process share same address space\n- Therefore, inter-thread communication is more efficient than inter-process communication\n\n### pthread\n\n- POSIX thread\n- Standardized C language threads for UNIX\n- For portability\n- Working in shared memory multiprocessor\n\n- Why pthreads?\n\t- Performance gains\n\t- Requires fewer system resources than process\n\t\t- compare fork() and pthread_create(): 10~50 times\n\n### Pthreads API\n\n- Thread Management\n\t- Thread creation, and destruction\n- Mutexes\n\t- synchronization\n- Conditional Variables\n\t- Communication between threads that share a mutex\n\n#### Thread Creation\n\n```c\nint pthread_create(\n\tpthread_t *restrict thread,\n\tconst pthread_attr_t *restrict attr,\n\tvoid *(*start_routine) (void *),\n\tvoid *restrict arg\n);\n```\n\n- Creates a new thread and makes it executable\n- The creating process (or thread) must provide a location for storage of thread id\n- The third parameter is just the name of the function for the thread to run\n- The last parameter is a pointer to the arguments\n- When a new thread is created, it runs concurrently with the creating process.\n- When creating a thread, you indicate which function the thread should execute\n- Thread handle returned via `pthread_t` structure\n- Specify `NULL` to use default attributes\n- Single argument sent to the function\n- If no arguments to function, specify `NULL`\n- Check error codes!\n\n- [i] Example\n```c\n#include <iostream>\n#include <thread>\n#include <stdio.h>\n\nlong OddSum=0;\nlong EvenSum=0;\n\nvoid findEven(long start, long end)\n{\n        for (long i=start;i<=end;i++) if ((i&1)==0) EvenSum += i;\n}\n\nvoid findOdd(long start, long end)\n{\n        for (long i=start;i<=end;i++) if ((i&1)==1) OddSum += i;\n}\n\n\n// Functor (Function Object)\nclass FindOddFunctor {\n        public:\n                void operator()(int start, int end) {\n                        for (int i=start;i<=end;i++) if ((i&1)==1) OddSum += i;\n                }\n};\n\n// class member function\nclass FindOddClass {\n\tpublic:\n\t\tvoid myrun(int start, int end) {\n                        for (int i=start;i<=end;i++) if ((i&1)==1) OddSum += i;\n\t\t}\n};\n\n\nint main()\n{\n        long start = 0, end = 1000;\n\n        std::thread t1(findEven, start, end);\n\n        //std::thread t2(findOdd, start, end);   // (method 1) create thread using function pointer\n\n\t//FindOddFunctor findoddfunctor;\n        //std::thread t2(findoddfunctor, start, end); // (method 2) create thread using functor\n\n\t//FindOddClass oddObj;\n        //std::thread t2(&FindOddClass::myrun, &oddObj, start, end); // (method 3) create thread using member function of an object\n\n\t// (method 4) create thread using lambda function\n\tstd::thread t2([&](long s, long e) {\n\t\tfor (long i=s;i<=e;i++) if ((i&1)==1) OddSum += i;\n\t}, start, end);\n\t\t\n        t1.join(); // wait until thread t1 is finished.\n        t2.join(); // wait until thread t2 is finished.\n        //t2.detach(); // continue to run without waiting\n\n        std::cout << \"OddSum: \" << OddSum << std::endl;\n        std::cout << \"EvenSum: \" << EvenSum << std::endl;\n\n        return 0;\n}\n```\n#### Thread Termination\n\n`void pthread_exit(void *value_ptr)`\n\n- There are several ways in which a pthread may be terminated\n\t- The thread returns from its starting routine (the main routine for the initial thread)\n\t- The thread makes a call to the `pthread_exit` subroutine\n\t- The thread is canceled is terminated due to making a call to either the `exec()` or `exit()`\n\t- If main() finishes first, without calling `pthread_exit` explicitly itself\n- Typically, the pthread_exit() routine is called to quit the thread\n- If main() finishes before the threads it has created, and exits with pthread_exit(), the other threads will continue to execute. Otherwise, they’ll be automatically terminated when main() finishes.\n- The programmer may optionally specify a termination status, which is stored as a void pointer for any thread that may join the calling thread\n- Cleanup: the pthread_exit() routine does not close files; any files opened inside the thread wil remain open after the thread is terminated.\n\n#### Thread Cancellation\n\n- One thread can request that another exit with pthread_cancel\n- `int pthread_cancel(pthread_t thread)`\n- The pthread_cancel returns after making the request\n\n#### Joining\n\n`int pthread_join(pthread_t thread, void **value_ptr)`\n\n- The pthread_join() subroutine blocks the calling thread until the specified thread terminates\n- The programmer is able to obtain the target thread’s termination return status if it was specified in the target thread’s call to pthread_exit()\n- A joining thread can match one pthread_join() call. It is a logical error to attempt multiple joins on the same thread\n\n#### Mutexes\n\n- Mutual Exclusion\n- implementing thread synchronization and protecting shared data when multiple writes occur\n- A mutex variable acts like a “lock” protecting access to a shared data resource\n\t- only one thread can lock a mutex variable at any given time\n- Used for preventing race condition\n- When several threads compete for a mutex, the losers block at that call - an unblocking call is available with `trylock` instead of the `lock` call\n\n##### Mutex Routines\n\n`pthread_mutex_init (mutex, attr)`\n`pthread_mutex_destroy(mutex)`\n\n- Mutex variables must be declared with type `pthread_mutex_t`, and must be initialized before they can be used.\n\n##### Locking / Unlocking Mutexes\n\n- `pthread_mutex_lock(mutex)`\n\t- acquire a lock on the specified mutex variable\n- `pthread_mutex_trylock(mutex)`\n\t- attempt to lock a mutex. However, if the mutex is already locked, the routine will return immediately with a “busy” error code\n- `pthread_mutex_unlock(mutex)`\n\t- unlock a mutex if called by the owning thread\n\n##### User’s Responsibility for Using Mutex\n\n- When protecting shared data, it is the programmer’s responsibility to make sure every thread that needs to use a mutex does so\n- For example, if 3 threads are updating the same data, but only one or two use a mutex, the data can still be corrupted\n\n#### Condition Variables\n\n- another way for threads to synchronize\n- mutexes\n\t- synchronization by controlling thread access to data\n- condition variables\n\t- synchronization based upon the actual value of data\n\t- Without condition variables, the programmer would need to have threads continually polling (possibly in a critical section), to check if the condition is met\n\t- always used in conjunction with a mutex lock\n\n##### Condition Variables Routines\n\n`pthread_cond_init(condition, attr)`\n`pthread_cond_destroy(condition)`\n\n- Condition variables must be declared with type `pthread_cond_t`, and must be initialized before they can be used\n- attr is used to set condition variable attributes (NULL: defaults)\n- `pthread_cond_destroy()` should be used to free a condition variable that is no longer needed\n- `pthread_cond_wait`\n\t- blocks the calling thread until the specified condition is signalled\n\t- This routine should be called while mutex is locked\n\t- will automatically release the mutex lock while it waits\n\t- After signal is received and thread is awakened, mutex will be automatically locked for use\n- `pthread_cond_signal(condition)`\n\t- signal (or wake up) another thread which is waiting on the condition variable\n\t- It is a logical error to call pthread_cond_signal() before calling pthread_cond_wait()\n- `pthread_cond_broadcast(condition)`\n\t- should be used instead of pthread_cond_signal() if more than one thread is in a blocking wait state\n\n## C++ Multithreaded Programming\n\n### C++ Multi-Threading\n\n- C++11\n\t- First C++ standard that introduced threads, mutexes (locks), conditional variables etc\n- C++17\n\t- Parallel STL: addition of parallel algorithms in STL\n\n### C++ Thread Library\n\n- include header file `<thread>`\n- Create and starts a new thread using `std::thread`\n\t- Syntax: `thread(func, args…)`\n\t- `func` will be called in a new thread\n\t- The new thread will terminate when `func` returns\n\t- All parameters passed to `func` are passed by value\n\t- For pass by reference, wrap them in `std::ref`\n- 4 ways to create a thread in C++\n\t- using function pointer\n\t- using functor (function object)\n\t- using class member function\n\t- using lambda expression\n- Call the member function `join()` to wait for a thread to finish\n- Call the member function `detach()` to run independently\n\t- No join: join is not allowed after calling detach()\n\t- If thread object is destructed without calling detach(), error might occur\n\t- After a call to this function, the thread object becomes non-joinable and can be destroyed safely\n- The parent thread should call `join()` or `detach()`\n- Include header file `<mutex>` to use `std::mutex`\n\t- `std::lock_guard`: locks a supplied mutex on construction and unlocks it on destruction (simple exclusive lock)\n- `std::atomic` for atomic variables\n\t- operations are atomic\n\t- behave as if it is inside a mutex-protected critical section\n\t- usually faster than mutex lock (HW supported)\n\n### Parallel STL\n\n- C++ STL algorithms with support for execution policies (C++17 or later)\n- Execution Policy\n\t- `Stl_function(execution_policy, ... other_arguments ...);`\n\t- `std::execution::seq`\n\t\t- 1 thread, sequential\n\t- `std::execution::par`\n\t\t- multiple threads\n\t- `std::execution::par_unseq`\n\t\t- multiple threads, SIMD (vectorization) possible\n\t- `std::execution::unseq`\n\t\t- 1 thread, SIMD (vectorization) possible\n\n#### Example\n\n- clock_lock\n\n```c\n#include <iostream>\n#include <thread>\n#include <mutex>\n\nint inc_num=10001234;\nint dec_num=10000000;\n\nstd::mutex m;\n\nclass CountLock {\n\tint count;\npublic:\n\tCountLock() : count(0) {}\n\tint getCount() \n\t{\n\t\tint val;\n\t\tm.lock();\n\t\tval = count;\n\t\tm.unlock();\n\t\treturn val;\n\t}\n\t\n\tvoid inc()\n\t{\n\t\tm.lock();\n\t\tcount++;\n\t\tm.unlock();\n\t}\n\n\tvoid dec()\n\t{\n\t\tm.lock();\n\t\tcount--;\n\t\tm.unlock();\n\t}\n};\n \nclass Producer\n{\n\tCountLock& c_lock;\npublic:\n\tProducer(CountLock& clock): c_lock(clock) {\n\t}\n\n\tvoid run() {\n\t\tfor (int i=0;i<inc_num;i++) c_lock.inc();\n\t}\n};\n\nclass Consumer\n{\n\tCountLock& c_lock;\npublic:\n\tConsumer(CountLock& clock): c_lock(clock) {\n\t}\n\n\tvoid run() {\n\t\tfor (int i=0;i<dec_num;i++) c_lock.dec();\n\t}\n};\n \nint main()  \n{\n    CountLock count_lock;\n    Producer p(count_lock);\n    Consumer c(count_lock);\n    std::thread threadP(&Producer::run,&p);\n    std::thread threadC(&Consumer::run,&c);\n    threadP.join();    \n    threadC.join();    \n    std::cout<<\"after main join count:\"<<count_lock.getCount()<<std::endl;\n    return 0;\n}\n```\n\n- clock_atomic\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <atomic>\n\nint inc_num=10001234;\nint dec_num=10000000;\n\nclass CountLock {\n\tstd::atomic<int> count;\npublic:\n\tCountLock() : count(0) {}\n\tint getCount() \n\t{\n\t\treturn count;\n\t}\n\t\n\tvoid inc()\n\t{\n\t\tcount++;\n\t}\n\n\tvoid dec()\n\t{\n\t\tcount--;\n\t}\n};\n \nclass Producer\n{\n\tCountLock& c_lock;\npublic:\n\tProducer(CountLock& clock): c_lock(clock) {\n\t}\n\n\tvoid run() {\n\t\tfor (int i=0;i<inc_num;i++) c_lock.inc();\n\t}\n};\n\nclass Consumer\n{\n\tCountLock& c_lock;\npublic:\n\tConsumer(CountLock& clock): c_lock(clock) {\n\t}\n\n\tvoid run() {\n\t\tfor (int i=0;i<dec_num;i++) c_lock.dec();\n\t}\n};\n \nint main()  \n{\n    CountLock count_lock;\n    Producer p(count_lock);\n    Consumer c(count_lock);\n    std::thread threadP(&Producer::run,&p);\n    std::thread threadC(&Consumer::run,&c);\n    threadP.join();    \n    threadC.join();    \n    std::cout<<\"after main join count:\"<<count_lock.getCount()<<std::endl;\n    return 0;\n}\n```\n\n- psort.cpp\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n#include <execution>\n\nint main()\n{\n\tstd::vector<int> vec(100000000);\n\n\t// fill vector with random numbers\n\tstd::srand(unsigned(std::time(nullptr)));\n\tstd::generate(vec.begin(), vec.end(), std::rand);\n\tauto start_time = std::chrono::high_resolution_clock::now();\n\n\tstd::sort(vec.begin(), vec.end());\n\n\tauto end_time = std::chrono::high_resolution_clock::now();\n\tauto time_diff = end_time - start_time;\n\tstd::cout << \"sorting time: \" <<\n\t\ttime_diff / std::chrono::milliseconds(1) << \"ms to run.\\n\";\n\n\tstd::srand(unsigned(std::time(nullptr)));\n\tstd::generate(vec.begin(), vec.end(), std::rand);\n\tstart_time = std::chrono::high_resolution_clock::now();\n\n\tstd::sort(std::execution::par, vec.begin(), vec.end());\n\n\tend_time = std::chrono::high_resolution_clock::now();\n\ttime_diff = end_time - start_time;\n\tstd::cout << \"parallel sorting time: \" <<\n\t\ttime_diff / std::chrono::milliseconds(1) << \"ms to run.\\n\";\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- ptransform.cpp\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n#include <execution>\n\nbool isPrime(int x)\n{\n    int i;\n    if (x <= 1) return false;\n    for (i = 2; i < x; i++) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint getPrimeNo(int n)\n{\n    int i;\n    int prime_count = 0;\n\n    for (i = 2; i <= n; i++) {\n        if (isPrime(i)) prime_count++;\n    }\n    std::cout << \"No. of Primes (\" << n << \") =\" << prime_count << \"\\n\";\n    return prime_count;\n}\n\nint main()\n{\n    int i;\n    std::vector<int> A = { 100000, 100100, 100200, 100300, 100400, 100500, 100600, 100700, 100800, 100900, \n                           101000, 101100, 101200, 101300, 101400, 101500, 101600, 101700, 101800, 101900 };\n    std::vector<int> B;\n    B.resize(A.size());\n\n    auto start_time = std::chrono::high_resolution_clock::now();\n    std::transform(A.begin(), A.end(), B.begin(), getPrimeNo);\n    auto end_time = std::chrono::high_resolution_clock::now();\n    auto time_diff = end_time - start_time;\n    std::cout << \"transform time:\" << time_diff / std::chrono::milliseconds(1) << \"ms\\n\";\n    for (i = 0; i < B.size(); i++) std::cout << B[i] << \"\\n\";\n\n    start_time = std::chrono::high_resolution_clock::now();\n    std::transform(std::execution::par, A.begin(), A.end(), B.begin(), getPrimeNo);\n    end_time = std::chrono::high_resolution_clock::now();\n    time_diff = end_time - start_time;\n    std::cout << \"parallel transform time:\" << time_diff / std::chrono::milliseconds(1) << \"ms\\n\";\n    for (i = 0; i < B.size(); i++) std::cout << B[i] << \"\\n\";\n\n    system(\"pause\");\n    return 0;\n}\n```\n\n## OpenMP\n\n### Background\n\n- OpenMP is a framework for shared memory parallel computing\n- OpenMP is a standard C/C++ and Fortran compilers\n- Compiler directives indicate where parallelism should be used\n\t- C/C++ use `#pragma` directives\n\t- Fortran uses structured comments\n- A library provides support routines\n- Based on the fork / join model:\n\t- the program starts as a single thread\n\t- at designated parallel regions a pool of threads is formed\n\t- the threads execute in parallel across the region\n\t- at the end of the region the threads wait for all of the team to arrive\n\t- the master thread continues until the next parallel region\n- Some advantages\n\t- Usually can arrange so the same code can run sequentially\n\t- Can add parallelism incrementally\n\t- Compiler can optimize\n- The OpenMP standard specifies support for C/C++ and Fortran\n- Many compilers now support OpenMP\n- The OpenMP runtime creates and manages separate threads\n- OpenMP is much easier to use than low level thread libraries\n- You still have to make sure what you are donig is thread-safe\n\n### Some OMP Library Functions\n\n- The OMP library provides a number of useful routines\n- Some of the most commonly used\n\t- `omp_get_thread_num`: current thread index\n\t- `omp_get_num_threads`: size of the active team\n\t- `omp_get_max_threads`: maximum number of threads\n\t- `omp_get_num_procs`: number of processors available\n\t- `omp_get_wtime`: elapsed wall clock time from “some time in the past”\n\t- `omp_get_wtick`: timer resolution\n\n### Parallel Loops in OpenMP\n\n- OpenMP provides directives to support parallel loops\n```cpp\n#pragma omp parallel\n#pragma omp for\n\tfor (i = 0; i<n; i++)\n```\n```cpp\n#pragma omp parallel for\nfor (i = start; i<end; i++)\n```\n\n- There are some restrictions on the loop, including\n\t- The loop has to be of this simple form with\n\t\t- start and end computable before the loop\n\t\t- a simple comparison test\n\t\t- a simple increment or decrement expression\n\t- exits with `bread`, `goto`, `return` are not allowed\n\n### Shared and Private Variables\n\n- Variables declared before a prallel block can be shared or private\n- Shared variables are shared among all threads\n- Private variables vary independently within threads\n\t- On entry, values of private variables are undefined\n\t- On exit, values of private variables are undefined\n- By default,\n\t- all varaibles declared outside a parallel block are shared\n\t- except the loop index variable, which is private\n- Variables declared in a prallel block are always private\n- Variables can be explicitly declared shared or private\n- A simple example\n```cpp\n#pragma omp parallel for \nfor (i = 0; i<n; i++)\n\tx[i] = x[i] + y[i];\n```\n- Here x, y, and n are shared an i is private in the parallel loop\n- We can make the attributes explicit with\n```cpp\n#pragma omp parallel for shared(x, y, n) private (i)\nfor (i = 0; i<n; i++) {\n\tx[i] = x[i] + y[i];\n}\n\nor\n\n#pragma omp parallel for default(shared) private (i)\nfor (i = 0; i<n; i++) {\n\tx[i] = x[i] + y[i];\n}\n```\n- The value of i is undefined after the loop\n\n### Critical Sections and Reduction Variables\n\n```cpp\nint sum = 0;\n#pragma omp parallel for\nfor(i = 0; i<n; i++) {\n\tint val = f(i);\n\tsum = sum + val;\n}\n```\n\n- Problem: there is a race condition in the updating of sum\n- One solution is to use a critical section\n```cpp\nint sum = 0;\n#pragma omp parallel for\nfor(i = 0; i<n; i++) {\n\tint val = f(i);\n\t#pragma omp critical\n\tsum = sum + val;\n}\n```\n- Only one thread at a time is allowed into a critical section\n- An alternative is to use a reduction variable\n```cpp\nint sum = 0;\n#pragma omp parallel for reduction(+:sum)\nfor(i = 0; i<n; i++) {\n\tint val = f(i);\n\tsum = sum + val;\n}\n```\n- Reduction variables are in between private and shared variables\n- Other supported reduction operators include `*, &&, and ||`\n\n### Some Additional Clauses\n\n- `firstprivate` `lastprivate` declare variables private\n- `firstprivate` variables are initialized to their value before the parallel section\n- For `lastprivate` variables the value of the variable after the loop is the value after the logically last iteration\n- Variables can be listed both as `firstprivate` and `lastprivate`\n- The `if` clause can be used to enable parallelization conditionally\n- `num_threads(p)` says to use `P` threads\n- `schedule(static, n)` divides the loop into chunks of size n assigned cyclically to the threads\n- `schedule(dynamic, n)` divides the loop into chunks of size n assigned cyclically to the next available thread\n\n### The parallel region\n\n- A parallel region is a block of code executed by multiple threads simultaneously\n```cpp\n#pragma omp parallel [clause ...]\n{\n\t\"this will be executed in parallel\"\n} (implied barrier)\n\n!$omp parallel [clause ...]\n\"this will be executed in parallel\"\n!$omp end parallel\n```\n\n#### The parallel region - clauses\n\n- A parallel region supports the following clauses\n\t- if\n\t- private\n\t- shared\n\t- default\n\t- reduction\n\t- copyin\n\t- firstprivate\n\t- num_threads\n\n### Work-sharing constructs\n\n```cpp\n#pragma omp for \n{\n\n}\n\n#pragma omp sections\n{\n\n}\n\n#pragma omp single\n{\n\n}\n```\n\n- The work is distributed over the threads\n- Must be enclosed in a prallel region\n- Must be encountered by all threads in the team, or none at all\n- No implied barrier on entry; implied barrier on exit (unless nowait is specified)\n- A work-sharing construct does not launch any new threads\n\n### Load balancing\n\n- Load balancing is an important aspect of performance\n- For regular operations, load balancing is not a issue\n- For less regular workloads, care needs to be taken in distributing the work over the threads\n- Examples of irregular workloads\n\t- Transposing a matrix\n\t- Multiplication of triangular matrices\n\t- Parallel searches in a linked list\n- For these irregular situations, the schedule clause supports various iteration scheduling algorithms\n\n#### The schedule clause / 1\n\n- `static [, chunk]`\n\t- Distribute iterations in blocks of size “chunk” over the threads in a round-robin fashion\n\t- In absence of chunk, each thread executes approx. N/P chunks for a loop of length N and P threads\n- `dynamic [, chunk]`\n\t- Fixed portions of work; size is controlled by the value of chunk\n\t- When a thread finishes, it starts on the next portion of work\n- `guided [, chunk]`\n\t- Same dynamic behaviour as “dynamic”, but size of the portion of work decreases exponentially\n- `runtime`\n\t- Iteration scheduling scheme is set at runtime through environment variable`OMP_SCHEDULE\n\n### The SECTIONS directive\n\n- The individual code blocks are distributed over the threads\n\n```cpp\n#pragma omp sections [clauses]\n{\n#pragma omp section\n<code block1>\n#pragma omp section\n<code block2>\n...\n}\n```\n- Clauses supported\n\t- private\n\t- firstprivate\n\t- lastprivate\n\t- reduction\n\t- nowait\n\n### Barrier\n\n- We need to have updated all of a first, before using a\n- Each thread waits until all others have reached this point\n\t- `#pragma omp barrier`\n\n### Critical region\n\n- If sum is a shared variable, this loop can not be run in parallel\n- All threads execute the code, but only one at a time\n\t- `#pragma omp critical [(name)]`\n\t- `#pragma omp atomic`\n\t\t- This is a lightweight, special form of a critical section\n\n### SINGLE and MASTER construct\n\n- Only one thread in the team executes the code enclosed\n```cpp\n#pragma omp single [clauses ...]\n{\n<code-block>\n}\n```\n- Only master thread executes the code block:\n```cpp\n#pragma omp master\n{code block}\n```\n- There is no implied barrier on entry or exit\n\n### pi computation\n\n![[pi-computation.png]]\n\n#### OpenMP\n\n```cpp\n#include <omp.h>\n#include <stdio.h>\n\nlong num_steps = 1000000000; \ndouble step;\n\nvoid main ()\n{ \n\tlong i; double x, pi, sum = 0.0;\n\tdouble start_time, end_time;\n\n\tstart_time = omp_get_wtime();\n\tstep = 1.0/(double) num_steps;\n\tfor (i=0;i< num_steps; i++){\n\t\tx = (i+0.5)*step;\n\t\tsum = sum + 4.0/(1.0+x*x);\n\t}\n\tpi = step * sum;\n\tend_time = omp_get_wtime();\n\tdouble timeDiff = end_time - start_time;\n        printf(\"Execution Time : %.10lfsec\\n\", timeDiff);\n\n\tprintf(\"pi=%.10lf\\n\",pi);\n}\n```\n\n#### pthread\n\n```cpp\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define NUM_THREADS 4\n#define num_steps 100000\n\ndouble pi[NUM_THREADS];\n\nvoid *run(void *threadid) {\n\tint* t_ptr=(int*)threadid;\n    double step;\n\tdouble x, sum = 0.0;\n\tint my_id, i;\n\tint i_start = 0, i_end = 0;\n\tmy_id = *t_ptr;\n\n\ti_start = my_id * (num_steps / NUM_THREADS);\n\ti_end = i_start + (num_steps / NUM_THREADS);\n\tstep = 1.0 / (double)num_steps;\n\n\tfor (i = i_start; i < i_end; i++) {\n\t\tx = (i + 0.5)*step;\n\t\tsum = sum + 4.0 / (1.0 + x*x);\n\t}\n\n\tprintf(\"Myid%d, sum=%.8lf\\n\", my_id, sum*step);\n\tpi[my_id] = sum*step;\n\tpthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n\n\tpthread_t threads[NUM_THREADS];\n\n\tint t, pro_i, status;\n\tint ta[NUM_THREADS];\n\n\tfor (t = 0; t < NUM_THREADS; t++){\n\t\tta[t]=t;\n\t\tpro_i = pthread_create(&threads[t], NULL, run, (void *)&ta[t]);\n\n\t\tif (pro_i) {\n\t\t\tprintf(\"ERROR code is %d\\n\", pro_i);\n\t\t\texit(-1);\n\t\t}\n\t}\n\n    int i;\n    for (i=0;i<NUM_THREADS;i++) \n\tpthread_join(threads[i], (void **)&status);\n\n    double pi_sum=0;\n    for (i=0;i<NUM_THREADS;i++) pi_sum = pi_sum + pi[i];\n    \n    printf(\"integration result=%.8lf\\n\", pi_sum);\n    pthread_exit(NULL);\n}\n```\n\n### Matrix Calculation\n\n```cpp\n#include <stdio.h>\n#include <omp.h>\n\n#define NUM_THREADS 4\n\n#define NX 1000\n#define NM NX\n#define NY NX\n\nint a[NX * NM];\nint b[NM * NY];\nint m[NX * NY];\n\n#define A(i, n) a[(i) + NX * (n)]\n#define B(n, j) b[(n) + NM * (j)]\n#define M(i, j) m[(i) + NX * (j)]\n\nvoid printMatrix(int* mat, int X, int Y)\n{\n\tint i,j;\n\tfor (j=0;j<Y;j++) {\n\t\tfor (i=0;i<X;i++) {\n\t\t\tprintf(\"%4d \",mat[i+j*X]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n    int i, j, n;\n\tdouble t1,t2;\n    /* Initialize the Matrix arrays */\n\n\tomp_set_num_threads(NUM_THREADS);\n\tt1=omp_get_wtime();\n#pragma omp parallel for default(shared) private(n, i)\n    for (n = 0; n < NM; n++) {\n\tfor (i = 0; i < NX; i++) {\n\t    A(i, n) =3;\n\t}\n    }\n#pragma omp parallel for default(shared) private(n, j)\n    for (j = 0; j < NY; j++) {\n\tfor (n = 0; n < NM; n++) {\n\t    B(n, j) = 2;\n\t}\n    }\n \n#pragma omp parallel for default(shared) private(i, j)\n    for (j = 0; j < NY; j++) {\n\tfor (i = 0; i < NX; i++) {\n\t    M(i, j) = 0;\n\t}\n    }\n \n    /* Matrix-Matrix Multiplication */\n#pragma omp parallel for default(shared) private(i, j, n)\n    for (j = 0; j < NY; j++) {\n\tfor (n = 0; n < NM; n++) {\n\t    for (i = 0; i < NX; i++) {\n\t\tM(i, j) += A(i, n) * B(n, j);\n\t    }\n\t}\n    }\n\tt2=omp_get_wtime();\n\n\t//printMatrix(m,NX,NY);\n\tprintf(\"computation time:%lf, using %d threads\\n\",t2-t1,NUM_THREADS);\n    return 0;\n}\n```\n\n### Schedule\n\n```cpp\n#include <omp.h>\n#include <stdio.h>\n\n#define NUM_THREADS 4\n#define END_NUM 20\n\nint main ()\n{ \n\tint i;\n\tdouble start_time, end_time;\n\tomp_set_num_threads(NUM_THREADS);\n\tstart_time = omp_get_wtime( );\n\n\t#pragma omp parallel for schedule(static,2)\n\t//#pragma omp parallel for schedule(dynamic, 2)\n\t//#pragma omp parallel for schedule(guided, 2)\n\tfor (i = 1; i <= END_NUM; i++) {\n\t\tprintf(\"%3d -- (%d/%d)\\n\",i, omp_get_thread_num(),omp_get_num_threads());\n\t}\n\n\tend_time = omp_get_wtime( );\n\tprintf(\"time elapsed: %lfs\\n\",end_time-start_time);\n\n\treturn 0;\n}\n```\n\n### Merge Sort\n\n- Serial Merge Sort\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <omp.h>\n\n#define SWAP(a,b) {int temp = a; a = b; b = temp;}\n\n#define SIZE (1<<16)\n\nvoid setUp(int a[], int size);\nvoid tearDown(double start, double end, int a[], int size);\nvoid merge(int a[], int size, int temp[]);\nvoid mergesort_serial(int a[], int size, int temp[]);\nvoid mergesort_parallel_omp\n(int a[], int size, int temp[], int threads);\n\nint main() {\n\tint a[SIZE];\n\tint temp[SIZE];\n\tdouble startTime, endTime;\n\tint num_threads;\n\n\tnum_threads = omp_get_num_threads();\n\n\tsetUp(a, SIZE);\n\n\tstartTime = omp_get_wtime();\n\tmergesort_serial(a, SIZE, temp);\n\tendTime = omp_get_wtime();\n\n\ttearDown(startTime, endTime, a, SIZE);\n}\n\nvoid setUp(int a[], int size){\n\tint i;\n\n\tsrand(time(NULL));\n\tfor (i = 0; i<size; ++i) {\n\t\ta[i] = rand() % size;\n\t}\n\treturn;\n}\n\nvoid tearDown(double start, double end, int a[], int size) {\n\tint sorted = 1;\n\tint i;\n\n\tprintf(\"Time to execute: %f\\n\", end-start);\n\t\n\tfor (i = 0; i < size-1; ++i) {\n\t\tsorted &= (a[i] <= a[i+1]);\n\t}\n\n\tprintf(\"Array sorted: %d\\n\", sorted);\n\n\tprintf(\"Num threads: %d\\n\", omp_get_num_threads());\n}\n\nvoid merge(int a[], int size, int temp[]) {\n\tint i1 = 0;\n\tint i2 = size / 2;\n\tint it = 0;\n\n\twhile(i1 < size/2 && i2 < size) {\n\t\tif (a[i1] <= a[i2]) {\n\t\t\ttemp[it] = a[i1];\n\t\t\ti1 += 1;\n\t\t}\n\t\telse {\n\t\t\ttemp[it] = a[i2];\n\t\t\ti2 += 1;\n\t\t}\n\t\tit += 1;\n\t}\n\n\twhile (i1 < size/2) {\n\t    temp[it] = a[i1];\n\t    i1++;\n\t    it++;\n\t}\n\twhile (i2 < size) {\n\t    temp[it] = a[i2];\n\t    i2++;\n\t    it++;\n\t}\n\n\tmemcpy(a, temp, size*sizeof(int));\n\n}\n\nvoid mergesort_serial(int a[], int size, int temp[]) {\n\tint i;\n\n\tif (size == 2) { \n\t\tif (a[0] <= a[1])\n\t\t\treturn;\n\t\telse {\n\t\t\tSWAP(a[0], a[1]);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmergesort_serial(a, size/2, temp);\n\tmergesort_serial(a + size/2, size - size/2, temp);\n\tmerge(a, size, temp);\n}\n\nvoid mergesort_parallel_omp\n(int a[], int size, int temp[], int threads) {\n\tif ( threads == 1) {\n        mergesort_serial(a, size, temp);\n    }\n    else if (threads > 1) {\n        #pragma omp parallel sections\n        {\n            #pragma omp section\n            mergesort_parallel_omp(a, size/2, temp, threads/2);\n            #pragma omp section\n            mergesort_parallel_omp(a + size/2, size-size/2,\n                temp + size/2, threads-threads/2);\n        }\n\n        merge(a, size, temp);\n\t} // threads > 1\n}\n```\n\n#### Merge-Sort Algorithm\n\n- if n = 1\n$$T_{1(n)}= \\theta(1)$$\n- otherwise,\n$$T_1{(n)}= 2T_{1}(\\frac{n}{2})+ \\theta(n) = \\theta(n logn)$$\n\n## Manycore GPU Programming with CUDA\n\n### Moore’s Law\n\n- Transistor count of integrated circuits doubles every two years\n\n### The Need of Multicore Architecture\n\n- Hard to design high clock speed (frequency)\n\t- power consumption and heat generation: too high\n\t- number of cores may still increase\n\n### Many-core GPUs\n\n- Motivation\n\t- Originally driven by the insatiable market demand for realtime, high-definition 3D graphics\n\t- progammable GPU has evolved into a highly parallel, multithreaded, manycore processor with tremendous computational horsepower and very high memory bandwidth\n\t- GPGPU\n\t\t- General Purpose computing on GPU (Graphical Processing Unit)\n\t\t- Utilization of GPU (typically handles computations for graphics) to perform general purpose computation (traditionally handled by CPU)\n\n### Processor: Multicore vs Many-core\n\n- Multicore direction (CPU) : 2~8 cores\n\t- Typically handles general purpose computation\n\t- seeks to maintain/increase the execution speed of sequential programs\n\t- Complex: out-of-order, multiple instruction issue, branch prediction, pipelining, large cache, …\n\t- while moving into multiple cores\n\t- Ex. Intel i7 has 4 cores (hexa-core was release recently)\n- Many-core direction (GPU): 100~3000 cores\n\t- Focus on the execution throughput of parallel applications\n\t- Simple: in order, single instruction issue\n\t- Large number of smaller cores\n\n### GPU\n\n- Specially designed for highly parallel applications\n\t- Programmable using high level lauguages\n\t- Supports standard 32-bit floating point precision\n\t- Lots of GFLOPS\n- Fast processing must come with high bandwidth!\n- Simpler memory models and fewer constraints allow high bandwidth\n- Memory bandwidth\n\t- the rate at which data can be read from or stored into memory by a processor\n- GPU is specialized for\n\t- Compute-intensive\n\t- Highly data parallel computation\n\t\t- the same program is executed on many data elements in parallel\n\t- More transistors devoted to data processing rather than data caching and flow control\n- What graphics rendering needs?\n\t- Geometry(vertex) + Pixel processing\n- Motivates many application developers to move the computationally intensive parts of their software to GPUs for execution\n\n### Applications\n\n- 3D rendering\n\t- large sets of piels and vertices are mapped to parallel threads\n- image and media processing applications such as post-processing of rendered images, cideo encoding and decoding, image scaling, stereo vision, and pattern recognition\n\t- can map image blocks and pixels to parallel processing threads\n- many other kinds of algorithms are accelerated by data-parallel processing\n\t- from general signal processing or physics simulation to compuational finance or computational biology\n\n### CPU vs GPU\n- CPU vs GPU: fundamentally different design philosophies\n- CPU: Optimized for sequential code performance\n\t- sophisticated control logic\n\t\t- to allow instructions from single thread to execute in parallel or even out-of-order\n\t\t- branch prediction\n\t- large cache memory\n\t- powerful ALU: reduced operation latency\n\t- **Minimize latency (time to complete a task)**\n- GPU: Optimized for execution throughput of multiple threads\n\t- Originally for fast (3D) video game\n\t\t- Requires a massive number of floating-point calculations per frame\n\t- Minimize control logic and cache memory\n\t\t- Much more chip area is dedicated to the floating-point calculations\n\t\t- Boost memory throughput\n\t- Energy Efficient ALU\n\t- Designed as (data parallel) numeric computing engines\n\t- **GPU designed for many simple tasks and Maximize throughput (number of tasks in fixed time)**\n\n### GPU Architecture\n\n- GPUs consist of many simple cores\n- Array of highly threaded streaming multiprocessors (SMs)\n- Two or more SMs form a building block\n\n### GPU chip design\n\n- GPU core is stream processor\n- Stream processors are grouped in stream multiprocessors\n\t- SM is basically a SIMD processor (single instruction multiple data)\n\n### Winning Applications Use Both CPU and GPU\n\n- GPUs will not perform well on some tasks on which CPUs perform well\n- Use both CPUs and GPUs\n\t- Executing essentially sequential parts on CPU\n\t- Numerically intensive parts on GPU\n- CUDA\n\t- Introduced by NVIDIA in 2007\n\t- Designed to support joint CPU / GPU execution of applications\n\n### Popularity of GPUs\n\n- Performance\n- Cost\n- large marketplace & customer population\n- Practical factors and easy accessibility\n\t- GE MRI with {clusters and GPU}\n- Support of IEEE floating-point standard\n- CUDA\n\t- programmer can use C/C++ programming tools\n\t- No longer go through complex graphics interface\n\n### Why more parallelism?\n\n- Applications will continue to demand increased speed\n- A good implementation on GPU can achieve more than 100 times speedup over sequential execution\n- Supercomputing applications\n\t- Any applications that require data-parallel calculations such as matrix calculations\n\n### CUDA(Computer Unified Device Architecture)\n\n- Parallel Computing Framework Developed by NVIDIA (working only NVIDIA cards)\n- Introduced in 2006\n- General purpose Programming Model\n\t- GPGPU (General Purpose GPU)\n\t- Offers a computing API\n\t- Explicit GPU memory management\n- Goal\n\t- Develop application SW that transparently scales its parallelism to leverage the increasing number of processor cores\n\n### Compute Capability\n\n- general specifications and features of compute device\n- Defined by major revision number and minor revision number\n\n### CUDA - Main Features\n\n- C/C++ with extensions\n- Heterogeneous programming model\n- Operates in CPU (host) and GPU (device)\n\n### CUDA Device and Threads\n\n- Device\n\t- Is a coprocessor to the CPU or host\n\t- Has access to DRAM (device memory)\n\t- Runs many threads in parallel\n\t- Is typically a GPU but can also be another type of parallel processing device\n- Data-parallel portions of an application are expressed as device kernels which run on many threads\n- Differences between GPU and CPU threads\n\t- CPU threads are extremely lightweight (little overhead for creation)\n\t- GPU needs 1000s of threads for full efficiency\n\t\t- multicore CPU needs only a few\n\n## CUDA Programming Slides (NVIDIA)\n\n- __host__: CPU → CPU\n- __device__: GPU → GPU\n- __global__: CPU → GPU\n\n`<<<block, thread>>>`\n\n- `a`, `b` and `c` must point to device memory (매개변수는 디바이스)\n\n(N+thread-1)/(Thread)\n\n## Thrust\n\n### Transformation.cu\n\n```cpp\n#include <thrust/device_vector.h>\n#include <thrust/transform.h>\n#include <thrust/sequence.h>\n#include <thrust/copy.h>\n#include <thrust/fill.h>\n#include <thrust/replace.h>\n#include <thrust/functional.h>\n#include <iostream>\n\nstruct saxpy_functor\n{\n    const int a;\n\n    saxpy_functor(int _a) : a(_a) {}\n\n    __host__ __device__\n        int operator()(const int& x, const int& y) const {\n            return a * x + y;\n        }\n};\n\nvoid saxpy_fast(int A, thrust::device_vector<int>& X, thrust::device_vector<int>& Y)\n{\n    // Y <- A * X + Y\n    thrust::transform(X.begin(), X.end(), Y.begin(), Y.begin(), saxpy_functor(A));\n}\n\nvoid saxpy_slow(int A, thrust::device_vector<int>& X, thrust::device_vector<int>& Y)\n{\n    thrust::device_vector<int> temp(X.size());\n\n    // temp <- A\n    thrust::fill(temp.begin(), temp.end(), A);\n\n    // temp <- A * X\n    thrust::transform(X.begin(), X.end(), temp.begin(), temp.begin(), thrust::multiplies<int>());\n\n    // Y <- A * X + Y\n    thrust::transform(temp.begin(), temp.end(), Y.begin(), Y.begin(), thrust::plus<int>());\n}\n\nint main(void)\n{\n    // allocate three device_vectors with 10 elements\n    thrust::device_vector<int> X(10);\n    thrust::device_vector<int> Y(10);\n    thrust::device_vector<int> Y2(10);\n    thrust::device_vector<int> Y3(10);\n    thrust::device_vector<int> Z(10);\n\n    // initialize X to 0,1,2,3, ....\n    thrust::sequence(X.begin(), X.end());\n\n    // compute Y = -X\n    thrust::transform(X.begin(), X.end(), Y.begin(), thrust::negate<int>());\n\n    // fill Z with twos\n    thrust::fill(Z.begin(), Z.end(), 2);\n\n    // compute Y = X mod 2\n    thrust::transform(X.begin(), X.end(), Z.begin(), Y.begin(), thrust::modulus<int>());\n\n    // replace all the ones in Y with tens\n    thrust::replace(Y.begin(), Y.end(), 1, 10);\n\n\n    // print X\n    std::cout << \"X = \";\n    thrust::copy(X.begin(), X.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\n\";\n\n    // print Y\n    std::cout << \"Y = \";\n    thrust::copy(Y.begin(), Y.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\n\";\n\n    std::cout << \"Y=2*X+Y using saxpy_slow : \";\n    saxpy_slow(2,X,Y);\n    thrust::copy(Y.begin(), Y.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\n\";\n\n    std::cout << \"Y=3*X+Y using saxpy_fast : \";\n    saxpy_fast(3,X,Y);\n    thrust::copy(Y.begin(), Y.end(), std::ostream_iterator<int>(std::cout, \" \"));\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```\n\n```cpp\n#include <thrust/transform_reduce.h>\n#include <thrust/functional.h>\n#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <cmath>\n\n// square<T> computes the square of a number f(x) -> x*x\ntemplate <typename T>\nstruct square\n{\n    __host__ __device__\n        T operator()(const T& x) const { \n            return x * x;\n        }\n};\n\nint main(void)\n{\n    // initialize host array\n    float x[4] = {1.0, 2.0, 3.0, 4.0};\n\n    // transfer to device\n    thrust::device_vector<float> d_x(x, x + 4);\n\n    // setup arguments\n    square<float>        unary_op;\n    thrust::plus<float> binary_op;\n    float init = 0;\n\n    float sum = thrust::reduce(d_x.begin(), d_x.end());\n    // compute norm\n    float norm = std::sqrt( thrust::transform_reduce(d_x.begin(), d_x.end(), unary_op, init, binary_op) );\n\n    std::cout << \"X = \";\n    for (int i=0;i<d_x.size();i++) std::cout << d_x[i] << \" \";\n    std::cout << \"\\n\";\n    std::cout << \"sum = \" << sum << std::endl;\n    std::cout << \"norm = \" << norm << std::endl;\n\n    thrust::inclusive_scan(d_x.begin(),d_x.end(), d_x.begin());\n    std::cout << \"prefix sum(X) = \";\n    for (int i=0;i<d_x.size();i++) std::cout << d_x[i] << \" \";\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```\n\n```cpp\n#include <thrust/transform_reduce.h>\n#include <thrust/functional.h>\n#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <cmath>\n\n// square<T> computes the square of a number f(x) -> x*x\ntemplate <typename T>\nstruct square\n{\n    __host__ __device__\n        T operator()(const T& x) const { \n            return x * x;\n        }\n};\n\nint main(void)\n{\n    // initialize host array\n    float x[4] = {1.0, 2.0, 3.0, 4.0};\n\n    // transfer to device\n    thrust::device_vector<float> d_x(x, x + 4);\n\n    // setup arguments\n    square<float>        unary_op;\n    thrust::plus<float> binary_op;\n    float init = 0;\n\n    float sum = thrust::reduce(d_x.begin(), d_x.end());\n    // compute norm\n    float norm = std::sqrt( thrust::transform_reduce(d_x.begin(), d_x.end(), unary_op, init, binary_op) );\n\n    std::cout << \"X = \";\n    for (int i=0;i<d_x.size();i++) std::cout << d_x[i] << \" \";\n    std::cout << \"\\n\";\n    std::cout << \"sum = \" << sum << std::endl;\n    std::cout << \"norm = \" << norm << std::endl;\n\n    thrust::inclusive_scan(d_x.begin(),d_x.end(), d_x.begin());\n    std::cout << \"prefix sum(X) = \";\n    for (int i=0;i<d_x.size();i++) std::cout << d_x[i] << \" \";\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```\n\n```cpp\n#include <thrust/host_vector.h>\n#include <thrust/device_vector.h>\n#include <thrust/generate.h>\n#include <thrust/sort.h>\n#include <thrust/copy.h>\n#include <thrust/random.h>\n#include <iostream>\n#include <chrono>\n#include <algorithm>\n#include <vector>\n\nint main() {\n\n\t//\tdata initialization (random number generation for vectors)\n\t\t\tstd::vector<int> vec(20000000);\n\t\t\tstd::generate(vec.begin(), vec.end(), std::rand);\n\t\t\tthrust::device_vector<int> d_vec(vec.begin(), vec.end()) ;\n\n\t// perform STL sorting\n\t\t\tstd::cout << \"first 10 elements (before sorting): \"; std::copy(vec.begin(), vec.begin()+10, std::ostream_iterator<int>(std::cout, \" \")); std::cout << \"\\n\";\n\t\t\tauto start_time = std::chrono::high_resolution_clock::now();\n\n\t\t\tstd::sort(vec.begin(), vec.end());\n\n\t\t\tauto end_time = std::chrono::high_resolution_clock::now();\n\t\t\tauto time_diff = end_time - start_time;\n\t\t\tstd::cout << \"first 10 elements (after sorting): \"; std::copy(vec.begin(), vec.begin()+10, std::ostream_iterator<int>(std::cout, \" \")); std::cout << \"\\n\";\n\t\t\tstd::cout << \"STL sorting time (single thread): \" << time_diff / std::chrono::milliseconds(1) << \"ms to run.\\n\\n\";\n\n\t// perform thrust sorting\n\t\t\tstd::cout << \"first 10 elements (before sorting): \"; thrust::copy(d_vec.begin(), d_vec.begin()+10, std::ostream_iterator<int>(std::cout, \" \")); std::cout << \"\\n\";\n\t\t\tstart_time = std::chrono::high_resolution_clock::now();\n\n\t\t  thrust::sort(d_vec.begin(), d_vec.end());\n\n\t\t\tend_time = std::chrono::high_resolution_clock::now();\n\t\t\ttime_diff = end_time - start_time;\n\t\t\tstd::cout << \"first 10 elements (after sorting): \"; thrust::copy(d_vec.begin(), d_vec.begin()+10, std::ostream_iterator<int>(std::cout, \" \")); std::cout << \"\\n\";\n\t\t\tstd::cout << \"thrust sorting time (GPU): \" << time_diff / std::chrono::milliseconds(1) << \"ms to run.\\n\";\n\n\treturn 0;\n}\n```\n\n## Parallel Algorithms (focus on sorting algorithms)\n\n### Parallel / Distributed Algorithms\n\n- Parallel program (algorithm)\n\t- A program (algorithm) is divided into multiple processes (threads) which are run on multiple processors\n\t- The processors normally are in one machine execute one program at a time have high speed communications between them\n- Distributed program (algorithm)\n\t- A program (algorithm) is divided into multiple processes which are run on multiple distinct machines\n\t- The multiple machines are usual connected by network. Machines used typically are workstations running multiple programs\n\n### Parallelism idea\n\n- Idea: Have 4 threads simultaneously sum 1/4 of the array\n\t- Warning: This is an inferior first approach\n\t- Create 4 thread objects, each given a portion of the work \n\t- Call start() on each thread object to actually run it in parallel\n\t- Wait for threads to finish using join()\n\t- Add together their 4 answers for the final result\n\t- Problems: processor utilization, subtask size\n\n### A Better Approach\n\n- Problem → Solution is to use lots of threads, far more than the number of processors\n\n1. reusable and efficient across platforms\n2. Use processors “available to you now”\n\t- Hang out “work chunks” as you go\n3.  Load balance\n\t- in general subproblems may take significantly different amounts of time\n\n### Naive algorithm is poor\n\n- Suppose we create 1 thread to process every 1000 elements\n- Then combining results will have `arr.length / 1000` additions\n\t- Linear in size of array (with constant factor 1 / 1000)\n\t- Previously we had only 4 pieces (constant in size of array)\n- In the extreme, if we create 1 thread for every 1 element, the loop to combine results has length-of-array iterations\n\t- Just like the original sequential algorithms\n\n### Being realistic\n\n- In theory, you can divide down to single elements, do all your result - combining in parallel and get optiomal speedup\n\t- Total time $O(n / numProcessors + log n)$\n- In practice, creating all those threads and communicating swamps the savings, so\n\t- Use a sequential cutoff, typically around 500-1000\n\t\t- Eliminates almost all the recursive thread creation (bottom levels of tree)\n\t\t- Exactly like quicksort switching to insertion sort for small subproblems, but more important here\n\t- Do not create two recursive threads; create one and do the other “yourself”\n\t\t- Cust the number of threads created by another 2x\n\n### Similar Problems\n\n- Maximum or minimum element\n- Is there an element satisfying some property\n- Left-most element satisfying some property\n- Corners of a rectangle containing all points (a bounding box)\n- Counts, for example, number of strings that start with a vowel\n\n=> computations of this form are called **reductions**\n\n### Even easier: Maps (Data Parallelism)\n\n- A map operates on each element of a collection independently to create a new collection of the same size\n\t- No combining results\n\t- For arrays, this is so trivial some hardware has direct support\n- Canonical example: Vector addition\n```cpp\nint[] vector_add(int[] arr1, int[] arr2) {\n\tassert (arr1.length == arr2.length);\n\tresult = new int[arr1.length];\n\tFORALL(i = 0; i<arr1.length; i++) {\n\t\tresult[i] = arr1[i] + arr2[i];\n\t}\n\treturn result;\n}\n```\n\n### Maps and reductions\n\nMaps and reductions: the “workhorses” of parallel programming\n\n- By far the two most important and common patterns\n- Learn to recognize when an algorithm can be written in terms of maps and reductions\n- Use maps and reductions to describe (parallel) algorithms\n\n### Divide-and-Conquer\n\n- Divide\n\t- divide the original problem into smaller subproblems that are easier are to solve\n- Conquer\n\t- solve the smaller subproblems (perhaps recursively)\n- Merge\n\t- combine the solutions to the smaller subproblems to obtain a solution for the original problem\n\n→ Can be extended to parallel algorithm\n\n- The divide-and-conquer paradigm improves program modularity, and often leads to simple and efficient algorithms\n- Since the subproblems created in the divide step are often independent, they can be solved in parallel\n- If the subproblems are solved recursively, each recursive divide step generates even more independent subproblems to be solved in parallel\n- In order to obtain a highly parallel algorithm it is often necessary to parallelize the divide and merge steps, too\n\n### Example of Parallel Program\n\n- `spawn`\n\t- Subroutine can execute at the same time as its parent\n- `sync`\n\t- Wait until all children are done\n\t- A procedure cannot safely use the return values of the children it has spawned until it executes a `sync` statement\n\n### Analyzing algorithms\n\n- Like all algorithms, parallel algorithms should be\n\t- Correct\n\t- Efficient\n- For our algorithms so far, correctness is “obvious” so we’ll focus on efficiency\n\t- Want asymptotic bounds\n\t- Want to analyze the algorithm without regard to a specific number of processors\n\n### Performance Measure\n\n- $T_p$\n\t- running time of an algorithm on $p$ processors\n- $T_1$: work\n\t- running time of algorithm on 1 processor\n- $T_{infinity}$\n\t- the longest time to execute the algorithm on infinite number of processors\n- Lower bounds on $T_p$\n\t- $T_{p}>= \\frac{T_{1}}{ p}$\n\t- $T_{p}>= T_{infinity}$\n\t\t- P processors cannot do more than infinite number of processors\n- Speedup\n\t- $\\frac{T_{1}}{ T_{p}}$ : speedup on p processors\n- Parallelism\n\t- $\\frac{T_{1}}{ T_{infinity}}$\n\t- Max possible parallel speedup\n\n### Related Sorting Algorithms\n\n- Sorting Algorithms\n\t- Sort an array `A[1, ... , n]` of n keys (using p ≤ n processors)\n- Examples of divide-and-conquer methods\n\t- Merge-sort\n\t- Quick-sort\n\n### Merge-Sort\n\n- Basic Plan\n\t- Divide array into two halves\n\t- Recursively sort each half\n\t- Merge two halves to make sorted whole\n\n### Performance analysis\n\n$$T(n)=aT(\\frac{b}{n}​)+f(n)$$\n\n- The Master Theorem\n\t- it is used to analyze the time complexity of a recursively defined algorithm\n- $T(n)$ : the time complexity of the algorithm if input size is n\n- $a$: the count of recursive call\n- $n/b$ : the size of problem which are processed by each recursive call\n- $f(n)$: the time that takes to resolve if we can’t divide the problem into subproblems (conquer)\n\n#### 마스터 정리의 세 가지 경우의 수\n\n1. $f(n)$ 이 재귀 호출 부분보다 느리게 증가하는 경우\n\t- 하위 문제들을 해결하는 데 드는 시간이 최종적으로 알고리즘의 전체 시간 복잡도를 결정한다.\n\t- 이 경우, 전체 시간 복잡도는 재귀 호출의 시간 복잡도에 의해 지배된다.\n2. $f(n)$ 이 재귀 호출 부분과 비슷한 속도로 증가하는 경우\n\t- 재귀 호출과 결합 비용 $f(n)$ 이 비슷한 비율로 증가한다. 따라서 이 둘의 결합이 최종 시간 복잡도를 결정한다.\n\t- 이 경우, 전체 시간 복잡도는 재귀 호출과 $f(n)$ 이 결합되어 결정된다.\n\t- $T(n) = \\Theta(n^{log_{b}{a}}log^{k+1}n)$ \n3. $f(n)$ 이 재귀 호출 부분과 빠르게 증가하는 경우\n\t- 상위 문제를 해결하는 데 드는 시간이 최종적으로 알고리즘의 시간 복잡도를 결정한다.\n\t- 이 경우, 전체 시간 복잡도는 $f(n)$ 에 의해 지배된다.\n\nMerge-Sort 를 진행할 때, 다음과 같은 방식으로 작동한다.\n\n1. 배열을 두 개의 균등한 부분으로 나눈다.\n2. 각각의 부분을 재귀적으로 정렬한다.\n3. 두 정렬된 부분을 병합하여 전체를 정렬한다.\n\n이 알고리즘의 시간 복잡도는 다음과 같이 나타낼 수 있다.\n\n$$T(n) = 2T\\left(\\frac{n}{2}\\right)+ O(n)$$\n\n- a = 2 (두 개의 부분으로 나누기 때문에)\n- b = 2 (각 부분의 크기가 원래의 반이기 때문에)\n- $f(n) = O(n)$ (병합하는 데 걸리는 시간)\n\n#### 왜 $n^{log_{b}{a}}$ 를 계산해야 하는가?\n\n- a: 각 문제에서 만들어지는 하위 문제의 수\n- b: 각 하위 문제의 크기\n\n- [?] 전체 문제의 크기 n 에서 문제를 b 로 나누고 a 의 하위 문제를 해결할 때, 각 단계에서 얼마나 많은 계산이 필요한가?\n\n$n^{log_{b}{a}}$ 는 각 단계에서 발생하는 재귀 호출들의 총 계산량을 나타낸다. 이를 통해 각 단계에서 하위 문제를 해결하는 데 드는 비용과 비교하여 전체 알고리즘의 시간 복잡도를 결정할 수 있다.\n\n### Time Complexity Notation\n\n- Asymptotic Notation (점근적 표기법)\n\t- A way to describe the behavior of functions in the limit\n\t- 어떤 함수의 인수값이 무한히 커질 때, 그 함수의 증가율을 더 간단한 함수를 이용해 나타내는 것\n- O notation - upper bound\n- $\\Omega$ notation - lower bound\n- $\\Theta$ notation - tight bound\n\n### Parallel Merge\n\n1. Find $x = T[q_1]$, where $q_1$ is the midpoint of $T[p_1..r_1]$\n2. Use binary search to find the index $q_2$ in subarray $T[p_2..r_2]$ so that the subarray would still be sorted if we insert $x$ between $T[q_{2}- 1]$ and $T[q_2]$\n3. Copy $x$ to $A[q_3]$, where $q_{3}= p_{3}+ (q_{1}- p_{1}) + (q_{2}- p_2)$\n4. Perfom the following two steps in aprallel\n\t1. Recursively merge $T[p_1..q_{1}- 1]$ with $T[p_2..q_{2}- 1]$, and place the result into $A[p_3..q_{3}- 1]$\n\t2. Recursively merge $T[q_{1}+ 1..r_{1]}$ with $T[q_{2}+ 1..r_2]$, and place the result into $A[q_{3}+ 1..r_3]$\n\n### Quick-Sort algorithm\n\n- a recursive procedure\n\t- Select one of the numbers as pivot\n\t- Divide the list into two sublists: a “low list” containing numbers smaller than the pivot, and a “high list” containing numbers larger than the pivot\n\t- The low list and high list recursively repeat the procedure to sort themselves\n\t- The final sorted result is the concatenation of the sorted low list, the pivot, and the sorted high list\n\n### Randomized quick-sort\n\n- Worst-Case Time Complexity of Quick-Sort: $O(N^2)$\n- Average Time Complexity of Sequential Randomized Quick-Sort: $O(NlogN)$\n\n### Parallel partition\n\n- Recursive divide-and-conquer\n\n### Prefix Sums\n\n- Input: A sequence of n elements ${x_{1,}x_{2,}..., x_n}$ drawn from a set S with a binary associative operation, denoted by +\n- Output: A sequence of n partial sums ${s_{1,}s_{2,}..., s_n}$\n\n![[prefix-sums.png]]\n"},{"excerpt":"Physical Storage Systems Magnetic Disks platter 의 표면은 동심원으로 나누어진다. 각 track 은 sector 로 나뉜다. sector 는 데이터 읽기, 쓰기의 기본 단위이다. Cylinder: Platter 들의 집합인 가상의 원통 Seek time 1회만 필요함 Performance Measures of Disk…","fields":{"slug":"/2024-database-system/"},"frontmatter":{"date":"2024년 04월 21일 08:04","title":"데이터베이스시스템","tags":null},"rawMarkdownBody":"\n## Physical Storage Systems\n\n### Magnetic Disks\n\n- platter 의 표면은 동심원으로 나누어진다.\n- 각 track 은 sector 로 나뉜다.\n\t- sector 는 데이터 읽기, 쓰기의 기본 단위이다.\n- Cylinder: Platter 들의 집합인 가상의 원통\n\t- Seek time 1회만 필요함\n\n### Performance Measures of Disks\n\n- Access time: 기계를 움직이는데 필요한 시간\n\t- Seek time(탐색 시간): arm 을 정확한 track 으로 올려놓는 데 걸리는 시간\n\t- Rotational latency(회전지연시간): 접근해야 하는 sector 로 이동하는데 걸리는 시간\n\t\t- 평균적으로 반 바퀴 정도 돌아야 함\n- Data-transfer rate: 디스크에서 데이터를 가져오거나 저장하는 데 걸리는 속도\n\n### Performance Measures\n\n- Disk block\n\t- Disk I/O 를 진행하는 논리적인 단위, 데이터 이동이 이루어지는 단위\n\t- 4~16KB 정도로 설정됨\n\t\t- 더 작은 블록: I/O 횟수가 늘어날 수 있다.\n\t\t- 더 큰 블록: 불필요한 데이터를 I/O 하는 낭비가 발생할 수 있다.\n- Sequential access pattern\n- Random access pattern\n- I/O operations per second (IOPS)\n- Blocking Factor = block size / record size\n\n## Data Storage Structures\n\n### File Organization\n\n- 데이터베이스는 파일의 모음으로 저장된다. 각 파일은 레코드의 나열이다.\n\n### Fixed-Length Records\n\n- 레코드 크기가 고정되어 있다.\n- 각 파일들의 레코드 타입은 모두 같다.\n- 각 테이블마다 독립된 파일을 할당해준다.\n\n#### Deletion of record\n\ni 번째 레코드를 삭제한다고 가정한다.\n\n1. i + 1 ~ n까지의 레코드를 i ~ n-1 로 위치를 이동한다. => 많은 횟수의 I/O 를 유발한다.\n2. n번째의 레코드를 i 번째로 이동한다. => 2번의 I/O 필요\n3. 레코드들을 이동하지 않고, 모든 비어 있는 공간을 free list 로 관리한다.\n\n### Variable-Length Records\n\n- 가변길이 레코드는 데이터베이스 시스템에서 다양한 방식으로 사용된다.\n\t- 한 파일 안에 복수 개의 레코드를 저장하는 방식\n\t- 필드의 값 자체가 가변길이인 경우가 많다.\n\t- 레코드마다 반복되는 필드가 존재한다. (최신 RDB에서는 잘 안 쓰인다.)\n- 필드들을 정해진 순서대로 저장한다.\n- 고정 길이 속성을 저장한 뒤에 가변 길이 데이터를 저장한다.\n\t- 고정 길이 속성 값 + Null bitmap + 가변 길이 데이터\n\n#### Variable-Length Records: Slotted Page Structure\n\n- Slotted page 헤더가 포함하는 것\n\t- 블록 내의 레코드 개수\n\t- 빈 공간의 끝 위치\n\t- 각 레코드의 위치 (포인터), 길이\n- Record 와 Slot 은 1:1 매칭되지만, 레코드 순서와 slot 순서가 동일하지는 않다.\n- 레코드 삽입을 하기 위해서는 빈 공간의 크기가 Slot 길이 + 레코드 길이보다 같거나 커야 한다. \n- 레코드가 갱신된 경우 레코드의 길이를 변경하고, 인접 레코드를 이동한 뒤, Slot 의 레코드 길이와 포인터를 갱신한다.\n- 레코드가 삭제된 경우 레코드 공간을 free space 로 회수하고, 인접 레코드를 이동시킨 뒤, slot 의 레코드 포인터를 갱신한다. 이는 Record fragmentation 을 방지한다.\n\t- 레코드가 삭제될 때 레코드 공간은 회수하지만, slot 은 회수하지 않는다. (레코드 길이를 -1로 설정하는 등의 방식으로 삭제되었음을 표현한다.)\n\t- 항상 slot 수 == 레코드 수인 것은 아니다.\n- 블록 외부의 포인터는 레코드를 직접 가리키지 않고, 헤더의 slot 을 포인팅해야 한다.\n\n### Organization of Records in Files\n\n- Heap\n\t- 가장 기본적인 파일 구조\n\t- 공간이 있다면 레코드는 어디든지 놓일 수 있다.\n- Sequential\n\t- 레코드에 순서를 부여한다.\n\t- 각 레코드의 search key 의 값을 기준으로 레코드를 정렬된 상태로 저장한다.\n- B+-tree file organization\n\t- 가장 많이 사용되는 구조\n\t- 삽입/삭제가 진행되어도 정렬된 상태를 유지한다.\n- Hashing\n\n### Heap File Organization\n\n- 빈 공간이 있다면 파일 어디든지 위치할 수 있다.\n- 한 번 할당이 되면 잘 움직이지 않는다. (Block 들 사이에서)\n- 어떤 블록에 빈 공간이 있는지를 알아내는 것이 중요하다.\n- Free-space map\n\t- 각 블록 간의 상태 정보를 저장한다.\n\t- 블록마다 1개의 entry 를 갖는다.\n\t- 각 entry 는 몇 개의 bit 나 byte 로 구성이 되는데, 현재 얼마나 빈 공간이 존재하는지에 대한 값을 저장한다.\n\t- Second-level free-space map 을 갖기도 한다.\n\n### Sequential File Organization\n\n- search-key 값으로 파일의 레코드들이 정렬된다.\n- 파일의 모든 레코드를 순차적으로 접근하는 연산이 많이 발생하는 경우 유리하다. 소수의 레코드를 찾는데 사용하는 것은 비효율적이다.\n- 레코드 삭제\n\t- pointer chain 을 사용한다.\n- 레코드 삽입\n\t- 빈 공간이 있으면 그 부분에 삽입하고 포인터를 업데이트한다.\n\t- 빈 공간이 없으면, 임시 저장 블록에 record 를 삽입하고 포인터를 업데이트한다.\n- 점점 레코드 link 가 복잡해지게 되고, 이는 검색 성능에 영향을 준다. (Overflow block 이 다른 block 에 존재하면 Disk I/O가 필요하기 때문에 성능이 저하된다.) 따라서 주기적으로 reorganize 를 수행하여 논리적 순서와 물리적 순서를 동일하게 만들어주는 것이 좋다.\n\n### Multitable Clustering File Organization\n\n- 논리적으로 다른 테이블의 레코드를 같은 파일에 저장하는 것이다.\n- 해당 구조를 효율적으로 사용할 수 있는 질의들에는 자연 조인이 있다.\n- 한 파일 내에서 하나의 테이블만 조회하면 성능이 저하될 수 있다. (데이터가 뒤섞여 있기 때문에 골라내는 추가적인 과정이 필요함)\n- 레코드 포맷이 다르기 떄문에 레코드 크기가 다양하다.\n- 특정 테이블의 레코드들은 그들만의 링크로 연결하는 방식을 사용할 수도 있다.\n\n### Data Dictionary Storage\n\n- system catalog 라고 하기도 한다.\n- metadata 를 저장한다.\n- 메타데이터의 종류\n\t- 관계 테이블의 정보\n\t\t- 관계 테이블의 이름\n\t\t- 각 속성들의 이름, 타입, 길이\n\t\t- view (가상 테이블) 의 이름과 정의\n\t\t- 무결성 제약\n\t- 유저, 계정 정보\n\t- 통계 정보\n\t\t- 각 관계 테이블의 튜플의 개수\n\t- 물리적 파일 구성 정보\n\t\t- 관계 테이블이 어떤 방식으로 저장이 되었는가 (sequential / hash / …)\n\t\t- 관계 테이블의 물리적인 위치\n\t- 인덱스 정보\n- 메타데이터는 테이블에 저장될 수 있고, 인메모리 자료구조로 메타데이터를 적재하기도 한다.\n\n### Storage Access\n\n- Buffer: Disk 블록들의 복사본을 저장하기 위해 이용 가능한 메인 메모리의 일부\n- Buffer manager: 메인 메모리의 버퍼 공간을 할당하는 책임을 갖는 서브 시스템\n\n#### Buffer Manager\n\n- 프로그램은 Disk 에서 블록이 필요하면 buffer manager 를 호출한다.\n\t- 블록이 이미 버퍼에 존재하면, buffer manager 는 메인 메모리의 블록 주소를 반환한다.\n\t- 블록이 버퍼에 없는 경우\n\t\t- 블록을 버퍼로 가져온다.\n\t\t\t- 필요하다면 새 블록을 위한 공간을 만들기 위해 다른 블록을 대체할 수 있다.\n\t\t\t- 대체되는 블록이 가장 최근에 disk 에 쓰이거나 / fetch 되었던 시간 이후에 변경되었다면, disk 에 변경 사항을 반영한다.\n\t\t- 블록을 읽고, 프로그램에게 메인 메모리의 블록 주소를 반환한다.\n- Buffer replacement strategy\n\t- Pinned Block\n\t\t- Pin: 버퍼 내에 내용을 고정시켜, 페이지 교체 대상에서 면제한다.\n\t\t- Unpin: 버퍼 교체 대상이 될 수 있다.\n\t- Shared and exclusive locks on buffer\n\n#### Buffer-Replacement Policies\n\n- 대부분의 OS 는 블록을 Least Recently Used 방식으로 교체한다.\n\t- 그러나 LRU 는 DB 의 경우 좋지 않은 경우가 존재한다. 예를 들어 2개의 관계 테이블을 join 할 때, 가장 최근에 사용된 데이터를 삭제하는 것이 더 좋을 것이다. (왜냐하면 가장 최근에 사용된 데이터는 조인 과정 내에서 앞으로 더 이상 사용되지 않을 가능성이 높기 때문이다.)\n- **Toss-immediate strategy**\n\t- 블록에 들어 있는 마지막 튜플의 접근이 끝나자마자 버퍼에서 지운다.\n- **Most recently used (MRU) strategy**\n\t- 가장 최근에 접근한 블록을 제거한다. (중첩 루프 조인 알고리즘)\n\n## Indexing\n\n### Basic Concepts\n\n- 데이터에 접근하는 속도를 높이기 위해 사용된다.\n- Search Key\n\t- 인덱스를 만드는 컬럼 속성\n\t- 한 개일 수도 있고, 합성을 할 수도 있다.\n- Index file\n\t- search-key 와 pointer 로 구성되어 있는 index entry 의 집합\n- 인덱스 파일의 크기는 원본 파일보다 더 작기 때문에 검색 성능이 향상된다.\n- 인덱스의 종류\n\t- Ordered indices: B+ 트리\n\t- Hash indices: 해시 함수를 사용하여 인덱스를 여러 버킷에 분산하는 방식\n\n### Index Evaluation Metrics\n\n접근 방식은 두 가지가 존재한다. \n- 특정 값을 갖는 레코드 찾기\n- 컬럼 값의 범위를 주고, 해당하는 범위의 레코드 찾기\n\n- Access time\n- 삽입 시간\n- 삭제 시간\n- 공간 오버헤드\n\n### Ordered Indices\n\n- 인덱스가 Search Key 값으로 정렬된 것을 말한다.\n- **Clustering Index**\n\t- 순차적으로 정렬된 파일에서, 데이터 파일 레코드 자체가 정렬되어 있는 것\n\t- primary index 라고 부르기도 한다.\n\t- 보통은 primary key 로 만들어지지만, 필수적으로 그런 것은 아니다.\n- **Secondary Index**\n\t- 데이터의 정렬 순서와 인덱스 정렬 순서가 동일하지 않은 상태\n\t- **nonclustering index** 라고 부르기도 한다.\n\t- have to be dense.\n- **Index-sequential file**\n\t- Clustering index 가 search key 에 대해 정렬되어 있는 상태\n\n### Dense Index Files\n\n- 데이터 파일 대비 인덱스 파일 용량이 더 작기 때문에 접근하는 시간이 더 작다.\n- Dense Index는 모든 search-key value 에 대해 인덱스 레코드가 존재하는 것을 말한다.\n\t- ID 값은 유니크하기 때문에 모든 search key value 에 대해 인덱스 레코드가 존재한다.\n- 데이터들이 모여있기 때문에 디스크 I/O 를 덜 해도 된다는 장점이 있다.\n\n### Sparse Index Files\n\n- 몇 개의 search-key 값에 대한 index record 만 포함하는 인덱스\n\t- 레코드가 순차적으로 search-key 로 정렬되어 있는 경우 주로 사용 (순차 파일 구조여야 함)\n- K 값을 가진 레코드를 찾을 때, K보다 작은 값들 중에 최댓값의 search-key 값을 갖는 인덱스 레코드를 찾는다. 그 후 해당 인덱스 레코드가 가리키는 레코드부터 시작해서 순차적으로 탐색한다.\n- Dense Index File 과 비교했을 때\n\t- 공간을 더 적게 사용하고, 삽입 삭제시 관리 오버헤드가 더 적다.\n\t- 부분적인 순차 접근을 요구하기 때문에 dense index 에 비해 일반적으로 더 느리다. \n- **Good tradeoff**\n\t- clustered index 에서 파일 내에 있는 각 블록의 가장 작은 값만 뽑아 sparse index 로 만들기\n\n### Clustering vs Nonclustering Indices\n\n- clustering: block I/O 를 덜 하면서 레코드에 접근할 수 있다.\n- nonclustering: 레코드가 서로 다른 블록에 있어 하나에 접근할 때마다 disk I/O 를 해야 하기 때문에 seek time 등 여러 오버헤드가 존재한다.\n\n### Multilevel Index\n\n- 인덱스에 대한 인덱스\n- 인덱스가 메모리에 맞지 않으면, 접근을 더 많이 해야 하기 때문에 비용이 커진다.\n- outer index 로 sparse index 를 사용하고, inner index 가 basic index file 이 된다. \n- 계속해서 상위의 multilevel index 를 만들 수 있다.\n- 모든 level 의 인덱스들은 삽입이나 삭제가 발생할 때마다 업데이트되어야 한다.\n\n### Indices on Multiple Keys\n\n- Composite search key\n\t- DBMS 내부적으로 Non-unique index 를 만들 때, unique search key 와 합성해서 non-unique index 를 생성하기도 한다.\n\n### B+-Tree Index Files\n\n- indexed-sequential files 의 단점\n\t- 많은 overflow 블록이 생성되기 때문에, 파일 크기가 커질 수록 성능이 낮아진다.\n\t- 주기적으로 파일 전체를 재구성해야 한다.\n- B+-tree index file 의 장점\n\t- 삽입, 삭제가 일어날 때마다 적은 부담으로 재구성을 자동으로 수행할 수 있다.\n\t- 성능을 관리하기 위한 전체 파일의 재구성이 필요하지 않다.\n- B+-tree 의 (사소한) 단점\n\t- 삽입, 삭제의 오버헤드가 존재하지만, 크지 않다.\n\n#### 특징\n\n다음과 같은 특성을 만족해야 한다.\n\n- Balanced tree 이기 때문에 루트에서 리프노드까지의 거리는 모두 같다. \n- 각 노드의 50% 이상이 데이터로 차있어야 한다. (root 는 제외한다)\n- 특별한 경우\n\t- 루트가 리프가 아니면 자식이 2개 이상이어야 한다.\n\t- 루트가 리프면, 루트 노드는 0~n-1 개의 데이터로 구성되어야 한다.\n\n#### B+-Tree Node Structure\n\n- $K_i$ : search-key 값\n- $P_i$: 자식 노드를 가리키는 포인터 (non-leaf node 의 경우) 이거나, 레코드나 버킷을 가리키는 포인터 (leaf node 의 경우)\n- $P_{n-1}$ 은 인접한 형제 노드를 가리킨다.\n\n#### Non-Leaf Nodes in B+-Trees\n\n- Non-Leaf node 는 리프 노드의 multi-level sparse index 이다.\n\n#### Observations about B+-trees\n\n- 논리적으로 근접한 블록들이 물리적으로는 그렇지 않을 수 있다.\n- Non-leaf 노드는 sparse index 계층 구조를 구성한다.\n- B+-tree 는 높이가 낮은 편이다.\n- K 개의 search-key 값이 존재할 때, 트리의 높이는 $ceil(log_{n/2}(K))$ 보다 클 수 없기 때문에, 탐색이 매우 효율적이다.\n- 삽입 / 삭제가 발생할 때 시간 복잡도는 Log 시간으로 동작한다.\n\n#### Queries on B+-Trees\n\n- Range query 를 지원한다. 범위의 시작 값으로 검색을 시작하고, 계속해서 옆으로 이동하며 range 검색을 수행할 수 있다.\n\n#### Updates on B+-Trees: Insertion\n\n1. search-key 값으로 리프 노드를 찾는다.\n\t- 만약 리프 노드에 빈 공간이 있으면, 삽입한다.\n\t- 공간이 없으면 노드를 분할한다.\n2. 부모 노드에 k (키값), p (새로 삽입한 형제 노드 포인터) entry 를 삽입한다.\n\t- 부모 노드가 꽉 차있다면, 계속해서 상위로 전파한다.\n\t- 루트도 자리가 없으면 루트가 새롭게 생긴다.\n"},{"excerpt":"LOG 오늘의 영어 배운 것 DB 의 Connection 을 재사용할 수 있는 이유는 host 와 client 가 정해져 있고 바뀌지 않기 때문이다 (host 는 웹 서버, client 는 데이터베이스) 느낀 것","fields":{"slug":"/2024-03-26/"},"frontmatter":{"date":"2024년 03월 26일 07:03","title":"2024년 03월 26일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 오늘의 영어\n\n## 배운 것\n\n- DB 의 Connection 을 재사용할 수 있는 이유는 host 와 client 가 정해져 있고 바뀌지 않기 때문이다 (host 는 웹 서버, client 는 데이터베이스)\n\n## 느낀 것"},{"excerpt":"Blocking 특정 작업을 수행할 때 해당 작업이 완료될 때까지 호출한 프로세스 (또는 스레드)가 대기 상태에 놓이는 것 블로킹 작업 중에는 해당 프로세스가 다른 작업을 수행할 수 없다. Non-Blocking 작업을 요청했을 때 해당 요청이 즉시 완료되지 않더라도 호출한 프로세스가 대기하지 않고 즉시 실행을 계속할 수 있음을 의미한다. 결과는 나중에 …","fields":{"slug":"/blocking-synchronous/"},"frontmatter":{"date":"2024년 03월 25일 06:03","title":"Blocking vs Non-Blocking vs Synchronous vs Asynchronous","tags":null},"rawMarkdownBody":"\n## Blocking\n\n- 특정 작업을 수행할 때 해당 작업이 완료될 때까지 호출한 프로세스 (또는 스레드)가 대기 상태에 놓이는 것\n- 블로킹 작업 중에는 해당 프로세스가 다른 작업을 수행할 수 없다.\n\n## Non-Blocking\n\n- 작업을 요청했을 때 해당 요청이 즉시 완료되지 않더라도 호출한 프로세스가 대기하지 않고 즉시 실행을 계속할 수 있음을 의미한다.\n- 결과는 나중에 확인되거나, 다른 방식 (콜백 등) 으로 전달된다.\n\n## Synchronous\n\n- 동기 방식에서는 작업들이 순서대로 실행된다. 한 작업의 완료 후 다음 작업이 시작된다. \n- 결과는 바로 반환되며, 호출된 프로세스는 각 작업의 완료를 기다린다.\n\n## Asynchronous\n\n- 여러 작업이 동시에 실행될 수 있다. 한 작업의 완료를 기다리지 않고 다음 작업을 시작할 수 있다.\n- 작업 완료와 결과는 나중에 알림 (콜백, 프로미스, 이벤트 리스너)을 통해 전달된다.\n\n## Blocking Synchronous\n\n작업 요청이 끝날 떄까지 프로그램의 실행이 정지되며, 요청한 작업이 완료된 후에야 다음 작업으로 넘어간다. 작업 처리 과정에서 프로그램은 대기 상태에 있으며, 이후의 작업들은 이전 작업이 완료될 때까지 실행되지 않는다.\n\nex. 파일 시스템에서 파일을 읽는 작업을 요청하고, 파일의 모든 내용이 읽혀질 때까지 기다린 후, 파일 내용을 메모리에 저장하고 출력하는 프로그램\n\n## Blocking Asynchronous\n\n(일반적이지 않음)  \n블로킹이지만 비동기적 요소를 포함할 수 있는 특별한 상황을 가리킨다. 메인 작업이 대기 상태에 있지만, 백그라운드에서 비동기적으로 여러 작업이 진행되는 경우를 말할 수 있다. \n\nex. GUI 애플리케이션에서 메인 UI 스레드가 사용자 입력을 기다리는 동안(블로킹), 백그라운드 스레드에서 비동기적으로 데이터를 다운로드 받는 경우를 생각할 수 있다. 메인 스레드는 블로킹되지만, 백그라운드 작업은 비동기적으로 진행된다.\n\n## Non-Blocking Synchronous\n\n작업 요청이 즉시 반환되며, 호출자는 결과가 준비되지 않았다면 다시 시도해야 한다. 작업 완료를 기다리는 대신, 주기적으로 작업의 완료 여부를 폴링한다. \n\nex. 데이터베이스 쿼리를 보내고, 즉시 응답을 받는다. 그러나 응답에 데이터가 없다면, 일정 시간 후 다시 쿼리를 보내 결과가 준비되었는지 확인한다. 이 과정을 결과를 얻을 때까지 반복한다.\n\n## Non-Blocking Asynchronous\n\n작업 요청이 즉시 반환되고, 작업의 완료와 결과는 콜백, 프로미스, 이벤트 리스너 등을 통해 비동기적으로 처리된다. 호출자는 다른 작업을 계속 수행할 수 있으며, 특정 작업이 완료되면 그에 대한 알림을 받는다. \n\nex. 웹 서버에서 클라이언트의 HTTP 요청을 처리하는 경우, 서버는 각 클라이언트 요청을 즉시 수락하고, 요청 처리는 비동기적으로 수행된다. 각 요청이 처리되면, 결과는 비동기적으로 클라이언트에게 전송된다. 서버는 이 과정에서 다른 클라이언트의 추가 요청을 계속 받을 수 있다.\n\n## Blocking & Non-Blocking\n\n이 개념들은 호출된 작업이 호출자의 실행 흐름을 어떻게 다루는지에 대해 초점을 맞춘다. Blocking 은 호출된 작업이 완료될 때까지 호출자의 실행 흐름을 대기 상태로 만들고, Non-blocking 은 호출된 작업이 즉시 반환되어, 호출자가 대기 없이 다른 작업을 계속할 수 있도록 한다.\n\n## Synchronous & Asynchronous\n\n이 개념들은 작업의 완료가 어떻게 전달되는지에 대한 것이다. Synchronous 방식에서는 작업의 결과나 완료가 바로 반환되며, 작업 처리가 순차적이다. Asynchronous 방식에서는 작업이 백그라운드에서 수행되며, 완료 시 콜백, 이벤트, 프로미스 등을 통해 결과가 반환된다. \n\n## 참고\n\n- Non-blocking 방식은 시스템의 응답성을 높일 수 있지만, 반드시 비동기적일 필요는 없다. Non-blocking Synchronous 방식은 polling 이나 반복 확인을 통해 작업 완료를 확인할 수 있다."},{"excerpt":"","fields":{"slug":"/rsync/"},"frontmatter":{"date":"2024년 03월 25일 06:03","title":"rsync","tags":["linux","zeropage","미완"]},"rawMarkdownBody":"\n"},{"excerpt":"LOG ‘정체성의 심리학’ 이라는 책을 읽었다. 그래서 ‘나는 내가 무엇을 하고 싶은지 모르는 사람이다’와 같은 답변은 자기개념이 될 수는 있어도 정체성은 될 수 없다. 자신에게 중요한 인생 이야기들이 결국 자신이 어떤 사람인지에 대한 가장 좋은 설명, 즉 정체성 그 자체이다. 인생 이야기란 어떤 일에 대한 객관적 사실에 관한 이야기가 아니라 그 사건이 …","fields":{"slug":"/2024-03-13/"},"frontmatter":{"date":"2024년 03월 13일 09:03","title":"2024년 03월 13일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- ‘정체성의 심리학’ 이라는 책을 읽었다.\n\n> 그래서 ‘나는 내가 무엇을 하고 싶은지 모르는 사람이다’와 같은 답변은 자기개념이 될 수는 있어도 정체성은 될 수 없다.\n\n> 자신에게 중요한 인생 이야기들이 결국 자신이 어떤 사람인지에 대한 가장 좋은 설명, 즉 정체성 그 자체이다.\n\n> 인생 이야기란 어떤 일에 대한 객관적 사실에 관한 이야기가 아니라 그 사건이 자신에게 어떤 의미로 맺히게 되어 자신의 삶을 이끌어가고 있는지에 대한 이야기이다.\n\n> 한 개인이 결코 역사나 사회현실로부터 자유로울 수 없다. 사회현실이 개인을 내버려두지 않기 때문이다. 그렇지만 어떠한 정치적 현실이나 외부의 파괴적인 힘도 인간의 숭고한 영혼을 완전히 파괴할 수 없다. 한 개인이 지킬 수 있는 자신의 몫은 있다. 주인공 역시 자신에게 주어진 시간과 기회들을 ‘좋은 꿈’으로 만들 수 있는 기회는 있었다.\n\n> 인생의 전환점들은 하루하루 산다고 저절로 이어지는 것이 아니다. 자신의 인생 이야기를 통해 엮어내야만 하는 것이다.\n\n> 의미가 만드는 것이든 찾는 것이든 중요한 점은 자신의 인생 이야기에 의미를 부여하는 일이다.\n\n> 때때로 길을 잃어 헤맸고, 가까운 길을 돌아가기도 했고, 왔던 길로 다시 돌아가야 했더라도 모두 ‘자신의 길’ 로 받아들이고 그 여정에서 의미를 찾는 것이다.\n\n> 진짜 우리가 물어야 하는 질문은 ‘무엇을 하며 살 것이냐’ 이다. 우리가 선택해서 태어나지 않았기 때문에 ‘왜’ 라는 물음에 대한 근원적인 답변은 불가능하다. \n\n## 배운 것\n\n## 느낀 것\n\n- 최근에 내가 살아야 하는 이유, 너무나도 권태롭고 지루한 인생에 대해 생각하고 있었는데, 마침 오늘 정말 좋은 책을 만났다. 내가 걸어온 길, 내가 겪었던 경험을 통해 나는 ‘나’ 를 만들어 왔다. 일련의 사건들을 통해 내가 느낀 것, 내가 생각한 것, 사랑했던 것, 좋았던 것, 싫었던 것, 혐오하던 것, 염원하던 것… 그 모든 게 내 인생이자 나였다. 인생이란 ‘나’ 를 만들어가는 과정으로, 있었던 경험들을 모두 하나의 주제로 회귀되는 ‘나의 삶’ 을 살아야 한다는 생각이 크게 들었다. 오늘이 지루함과 권태로운 하루 중의 하나가 아니라 내 인생의 전개 과정이라고 생각한다면 못할 것도 없다. 나는 뭐든 바꿀 수 있다. 내일은 오늘까지 살아온 내가 살아갈 새로운 날, 내 마음대로 행동할 수 있는 날이니까. 이제 조금 인생을 살아보고 싶은 마음이 들었다."},{"excerpt":"설치 Ubuntu 20.04 버전에서 진행했다. tar 파일 다운로드 받기 github 링크 에서 필요한 버전의 파일을 다운로드 받는다. 나는 PCL 1.14.0 버전으로 진행했고, source.tar.gz 를 다운로드 받는다. 파일의 압축을 풀어준다. CMake 압축이 풀리면  이라는 폴더가 생성된다.\n해당 폴더로 이동하고, build 폴더를 만든 뒤 …","fields":{"slug":"/pcl/"},"frontmatter":{"date":"2024년 02월 20일 06:02","title":"Point Cloud Library","tags":["lidar","pcl","lab"]},"rawMarkdownBody":"\n## 설치\n\nUbuntu 20.04 버전에서 진행했다.\n\n### tar 파일 다운로드 받기\n\n[github 링크](https://github.com/PointCloudLibrary/pcl/releases) 에서 필요한 버전의 파일을 다운로드 받는다. 나는 PCL 1.14.0 버전으로 진행했고, source.tar.gz 를 다운로드 받는다. \n\n```shell\ntar xvfz source.tar.gz\n```\n\n파일의 압축을 풀어준다. \n\n### CMake\n\n압축이 풀리면 `pcl` 이라는 폴더가 생성된다. \n해당 폴더로 이동하고, build 폴더를 만든 뒤 이동한다. \n\n```shell\ncd pcl && mkdir build && cd build\n```\n\nbuild 내부에서 CMake 를 수행한다.  \n\n```shell\ncmake ..\n```\n\n### 설치하기\n\n파일을 설치한다. 설치하는 데는 시간이 꽤 오래 걸렸다. \n\n```shell\nsudo make -j2 install\n```\n\n잘 설치되었는지 확인하기 위해 PCL 버전을 확인해보자.  \n\n```shell\ndpkg -s libpcl-dev | grep 'Version'\n```\n\n잘 나온다면 설치가 완료된 것이다. \n\nPCD 파일도 출력해보자.  \n\n```shell\n/usr/local/bin/pcl_viewer pcd파일이름\n```\n\nviewer 창이 떠서 pcd 파일이 시각화되어 잘 보인다면 설치가 잘 된 것이다. \n\n## PCD 파일 실행하기\n\n[해당 링크](https://pcl.readthedocs.io/projects/tutorials/en/latest/using_pcl_pcl_config.html#using-pcl-pcl-config) 를 참고하여 작성되었다. \n\n`~/pcd-test` 디렉터리에 `pcd_read.cpp` 라는 파일이 존재한다고 가정하자.  \n\n`CMakeLists.txt` 라는 파일을 만들어야 한다. 내용은 다음과 같다.  \n\n```cmake\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\nproject(pcd-read)\nfind_package(PCL 1.3 REQUIRED)\ninclude_directories(${PCL_INCLUDE_DIRS})\nlink_directories(${PCL_LIBRARY_DIRS})\nadd_definitions(${PCL_DEFINITIONS})\nadd_executable(pcd_read pcd_read.cpp)\ntarget_link_libraries(pcd_read ${PCL_LIBRARIES})\n```\n\n### 설명\n\n```cmake\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n```\n\ncmake 의 필수 기능이다.\n\n```cmake\nproject(pcd-read)\n```\n\n프로젝트의 이름을 지정하고, 소스 디렉터리 (MY_GRAND_PROJECT_SOURCE_DIR) 과 cmake 를 호출하는 디렉터리 (MY_GRAND_PROJECT_BINARY_DIR) 를 참조하는 변수와 같은 몇 가지 유용한 cmake 변수를 설정한다. \n\n```cmake\nfind_package(PCL 1.3 REQUIRED)\n```\n\n최소 버전 1.3에서 PCL 패키지를 찾도록 요청하고 있다. \n\n- 단 하나의 컴포넌트: `find_package(PCL 1.3 REQUIRED COMPONENTS io)`\n- 여러 개: `find_package(PCL 1.3 REQUIRED COMPONENTS io common)`\n- 기존 모든 구성 요소: `find_package(PCL 1.3 REQUIRED)`\n\n```cmake\ninclude_directories(${PCL_INCLUDE_DIRS})\nlink_directories(${PCL_LIBRARY_DIRS})\nadd_definitions(${PCL_DEFINITIONS})\n```\n\nPCL 이 발견되면 몇 가지 관련 변수가 설정된다. 프로젝트에 포함하는 외부 헤더를 cmake 에 알려주려면 `include_directoreis` 매크로를 사용해야 한다. \n\n```cmake\nadd_executable(pcd_read pcd_read.cpp)\n```\n\n하나의 소스 파일 `pcd_read.cpp` 와 `pcd_read` 라는 실행 파일을 만들려고 한다고 cmake 에 알려준다. \n\n```cmake\ntarget_link_libraries(pcd_read ${PCL_LIBRARIES})\n```\n\n빌드하는 실행 파일은 PCL 함수를 호출한다. 지금까지는 컴파일러가 우리가 호출하는 메서드에 대해 알 수 있도록 PCL 헤더만 포함했다. 또한 링커가 우리가 링크하려는 라이브러리에 대해 알 수 있도록 해야 한다. PCL 에서 찾은 라이브러리는 `PCL_LIBRARIES` 변수를 사용하여 참조된다. \n\n## PCD 파일 읽기\n\n다음과 같이 작성하면, pcd 파일에 있는 모든 point 를 출력할 수 있다.\n\n```cpp\n#include <iostream>\n #include <pcl/io/pcd_io.h>\n #include <pcl/point_types.h>\n \n int\n main ()\n {\n   pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);\n \n  if (pcl::io::loadPCDFile<pcl::PointXYZ> (\"test_pcd.pcd\", *cloud) == -1) //* load the file\n  {\n    PCL_ERROR (\"Couldn't read file test_pcd.pcd \\n\");\n    return (-1);\n  }\n  std::cout << \"Loaded \"\n            << cloud->width * cloud->height\n            << \" data points from test_pcd.pcd with the following fields: \"\n            << std::endl;\n  for (const auto& point: *cloud)\n    std::cout << \"    \" << point.x\n              << \" \"    << point.y\n              << \" \"    << point.z << std::endl;\n\n  return (0);\n}\n```"},{"excerpt":"Expression in return: 보답으로 I had been debating / They were debating whether or not ~: ~ 을 할지 말지 고민이었다. what they said: 그들이 했던 말 I misunderstood what they said. get mad: 화가 나다 be against N: N을 반대하다. T…","fields":{"slug":"/english-speaking-2024-02-13/"},"frontmatter":{"date":"2024년 02월 13일 11:02","title":"02월 13일 영어회화","tags":["english"]},"rawMarkdownBody":"\n## Expression\n\n- in return: 보답으로\n- I had been debating / They were debating whether or not ~: ~ 을 할지 말지 고민이었다.\n- what they said: 그들이 했던 말\n\t- I misunderstood what they said.\n- get mad: 화가 나다\n- be against N: N을 반대하다.\n\t- They were strongly against me living with him.\n- It’s someone’s way of V-ing : V를 하는 someone 만의 방법이다.\n- one time, two hours\n\t- 한 번에 2 시간\n\n## 구문\n\n- when ~ , then I will 구문은 fact 나 habit 을 뜻한다. 이때는 현재형을 사용할 수도 있다. 현재형을 사용하는 것도 fact, habit 을 의미한다.\n- If + past tense, S could / would / should (not) 는 가능성을 표현하는 구문이다.\n- I’m thinking about having more of these classes.\n\n## 알아둘 내용\n\n- Could I ~ 가 Could you ~ 보다 더 정중한 표현이다. Could you 는 you 가 줘야 하는 의무 같은 게 있는 느낌? 무례한 것처럼 보일 수도 있다고 한다. \n\t- Could I have a piece of paper to write on? : 종이를 빌려주실 수 있을까요?\n- Could I have / do / use / see  … : I want to do something, but need your permission.\n- Could you ~ : **I want you to do**\n- sheet 를 발음할 때 shit 말고 ee 발음을 살려서 제대로 발음할 것\n- oppose 는 굉장히 formal 한 표현이다. 한국어로 ‘항의하다’ 라고 쓰이는 듯. "},{"excerpt":"Point Cloud Compression PCC 라고 부르기도 한다. Reference https://pcl.readthedocs.io/projects/tutorials/en/latest/compression.html#octree-compression point cloud library tutorial (한글) 논문 조사 Real-time Compres…","fields":{"slug":"/point-cloud-compression/"},"frontmatter":{"date":"2024년 02월 13일 07:02","title":"Point Cloud Compression","tags":["lidar","lab"]},"rawMarkdownBody":"\n## Point Cloud Compression\n\nPCC 라고 부르기도 한다.\n\n### Reference\n\nhttps://pcl.readthedocs.io/projects/tutorials/en/latest/compression.html#octree-compression\n- [point cloud library tutorial (한글)](https://pcl.gitbook.io/tutorial/part-0/part00-chapter02)\n\n## 논문 조사\n### [Real-time Compression of Point Cloud Streams](https://ieeexplore.ieee.org/document/6224647)\n\n#### Introduction\n\npoint cloud 의 큰 size 때문에 처리와 변환이 리소스의 상당한 부분을 차지한다. 특히, 원격 데이터 처리 또는 포인트 클라우드의 실시간 전달은 어렵다. 대역폭이 제한된 환경 (온라인 스트리밍이나 저장소) 를 위해 효율적인 압축 해결책을 개발하는 것은 필수가 되어가고 있다.  \n\n깊이 이미지를 만들어내는 센서를 위해, 여러 접근 방식들이 제안되어 오고 있다. 그 중에서 이미지 압축 분야에서 사용되는 이미 존재하는 방법들을 채택하기도 하고, 일관적으로 샘플링되거나 구성된 포인트 클라우드를 위해 특별하게 고안된 자료 구조나 알고리즘을 이용하기도 한다. 그러나 여러 개의 3D 카메라 시스템을 사용하는 경우에서는, 이미지 영역이 겹치는 것은 중복 정보를 야기하게 되어 이를 위해 다른 해결책이 고려되어야만 한다. 예를 들어, 이는 또한 움직이는 환경에 고정된 기울어진 레이저 스캐너에도 적용이 되는데, 이때 단일 프레임이 특정 포인트에서 찍혔을 것이라고 추측할 수 없다. 여기서, 들어오는 포인트들은 일반적으로 종종 사용될 수 있는 센서의 궤적에 대한 정보에 따라 예비 정렬 (prealign) 되어 있다. (또는 다양한 SLAM 변수들을 사용하여 추정될 수 있다.)  \n\n우리는 이러한 문제를 구성되지 않은 (unorganized) 포인트 클라우드, (즉 무작위 순서로 포인트 집합이 저장되어 있는), 로서 데이터를 다룸으로써 접근했고, 스캔에 빠진 곳이 있거나 샘플링 밀도가 불규칙할 수 있다. 이는 우리의 제안된 시스템을 더 넓은 범위의 센서들과 데이터 획득 전략에서 더욱 일반적이고 접근하기 쉽도록 만들어준다.  \n\n압축 알고리즘은 loss-less (원본 데이터에 포함된 모든 정보는 압축된 형식으로 재구축될 수 있음) 와 lossy 로 넓게 구분될 수 있다. 후자의 경우, 세세한 정보는 특정 수준 정도 희생되지만, 상당히 높은 압축률을 얻을 수 있다. 많은 방법들에서 raw 데이터는 본질적으로 \n\n### Emerging MPEG Standards for Point Cloud Compression\n\n#### Introduction\n\n3D 센싱과 캡쳐 기술의 발전은 VR/AR/MR 컨텐츠 창작과 소통뿐 아니라 스마트 시티, 로봇공학과 자동화 주행 분야를 위한 3D 센싱 분야에서의 혁명의 물결을 해방했다. 현재 현실 세계를 디지털 3차원으로 표현할 수 있고 최종 사용자가 자유롭게 디지털 표현을 펼치게 할 수 있는 가상현실 시장인 거대한 인터넷이 존재한다. 측정에 관한 시각 데이터는 3D 장면과 객체들을 그들의 기하학적 성질과 각각의 특징, 어떤 시간적 변화를 모사한다. 그런 데이터는 일반적으로 3D 모델로부터 컴퓨터에 의해 생성되거나, 여러 대의 카메라나 영상 합성, 전용 기하학적 센서를 사용하여 현실 장면을 포착되기도 한다. 그러한 측정과 관련된 데이터를 위한 흔한 표현 방식은 폴리곤 메쉬 (polygon meshes) 나 포인트 클라우드이다. 시간 정보는 각각의 포착된 개체 (2D 비디오의 한 프레임과 유사한) 들의 형태로 포함되어 있거나, 개체의 위치를 시간의 함수로 표현한다. 측정된 비디오는 완전한 3D 장면이나 개체를 묘사하기 때문에, 그러한 데이터는 어떤 관점에서든지 시각화되어야 한다. 그러므로 측정된 비디오는 어떤 AR, VR, MR 애플리케이션을 가능하게 하는 핵심 기술이며, 특히 Six Degrees of Freedom 제공을 위한 보기 기능을 제공한다.  \n\n이전의 기준들에서의 MPEG는 이미 3D 세상의 코딩으로 간주되었지만, 현재 실제 3D 장면들을 코딩으로 표현하기 위한 기술들의 야심찬 로드맵에 최근에 착수했다. 이러한 기술들 중의 하나는 Point Cloud Compression (PCC) 이라고 하며, 2020 초에 ISO 표준으로 제안될 예정이다. 2017 년에 MPEG 는 PCC 에 대한 제안 요청을 발표했으며, 이후 제안된 기술들의 성능을 평가하고 개선하고 있다. 이러한 포인트 클라우드 데이터는 신호 처리와 압축 연구 커뮤니티에 새로운 과제를 제시한다. 측정된 시각 매체들을 위한 이전 압축 해결법은 컴퓨터로 생성된 내용에 초점을 맞추거나 포착된 자연 컨텐츠를 처리할 때 공간 및 시간적 압축 성능이 낮았다. 3D 센서 신호로 포착된 원본을 위해, scene geometry 는 상세 수준에서 확장성이 있고, 압축에 효율적인 표현이 필요하며, photometric 속성은 균일한 유클리드 그리드에서 샘플링되지 않는 새로운 종류의 신호이므로 표현 및 압축을 위한 새로운 샘플링, 필터링, 변환 툴이 필요하다. 최근 Graph Signal Processing (GSP) 에서의 발전은 이를 위한 방대한 집합의 도구들을 제공해왔다. \n\n#### Point Cloud Data\n\n몰입형 VR/MR 비디오, 자동차/로봇 내비게이션, 의료 영상 등 새롭게 떠오르는 많은 애플리케이션에는 3D 장면/사물 지오메트리 데이터의 캡쳐와 처리가 필요하다. 이 데이터는 가장 원시적인 형태로, 포인트 클라우드라고 하는 점들의 집합으로 구성된다.  \n\n- 특징\n포인트 클라우드는 각각의 3D 포인트들의 집합으로 구성되어 있다. 각각의 포인트는, x, y, z 위치를 가질 뿐만 아니라 색깔, 반사도, 표면 법선 등의 다른 많은 속성을 포함할 수 있다. 이는 개별 포인트들간에 지정된 공간 연결이나 순서 관계가 없다.  \n특정 컴퓨터 그래픽스와 게임 애플리케이션을 위해, 3D 장면 객체 지오메트리는 일반적으로 일련의 정점들을 서로 연결하는 엣지, 표면의 정보를 통해 구성된 polygonal meshes 로 표현된다. 이러한 polygonal mesh 들은 촘촘한 표면을 간결한 표현하기 위해 잘 짜여져 있지만, 그들은 non-manifold 구조를 표현하는데에 문제가 있다. 포인트 클라우드 표현 방식이 갖는 polygonal mesh 에 비해 가장 큰 장점은 non-manifold 지오메트리를 표현하는 유연성과 저장, 관리하거나 표면 topological 정보를 처리할 필요 없이 실시간 처리가 가능하다는 점이다.  \n효율적인 포인트 클라우드 데이터 처리를 위해, 각 포인트는 큐빅 그리드로 quantize 된다. 결과 voxel을 옥트리 데이터 구조에 매핑하여 복셀화된 옥트리를 생성할 수 있으며, 이를 통해 인접한 복셀의 탐색, 검색, 접근이 용이해진다. \n\n- 사용 예시 & 응용\n3D 포인트 클라우드 데이터는 문화 유산/박물관, 3D 무료 비디오, 텔레프레젠스 등 많은 분야에서 적용되고 있다. 문화 유산 분야에서, 포인트 클라우드 데이터는 박물관에 있는 역사적 조각상들이나 건물 같은 것을 포함한 물건들을 보관하고 시각화 하기 위해 사용된다. 이 경우의 일반적인 포인트 클라우드들은 1cm 지오메트릭 정확도와 색깔 컴퓨넌트 정확도 당 8-12 비트를 포함하는 것보다 더 세세한 데이터를 갖는 포인트 클라우드는 수백만에서 수십억의 포인트들을 포함할 수 있다.  \n대용량 비디오의 목적은 더 높은 이미지 화질을 뛰어넘고, 더 높은 관점에서의 3D 유저 경험과 상호작용을 제공하기 위함이다. 실시간 3D 텔레프레젠스는 대용량 비디오와 3D 포인트 클라우드의 핵심 애플리케이션 중 하나로, 무작위하고 관련 없는 포인트들의 집합은 시각화, 필터링 및 편집이 간편하기 때문에 선호되는 데이터 표현 형식이다. 3D 텔레프레젠스가 사용되는 몇 가지 예시는 마이크로소프트의 Holoportation 과 8i 의 volumetric 비디오 기술을 포함한다. 대용량 비디오의 변화는 VR 과 3D 스포츠 리플레이와 브로드캐스팅에 기초한 HMD를 포함하는데, 이는 실시간 처리를 요구하지 않거나 추가로 그래픽 데이터 컨텐츠에 기초한 mesh 를 포함할 수도 있다. 그러한 미디어와 관련된 사용 사례는 보통 십만에서 천만 사이의 포인트 위치와 색상 정보, 몇 가지의 시간 정보를 가지며, 비디오 sequence 의 프레임들과 유사하다.  \n네비게이션 목적으로는, 높은 밀도의 레이저 스캐너인 LiDAR 로 측정된 깊이 수치와 카메라로 캡쳐된 이미지들, GPS 로 측정된 현지화된 데이터, IMU 데이터를 결합하여 3D 지도를 생성해낼 수 있다. 이러한 지도들은 도시 주위의 자동차들의 자동 길찾기를 가능하게 해주는 레인 정보나 도로 신호 같은 길 신호와 결합될 수도 있다. 이런 사용 예시는 1 cm 정확도까지의 수백만에서 수십억의 3D 포인트 캡쳐와 추가적인 속성을 함께 필요로 한다.이러한 넓은 범위의 애플리케이션에 대응하기 위해, MPEG PCC 표준화 활동은 포인트 클라우드 테스트 데이터의 일반적인 3가지 카테고리 (static, dynamic, dynamically acquired) 들을 생성했다.\n\n- 캡쳐 & 획득\n이미 이미지, 비디오, LIDAR 센서 데이터를 압축하기 위한 많은 기준들이 이미 존재한다. 그래서 이 PCC 기준은 raw 센서 데이터를 압축하는 것이 아니라, 센서에 의해 포착된 객체와 장면의 포인트 클라우드 표현을 압축하는 것을 목표로 한다. 여기서 개발된 코딩 기술은 일반적으로 포인트 클라우드 데이터를 생성하는 데 사용하는 특정 센서에 구애받지 않도록 설계되었으므로 압축하기 전에 여러 센서의 3D 데이터를 융합하여 압축할 포인트 클라우드 표현을 생성한다고 가정한다. 모바일 매핑과 자동화된 네비게이션을 위한 동적으로 데이터를 얻는 센서 시스템의 예시는 다음과 같다. LIDAR 센서는 차량의 위에 고정되어 방출된 레이저 빔의 방위와 높이에 기반하여 지속적으로 차량에 상대적인 포인트 위치를 수집한다. GPS 와 관성 센서는 차량의 위치를 파악하는 데 사용된다. LIDAR 가 포착한 상대적인 포인트 위치들과 차량의 위치를 함께 결합함으로써, 포인트 위치들은 고정된 지리 좌표 계에 상대적인 절대적 x, y, z 좌표들로 변환된다. 고정된 RGB 카메라들은 일련의 이미지나 비디오를 캡처한다. 이러한 데이터는 캡쳐 후 처리 작업에서 융합되어 각 포인트가 LIDAR 로 캡쳐한 반사율 속성 외에도 단일 RGB 색상 속성을 가질 수 있도록 한다. 융합 프로세스는 중복되거나 외곽에 있는 지점들을 제거하는 등 데이터를 정리할 수도 있다. 이 과정의 최종 결과는 각 포인트와 관련된 반사율 및 RGB 속성과 함께 (x, y, z) 포인트 좌표 목록으로 구성된 포인트 클라우드이다. 위도, 경도, GPS 타임스탬프와 같은 추가 속성도 속성으로 포함될 수 있지만, 이러한 추가 속성의 압축은 현재 개발 중인 이 표준의 범위를 벗어난다. \n\n### Comparative Study of 3D Point Cloud Compression Methods\n\n#### Introduction\n\n포인트 클라우드는 대규모의 3D 모델링에서 사용될 수 있는 측정값의 집합이다. 포인트 클라우드들은 지오메트리 정보와 관련 특징, 더하여 시간적 변화를 모두 전달할 수 있다. 포인트 클라우드는 많은 분야에서 광범위하게 사용되고 있는데, VR, AR, 실시간 대규모 통신, 바이오메디컬 이미지, 자율주행 시스템 등이다. 주로 LidAR 센서나 3D 레이저 스캐너, 스테레오 카메라들을 사용하여 포인트 클라우드를 생성한다. 3D 데이터 획득 기술의 최근의 진보는 효율적이고, 정확하고, 신뢰성 있고, 실시간으로 포인트 클라우드 표현을 제공한다. 그러나, 3D 센서로 생성된 포인트 클라우드 데이터의 규모는 거대하다. 예를 들어, 주어진 scene 을 지속적으로 스캐닝하는 64-Line Velodyne LiDAR 센서는 20분 동안 10억개의 포인트를 생성한다; 또한 포인트 초당 30프레임으로 3D 프레임 당 0.7백만 포인트의 클라우드 초당 fps 에 500메가바이트 (MB/s) 정도의 대역폭이 필요하다. 데이터의 거대한 양은 데이터 저장과 전달 모두에 큰 도전 과제를 제기한다. 예를 들어, 포인트 클라우드 데이터를 장치에 지역적으로 저장하는 것은 더 많은 공간을 필요로 하고, 다른 네트워크 노드와 데이터를 공유하거나, 조작하거나, 분석하는 것이 더 어렵다. 최근 몇 년 간, 몇몇의 포인트 클라우드 압축 방법이 개발되어오고 있다. 존재하는 PCC 알고리즘의 성능을 평가하기 위한 노력도 있었지만, 대부분은 데이터 세트와 특정 설정을 가진 소규모 압축 기술 집합에 초점을 맞추고 있다.\n\n#### 3D PCC Methods\n\nG-PCC 는 Apple에서 제안한 지오메트리에 기반한 기술이다. G-PCC 는 옥트리 표현으로 얻어진 좌표들을 사용해서 지오메트리 위치를 직접적으로 3D 공간에 인코딩한다. 지오메트리 위치는 두 가지 방법론을 사용하여 인코드 될 수 있고, 포인트 클라우드의 속성은 3개의 다른 방법을 사용하여 인코딩 될 수 있다. 마지막 비트스트림은 지오메트리 비트스트림과 색상 비트스트림 모두로부터 생산될 수 있다. \nV-PCC 는 투사에 기반한 코딩 원리를 채택했고, 마찬가지로 Apple 에서 제안되었다. V-PCC 는 포인트 클라우드 데이터를 patch 들의 집합으로 해체한다. 3D 패치는 여러 직교 방향에서 생성되어 2D 평면에 투영된다. 이러한 2D 패치들은 2D 비디오 인코더 기술을 사용하여 처리될 수 있다. 결과 투사 이미지에 깊이와 속성 정보를 모두 유지할 수 있다. \nDraco 는 구글에 의해 개발된 3D 지오메트리 메쉬와 포인트 클라우드들을 압축하고, 압축해제하는 오픈소스 라이브러리이다. Draco 의 주된 아이디어는 KD 트리를 사용하는 것이다. KD 트리 형성 후, Draco 는 데이터를 엔트로피 인코딩 툴을 사용하여 인코딩한다. 유저의 필요에 따라 압축된 파일 크기와 포인트 클라우드의 시각적 질 사이의 트레이드 오프가 있다. \nGeoCNNv2 는 GeoCNNv1 에서 향상된 아키텍쳐이다. GeoCNNv1 아키텍쳐는 3 계층의 분석 변환과 균일한 양자화 모듈, 3계층의 합성 변환으로 구성된 3D 컨볼루션 자동 인코더(CNN-AE) 이다. GeoCNNV2는 GeoCNNv1 을 기본 모델로 사용한 다음 엔트로피 모델링, 심층 변환, 초점 손실의 균형 가중치 변경, 디코딩의 최적 임계값, 순차적 훈련 등 몇 가지 새로운 구현을 추가했다. "},{"excerpt":"우리 연구실에 있는 LiDAR 센서를 예시로 들어서 설명하면 좋을 듯. LiDAR 센서 기초 LiDAR 구조 LiDAR 가 포인트 클라우드를 어떻게 만드는가? 패킷이 어떻게 구성되어 있는가? LiDAR 란? Lidar 는 light detection and ranging 의 줄임말이다. 눈에 안전한 레이저를 사용하여 3D로 세상을 보고, 기계와 컴퓨터가 …","fields":{"slug":"/what-is-lidar/"},"frontmatter":{"date":"2024년 02월 12일 12:02","title":"LiDAR 강의 준비","tags":["lidar","lab"]},"rawMarkdownBody":"\n우리 연구실에 있는 LiDAR 센서를 예시로 들어서 설명하면 좋을 듯.\n\n## LiDAR 센서 기초\n\n- LiDAR 구조\n- LiDAR 가 포인트 클라우드를 어떻게 만드는가?\n- 패킷이 어떻게 구성되어 있는가?\n\n### LiDAR 란?\n\nLidar 는 **li**ght **d**etection **a**nd **r**anging 의 줄임말이다. 눈에 안전한 레이저를 사용하여 3D로 세상을 보고, 기계와 컴퓨터가 조사된 환경을 정확하게 표현한다. [출처](https://velodynelidar.com/what-is-lidar/)\n\nVelodyne lidar sensors meet the FDA eye-safety standards under [IEC 60825](https://www.fda.gov/downloads/MedicalDevices/DeviceRegulationandGuidance/GuidanceDocuments/UCM592775.pdf).\n\n### LiDAR 는 어떻게 작동하는가?\n\n일반적인 LiDAR 센서는 펄스 광파를 주변 환경으로 방출한다. 이 펄스는 주변 물체에서 반사되어 센서로 돌아온다. 센서는 각 펄스가 센서로 돌아오는 데 걸린 시간을 사용하여 이동한 거리를 계산한다. 이 과정을 초당 수백만 번 반복하면 환경의 실시간 3D 지도가 생성된다. \n\n레이더는 마이크로파를 사용하고, 소나는 음파를 사용하는 반면, LiDAR는 반사광을 사용하기 때문에 레이더나 소나보다 더 정밀하고 높은 해상도로 더 빠르게 거리를 측정할 수 있다. \n\n## LiDAR 포인트 클라우드 처리\n\n- 포인트 클라우드 처리를 하는 이유 → 무엇을 하기 위해서?\n\t- Object Detection → 패킷 압축 완료하고 합류\n\t- **패킷 압축 → 논문 찾아보기**\n\t- 잡음 제거\n\t- 여러 포인트 클라우드를 결합하여 하나의 3차원 장면을 복원할 수도 있다.\n\t- SLAM\n- Wireshark 에 있는 실제 패킷 보여주기\n- LiDAR 포인트 클라우드 패킷 전달 방식\n\n### 방법/기법\n\n주요 과제 중 하나는 포인트 클라우드의 희소성과 불규칙성으로 인해, 기존의 컨볼루션 신경망 (convolution neural network)을 적용하기 어려움입니다. 또 다른 문제는 포인트 클라우드의 노이즈와 불완전성으로, 처리 시 오류와 아티팩트가 발생할 수 있는 점입니다.\n\n- LiDAR 포인트 클라우드 패킷 압축\n- ROS\n- Python 으로 처리하는 방법 알아보기\n\t- https://pointclouds.org/\n- Open3D\n\n#### 참고\n\n- https://gaussian37.github.io/autodrive-lidar-intro/\n- [LiDAR 를 소개하는 한글 자료](https://www.kibme.org/resources/journal/20220617110654606.pdf)_\n\n---\n\n## LiDAR 포인트 클라우드 프로세싱 응용 시스템\n\n### Application\n\n### SW\n\n### API\n\n### Platform\n\n## LiDAR 포인트 클라우드 프로세싱 실습 소개\n\n### OS 설치\n\n### 프로그램 설치\n\n### SW 개발 방법\n\n## 포인트 클라우드 프로세싱 프로그래밍 기초 실습/데모\n\n## 포인트 클라우드 응용 프로그래밍 실습/데모"},{"excerpt":"LOG There was a meeting to discuss a research topic with my advisor. It’s difficult to decide it. Hopefully, I have inspired by a task that my seniors asks to conduct. If I didn’t conduct the task, I…","fields":{"slug":"/2024-02-06/"},"frontmatter":{"date":"2024년 02월 06일 11:02","title":"2024년 02월 06일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- There was a meeting to discuss a research topic with my advisor. It’s difficult to decide it. Hopefully, I have inspired by a task that my seniors asks to conduct. If I didn’t conduct the task, I may tell the advisor nothing. It’s lucky.\n\t- I had a meeting with my advisor to discuss selecting a research topic, which I found challenging. Fortunately, I was inspired by a task that my seniors asked me to conduct. Had I not undertaken this task, I would have had nothing to report to my advisor. It was a fortunate turn of events.\n- Yesterday, I increased the capacity of medicines. I wondered whether it’s okay for me to increase the capacity. The doctor said that because I don’t have any side effects, increasing the capacity isn’t harmful for me. Yet, I still doubt those words.\n\t- Yesterday, I increased the dosage of my medication. I was concerned about whether it was for me to do so. The doctor mentioned that since I haven’t experienced any side effects, increasing the dosage wouldn’t be harmful to me. However, I still have my doubts about that.\n\n## 오늘의 영어\n\n## 배운 것\n\n## 느낀 것\n\n- I felt talking english about familiar subjects isn’t difficult than when I took a class at first. If I practice regularly, I can speak in english well. Let’s keep practicing to make english sentences and say them.\n\t- I’ve realized that discussing familiar subjects in English isn’t as challenging as it was when I first started taking classes. With regular practice, I believe I can become proficient in speaking English. I should continue to practice making English sentences and expressing them verbally."},{"excerpt":"발음과 악센트 A!ctivate A!llocate Assi!gn Access 접근하다 접근 권한 build 실행 파일을 만들다 소프트웨어 빌드 프로세스로 인한 결과물 Fork 새로운 프로젝트를 만들다 분기하다 포크로 생긴 결과물 opinionated 체계와 시스템을 확실히 갖춘, 정해져 있는 관행과 디자인 패턴을 따르도록 하는 Backward-compat…","fields":{"slug":"/geek-haus-02-05/"},"frontmatter":{"date":"2024년 02월 05일 07:02","title":"2월 5일 긱하우스 개발자 영어","tags":["english"]},"rawMarkdownBody":"\n## 발음과 악센트\n\n- A!ctivate\n- A!llocate\n- Assi!gn\n\n- Access\n\t- 접근하다\n\t- 접근 권한\n- build\n\t- 실행 파일을 만들다\n\t- 소프트웨어 빌드 프로세스로 인한 결과물\n- Fork\n\t- 새로운 프로젝트를 만들다 분기하다\n\t- 포크로 생긴 결과물\n- opinionated\n\t- 체계와 시스템을 확실히 갖춘, 정해져 있는 관행과 디자인 패턴을 따르도록 하는\n- Backward-compatible ←> Backward-incompatible\n\t- 하위 호환되는\n\n### 단어들\n\n- assign + to\n- default\n\t- by de!fault (명사)\n\t- def!ault (동사)\n- comp!ile\n\t- ex. compile to plain JavaScript\n- c!onstant\n- conv!ert\n- de!activate\n- def!ine\n- dep!endency\n\t- 셀 수 있는 명사\n- depl!oy\n- d!eprecate (동사이지만 보통 과거분사 형태로 사용)\n- emb!edded\n- esc!ape\n- !execute\n- extr!act\n- f!ork\n- g!enerate\n- gen!eric\n\t- 지네릭\n- imm!utable\n- !implement\n\t- 동사\n\t- 명사\n- in!itialize\n- !integrate\n- inv!oke\n- m!odify\n\t- 일부만 바꾸는 것\n\t- change: 전체를 바꾸는 것\n- m!ount\n- n!avigate\n- op!inionated\n- !optimize\n\t- optimization\n- !overwrite\n\t- o 발음시 우 발음 살려서\n- par!ameter\n- p!arse\n- pass + to\n- route\n\t- 루트로 발음하면 단순 길\n- render\n- rel!ease\n\t- z 발음이 아니라 s 발음하기\n- ret!urn\n- run\n- signed\n- store\n- s!yntax\n- trim\n\t- 앞 공백: leading whitespace\n\t- 뒷 공백: trailing whitespace\n- tr!uncate\n- vulnerab!ility\n\n## 전치사\n\n- On\n\t- 스크린으로 소통하는 서비스 또는 네트워크 컴퓨터, 저장장치와의 관계\n\t- ex. on the website, on the computer, on the network, \n\t- on wifi (the 안 씀)\n- In\n\t- 데이터를 저장하거나 프로그램을 수행하는 공간 및 시스템의 관계\n\t- ex. in the database, in the document, in the file, in the directory, in the folder, in the browser, in the system, in the code, in python, in the header, in the footer, in the section\n- at\n\t- 전치사 in 보다 좁은 범위로 특정한 시간 및 공간과의 관계를 나타낸다.\n\t- ex. work at Google, at www.geekhaus.club, at the moment, at the same time, at the beginning, \n- to \n\t- 방향성을 내포하며 시간, 공간, 데이터 등이 작용하는 다른 대상과의 관계를 나타낸다.\n\t- ex. add A to B, pass {data} to {function or component}, change A to B\n\n## Git\n\n- rebase onto the target branch\n- typo : 셀 수 있는 명사\n- squash : (커밋을) 합치다\n- merge A into target : A를 target 에 병합하다.\n- comment on : 댓글을 남기다\n- rebase onto another branch: 다른 브랜치로 리베이스하다\n\n### Quiz\n\n- Fix bug that preventing users from submitting form.\n- Improve \n- Add\n- Modify MAX_PURCHASE_LIMIT global constant value\n\n## 사칙연산\n\n- 2 plus 3 equals 5\n- 6 minus 4 is 2\n- 10 mod 3 is 1\n- 5 divided by 3 is 1\n- 5 multiplied by 2 is 10\n- 5 squared is 25, 5 to the 2nd power is 25, 5 to the power of 2 is 25\n- cubed (세제곱)\n\n## 증가 / 감소\n\n- Increment / Decrement the variable by 2\n- Add 3 to the integer variable / Subtract 3 from the integer valuable\n- Increment the index i in the for loop by 1\n\n## JSON 통신\n\n- stand for : 나타내다 / 상징하다\n- transfer : (데이터, 값 등을) 전달하다\n- **In** JSON\n- are enclosed within: ~로 감싸지다\n\n### GET\n\n- **fetch** data **through** the API\n- **Retrieve (Pull)** data **from** the database: 데이터베이스에서 데이터를 검색하다\n- **Get** data **through** Graphql queries: graphql 쿼리로 데이터를 가져오다.\n\t- query: 퀴어리\n\n### POST\n\n- **Send** data **to** the API server: API 서버로 데이터를 보내다\n- Post data to a backend server\n\n### 에러\n\n- **throw** an error\n- **raise** an error\n- when an exception **occurs**, control transfers to the catch block\n- **handle** an error / exception\n\n### QUIZ\n\n- print A to the console ; 콘솔에 출력하다\n\n## 인생은 실전, 개발 환경 속에서 배우는 실전 영어\n\n### Example\n\n- de-sugar: 리팩토링하다\n- go into details: 상세히 설명하다\n- come up with: 생각해내다\n- permutation: 순열\n- associate A with B: A와 B를 연관짓다, A로 B를 떠올리다\n- open to suggestions: 제안에 열려있다.\n- root cause: 근본 원인\n- cascade\n\t- 한 줄의 코드에서 여러가지의 행동을 수행하는 과정\n\t- 연달아 작동하는 것\n- resolve: 해결하다, 찾다\n- !archive: 따로 저장해두다, 기록 저장소\n- !upvote: 지지하다\n- hack: 문제를 해결하다, 기발한 해결책\n- triage: 우선순위, 우선순위를 분류하다. (트리아지)\n- backlog: 백로그\n- listen on: 접속을 기다리다, 통신을 대기하다\n- provision: 공급, 공급하다\n- be assigned to: ~에 할당하다\n- defected product: 불량품\n- height: 높이 (하이트)\n- look into: 조사하다, 주의 깊게 살피다 (go over)\n- r!eplicate an issue: 이슈를 재현하다.\n- tackle: (일, 문제에) 달라붙다, 해결하려 노력하다.\n- remove A from B: B에서 A를 제거하다.\n- issue **with**, bug **with**, problem **with**\n- experience **in** ~\n- **on** AWS, on Azure (애져, 아주어), on GCP\n- outgoing ←> incoming\n\n## 인터넷 용어 상식\n\n- LGTM (Looks Good To Me)\n\t- Pull request 코드 리뷰에서 코드에 별다른 문제가 없을 때 사용한다.\n- TL;DR (Too Long; Didn’t Read)\n\t- “너무 길어서 읽지 않는다”, 요약\n- SSIA (Subject Says It All)\n\t- “제목이 모든 것을 말한다”\n- TBD (To Be Determined)\n\t- 아직 결정되지 않은 내용이 있어, 나중에 결정해야 함을 의미\n- TBA (To Be Announced)\n- RFC (Request For Comments)\n\t- 풀 리퀘스트와 같이 새로운 것을 제안하거나 포럼에서 무언가를 제안할 때, 의견을 요청하기 위해 사용한다. \n- IMHO (In My Honest Opinion, In My Humble Opinion)\n\t- 제 솔직한 생각으로, 제 소견으로는\n- AFAIK (As Far As I know)\n\t- 내가 아는 한, 절대적으로 확실하지는 않지만 알고 있는 정보를 말할 때\n- FYI (For Your Information)\n\t- 참고로\n- TIA (Thanks In Advance)\n\t- 미리 감사합니다. 다른 사람에게 도움을 요청할 때 사용한다.\n- IRL (In Real Life)\n\t- “현실에서” 라는 의미로 테스트 및 가상세계와 다른 현실을 강조할 때\n- AFK (Away From Keyboard)\n\t- 외출인 경우 많이 사용\n- OOO (Out Of Office)\n\t- 휴가 중인 경우에 자주 사용\n- TBH (To Be Honest)\n\t- 솔직히\n- BTW (By The Way)\n\t- 그런데, 그건 그렇고\n- WIP (Work In Progress)\n\t- 진행중, 진행 중인 작업\n- ACK (Acknowledgement)\n\t- 변경을 허용, 동의한다는 의미로 사용 ←> NACK 또는 NAK\n- Noob\n\t- 입문자라는 뜻. 새로 참여하는 오픈소스 커뮤니티 또는 프로젝트에 자신을 소개할 때 사용\n- Well played\n\t- 잘했다, 인정한다는 뜻. 한국 인터넷 용어의 ㅇㅈ과 비슷\n\n## 실습\n\n### Pseudocode\n\nThis for loop iterates over numbers from 1 to 10. If the number is even, it prints the sentence “Number X is even”. In this case, X represents the current number. Otherwise, it prints the sentence “Number X is odd”. Likewise the former condition, X also represents the current number.\n\n- text: 셀 수 없는 명사\n- output: output 을 만들다"},{"excerpt":"LOG I went to the hospital. My main doctor said me I need to maintain daily life regularly. Therefore, I’ve decided to record my todos in my cellphone. I installed an app that maintains my works. 오늘의…","fields":{"slug":"/2024-02-05/"},"frontmatter":{"date":"2024년 02월 05일 05:02","title":"2024년 02월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- I went to the hospital. My main doctor said me I need to maintain daily life regularly. Therefore, I’ve decided to record my todos in my cellphone. I installed an app that maintains my works.\n\n## 오늘의 영어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"At 시간: 구체적인 시각을 나타낼 때 사용한다. Ex. at 3 PM, at noon 장소: 구체적인 위치나 특정 지점을 나타낼 때 사용한다. Ex. at the door, at the station In 시간: 월, 년, 계절, 세기 등 더 넓은 시간 단위를 나타낼 때 사용한다. Ex. in April, in 2020, in winter 장소: 더 넓…","fields":{"slug":"/preposition-guideline/"},"frontmatter":{"date":"2024년 02월 01일 08:02","title":"영어 전치사","tags":["english"]},"rawMarkdownBody":"\n## At\n\n- 시간: 구체적인 시각을 나타낼 때 사용한다. Ex. at 3 PM, at noon\n- 장소: 구체적인 위치나 특정 지점을 나타낼 때 사용한다. Ex. at the door, at the station\n\n## In\n\n- 시간: 월, 년, 계절, 세기 등 더 넓은 시간 단위를 나타낼 때 사용한다. Ex. in April, in 2020, in winter\n- 장소: 더 넓은 공간이나 영역 내부를 나타낼 때 사용한다. Ex. in the room, in New York.\n- 기타 상황: 상황이나 상태를 나타낼 때 사용한다. Ex. in love, in trouble\n\n## On\n\n- 시간: 특정한 날짜나 요일을 나타낼 때 사용한다. Ex. on Monday, on my birthday\n- 장소: 표면 위에 있음을 나타낼 때 사용한다. Ex. on the table, on the wall\n- 기타 상황: 특정한 상태나 과정에 있음을 나타낼 때 사용된다. Ex. on fire, on vacation\n\n## For\n\n- 시간: 지속 기간을 나타낼 때 사용한다. Ex. for two hours, for a week\n- 목적: 목적이나 이유를 나타낼 때 사용한다. Ex. for pleasure, for work\n- 대상: 수혜자를 나타낼 때 사용한다. Ex. for me, for the team\n"},{"excerpt":"현재 완료 (Present Perfect): Have / Has + 과거분사 과거의 어느 시점에서 시작된 행동이 현재까지 계속되거나, 과거에 일어난 행동이 현재 상황에 영향을 미치는 경우 I have finished my work : 나는 내 일을 마쳤다. 예시 과거의 행동이 현재까지 영향을 미치는 경우 I have lost my keys. : 나는 내 …","fields":{"slug":"/have-pp-guideline/"},"frontmatter":{"date":"2024년 02월 01일 07:02","title":"have pp 사용법","tags":["english"]},"rawMarkdownBody":"\n## 현재 완료 (Present Perfect): Have / Has + 과거분사\n\n과거의 어느 시점에서 시작된 행동이 현재까지 계속되거나, 과거에 일어난 행동이 현재 상황에 영향을 미치는 경우\n\n> I have finished my work : 나는 내 일을 마쳤다.\n\n### 예시\n\n1. 과거의 행동이 현재까지 영향을 미치는 경우\n> I have lost my keys. : 나는 내 열쇠를 잃어버렸다. \n> 열쇠를 잃어버린 것은 과거의 사건이지만, 그 사실이 현재 찾고 있는 상황에 영향을 미친다. \n\n2. 과거에 시작해 현재까지 계속되는 상태나 행동\n> She has lived in Paris for five years. : 그녀는 5년 동안 파리에 살고 있다.\n> 파리에서 살기 시작한 것은 과거의 일이지만, 그 상태가 현재까지 계속되고 있음을 나타낸다.\n\n3. 생애 동안 일어난 일을 설명할 때\n> I have traveled to Japan three times. : 나는 일본에 세 번 여행을 갔다.\n> 여행은 과거에 일어났지만, 생애 전체를 통틀어 본 일을 설명할 때 사용한다.\n\n4. 최근에 일어난 행동 (시간을 언급하지 않을 때)\n> We have just finished dinner. : 우리는 방금 저녁을 먹었다.\n> 저녁을 먹은 것은 최근의 일이며, 정확한 시간을 언급하지 않으면서 현재 완료 시제를 사용한다.\n\n5. 경험을 나타낼 때\n> Have you ever seen a shooting star? : 너는 별똥별을 본 적이 있니?\n> 특정한 경험이 생애 동안 일어났는지를 물어볼 때 사용한다. \n\n6. 변화나 개발을 나타낼 때\n> Technology has changed a lot in the last century. : 기술은 지난 세기 동안 많이 변했다. \n> 과거부터 현재까지의 변화나 발전을 설명할 때 사용한다.\n\n## 과거완료 (Past Perfect): Had + 과거분사\n\n과거의 두 사건을 나타낼 때, 시간적으로 더 앞선 사건을 설명한다.  \n\n> I had finished my work before he arrived : 그가 도착하기 전에 나는 내 일을 마쳤다. \n\n## 미래완료 (Future Perfect): Will have + 과거분사\n\n미래의 특정 시점 이전에 완료될 행동을 나타낸다. \n\n> I will have finished my work by 5 P.M. : 나는 오후 5시까지 내 일을 마칠 것이다.\n"},{"excerpt":"오늘의 키워드 나를 돌아보기 한국어 요즘 나를 돌아보는 시간을 계속해서 가지고 있다. 그 과정 속에서 알아낸 것들을 적어보려고 한다. 나는 다른 사람들을 돕는 것을 좋아한다. 아마 오빠가 들으면 누구나 다 그렇다고 말할 것 같긴 하지만 그렇다. 다른 사람들에게 내가 알고 있는 지식들을 나누는 것은 참 즐거운 일이다. 특히 주변 사람들과 더 나은 관계를 맺…","fields":{"slug":"/english-speaking-2024-02-01/"},"frontmatter":{"date":"2024년 02월 01일 05:02","title":"2024년 02월 01일 영어 회화","tags":null},"rawMarkdownBody":"\n## 오늘의 키워드\n\n나를 돌아보기\n\n## 한국어\n\n요즘 나를 돌아보는 시간을 계속해서 가지고 있다. 그 과정 속에서 알아낸 것들을 적어보려고 한다.  \n나는 다른 사람들을 돕는 것을 좋아한다. 아마 오빠가 들으면 누구나 다 그렇다고 말할 것 같긴 하지만 그렇다. 다른 사람들에게 내가 알고 있는 지식들을 나누는 것은 참 즐거운 일이다.  \n특히 주변 사람들과 더 나은 관계를 맺고 싶어졌다. 부모님, 동생, 친구들 모두에게 더 좋은 사람이 되고 싶다. 정말 내가 내면적으로 더 성장한 걸까? 참 신기하면서도 궁금하다.  \n그러기 위해서는 부모님과 해야 하는 대화가 있는데, 난 아직 조금 두려운 것도 같다. 해야 하는 말도 정리가 잘 안 됐고… 설날에 내려가서 할 수 있을지 잘 모르겠다. \n\n## 영어\n\nCurrently, I continuously took a time that reflects on myself. I start to write down somethings that I’ve learned in the process.  \nI like helping other people. Maybe, although my boyfriend would say anyone feels same thing, I felt that. It’s so glad for me that sharing knowledge that I’ve known with other people.  \nEspecially, I’ve wanted to make better relationship with people who are around me. I want to be the better person to my parents, my younger brother, friends, and everyone. Am I mentally more developed? I’m thinking it’s wonderful and have curiosity.  \nTo be that, I have to do conversation with my parents, but I’m likely to feel frightened. And I haven’t organized what I have to say. I don’t know exactly I can do that at Lunar New Year.\n## 끊어 읽기\n\nRecently, / I’ve been dedicating time / to self-reflection. In this process, / I have discovered several things / about myself / that I wish to document.  \nI find joy / in assisting others. While / my boyfriend might argue / that this is a common trait, / it’s indeed true for me. Sharing my knowledge / with others / is genuinely fulfilling.  \nMoreover, / I have developed a desire / to forge better relationships / with those around me, / including my parents, siblings, and friends. / I wonder / if this signifies / internal growth on my part /, which I find / both fascinating and curious.  \nTo achieve this, / I realize / there are conversations / I need to have with my parents, / though I admit / I feel somewhat apprehensive. / My thoughts are not yet/  fully organized, / and I’m uncertain / if I’ll be able to / address these matters / during my visit / for the Lunar New Year.\n\n## 키워드\n\n요즘 나를 돌아보는 시간 가지는 중 → 알아낸 것들을 말하고 싶다  : have p.p 사용하기\n다른 사람들을 돕는 것이 좋음. 오빠가 들으면 다 그렇다고 말할지도 모르지만 사실임. 내 지식을 다른 사람들에게 나누는 것이 기쁨.  : find joy in~ 구문 사용하기.while ~, it’s 구문 사용하기.\n주변 사람들과 더 나은 관계를 맺고 싶음. 더 많은 사람들에게 더 좋은 사람이 되기를 원함. 내면적으로 성장한 것인지 궁금.  : have p.p 사용하기. I wonder if 구문 사용하기\n부모님과 해야 하는 대화 → 두렵고 해야 할 말이 정리가 안 됨. 설날에 집에 가서 말할 수 있을지 의문. : 문장, though 구문 사용하기. I’m uncertain if ~ 구문 사용하기\n\n## 외워볼 단어\n\n- 나를 돌아보다\n- 정말로: genuinely\n- 신기한: fascinating\n- 그렇게 되기 위해서: To achieve this\n- 두려운, 걱정되는: apprehensive, afraid of\n- 설날: Lunar New Year\n- share + with\n- conversations … + with\n- forge : 맺다\n- reflect: 돌아보다\n\n### 문장 구조\n\n- I wonder if I’ll be able to ~\n- I’ve been dedicating time : 시간을 할애하고 있다. 시간을 투자하고 있다. \n- I find joy in ~ : ~에서 기쁨을 찾다. \n- During ~, there are things I’ve realized that I want to share with you : ~ 에서 나는 깨달은 것들이 있는데, 그것들을 당신과 공유하고 싶다.\n\n## 교정받은 문장\n\n### GPT\n\nRecently, I’ve been dedicating time to self-reflection. In this process, I have discovered several things about myself that I wish to document.  \nI find joy in assisting others. While my boyfriend might argue that this is a common trait, it’s indeed true for me. Sharing my knowledge with others is genuinely fulfilling.  \nMoreover, I have developed a desire to forge better relationships with those around me, including my parents, siblings, and friends. I wonder if this signifies internal growth on my part, which I find both fascinating and curious.  \nTo achieve this, I realize there are conversations I need to have with my parents, though I admit I feel somewhat apprehensive. My thoughts are not yet fully organized, and I’m uncertain if I’ll be able to address these matters during my visit for the Lunar New Year.\n\n## 더 알아둘 내용\n\n영어 문장에서 강세(intonation)는 문장의 의미와 감정을 전달하는 데 중요한 역할을 합니다. 이 문장들을 읽을 때, 특정 단어에 강세를 두어 의미를 강조할 수 있습니다. 여기서는 각 문장의 주요 단어나 구에 강세를 두는 방법을 제시합니다. 강세는 문맥에 따라 변할 수 있으며, 이는 단지 일반적인 가이드라는 점을 유의하세요.\n\n1. **Recently, I’ve been dedicating time to self-reflection.**\n    - 강세: **Recently**, **dedicating**, **self-reflection**.\n    - 이 문장에서는 시간 경과를 나타내는 \"Recently\"와 중요한 활동을 나타내는 \"dedicating\" 및 \"self-reflection\"에 강세를 줍니다.\n2. **In this process, I have discovered several things about myself that I wish to document.**\n    - 강세: **process**, **discovered**, **myself**, **document**.\n    - \"process\", \"discovered\", 그리고 \"document\"는 이 문장에서 강조되어야 하는 주요 동작과 목표를 나타냅니다.\n3. **I find joy in assisting others.**\n    - 강세: **find joy**, **assisting others**.\n    - 이 문장에서는 \"find joy\"와 \"assisting others\"에 강세를 줍니다.\n4. **While my boyfriend might argue that this is a common trait, it’s indeed true for me.**\n    - 강세: **boyfriend**, **argue**, **common trait**, **indeed true for me**.\n    - 강조하고 싶은 부분은 대비를 나타내는 \"boyfriend might argue\"와 개인적 진실을 나타내는 \"indeed true for me\"입니다.\n5. **Moreover, I have developed a desire to forge better relationships with those around me, including my parents, siblings, and friends.**\n    - 강세: **Moreover**, **developed**, **forge better relationships**, **parents, siblings, and friends**.\n    - 여기서는 \"developed\", \"forge better relationships\", 그리고 관계의 대상을 나타내는 \"parents, siblings, and friends\"에 강세를 줍니다.\n6. **I wonder if this signifies internal growth on my part, which I find both fascinating and curious.**\n    - 강세: **wonder**, **signifies**, **internal growth**, **fascinating and curious**.\n    - \"wonder\", \"signifies\", \"internal growth\", 그리고 감정을 나타내는 \"fascinating and curious\"에 강세를 줍니다.\n7. **To achieve this, I realize there are conversations I need to have with my parents, though I admit I feel somewhat apprehensive.**\n    - 강세: **achieve**, **realize**, **conversations**, **parents**, **apprehensive**.\n    - \"achieve\", \"conversations\", \"parents\", 그리고 감정을 나타내는 \"apprehensive\"에 강세를 줍니다.\n8. **My thoughts are not yet fully organized, and I’m uncertain if I’ll be able to address these matters during my visit for the Lunar New Year.**\n    - 강세: **thoughts**, **not yet fully organized**, **uncertain**, **address**, **visit**, **Lunar New Year**.\n    - 여기서는 상태를 나타내는 \"not yet fully organized\", \"uncertain\", 행동을 나타내는 \"address\", 그리고 특별한 이벤트를 나타내는 \"visit for the Lunar New Year\"에 강세를 줍니다.\n\n강세는 문장을 자연스럽고 의미 있게 만들며, 듣는 사람에게 중요한 단어나 구를 강조하여 정보의 전달을 도와줍니다. 각 문장을 읽을 때, 이러한 단어나 구에 더 많은 강조를 주어 의미를 분명히 하세요.\n\n**!!! 강조하고 싶은 단어와 구에 더 많은 강조를 주어 의미를 분명하게 하기 !!!**"},{"excerpt":"static modifier 란? 내용은 오라클 Java Tutorials에서 참고했다. 모든 객체들에서 공통으로 적용되는 변수를 선언하고 싶을 때,  을 사용하면 된다. 선언에  modifier 가 있는 필드를 static field 또는 클래스 변수라고 한다. 해당 변수는 어떤 객체가 아니라 클래스와 연관된다. 클래스의 모든 인스턴스는 메모리의 고정된…","fields":{"slug":"/why-should-we-avoid-use-static/"},"frontmatter":{"date":"2024년 02월 01일 04:02","title":"static 은 언제 사용해야 할까?","tags":["java","oop"]},"rawMarkdownBody":"\n## static modifier 란?\n\n> 내용은 [오라클 Java Tutorials](https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html)에서 참고했다.  \n\n모든 객체들에서 공통으로 적용되는 변수를 선언하고 싶을 때, `static` 을 사용하면 된다.  \n선언에 `static` modifier 가 있는 필드를 static field 또는 클래스 변수라고 한다. 해당 변수는 어떤 객체가 아니라 클래스와 연관된다.  \n클래스의 모든 인스턴스는 메모리의 고정된 한 위치에 있는 클래스 변수를 공유한다. 모든 객체는 클래스 변수의 값을 변경할 수 있지만, 클래스 변수는 클래스의 인스턴스를 생성하지 않고도 조작할 수 있다.  \n\nJava 는 static 변수 뿐만 아니라 static 메서드도 지원한다. 선언에 static modifier 가 있는 static 메서드는 클래스의 인스턴스를 생성할 필요 없이 클래스 이름으로 호출해야 한다. 물론 객체 참조로 static 메서드를 참조할 수도 있지만, 클래스 메서드라는 것을 명확히 알 수 없으므로 권장하지 않는다.  \n\n### Constants\n\n`static` modifier 는 `final` modifier 와 함께 상수를 정의하는 데에도 사용된다. `final` modifier 는 해당 필드의 값을 변경할 수 없음을 나타낸다.  \n`static final` 방식으로 정의된 상수는 재할당할 수 없으며, 프로그램에서 재할당을 시도하면 컴파일 타임 에러가 발생한다. 관례에 따라 상수 값의 이름은 대문자로 표기한다. \n\n> 원시 타입이나 문자열이 상수로 정의되어 있고 컴파일 타임에 값을 알 수 있는 경우, 컴파일러는 코드의 모든 곳에서 상수 이름을 해당 값으로 바꾼다. 이를 컴파일 타임 상수라고 한다. 외부 세계의 상수 값이 변경되면 (PI 값이 3.14 에서 3.2가 된다거나) 이 상수를 사용하는 모든 클래스를 다시 컴파일 하여 현재 값을 가져와야 한다. \n\n## static 을 왜 지양해야 하는가?\n\n### 변경 지점 추적의 어려움\n\n변경 가능한 `static` 변수를 사용하게 되면 인스턴스를 생성하지 않고도 해당 변수를 조작할 수 있는 전역 상태가 된다. 그렇기 때문에 여러 곳에서 `static` 변수의 값 또는 상태를 조작할 수 있게 되는데, 이런 경우 어느 곳에서 변수를 조작했는지 추적하기 어렵다는 단점이 있다.\n\n### 테스트의 어려움\n\n일반적인 테스트 방식들은 테스트 대상 객체의 종속성을 외부에서 주입하는 것이다. 이를 통해 테스트 중인 객체를 격리시켜 테스트의 정확도를 높일 수 있다. 그러나 `static` 메서드나 변수는 외부에서 주입하기 어렵다. `static` 메서드는 클래스에 직접 속해 있어 이를 사용하는 객체에서 분리하기 어렵고, `static` 변수는 전역 상태를 가지기 때문에 테스트 환경에서 격리하기 어렵다.  \n\n또한 `static` 변수는 전역 상태를 유지하므로, 한 테스트 케이스에서의 변경이 다른 테스트 케이스에 영향을 미칠 수 있다. 이는 테스트의 독립성을 해칠 뿐만 아니라 예측 불가능한 결과를 초래할 수 있다.  \n\n테스트 전에 특정 상태로 초기화하기 어렵다는 문제도 있다. 이를 해결하기 위해서는 테스트 실행 전후에 `static` 변수의 상태를 적절히 설정하고 정리해야 한다. \n\n### 객체지향 프로그래밍의 기본 원칙과 상충되는 구현 방식\n\n#### 캡슐화\n\n캡슐화는 객체의 데이터와 데이터를 처리하는 메서드를 하나의 단위로 묶는 것을 말한다. 이를 통해 데이터의 직접적인 접근을 제한하고, 객체 내부의 구현을 숨기며, 외부 인터페이스만을 통해 상호작용하도록 한다.  \n`static` 변수나 메서드는 객체의 상태와 무관하게 클래스 레벨에서 정의된다. 이는 객체의 개별적인 상태를 나타내는 캡슐화의 원칙을 위반한다. `static` 변수는 모든 객체 인스턴스에 의해 공유되므로, 객체별로 독립적인 상태를 유지하기 어렵다. \n\n#### 상속\n\n상속은 하나의 클래스가 다른 클래스의 속성과 메서드를 이어받을 수 있게 한다.  \n`static` 메서드나 변수는 상속되지만, 상속받은 클래스에서는 오버라이딩이 불가능하다. 즉, 자식 클래스에서 부모 클래스의 `static` 메서드나 변수의 동작을 변경하거나 확장하는 것이 어렵다. 상속을 통한 유연성과 확장성을 제한하는 것이다.  \n\n#### 다형성\n\n`static` 메서드는 클래스 레벨에 바인딩된다. 즉, 이 메서드들은 클래스에 속하며, 인스턴스에 속하지 않는다. 그런데 오버라이딩은 상속을 통해 부모 클래스의 인스턴스 메서드를 자식 메서드에서 재정의하는 것이다. `static` 메서드는 인스턴스가 아닌 클래스에 속하기 때문에 인스턴스의 다형성과 관련이 없다. 결론적으로 `static` 메서드는 오버라이딩 될 수 없다.  \n(자식 클래스에서 같은 이름과 시그니처를 가진 `static` 메서드를 선언하는 것은 부모 클래스의 메서드를 오버라이딩하는 것이 아니라 숨기는 것이다.)\n\n다형성은 같은 인터페이스나 부모 클래스에 속하는 다양한 객체들이 동일한 메시지에 대해 각기 다른 방식으로 반응할 수 있도록 하는 원리이다. 인스턴스 메서드는 실행 시점에 객체의 실제 타입에 따라 다르게 동작할 수 있다. 그러나 `static` 메서드 호출은 컴파일 타임에 결정되며, 클래스 타입에 의해 결정된다. 따라서 부모 클래스 타입의 참조 변수가 자식 클래스의 인스턴스를 참조하더라도, `static` 메서드 호출은 항상 부모 클래스의 메서드를 호출한다.  \n\n이런 부분에서 `static` 메서드는 객체의 상태와 동작을 나타내는 객체지향 프로그래밍의 다형성 원칙과 상충된다고 할 수 있다.\n\n### 멀티스레드 환경에서 발생할 수 있는 문제\n\n`static` 변수는 모든 스레드에 의해 공유된다. 동시에 여러 스레드가 변수에 접근하면 동기화 문제가 발생할 수 있으며, 데이터 일관성과 안정성 문제가 발생할 수 있다. \n\n## 어떤 경우에 static 을 사용해야 할까?\n\n[Stackoverflow](https://stackoverflow.com/questions/2671496/when-to-use-static-methods)에서도 많은 의견이 나오고 있다. 모든 상황에 맞는 방식이 아니므로, 각자의 상황에 맞춰 잘 판단해야 한다. \n\n### `static` 변수 / 메서드가 클래스 자체에 속할 때, 전역으로 관리해야 할 때\n\n해당 변수나 메서드가 특정 인스턴스에 속하지 않고, 클래스 전체와 관련된 상태나 동작이 필요한 경우, `static` 변수나 메서드를 사용하는 것이 좋다.  \n\nEx. 클래스 인스턴스의 개수를 추적할 때, 특정 클래스와 관련된 전역 설정을 관리할 때\n\n### `static` 변수가 상태를 갖지 않는 상수일 때\n\n변경되지 않는 고정 값이나 애플리케이션에서 공통으로 사용되는 설정 값들을 정의할 때 `static` 변수를 사용한다.  \n이런 상수들은 인스턴스마다 다르게 유지될 필요가 없기 때문에 클래스 레벨에서 관리되는 것이 좋다.  \n\nEx. PI 값, 설정 값\n\n### 싱글톤 패턴을 구현해야 할 때\n\n전역적으로 하나의 인스턴스만을 유지해야 할 때, 싱글톤 패턴을 사용할 수 있다. 인스턴스 자체를 `static` 변수로 유지하여 어디서나 동일한 인스턴스에 접근할 수 있도록 한다.  \n\nEx. 구성 관리, 로깅, 데이터베이스 접속 관리 등"},{"excerpt":"2024-02-01","fields":{"slug":"/2024-02/"},"frontmatter":{"date":"2024년 02월 01일 04:02","title":"2024년 02월","tags":["TIL"]},"rawMarkdownBody":"\n- [[2024-02-01]]"},{"excerpt":"TODO 오빠 노트북 갖다주기 유빈님 PR 리뷰 오후 9시 뉴피니언 회의 LOG Because my boyfriend left his laptop at home, I visited ‘카카오 아지트’ to deliver it to him. Initially, I was weary from the long journey. However, if I had st…","fields":{"slug":"/2024-02-01/"},"frontmatter":{"date":"2024년 02월 01일 04:02","title":"2024년 02월 01일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 오빠 노트북 갖다주기\n- [x] 유빈님 PR 리뷰\n- [x] 오후 9시 뉴피니언 회의\n\n## LOG\n\n- Because my boyfriend left his laptop at home, I visited ‘카카오 아지트’ to deliver it to him. Initially, I was weary from the long journey. However, if I had stayed at home as usual, I wouldn’t have accomplished anything. By leaving, I was able to focus on what I needed to study. Going outside helps me dedicate myself to my studies. \n- I drank an Ice Blended Dolce Latte at Starbucks.\n\n## 오늘의 영어\n\n오랜만에 영어 공부를 했다. [[english-speaking-2024-02-01]]  \n\nI decided to start making a diary every day. I’ve thought that I regularly document everyday behaviours in a diary is hard for me. Because I’ve been easily forgetting many things that I find important, I’ve thought so. In spite of that, ChatGPT encouraged me to write even small things down my note in English. He’s right. It’s the time when I have to concentrate on studying English. So I will make my diary by using Obsidian. Paper diary doesn’t fit in me. Let’s go and do my best to do it.  \n\n### 교정본\n\nI’ve decided to start keeping a diary every day. I used to think that regularly documenting my daily activities in a diary would be difficult for me. This is because I tend to forget many things I consider important. Despite this, ChatGPT encouraged me to write down even small things in my notes in English. He’s right. Now is the time when I need to focus on studying English. Therefore, I will create my diary using Obsidian. A paper diary doesn’t suit me. Let’s go and do my best. \n\n## 배운 것\n\n- 유빈님 PR 을 리뷰해주다가 static 키워드에 대한 의문이 들어서 [[why-should-we-avoid-use-static|static 을 언제 써야 할까?]] 라는 글을 썼다. 리뷰는 정말 많이 도움이 되는 것 같다. \n- I wrote about [[have-pp-guideline|when to use ‘have past participle’ structure]]. This helped me improve my ability to construct English sentences using the ‘have p.p’ form.\n- When I want to express visiting somewhere, I shouldn’t use the preposition ‘at’.\n- ‘weary from the long journey’ more naturally represents the fatigue caused by long travel.\n\n## 느낀 것\n"},{"excerpt":"IT 전문 용어 분석 변수: variable (셀 수 있는 명사) 자료형: type 변수를 선언하다: declare a variable 정수: integer 부호가 없는 정수: unsigned integer 부호가 있는 정수: signed integer 실수: float 문자: character 문자열: string boolean null 변수를 초기화하…","fields":{"slug":"/geek-haus-01-29/"},"frontmatter":{"date":"2024년 01월 29일 08:01","title":"1/29 개발 영어","tags":["english"]},"rawMarkdownBody":"\n## IT 전문 용어 분석\n\n- 변수: variable (셀 수 있는 명사)\n- 자료형: type\n- 변수를 선언하다: declare a variable\n- 정수: integer\n- 부호가 없는 정수: unsigned integer\n- 부호가 있는 정수: signed integer\n- 실수: float\n- 문자: character\n- 문자열: string\n- boolean\n- null\n- 변수를 초기화하다: initialize a variable\n- 반복문: loop statement\n- 조건문: conditional statement\n- 상속: inheritance\n- 객체 지향: object-oriented (오브직트)\n- 매개변수: parameter (셀있)\n- 인자: argument (셀있)\n- 지역 변수: local variable\n- 전역 상수: global constant\n- 함수 호출: function call\n- 명령어: comm!and\n- 비동기적인: asynchronous\n- 정규식: regex (Regular Expression)\n\t- 레겍스, 레직스와 같이 발음\n\n** O는 오-우 와 같이 발음해주기\n\n### 프로그래밍\n\n- 구문(문법) : syntax\n- 선언: de!claration(데클러레이션)\n- 예외 처리: error handling\n- 반복: iteration\n- 연산자: operator\n- 추상화: abstraction\n- 재귀 함수: recursive function\n- 중첩된: nested\n- 들여쓰기: indentation\n- 불변의: immutable\n- 보안 취약점: security vu!lnerabi!lity\n- 정적인 / 동적인: static / dyna!mic\n- 이중 for 문 / 삼중 for 문: double nested for loop / triple nested for loop\n\n### 실무\n\n- 프론트엔드: Front-end\n- 백엔드: Back-end\n- 데브옵스: DevOps\n- 풀 리퀘스트: Pull Request (셀있)\n- 온프레미스: On-Premises\n- SaaS (세스): Software as a Service\n- GUI: Graphic User Interface\n- WYSIWYG: What You See Is What You Get\n- JSON: JavaScript Object Notation\n- CRUD: Crea!te Read U!pdate Dele!te\n- MVC: Model (마를?) View Controller\n\n## `( ) { } [ ] ~ *`, 너희들 이름은 뭐니?\n\n- `()` : \n\t- Pare!nthesis (단괄호)\n\t- Parenthe!ses (양괄호)\n- `)`\n\t- Right Parenthesis\n\t- Closing Parenthesis : 클로징\n\t- close (가까운) : 클로스\n\t- close (닫다) : 클로즈\n- `(`\n\t- opening parenthesis\n\t- left parenthesis\n- `[ ]`\n\t- Brackets\n\t- Square Brackets\n- `{}`\n\t- Braces (브레시스)\n\t- Curly Brackets\n- `<>`\n\t- Angle Brackets\n\t- Chevrons (셰브론스)\n- `<`\n\t- Opening Angle Brackets\n\t- Less Than Symbol\n- `>`\n\t- Closing Angle Brackets\n\t- Greater Than Symbol\n- `#`\n\t- Number Sign\n\t- Hash\n- `@`\n\t- At sign\n- `!`\n\t- E!xclamation Mark (엑스크레메이션)\n- `%`\n\t- Perc!ent Sign\n- `*`\n\t- Asterisk (에스터리스크)\n\t- Star\n- `^`\n\t- Caret (캐럿)\n- `$`\n\t- Dollar Sign\n- `?`\n\t- Question Mark\n- 삼항 연산자: ternary operator\n- `:`\n\t- colon\n- ← bullet point\n- `;`\n\t- Semi Colon (세미 콜론, 세마이 콜론)\n- `-`\n\t- Hyphen\n\t- Dash\n- `_`\n\t- underscore\n- `+`\n\t- plus sign\n- =\n\t- Equal sign\n- \\\n\t- back slash\n- /\n\t- Forward Slash\n- `\n\t- backtick\n\t- Grave Accent\n- `\"\"`\n\t- Double Quotation Marks\n- `''`\n\t- Single Quotation Marks\n- `,`\n\t- comma\n- `.`\n\t- Dot\n\t- Period\n- `|`\n\t- Pipe\n\t- Ve!rtical Bar\n- `&`\n\t- And Sign\n\t- A!mpersand\n- `~`\n\t- Tilde (틸더)\n\n## camelCase, snake_case, 그리고 …\n\n- Camel Case\n- Pascal Case\n- Snake Case\n- Kebab Case\n\n## 질문\n\n### 대답\n\n- 첫 수업 소감 알았던 거 몰랐던 거\n\t- 오늘 수업 굉장히 유익하고 재미있었다. 수업에서 나오는 기본적인 영어 단어 같은 건 알고 있었지만, 간단한 발음도 제대로 모르고 있었음. 특히 키보드에 있는 기호들을 어떻게 부르는지 알려주신 게 많은 도움이 되었다.\n- 기존에 영어 얼마나 했는지\n\t- 작년 10월부터 영어 회화 학원을 다니기 시작했는데, 다닌지 얼마 안 돼서 아직도 잘은 못한다. 지금도 잘 못하는 것 같고, 오늘 한글을 영어로 바꾸는 문제가 있었는데, 몇 달째 공부하는데도 잘 안 되네요. 이번 개발 영어 수업 잘 들어서 영어 잘해보도록 노력하겠습니다.\n"},{"excerpt":"geek-haus-01-29","fields":{"slug":"/geek-haus/"},"frontmatter":{"date":"2024년 01월 29일 08:01","title":"긱하우스 개발 영어","tags":["english"]},"rawMarkdownBody":"\n- [[geek-haus-01-29]]"},{"excerpt":"TODO JSCODE 멘토 미팅 연구실 라이다 촬영   [scheduled:: 2024-01-25]  [completion:: 2024-06-16T19:15] S-HOOK 도메인 회의   [scheduled:: 2024-01-25]  [completion:: 2024-06-16T19:15] LOG 오늘의 영어 ~일 것 같다: 배운 것 느낀 것","fields":{"slug":"/2024-01-26/"},"frontmatter":{"date":"2024년 01월 26일 06:01","title":"2024년 01월 26일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] JSCODE 멘토 미팅\n- [x] 연구실 라이다 촬영   [scheduled:: 2024-01-25]  [completion:: 2024-06-16T19:15]\n- [x] S-HOOK 도메인 회의   [scheduled:: 2024-01-25]  [completion:: 2024-06-16T19:15]\n\n## LOG\n\n## 오늘의 영어\n\n- ~일 것 같다: \n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO Enoch 선배와 저녁 약속 matzip 회의 LOG 오늘의 영어 배운 것 느낀 것","fields":{"slug":"/2024-01-22/"},"frontmatter":{"date":"2024년 01월 22일 14:01","title":"2024년 01월 22일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] Enoch 선배와 저녁 약속\n- [x] matzip 회의\n\n## LOG\n\n## 오늘의 영어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO LOG 아코와 도메인에 대해서 이야기했다. 오랜만에 팀원들과 이야기 하니까 재밌었다. 다만 결정해야 하는 것들이 너무 많고 논의해야 할 것도 많아서 좀 곤란하긴 했다…ㅋㅋㅋ Neupinion startup 패키지를 신청했다. 이것으로 AWS 비용 문제를 조금 해결할 수 있지 않을까 기대중이다. 오늘의 영어 배운 것 느낀 것","fields":{"slug":"/2024-01-21/"},"frontmatter":{"date":"2024년 01월 21일 09:01","title":"2024년 01월 21일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 아코와 도메인에 대해서 이야기했다. 오랜만에 팀원들과 이야기 하니까 재밌었다. 다만 결정해야 하는 것들이 너무 많고 논의해야 할 것도 많아서 좀 곤란하긴 했다…ㅋㅋㅋ\n- Neupinion startup 패키지를 신청했다. 이것으로 AWS 비용 문제를 조금 해결할 수 있지 않을까 기대중이다.\n\n## 오늘의 영어\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO 우테코 전형 DH 합격자 밋업 뉴피니언 전체 회의 선우님께 데이터 전달 LOG 오늘의 영어 lotto 의 복수형은 lotties 이다. 배운 것 느낀 것","fields":{"slug":"/2024-01-19/"},"frontmatter":{"date":"2024년 01월 19일 02:01","title":"2024년 01월 19일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 우테코 전형 DH 합격자 밋업\n- [x] 뉴피니언 전체 회의\n- [x] 선우님께 데이터 전달\n\n## LOG\n\n## 오늘의 영어\n\n- lotto 의 복수형은 lotties 이다. \n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"개요 Java 의 getter 와 setter 의 위치는 Class 의 최하단에 정의하라는 리뷰를 받은 적이 있다. 우테코 때는 리뷰어 말대로 맨 밑에 두고 쓰다가, 내가 코드 리뷰를 하게 되어서 이유를 찾아보게 되었다. 근거가 있을까? getter 와 setter 가 클래스의 하단에 있어야 하는 이유가 있을까? 결론만 말하자면 정해진 컨벤션은 없다. O…","fields":{"slug":"/getter-setter-position/"},"frontmatter":{"date":"2024년 01월 19일 01:01","title":"getter 와 setter 의 위치","tags":["java"]},"rawMarkdownBody":"\n## 개요\n\nJava 의 getter 와 setter 의 위치는 Class 의 최하단에 정의하라는 리뷰를 받은 적이 있다.  \n우테코 때는 리뷰어 말대로 맨 밑에 두고 쓰다가, 내가 코드 리뷰를 하게 되어서 이유를 찾아보게 되었다.  \n\n## 근거가 있을까?\n\ngetter 와 setter 가 클래스의 하단에 있어야 하는 이유가 있을까?  \n결론만 말하자면 정해진 컨벤션은 없다.  \n\n[Oracle 컨벤션](https://www.oracle.com/java/technologies/javase/codeconventions-fileorganization.html)에 따르면 다음과 같이 명시하고 있다.  \n\n> These methods should be grouped by functionality rather than by scope or accessibility. For example, a private class method can be in between two public instance methods. The goal is to make reading and understanding the code easier.\n\n즉, 메서드들은 범위나 접근 제한으로 구분하는 것보다 기능 단위로 묶여야 한다는 것이다. getter 나 setter 가 클래스 하단에 내려가야 한다는 규칙 같은 건 공식 문서에는 정해져 있지 않다.  \n사람들의 선호로 인해 관례적으로 쓰이고 있는 것 뿐이다. \n\n## 그렇다면 어떻게 해야 할까?\n\n그렇다면 getter 와 setter 를 클래스 하단에 놓을 필요는 없지 않을까?  \n\n물론 그렇다. 사람의 선호에 따라 getter, setter 의 위치는 달라질 수 있다.  \n그러나 보통 getter 와 setter 는 클래스에서 그렇게 큰 의미를 가지고 있지 않은 경우가 많다.  \n굳이 중요하지 않은 getter와 setter 들을 중요한 메서드들이 있는 클래스의 중앙 또는 상단으로 올리게 되면 클래스를 읽으며 이해하는 과정을 방해할 수도 있을 것이다. \n\n이런 이유에서 getter 와 setter 는 클래스의 하단에 두면 좋다는 결론을 내렸다.  "},{"excerpt":"TODO 연구실 미팅 Prometheus + Grafana 서버 설정 스픽 듀오링고 1시간 Suits 한 화 보기 LOG 연구실 미팅에 갔다왔다. 오늘도 내가 할 건 딱히 없었다. 오늘도 연구실 가는 길에 지하철을 잘못 탔다. 5호선 타야 되는데 8호선 탔다. 다행히 석촌에서 내려서 9호선으로 갈아탈 수 있었다. 천만 다행이다!! S-HOOK 도메인 회의…","fields":{"slug":"/2024-01-16/"},"frontmatter":{"date":"2024년 01월 16일 06:01","title":"2024년 01월 16일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 연구실 미팅\n- [x] Prometheus + Grafana 서버 설정\n- [x] 스픽\n- [x] 듀오링고 1시간\n- [x] Suits 한 화 보기\n\n## LOG\n\n- 연구실 미팅에 갔다왔다. 오늘도 내가 할 건 딱히 없었다. \n- 오늘도 연구실 가는 길에 지하철을 잘못 탔다. 5호선 타야 되는데 8호선 탔다. 다행히 석촌에서 내려서 9호선으로 갈아탈 수 있었다. 천만 다행이다!!\n- S-HOOK 도메인 회의가 있었다. 오랜만에 개발 이야기 하니까 너무 좋았다. 혼자 백엔드 개발하는 것도 분명 장점이 있지만, 같이 하는 건 훨씬 더 좋다. \n- 선배에게 저녁을 같이 먹자고 제안했다. 용기낸 거였는데 받아주셔서 다행이었다. 다음 주 월요일에 뵙기로 했다. 요즘 다시 새로운 사람들을 만나는 게 재밌는데 두근두근하다. \n- 미룬 일들을 모두 마쳤다. 뉴피니언 CI 도 설정하고, 프로메테우스 그라파나도 설정하고, codeowners 도 설정하고. 엄청 바쁜 하루였는데 오빠가 많이 도와줬다. 역시 혼자하는 것보단 같이 하는 게 좋다. 고마워~~\n\n## 오늘의 영어\n\n- in the loop : 업데이트하다. \n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"Coordinate Frames and XYZ Calculation Lidar Coordinate Frame 은 오른손 법칙을 따르며, point clouds 를 계산하고 조작할 수 있는 가장 간단한 frame 의 point cloud-centric frame 이다. X 좌표는 외부 커넥터를 향해 뒤쪽을 향하고 있는데, 이는 직관적이지 않은 방향이며 다음…","fields":{"slug":"/lidar-sensor-data/"},"frontmatter":{"date":"2024년 01월 16일 05:01","title":"LiDAR Sensor Data","tags":["lidar"]},"rawMarkdownBody":"\n## Coordinate Frames and XYZ Calculation\n\nLidar Coordinate Frame 은 오른손 법칙을 따르며, point clouds 를 계산하고 조작할 수 있는 가장 간단한 frame 의 point cloud-centric frame 이다.  \n\nX 좌표는 외부 커넥터를 향해 뒤쪽을 향하고 있는데, 이는 직관적이지 않은 방향이며 다음 기준을 충족하기 위해 의도적으로 선택된 것이다.  \n\n- 데이터 프레임은 센서의 뒤에서 나누어진다. \n- 데이터 프레임은 방위각이 0도인 상태에서 시작한다.  \n\n방위각 window 설정 및 위상 locking 을 포함한 모든 point cloud feature 들은 Lidar Coordinate Frame 에서 정의된다. \n\n### Lidar Coordinate Frame\n\nLidar Coordinate Frame 은 lidar 회전축과 lidar 광학 중간면의 교차점에 정의된다. \n\nLidar Coordinate Frame 축은 다음과 같이 배열된다. \n- 인코더 각도 0도를 가리키는 양의 X축 및 외부 커넥터\n- 인코더 각도 90도를 가리키는 양의 Y축\n- 양의 Z축은 센서 상단을 향한다. \n\n### Lidar Range to XYZ\n\n범위 데이터는 Lidar Coordinate Frame의 3D cartesian XYZ 좌표로 변환될 수 있다.  \n\n#### From a measurement block from the UDP Packet\n\n- `Measurement ID` 값은 lidar data packet 에서 찾을 수 있다. \n- `scan_width` 값은 수평 해상도의 스캔 폭 값이다. \n- `r` 또는 `range_mm` 값은 i 번째 채널의 data block 이다.\n\n#### From the GET /api/v1/sensor/metadata/beam_intrinsics HTTP Command\n\n- `beam_to_lidar_transform` 값\n- `beam_altitude_angles` 배열\n- `beam_azimuth_angles` 배열\n\n상응하는 3D 좌표는 다음과 같이 계산될 수 있다. \n\n![[lidar-3d-point-computed-by.png]]\n\n![side-view-of-lidar-coordinate-frame](https://static.ouster.dev/sensor-docs/_images/lidar-frame-side.svg)\n\n### Sensor Coordinate Frame\n\nSensor Coordinate Frame 은 하단의 센서 하우징 중앙에 정의되며, X축은 앞쪽, Y축은 왼쪽, Z축은 센서 상단을 향한다. 외부 커넥터는 음의 X 방향에 위치한다.  \n\n![side-view-of-sensor-coordinate-frame](https://static.ouster.dev/sensor-docs/_images/sensor-frame-side.svg)\n\n### Combining Lidar and Sensor Coordinate Frame\n\nLidar Coordinate Frame 의 양의 X축 (0 인코더 값) 은 Sensor Coordinate Frame 의 양의 X축 반대편에 위치하여 Sensor Coordinate Frame 의 양의 X축에 대한 Lidar 데이터의 중심을 맞춘다. 단일 측정 프레임은 Lidar 좌표 프레임의 0도 위치에서 시작하여 360도 위치에서 끝난다. 이는 Ouster Sensor 측정 값의 “range image” 를 볼 때 편리하며, “range image” 가 대부분의 로봇 시스템에서 일반적으로 정면을 향하는 센서 좌표 프레임의 양의 X축 중앙에 위치할 수 있도록 한다. \n\nOuster 센서는 위에서 봤을 때 시계 방향으로 스캔하며, 이는 Z축에 대한 음의 회전 속도이다. 따라서 인코더 tik 이 0에서 90,111로 증가하면 Lidar 좌표 프레임에서 Z축에 대한 실제 각도는 감소한다.  \n\n### Lidar Intrinsic Beam Angles\n\n각 빔의 고유 빔 각도는 각 빔에 방위각 및 고도 조정 오프셋을 제공하기 위해 HTTP 명령 `GET /api/v1/sensor/metadata/beam_intrinsics` 로 쿼리할 수 있다. 방위각 조정은 현재 인코더 각도에서 참조되고 고도 조정은 센서 및 라이다 좌표 프레임의 XY 평면에서 참조된다.  \n\n## Lidar Range Data To Sensor XYZ Coordinate Frame\n\n정밀 마운트에 대한 보정이 필요하거나 Lidar 데이터와 함께 IMU 데이터 (관성 측정 장치) 를 사용해야 하는 애플리케이션의 경우 XYZ 포인터를 센서 좌표 프레임에 맞게 조정해야 한다. 이를 위해서는 Z 이동과 Z 축을 중심으로 한 X, Y, Z 포인트의 회전이 필요하다. Z 이동은 센서 원점 위의 라이더 조리개 정지 높이로, 사용 중인 센서에 따라 다르며, 데이터는 Z 축을 중심으로 180도 회전해야 한다. 이 정보는 행 대소 순서에 따른 homogeneous transformation matrix의 형태로 TCP를 통해 쿼리할 수 있다. \n\n`GET /api/v1/sensor/metadata/lidar_intrinsics` 에서 `lidar_to_sensor_transform` 으로 가져올 수 있다.  \n\n### IMU Data To Sensor XYZ Coordinate Frame\n\nIMU 는 실용적인 이유로 센서 좌표 프레임에서 약간 offset 되어 있다. 센서 좌표 프레임의 IMU 원점은 행 대소 순서에 따른 Homogeneous transformation matrix 의 형태로 HTTP 명령을 통해 쿼리할 수 있다. \n\n`GET /api/v1/sensor/metadata/imu_intrinsics` 에서 `imu_to_sensor_transform` 으로 가져올 수 있다.  \n\n## Lidar Data Packet Format\n\n[[lidar-data-format]]"},{"excerpt":"Configurable Data Packet Format 데이터 패킷은 Packet Header, Measurement Header, Channel Data blocks, Packet Footer 로 구성되어 있다. 패킷 속도는 lidar mode 에 따라 다르다. 워드는 32bit, little endian 이다. 기본적으로 lidar UDP 데이터는 …","fields":{"slug":"/lidar-data-format/"},"frontmatter":{"date":"2024년 01월 16일 05:01","title":"LiDAR Data Format","tags":["lidar"]},"rawMarkdownBody":"\n## Configurable Data Packet Format\n\n데이터 패킷은 Packet Header, Measurement Header, Channel Data blocks, Packet Footer 로 구성되어 있다.  \n패킷 속도는 lidar mode 에 따라 다르다.  \n워드는 32bit, little endian 이다.  \n\n기본적으로 lidar UDP 데이터는 Port `7502` 로 포워딩된다.  \n\n### Packet Header\n\n- Packet type (16 bit unsigned bit): lidar data와 다른 패킷들을 stream 에서 구별하기 위함이다. Lidar 패킷은 Packet Type이 0x1 이다. \n- Frame ID (16 bit unsigned int) : lidar 스캔의 인덱스. 센서가 회전을 완료하는 매 시간마다 증가한다. \n\t- Init ID (24 bit unsigned int) : ID 초기화. 매 유저에 의해 트리거되거나 에러가 발생했을 때, reboot 가 발생할 때 일어나는 reinit 마다 변경된다. 이 값은 또한 HTTP command `GET /api/v1/sensor/metadata/sensor_info` 로 얻을 수 있다. \n- Serial No (40 bit unsigned int) : 센서의 serial number. 이 값은 각 센서마다 고유하고, 센서 위에 붙여져 있는 스티커 위에서 찾을 수 있다. 추가로, 이 정보는 Web UI 에서도 볼 수 있고, `get_sensor_info` 의 `prod_sn` 필드에서도 확인할 수 있다. \n- Shot limiting status (4 bit unsigned int) : 센서의 shot 제한 상태를 볼 수 있다. 다른 코드들은 sensor 가 Normal Operation 으로 작동하는지, Shot limiting 으로 작동하는지 알려준다. \n- Shutdown Status (4 bit unsigned int) : thermal shutdown 이 imminent인지 알려준다. \n- Shot limiting countdown (8 bit unsigned int) : 30초에서 shot limiting 에 도달할 때까지 카운트 다운된다. \n- Shutdown Countdown (8 bit unsigned int) : 30 초에서 thermal shutdown 이 발생할 때까지 카운트 다운된다.\n\n### Column Header Block\n\n- Timestamp (64 bit unsigned int) : nanoseconds 단위로 측정되는 Timestamp\n- Measurement ID (16 bit unsigned int) : 0 부터 511, 또는 0 부터 1023, 또는 0 부터 2047 와 같이 lidar_mode 에 따라 순차적으로 증가하는 수치이다. \n- Status (1 bit unsigned int) : 수치의 유효성을 알려준다. 유효한 수치인 경우에는 0x01, dropped 이거나 disabled column의 경우에는 0x00 이다. \n\n### Channel Data Blocks\n\n- channel data block 의 구조와 크기는 유저가 설정할 수 있는 data packet 의 포맷에 기초한다. \n\n### Packet Footer (256 bits)\n\n![[lidar-packet-footer.png]]\n\n## Channel Data Profiles\n\n구성 가능한 데이터 패킷 형식의 일부로 사용자가 사용할 수 있는 다양한 채널 데이터 프로필 옵션이다.  \n`udp_profile_lidar` 를 다음 옵션 중 하나로 설정하여 선택할 수 있다.  \n\n- RNG19_RFL8_SIG16_NIR16 (Single Return Profile)\n- RNG15_RFL8_NIR8 (Low Data Rate Profile)\n- RNG19_RFL8_SIG16_NIR16_DUAL (Dual Return Profile)\n\n### Single Return Profile\n\n모든 센서의 데이터 패킷 형식은 기본적으로 Single Return Profile 로 설정된다.  \n\n"},{"excerpt":"Trickle Algorithm Trickle 알고리즘은 영원히 전송하는 것. transmission time 이 지수적으로 증가하는 이유는 collision 을 줄이기 위해서. LiDAR 과제 (A4지 기준으로 사진 3장) x 2세트 완성하기. 연구실 회의 이번 주 회의는 건너뛴다. 다음 주 수요일 오후 4시","fields":{"slug":"/lab-meeting-01-16/"},"frontmatter":{"date":"2024년 01월 16일 04:01","title":"1월 16일 연구실 회의","tags":null},"rawMarkdownBody":"\n## Trickle Algorithm\n\n- Trickle 알고리즘은 영원히 전송하는 것. transmission time 이 지수적으로 증가하는 이유는 collision 을 줄이기 위해서. \n\n## LiDAR 과제\n\n(A4지 기준으로 사진 3장) x 2세트 완성하기.\n\n## 연구실 회의\n\n이번 주 회의는 건너뛴다.  \n다음 주 수요일 오후 4시"},{"excerpt":"Git 브랜치 전략 소스 코드의 버전 관리를 효율적으로 수행하기 위해 사용되는 방법론이다. 왜 정해야 하는가? 팀 협업의 효율성이 증가한다. 여러 개발자들이 동시에 다른 기능을 개발하거나 버그를 수정할 수 있도록 해주기 때문에 프로젝트의 전반적인 생산성을 향상시킨다. 소스코드의 안정성을 유지할 수 있다. 기능 개발 또는 버그 수정이 메인 code base…","fields":{"slug":"/branch-strategy/"},"frontmatter":{"date":"2024년 01월 14일 12:01","title":"브랜치 전략","tags":["github"]},"rawMarkdownBody":"\n## Git 브랜치 전략\n\n소스 코드의 버전 관리를 효율적으로 수행하기 위해 사용되는 방법론이다.  \n\n### 왜 정해야 하는가?\n\n1. 팀 협업의 효율성이 증가한다. 여러 개발자들이 동시에 다른 기능을 개발하거나 버그를 수정할 수 있도록 해주기 때문에 프로젝트의 전반적인 생산성을 향상시킨다. \n2. 소스코드의 안정성을 유지할 수 있다. 기능 개발 또는 버그 수정이 메인 code base 에 직접적으로 영향을 주지 않도록 하여, 안정적인 소프트웨어 유지 관리를 가능하게 한다. \n3. 지속적 통합 및 배포(CI/CD)가 용이하다. 자동화된 테스트와 배포를 통해 신속하고 효율적인 소프트웨어 업데이트가 가능하다. \n"},{"excerpt":"AppImage 를 실제로 실행하려고 더블 클릭을 하면 실행되지 않는다. 다음과 같이 권한을 부여하면 실행할 수 있다.","fields":{"slug":"/app-image-execute/"},"frontmatter":{"date":"2024년 01월 12일 07:01","title":"ubuntu AppImage 파일 실행하기","tags":["짧은-개발-지식"]},"rawMarkdownBody":"\nAppImage 를 실제로 실행하려고 더블 클릭을 하면 실행되지 않는다.  \n\n다음과 같이 권한을 부여하면 실행할 수 있다.\n\n```shell\nchmod a+x 파일이름\n```"},{"excerpt":"노트북에 ubuntu 를 usb 를 사용해서 설치할 때 usb 가 인식이 안 되는 경우가 있다. 방법 간단해서 적을까 말까 했지만… 삼성 BIOS 에 들어가서 Fast BIOS 설정과 Secure BIOS 설정을 꺼주고, Secure BIOS 설정을 맨 위에 있는 설정으로 바꿔준다. 그 다음 재부팅에서 USB가 보이는 것을 볼 수 있다.","fields":{"slug":"/ubuntu-device-recognition-error/"},"frontmatter":{"date":"2024년 01월 12일 06:01","title":"Samsung 노트북 ubuntu 설치 USB 인식이 안 될 때","tags":["trouble-shooting"]},"rawMarkdownBody":"\n노트북에 ubuntu 를 usb 를 사용해서 설치할 때 usb 가 인식이 안 되는 경우가 있다.  \n\n## 방법\n\n간단해서 적을까 말까 했지만…\n\n삼성 BIOS 에 들어가서 Fast BIOS 설정과 Secure BIOS 설정을 꺼주고, Secure BIOS 설정을 맨 위에 있는 설정으로 바꿔준다.   \n그 다음 재부팅에서 USB가 보이는 것을 볼 수 있다."},{"excerpt":"Vehicular Ad-hoc Networks autonomous driving, traffic managements 문제 발생 시 빠르게 전파해야 한다. Unicast src → dst Broadcast src ←→ obj → 빠른 특성 때문에 broadcast 채택 Various Methods Probability-based 시간 오래 걸림 Dista…","fields":{"slug":"/lab-meeting-01-12/"},"frontmatter":{"date":"2024년 01월 12일 04:01","title":"1월 12일 연구실 회의","tags":null},"rawMarkdownBody":"\n## Vehicular Ad-hoc Networks\n\nautonomous driving, traffic managements\n\n문제 발생 시 빠르게 전파해야 한다. \n\n1. Unicast\n\t- src → dst\n2. Broadcast\n\t- src ←→ obj\n\n→ 빠른 특성 때문에 broadcast 채택\n\n### Various Methods\n\n- Probability-based\n\t- 시간 오래 걸림\n- Distance-based\n\t- 가장 가까운 거 위주로 dynamic mobility\n- Cluster-based\n\t- Cluster overhead\n\n### Trickle algorithm\n\nwireless sensor network’s dissemination algorithm\ntrickle time : exponentially increased interval\n\ntrickle timer 시작 → transmission period 동안 범위 내의 다른 자동차에게 전달\n\n### Vehicle-aware adaptive Trickle (VaaT)\n\n- adjust transmission period\n- As far distance as possible\n\t- Distance: relative distance between cars\n\t- Not always select by distance\n\n### Simulation\n\n- ns-3 Simulation\n\t- IEEE 802.11p, OFDM , 6Mbps, 10Mhz\n\n## 해야 할 일\n\nLiDAR 로 차를 찍음\n1대로 찍을 때보다 2개로 찍을 때 더 많이 나온다는 걸 보여줘야 함. \n1. point count 를 찍다보면 데이터 양이 다름 시간 흐름에 따라 그래프를 그린다. (몇 메가 인지) 이걸 네트워크로 전송하려면 속도가 얼마나 나와야 하는지 1초에 10번씩 전송할 수 있는지. \n2. 확대된 것에서 object detection 이미지 (1개로 했을 때 / 2개로 했을 때)\n\nLiDAR 프로그램 돌리기 위해서 OS 설치하고 프로그램 설치\n그걸로 다음 주에 실험  \n필요한 network throughput 측정하기\n\n### LiDAR\n\nLiDAR는 Light Detection and Ranging의 약자이다. LiDAR에서 레이저는 광원(송신기)에서 보내지고 물체에서 반사됩니다. 반사광은 시스템 수신기에 의해 감지되고 비행시간 (TOF)은 물체의 거리 지도를 개발하는 데 사용된다.  \n레이저의 직진성을 이용하여 먼 거리의 물체를 정확하고 빠르게 감지가 가능하다는 장점이 있다.\n\n#### 유형\n\n- 회전형\n\t- 전기 모터를 사용하여 360도 회전 가능\n\t- 전방향으로 사물의 유무와 거리 및 방향 정보 획득 가능\n\t- 수직으로 동시에 송신하는 레이저 빔의 개수에 따라 4/16/32/64/128 채널 등이 있음.\n\t- 채널 수가 높을수록 해상도가 높아지고 가격 올라감\n- 고정형\n\t- 구성이 단순. 회전형에 비해 가격이 상대적으로 저렴함\n\t- 화각 한계 때문에 화격을 넘으면 물체 탐지가 불가능함\n\t- 동작 원리에 따라 MEMS 라이다, 플래시 라이다, 광학 위상 라이다, FMCW 라이다 등으로 구분 가능\n\n#### 종류\n\n1. 전동 기계식 라이다\n가장 일반적인 유형. 모터를 통해 360도 회전시켜 전방향을 센싱. 수직 해상도는 채널 수에 의해 결정되며 가격이 비쌈.\n\n2. MEMS 라이다\n전압으로 기울기가 달라지는 마이크로 미러를 사용. 다차원으로 레이저 빔을 전달하기 위해 다수의 거울을 계단식으로 배열하는 구조. MEMS 라이다는 온도와 진동에 취약하나 크기가 작고 가격이 저렴함. \n\n3. 플래시 라이다\n레이저를 전방에 비추고 레이저 가까이 위치한 수신기에서 반사된 산란광을 포착하여 하나의 이미지로 전체 물제를 감지한다. 이미지 포착 속도가 빠르지만, 역반사체로 인해 물체를 감지 못하는 경우가 발생할 수 있다. \n\n4. 광학 위상 배열 (OPA: Optical Phased Arrays)\n광학 위상 배열이 렌즈를 통과하는 빛의 속도를 제어하여 빛의 파면 현상을 제어하고 빔을 여러 방향으로 쏘아 물체를 인식한다. 가격이 저렴하고 소형이지만, 시야가 좁다는 단점이 있다. \n\n5. FMCW 라이다\n짧은 chirp 주파수 변조 레이저를 생성하여 수신한 chirp 신호의 위상, 주파수를 통해 대상물의 거리와 속도를 측정할 수 있다. FMCW 라이다는 주변 환경에 대해 강건하다는 장점이 있는 반면, 가격이 높고 아직 선행 단계로 상용화까지는 아직 해결해야 할 부분이 많다. \n\n#### 원리\n\n물체와의 거리 측정에 있어 TOF 원리를 사용한다.  \n거리는 다음과 같은 수식으로 계산한다. \n\n$$d = \\frac{c\\Delta t}{2}$$\n\n\n\n#### 문제점\n\n- 악천후에서 성능 약화\n- 개체의 반사율에 의해 성능이 결정되기도 함\n- 방출된 빔으로부터의 신호 격리 및 거부\n- 송신기와 의도된 타겟 사이의 대기에 있는 먼지로 인한 superious 리턴\n- 사용 가능한 광 전력의 제한: 더 많은 전력이 있는 시스템은 더 높은 정확도를 제공하지만 작동 비용이 더 높음. \n- 스캐닝 속도: 레이저 소스가 사람 눈에 위험한 주파수에서 작동할 때 안전에 문제가 있을 수 있다. \n\n### 디지털트윈\n\n디지털 트윈(Digital Twin)이란 **현실 세계의 기계나 장비, 사물 등을 컴퓨터 속 가상세계에 구현하는 것을 의미**\n\n"},{"excerpt":"오늘의 키워드 영어 공부의 중요성 한국어 영어를 공부하는 것은 중요하다. 특히 내가 해외 취업을 하고 싶다면 필수적으로 영어로 소통하는 것을 잘해야 한다. 가끔 한국어가 세계 공용어였다면 어땠을지 생각한다. 그렇지 않기 때문에 우리는 세계인과 소통하기 위해 영어를 공부해야만 한다. 영어는 한국어와 문장 구조가 다르기 때문에 한국인에게 배우기 어려운 언어 …","fields":{"slug":"/english-speaking-2024-01-12/"},"frontmatter":{"date":"2024년 01월 12일 04:01","title":"2024년 01월 12일 영어 회화","tags":null},"rawMarkdownBody":"\n## 오늘의 키워드\n\n영어 공부의 중요성\n\n## 한국어\n\n영어를 공부하는 것은 중요하다. 특히 내가 해외 취업을 하고 싶다면 필수적으로 영어로 소통하는 것을 잘해야 한다. 가끔 한국어가 세계 공용어였다면 어땠을지 생각한다. 그렇지 않기 때문에 우리는 세계인과 소통하기 위해 영어를 공부해야만 한다.  \n영어는 한국어와 문장 구조가 다르기 때문에 한국인에게 배우기 어려운 언어 중 하나이다. 영어로 말하는 것을 잘하기 위해서는 영어 문장에 많이 노출되어야 한다. 주변에서 영어를 쓰는 환경이라면 영어를 잘하는 데에 많은 도움이 될 것이다. \n\n## 영어\n\nIt’s important to study English.  \nEspecially, If I want to work on abroad, I should be necessarily good at communicating in English.  \nI sometimes used to think if Korean is the language which every people in the world use.  \nBecause it’s not true, We have to study English to communicate with the people in the world.  \nEnglish is one of the difficult languages for Korean because it has different sentence structure compared to Korean.  \nTo speak English well, I have to be exposed a lot by english sentences.  \nIf you’re placed in the environment which other people speak in English, it’s helpful to be good at English. \n\n## 끊어 읽기\n\nIt’s important / to study English.  \nEspecially, / If I want to work on abroad, / I should be necessarily / good at communicating / in English.  \nI sometimes used to think / if Korean is the language / which every people in the world / use.  \nBecause it’s not true, / We have to study English / to communicate / with the people / in the world.  \nEnglish is one of the difficult languages / for Korean / because it has different sentence structure / compared to Korean.  \nTo speak English well, / I have to be exposed a lot / by english sentences.  \nIf you’re placed in / the environment / which other people speak / in English /, it’s helpful to be good at English. \n\n## 키워드\n\n영어 공부가 중요해.  \n특히 해외 취업 원한다면 영어로 소통 잘해야 해.  \n가끔 한국어가 세계 공용어였으면 어땠을까 상상하기도 해.  \n하지만 그렇지 않으니 세계인과 소통하려면 영어 배워야 하지.  \n영어는 한국어와 구조가 달라서 한국인이 배우기 어렵고, 영어로 잘 말하려면 영어 문장 많이 접해야 해.  \n주변에서 영어 자주 쓰면 영어 실력 향상에 도움 많이 될 거야.\n\n## 교정받은 문장\n\nIt’s important to study English, especially if you want to **get a job abroad** where you need to communicate in English.  \nSometimes I imagine what **it would be like** if Korean were the language everyone in the world used.  \nBut since **that’s not the case**, I have to study English to communicate with people worldwide.  \nIt’s difficult for Koreans to learn English because English has a different sentence structure than Korean.  \nSo I need to **be exposed to** English sentences to speak English well.  \nBeing in an environment where other people speak English is **helpful for improving** English skills.  \n\nIt **makes it challenging for koreans to learn** English. "},{"excerpt":"TODO 연구실 회의 참석 영어 문장 만들고 연습하기 1시간 기타 연습 1시간   [scheduled:: 2024-01-11]  [completion:: 2024-06-16T19:15] 스픽 1시간 Suits 한 화 시청   [scheduled:: 2024-01-11]  [completion:: 2024-06-16T19:15] LOG 연구실 미팅에 참여했…","fields":{"slug":"/2024-01-12/"},"frontmatter":{"date":"2024년 01월 12일 03:01","title":"2024년 01월 12일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 연구실 회의 참석\n- [x] 영어 문장 만들고 연습하기 1시간\n- [x] 기타 연습 1시간   [scheduled:: 2024-01-11]  [completion:: 2024-06-16T19:15]\n- [x] 스픽 1시간\n- [x] Suits 한 화 시청   [scheduled:: 2024-01-11]  [completion:: 2024-06-16T19:15]\n\n## LOG\n\n- 연구실 미팅에 참여했다. 교수님이 라이다로 차 두 대를 찍어오라는 미션을 주셔서 오늘 연구실에서 라이다 센서를 노트북에 연결하는 방법에 대해 배웠다. 다들 좋으신 분들 같다. 연구실 생활 아자아자 파이팅\n\n## 오늘의 영어\n\n- alleviate: 완화시키다.\n- undergraduate research student: 학부 연구생\n- line of sight: 시야\n- be exposed **to** : 노출되다\n- helpful for ~ing: ~하는 것이 도움이 된다.\n- speak English: 영어로 말하다\n- that’s not the case: (가정한 것이) 사실이 아니다.\n- get a job abroad: 해외로 취업하다. \n\n## 배운 것\n\n## 느낀 것\n\n- 저번보다 영어 문장을 더 잘 만들 수 있게 됐다. 오늘 주제가 쉬워서 그랬을지도…"},{"excerpt":"오늘의 키워드 취미 만들기 한국어 나는 최근까지도 취미가 없었다. 그렇지만 나도 한 달 전부터 기타를 치기 시작했다. 기타를 치게 된 이유는 단순하다. 예전에 봤던 블루자이언트라는 영화가 있는데, 거기서 나온 인물의 노력하는 과정이 멋있었다. 나는 기타를 처음 쳐보니까, 무조건 처음에는 연습을 열심히 해야 한다. 예전에는 천재가 되고 싶었지만, 요즘은 노…","fields":{"slug":"/english-speaking-2024-01-11/"},"frontmatter":{"date":"2024년 01월 11일 00:01","title":"2024년 01월 11일 영어 회화","tags":null},"rawMarkdownBody":"\n## 오늘의 키워드\n\n취미 만들기\n\n## 한국어\n\n나는 최근까지도 취미가 없었다. 그렇지만 나도 한 달 전부터 기타를 치기 시작했다. 기타를 치게 된 이유는 단순하다. 예전에 봤던 블루자이언트라는 영화가 있는데, 거기서 나온 인물의 노력하는 과정이 멋있었다. 나는 기타를 처음 쳐보니까, 무조건 처음에는 연습을 열심히 해야 한다. 예전에는 천재가 되고 싶었지만, 요즘은 노력하는 과정을 즐길 수 있게 된 것 같다. 노력으로 천재를 이기는 사람도 멋진 것 같다. \n나는 하루에 한 시간씩 내가 원하는 곡을 연주하는 것을 연습한다. 내가 연습하는 노래는 요아소비의 밤을 달리다 라는 노래이다. 나같은 초보에게는 매우 어려운 곡이지만 연습하는 것이 즐겁다.\n\n## 영어\n\nI don’t have some hobbies recently. → I haven’t had any hobbies recently. \nHowever, I started to play a guitar before a month ago. → I started to play the guitar a month ago. \nThe reason to play the guitar is simple. → The reason I started playing the guitar is simple.\nI watched a movie, called Blue giant, I thought the process of the character in it to practice. → I watched a movie called ‘Blue Giant’ and I was inspired by the character’s practice routine.\nBecause It’s first time for me to play the guitar, I unconditionally have to practice hard at first. → Because it’s my first time playing the guitar, I absolutely have to practice hard initially. \nWhen I was young, I wanted to be a genius. → When I was younger, I aspired to be a genius.\nBut nowadays, I would like to enjoy the process to take hard. → But nowadays, I want to enjoy the process fully. \nThose who beat a genius by practicing is wonderful. → It’s wonderful when someone surpasses a genius through practice. \nI have practiced the song I want to play an hour ~~in~~ every day.   \nThe song which I have been practicing is YOASOBI’s Into The Night.  \nIt’s very difficult song for a beginner like me, but I enjoy it. → It’s quite difficult for a beginner like me, but I enjoy it. \n\n## 키워드\n\n최근까지 취미 X (have pp)\n한 달 전부터 기타를 치기 시작. \n이유는 단순 → 블루자이언트라는 영화에서 인물의 노력하는 과정이 멋있었음\n기타를 처음 쳐보기 때문에 연습을 많이 해야 함\n예전에는 천재가 되고 싶었음 → 요즘에는 노력하는 과정을 즐길 수 있게 됨  \n노력으로 천재를 이기는 것도 멋짐  (it when)\n하루에 한 시간씩 원하는 곡 연주하는 중  (have pp)\n요아소비의 밤을 달리다라는 노래 연습 중  (have pp ing)\n초보에게 어려운 곡이지만 연습이 재밌음 (quite)\n"},{"excerpt":"TODO 듀오링고 1시간 캡스톤 회의 prometheus + grafana 모니터링 서버 구축하기   [scheduled:: 2024-01-10]  [completion:: 2024-06-16T19:15] 영어 문장 만들고 연습하기 1시간 스픽 1시간 기타 연습 1시간 LOG 스픽 열심히 하는 중이다. 듀오링고 한 2시간 반 정도 한 것 같다. 엄청 열심…","fields":{"slug":"/2024-01-11/"},"frontmatter":{"date":"2024년 01월 10일 23:01","title":"2024년 01월 11일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 듀오링고 1시간\n- [x] 캡스톤 회의\n- [x] prometheus + grafana 모니터링 서버 구축하기   [scheduled:: 2024-01-10]  [completion:: 2024-06-16T19:15]\n- [x] 영어 문장 만들고 연습하기 1시간\n- [x] 스픽 1시간\n- [x] 기타 연습 1시간\n\n## LOG\n\n- 스픽 열심히 하는 중이다.\n- 듀오링고 한 2시간 반 정도 한 것 같다. 엄청 열심히 했는데 너무 어렵다… 독일어 단어 너무 많이 나오고 어렵다 ㅠ\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"오늘의 키워드 어떻게 하면 말을 잘 정리해서 말할 수 있을까? 한국어 나는 말을 정리해서 말하는 것을 잘 못하는 편이다. 간단한 문장도 머릿속에서 뒤죽박죽이 되곤 한다. 영어로 말하는 것은 말할 것도 없다. 한국어로 생각하는 것도 어려운데 영어로 말하는 게 쉬울 리 없다. 특히 내가 떠올린 문장을 기억하는 것이 내게 가장 어려운 부분이다. 나는 단기 기억…","fields":{"slug":"/english-speaking-2024-01-09/"},"frontmatter":{"date":"2024년 01월 09일 00:01","title":"1월 9일 영어 회화 연습","tags":null},"rawMarkdownBody":"\n## 오늘의 키워드\n\n- 어떻게 하면 말을 잘 정리해서 말할 수 있을까?\n\n## 한국어\n\n나는 말을 정리해서 말하는 것을 잘 못하는 편이다. 간단한 문장도 머릿속에서 뒤죽박죽이 되곤 한다. 영어로 말하는 것은 말할 것도 없다. 한국어로 생각하는 것도 어려운데 영어로 말하는 게 쉬울 리 없다. 특히 내가 떠올린 문장을 기억하는 것이 내게 가장 어려운 부분이다. 나는 단기 기억력이 좋지 않다. 방금 생각한 문장도 까먹곤 한다. 그래서 그런지 머릿속에 떠오른 문장을 바로 말해야 한다는 강박이 있다. 다른 사람들이 말할 때 하고 싶은 말이 떠오르면 말을 끊기도 한다. 의식적으로 고치려고 노력하고 있지만 어렵다. 이를 해결하기 위해 주변 사람들이 추천해준 방법은 다음과 같다. \n먼저 말하려고 준비하지 말고, 생각을 정리하는 시간을 갖는다. 나는 잊어버렸다고 생각하지만 실제로는 생각이 끝까지 진행이 안 되고 느낌만 남아있는 경우가 있다. 이럴 때 말을 시작하게 되면 다른 사람들이 이해하지 못하는 문장이 완성된다. 당연히 알아듣기 힘들다. 내가 하고자 하는 말을 처음부터 끝까지 정리하는 습관을 들이는 것이 중요하다. \n기억력에 의존하지 말고 떠오른 생각은 적어둔다. 모든 사람들이 그렇듯이 머리에 떠오른 생각을 전부 기억할 수는 없다. 그러니 어떤 아이디어가 떠올랐다면 다른 곳에 메모해두고, 메모를 보면서 말하면 효율이 좋을 것이다. \n물론 이전에도 많이 실패했다. 메모하는 습관을 들이기 위해 잃어버린 공책은 수십권 정도 될 것이다. 그렇지만 나아지려고 시도하지 않으면 나아지는 건 없다. 나는 오늘도 공책을 잃어버리겠지만, 오늘도 메모를 할 것이다. \n\n## 영어\n\nIt’s hard for me to speak well-organized sentences. Some simple sentences used to **be mixed up** in my head. **It goes without saying that** when I speak in english. It’s hard to think in Korean, how much more would I speak in English? Especially remembering sentences that I come up with is the most difficult part for me. I have poor **short-term** memory. I used to forget a sentence which I think **a moment ago**. That’s the reason why I have an **obsession** that I should speak the sentence which just **come to my mind** immediately. I used to **cut the word** when I come up with sentences I want to say even if other people are speaking. I’m trying to fix the habit but it’s difficult. To resolve this problem, the way the people around me recommend is as follows. \nDon’t prepare to speak in first and take a time to organize my thought. I think I forget the point but in reality, there is a case that my thought isn’t proceeded **to the end** and only feelings remain. If I start to speak in this case, the sentence which other people can’t understand is completed. Of course, it’s difficult to understand well. So it’s important to make a habit that organize the work I want to say **from start to finish**.\nDon’t depend on memory and write down my thought. We can’t remember whole thoughts I **came into my head** as all people. So if I come up with any idea, it has great efficiency to take a note to other place and to say to see it.\nNaturally, I failed a lots of times before. There would be tens of notes which I lost to make it a habit to take a note. However, if I don’t try to improve, nothing improves. Even if I would lose my note today, I will take notes today.\n\n## 끊어 읽기\n\nIt’s hard for me / to speak well-organized sentences. Some simple sentences used to **be mixed up** / in my head. **It goes without saying that** / when I speak in english. It’s hard to think / in Korean, how much more would I speak in English? Especially / remembering sentences that / I come up with / is the most difficult part for me. I have poor **short-term** memory. I used to forget a sentence / which I think **a moment ago**. That’s the reason why / I have an **obsession** that / I should speak the sentence / which just **come to my mind** immediately. I used to **cut the word** / when I come up with sentences / I want to say / even if other people are speaking. I’m trying to fix the habit / but it’s difficult. To resolve this problem, / the way the people around me recommend / **is as follows**. \nDon’t prepare to speak in first / and take a time to organize my thought. I think / I forget the point / but in reality, / there is a case that / my thought isn’t proceeded **to the end** and / only feelings remain. If I start to speak in this case, / the sentence / which other people can’t understand / is completed. Of course, / it’s difficult to understand well. So it’s important to make a habit / that organize the work / I want to say **from start to finish**.\nDon’t depend on memory and / write down my thought. We can’t remember whole thoughts / I **came into my head** / as all people. So if I come up with any idea, / it has great efficiency to take a note to other place and / to say to see it.\nNaturally, I failed a lots of times before. / There would be tens of notes / which I lost to make it a habit / to take a note. However, if I don’t try to improve, / nothing improves. Even if I would lose my note today, / I will take notes today.\n\n## 키워드\n\n말을 정리해서 말하기 힘들다. it to 부정사\n간단한 문장도 머릿속에서 뒤죽박죽이 된다. \n영어로 말하는 것도 똑같다. \n한국어로 생각하는 것 → 어려움 영어로 말하는 것도 쉽지 않음. \n특히 문장을 기억하는 것이 가장 어려운 부분. \n좋지 않은 단기 기억력 \n방금 생각한 문장도 까먹음. \n머리에 생각난 문장을 바로 말해야 한다는 강박 있음. \n다른 사람들이 말하고 있을 때도 말이 생각나면 말을 끊기도 한다. \n의식적으로 고치려고 노력 중 → 어려움. \n해결하기 위해 → 주변 사람들이 추천해준 방법은 다음과 같음\n먼저 말하려고 준비 X → 생각을 정리하는 시간 갖기. \n잊어버렸다고 생각하지만 생각이 끝까지 진행이 안 되고 느낌만 남아있는 경우 많음. \n그럴 때 말을 시작하면 다른 사람들이 이해하기 어려운 문장 완성됨. 당연히 알아듣기 힘듦. \n내가 하려는 말을 처음부터 끝까지 정리하는 습관을 들이는 것 중요. \n\n기억력에 의존하지 말고 떠오른 생각은 적어두기. \n모든 사람들이 그렇듯이 머리에 떠오른 생각을 전부 기억할 수는 없다. 그러니 어떤 아이디어가 떠올랐다면 다른 곳에 메모해두고, 메모를 보면서 말하면 효율이 좋을 것이다. \n물론 이전에도 많이 실패했다. 메모하는 습관을 들이기 위해 잃어버린 공책은 수십권 정도 될 것이다. 그렇지만 나아지려고 시도하지 않으면 나아지는 건 없다. 나는 오늘도 공책을 잃어버리겠지만, 오늘도 메모를 할 것이다. \n\n## 교정받은 문장\n\n- Thinking in Korean is difficult, and speaking in English is equally challenging for me. \n\t- the same 보다 equally challenging 사용하기\n- I have a poor short-term memory and I forgot the sentence I just thought of a moment ago.\n- I’m obsessed with talking about the thoughts that come into my head, and I tend to **interrupt** when someone is speaking about a different subject. I’m consciously trying to fix this problem, but it’s difficult for me. \n\t- cut the word 보다 I tend to interrupt 사용하기\n- The solution recommended by those around me is as follows. \n\t- 간결하게 표현하기\n- I **should avoid preparing** to speak **too early** and take time to organize my thoughts. There are many cases where I think **I’ve forgotten** my thoughts, but in reality, they are just feelings. There are no thoughts, only feelings. \n\t- Don’t prepare to speak in first 대신 should avoid preparing 사용\n- I should develop a habit of organizing what I want to say from start to finish, not rely on my memory, and write down my thoughts. \n- Like everyone else, I can’t remember all the thoughts that come to my mind, so if I have an idea, I’ll take a note somewhere else and then refer to the content of the note. It helps me to **speak in** well-organized sentences. \n- I’ve experienced a lot of failures before. There are many notebooks to help make **note-taking** a habit. However, I can’t improve if I don’t try to do so. Therefore, even if I lose my notebook, I’ll still take notes. \n\n좀 더 간결하게 표현하고, have+p.p 신경쓰기"},{"excerpt":"english-speaking-2024-01-09 english-speaking-2024-01-11 english-speaking-2024-01-12","fields":{"slug":"/english-speaking/"},"frontmatter":{"date":"2024년 01월 09일 00:01","title":"English Speaking","tags":["english"]},"rawMarkdownBody":"\n- [[english-speaking-2024-01-09]]\n- [[english-speaking-2024-01-11]]\n- [[english-speaking-2024-01-12]]"},{"excerpt":"TODO LOG 배운 것 느낀 것 최근에 영어 공부를 어떻게 해야 할 지 고민이 많아서 글을 찾아보다 우연히 이 글을 접하게 되었다. 큰 위로가 되었고, 큰 동기부여가 되었다. 나도 할 수 있다! 진짜로 할 수 있다.","fields":{"slug":"/2024-01-09/"},"frontmatter":{"date":"2024년 01월 09일 00:01","title":"2024년 01월 09일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n## 느낀 것\n\n- 최근에 영어 공부를 어떻게 해야 할 지 고민이 많아서 글을 찾아보다 우연히 [이 글](https://brunch.co.kr/@englishspeaking/96)을 접하게 되었다. 큰 위로가 되었고, 큰 동기부여가 되었다. 나도 할 수 있다! 진짜로 할 수 있다."},{"excerpt":"How Secure and Quick is QUIC? Provable Security and Performance Analyses Abstraction QUIC은 구글에서 개발하여 2013년에 Chrome 에 구현한 보안 전송 프로토콜로, 현재 지연 시간을 줄이면서 TLS와 유사한 보안 특성을 제공하는 가장 유망한 솔루션 중 하나이다. 공격자가 있는 상황…","fields":{"slug":"/research-subject-instruction/"},"frontmatter":{"date":"2024년 01월 08일 08:01","title":"연구 주제 조사","tags":["연구실"]},"rawMarkdownBody":"\n## How Secure and Quick is QUIC? Provable Security and Performance Analyses\n\n### Abstraction\n\nQUIC은 구글에서 개발하여 2013년에 Chrome 에 구현한 보안 전송 프로토콜로, 현재 지연 시간을 줄이면서 TLS와 유사한 보안 특성을 제공하는 가장 유망한 솔루션 중 하나이다. 공격자가 있는 상황에서 입증 가능한 보안 및 성능 보장 측면에서 QUIC 의 장단점을 살펴본다. 먼저 QUIC과 같은 성능 중심 프로토콜을 분석하기 위한 보안 모델을 소개하고, 프로토콜의 빌딩 블럭에 대한 합리적인 가정 하에서 QUIC이 정의를 만족한다는 것을 증명한다. 그러나 QUIC은 TLS-DHE와 같은 일부 TLS 모드에서 제공하는 순방향 비밀성이라는 전통적인 개념을 만족하지 못한다. \n\n### Introduction\n\nTLS와 같은 프로토콜은 상대적으로 높은 연결 설정 지연 시간 오버헤드로 인해 사용자 불만을 야기하고 있다. 이를 위해 기밀성, 인증, 무결성과 같은 기본적인 보안 목표 이외에도 지연 시간이 짧은 새로운 전송 프로토콜을 설계하기 위한 여러 노력이 있었다. \n\n그 중 가장 유망한 프로토콜 중 하나인 QUIC이 있다. QUIC은 TCP, TLS, DTLS 의 아이디어를 통합하여 TLS에 필적하는 보안 기능, TCP에 필적하는 혼잡 제어 기능 등을 제공한다. 중복 통신을 없애기 위해 TCP에 의존하지 않고, 더 빠른 연결 설정을 위해 initial keys 를 사용하지 않는다는 점이 TLS 와의 주요 차이점이다. \n\n## A Survey of TCP Congestion Control Algorithm\n\n### Abstraction\n\n인터넷의 빠른 발전과 함께 다양한 애플리케이션에 기반한 Internet 이 나타났고, 인터넷의 트래픽 또한 기하급수적으로 증가했다. 네트워크의 혼잡은 네트워크 연구 분야에서 가장 중요한 문제가 되어가고 있다. 적절한 혼잡 제어 (CC) 는 네트워크 혼잡 문제를 완화할 수 있다. \n\n### Instruction\n\n"},{"excerpt":"TODO 논문 읽기   [scheduled:: 2024-01-07]  [completion:: 2024-06-16T19:15] 기타 연습 1시간 Suits 2화 LOG 배운 것 느낀 것","fields":{"slug":"/2024-01-08/"},"frontmatter":{"date":"2024년 01월 08일 07:01","title":"2024년 01월 08일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 논문 읽기   [scheduled:: 2024-01-07]  [completion:: 2024-06-16T19:15]\n- [x] 기타 연습 1시간\n- [x] Suits 2화\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"2024년 1분기 2024-01 2024-02 2024년 2분기 2024-06","fields":{"slug":"/2024/"},"frontmatter":{"date":"2024년 01월 08일 07:01","title":"2024년","tags":null},"rawMarkdownBody":"\n## 2024년 1분기\n\n- [[2024-01]]\n- [[2024-02]]\n\n## 2024년 2분기\n\n- [[2024-06]]"},{"excerpt":"2024-01-07 2024-01-08 2024-01-09 2024-01-11 2024-01-12 2024-01-16 2024-01-19 2024-01-21","fields":{"slug":"/2024-01/"},"frontmatter":{"date":"2024년 01월 08일 07:01","title":"2024년 01월","tags":["TIL"]},"rawMarkdownBody":"\n- [[2024-01-07]]\n- [[2024-01-08]]\n- [[2024-01-09]]\n- [[2024-01-11]]\n- [[2024-01-12]]\n- [[2024-01-16]]\n- [[2024-01-19]]\n- [[2024-01-21]]"},{"excerpt":"너무 많이 삽질을 해서 나중에도 기억하기 위해 기록으로 남겨둔다. 하려고 하는 것 Github 에 새로운 커밋이 푸시된다. Jenkins 가 있는 EC2 인스턴스에서  를 수행한다. jar 파일이 만들어지면 Docker image 를 빌드하여 Docker Hub 에 push 한다. Image push 가 완료되면 production 서버에서 Docker …","fields":{"slug":"/jenkins-docker/"},"frontmatter":{"date":"2024년 01월 07일 06:01","title":"Jenkins 로 docker image 빌드 후 배포하기","tags":["jenkins","docker","spring"]},"rawMarkdownBody":"\n너무 많이 삽질을 해서 나중에도 기억하기 위해 기록으로 남겨둔다.  \n\n## 하려고 하는 것\n\n1. Github 에 새로운 커밋이 푸시된다.\n2. Jenkins 가 있는 EC2 인스턴스에서 `gradlew clean bootJar` 를 수행한다. \n3. jar 파일이 만들어지면 Docker image 를 빌드하여 Docker Hub 에 push 한다. \n4. Image push 가 완료되면 production 서버에서 Docker 컨테이너를 실행한다. \n\n## Github Push 이벤트 수신하기\n\n`jenkins EC2의 ip/github-webhook/` 으로 Github Webhook 을 등록한다. \n\n![[github-jenkins-webhook.png]]\n\n당연하게도 Github, Docker hub Credentials 는 있어야 한다. Github 는 비밀번호를 토큰으로, Docker Hub 는 회원가입 때 만들었던 아이디와 비밀번호를 넣어서 Credentials 를 생성해준다. \n\n## Docker image 빌드 Pipeline\n\nGithub 프로젝트를 체크하고 트래킹할 레포지토리를 적어준다. \n\n![[jenkins-docker-github-project.png]]\n\npush event 를 수신할 것이기 때문에 Github hook trigger 를 설정해준다. \n\n![[jenkins-push-event.png]]\n\nPipeline script from SCM 으로 설정해주고, 똑같이 Repository URL 을 적어준다. \n\n![[jenkins-github-repository-setting.png]]\n\n나는 Submodule 을 사용했기 때문에 `Advanced sub-modules behaviours` 를 추가해주었다.  \n\n![[jenkins-github-submodules.png]]\n\n그리고 아래에는 Script Path 가 있는데, Jenkinsfile 이라고 적어준다.  \n\n그런 다음 Spring Project 의 최상단에 Jenkinsfile 을 생성해준다. 내부는 다음과 같다. \n\n```text\npipeline {  \n    agent any  \n  \n    environment {  \n        // Define Docker image tag and credentials ID  \n        DOCKER_IMAGE = 'neupinion/neupinion:1.0'  \n        DOCKER_CREDS = 'docker_hub'  \n    }  \n  \n    stages {  \n        stage('Prepare Environment') {  \n            steps {  \n                // Make the Gradle wrapper script executable  \n                sh 'chmod +x gradlew'  \n            }  \n        }  \n  \n        stage('Build with Gradle') {  \n            steps {  \n                // Clean and build the project using Gradle wrapper  \n                sh './gradlew clean bootJar'  \n            }  \n        }  \n  \n        stage('Build Docker Image') {  \n            steps {  \n                // Build the Docker image  \n                sh \"docker build -t ${DOCKER_IMAGE} .\"            }  \n        }  \n  \n        stage('Push to Docker Hub') {  \n            steps {  \n                // Log in to Docker Hub with --password-stdin  \n                withCredentials([usernamePassword(credentialsId: DOCKER_CREDS, usernameVariable: 'DOCKERHUB_USERNAME', passwordVariable: 'DOCKERHUB_PASSWORD')]) {  \n                    sh \"echo ${DOCKERHUB_PASSWORD} | docker login -u ${DOCKERHUB_USERNAME} --password-stdin\"                }  \n                // Push the image to Docker Hub  \n                sh \"docker push ${DOCKER_IMAGE}\"  \n            }  \n        }  \n    }  \n  \n    post {  \n        always {  \n            // Post actions like cleaning up, notifications, etc.  \n            echo 'Build process completed.'  \n        }  \n    }  \n}\n```\n\n## Docker Hub 에서 이미지 받아서 배포하기\n\n이제 새로운 파이프라인을 만든다.  \n\nbuild 파이프라인이 stable 할 때만 해당 프로젝트가 실행되도록 한다.  \n\n![[jenkins-build-trigger.png]]\n\n다음으로, Send files or execute commands over SSH 를 선택한다.  \nExec command 에는 다음과 같이 적어주었다.  \n\n```shell\nsudo docker stop neupinion \nsudo docker rm -f $(sudo docker ps -qa)\nsudo docker image prune -a -f\nsudo docker pull neupinion/neupinion:latest && \\\nsudo docker run -d -p 8080:8080 \\\n    -p 8090:8090 \\\n    -e \"SPRING_PROFILE=prod\" \\\n    --name neupinion \\\n    neupinion/neupinion:latest\nsudo docker-compose up -d\n```\n\nBuild 가 완료되면 Slack Notification 으로 Success, Failure 를 결과로 알려주도록 설정한다.  \n\n이로써 모든 설정이 완료되었다.  \nGithub main 브랜치에 코드가 push 되면, Jenkins 서버에서 코드를 pull 받아서 build 한 뒤 Docker hub 로 이미지를 만들고, Docker hub 에 업로드 된 이미지를 프로덕션 서버에서 pull 받아 배포하는 과정을 자동화할 수 있었다.  \n\n굉장히 많은 삽질을 했지만, 결국은 해냈다."},{"excerpt":"의존성 추가 swagger 의존성을 추가해준다. config 파일 Config 파일은 간단하게 구성했다. 프로덕션 코드와 API 문서 코드 분리하기 Swagger 의 최대 단점인 프로덕션 코드에 API 문서 코드가 생긴다는 단점을 보완하기 위해 Interface 를 사용하여 API 문서 코드를 프로덕션 코드와 분리해보자. hidden 속성을  로 하면 p…","fields":{"slug":"/spring-boot-3-swagger/"},"frontmatter":{"date":"2024년 01월 07일 05:01","title":"Swagger 3.0 설정하기","tags":["spring"]},"rawMarkdownBody":"\n## 의존성 추가\n\nswagger 의존성을 추가해준다. \n\n```groovy\n//swagger  \nimplementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2'\n```\n\n## config 파일\n\nConfig 파일은 간단하게 구성했다. \n\n```java\n@OpenAPIDefinition(  \n    info = @Info(  \n        title = \"neupinion API 명세서\",  \n        version = \"v1\"  \n    )  \n)  \npublic class OpenApiConfig {  \n  \n}\n```\n\n## 프로덕션 코드와 API 문서 코드 분리하기\n\nSwagger 의 최대 단점인 프로덕션 코드에 API 문서 코드가 생긴다는 단점을 보완하기 위해 Interface 를 사용하여 API 문서 코드를 프로덕션 코드와 분리해보자.  \n\n```java\npackage shook.shook.member.ui.openapi;  \n  \nimport io.swagger.v3.oas.annotations.Operation;  \nimport io.swagger.v3.oas.annotations.Parameter;  \nimport io.swagger.v3.oas.annotations.responses.ApiResponse;  \nimport io.swagger.v3.oas.annotations.tags.Tag;  \nimport org.springframework.http.ResponseEntity;  \nimport org.springframework.web.bind.annotation.DeleteMapping;  \nimport org.springframework.web.bind.annotation.PathVariable;  \nimport shook.shook.auth.ui.argumentresolver.Authenticated;  \nimport shook.shook.auth.ui.argumentresolver.MemberInfo;  \n  \n@Tag(name = \"Member\", description = \"회원 관리 API\")  \npublic interface MemberApi {  \n  \n    @Operation(  \n        summary = \"회원 탈퇴\",  \n        description = \"회원 탈퇴로 회원을 삭제한다.\"  \n    )  \n    @ApiResponse(  \n        responseCode = \"204\",  \n        description = \"회원 탈퇴, 삭제 성공\"  \n    )  \n    @Parameter(  \n        name = \"member_id\",  \n        description = \"삭제할 회원 id\",  \n        required = true  \n        hidden = false\n    )  \n    @DeleteMapping  \n    ResponseEntity<Void> deleteMember(  \n        @PathVariable(name = \"member_id\") final Long memberId,  \n        @Authenticated final MemberInfo memberInfo  \n    );  \n}\n```\n\nhidden 속성을 `true` 로 하면 parameter 를 감출 수 있다. \n\n```java\n@RequiredArgsConstructor  \n@RequestMapping(\"/members/{member_id}\")  \n@RestController  \npublic class MemberController implements MemberApi {  \n  \n    private final MemberService memberService;  \n  \n    @DeleteMapping  \n    public ResponseEntity<Void> deleteMember(  \n        @PathVariable(name = \"member_id\") final Long memberId,  \n        @Authenticated final MemberInfo memberInfo  \n    ) {  \n        memberService.deleteById(memberId, memberInfo);  \n  \n        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();  \n    }  \n}\n```\n\n`implements` 로 방금 설정해둔 API interface 를 설정해주면 프로덕션 코드에 최소한으로 영향을 주는 코드를 작성할 수 있다. \n\n물론 이렇게 설정하더라도 Controller 메서드 이름, 매개 변수가 변경될 때마다 수정해주어야 한다는 단점이 있다. "},{"excerpt":"TODO 컴퓨터-네트워킹-하향식-접근 UDP 까지 읽기 운영 서버 슬랙 로깅 설정 논문 1개 읽기 시작   [scheduled:: 2024-01-06]  [completion:: 2024-06-16T19:15] 기타 연습 1시간 듀오링고 1시간 Suits 1화 LOG 배운 것 John looks at him, intrigued in spite of him…","fields":{"slug":"/2024-01-07/"},"frontmatter":{"date":"2024년 01월 07일 04:01","title":"2024년 01월 07일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 컴퓨터-네트워킹-하향식-접근 UDP 까지 읽기\n- [x] 운영 서버 슬랙 로깅 설정\n- [x] 논문 1개 읽기 시작   [scheduled:: 2024-01-06]  [completion:: 2024-06-16T19:15]\n- [x] 기타 연습 1시간\n- [x] 듀오링고 1시간\n- [x] Suits 1화\n\n## LOG\n\n## 배운 것\n\n- John looks at him, intrigued in spite of himself: john 은 자신도 모르게 흥미를 느끼며 그를 바라보았다. \n- dissection table: 해부대\n- early thirties, tall, lean, imperious. 30대 초반, 키가 크고, 마르고, 거만한 사람. \n- natural causes: 자연사\n- the riding crop: 채찍질\n- Sherlocks’s shadows flap over the wall: 벽 위로 펄럭이는 셜록의 그림자\n- flutter: 설렘\n- sherlock appears in shot: 장면에 나타나다.\n- I need to know what bruises for in the next twenty minutes: 다음 20분 동안 어떤 멍이 생기는지 알고 싶어. \n- he has swivelled round in his chair: 그는 의자에서 몸을 돌렸다. \n\n## 느낀 것"},{"excerpt":"오전 9시: 기상 논문 조사 뉴피니언 개발 듀오링고 1시간 오후 9~10시: 기타 연습 오후 10~11시: 영어 공부","fields":{"slug":"/2024-winter-vacation-plan/"},"frontmatter":{"date":"2024년 01월 07일 02:01","title":"2024년 겨울 방학 계획","tags":["2024"]},"rawMarkdownBody":"\n- 오전 9시: 기상\n- 논문 조사\n- 뉴피니언 개발\n- 듀오링고 1시간\n- 오후 9~10시: 기타 연습\n- 오후 10~11시: 영어 공부"},{"excerpt":"우아한테크코스를 수료하고 나서 많은 곳에 인턴 서류를 넣었다. 그 중에는 대학교 연합 동아리 서류도 있었는데, 결과는 다음과 같다. 당근마켓 인턴 두 곳 서류 탈락 카카오 인턴 코딩 테스트 탈락 에이블리 인턴 서류 탈락 학교에서 중개해주는 placement 인턴 서류 탈락 Nexters 서류 탈락 연이은 서류 탈락들에 어지러웠다. 나는 정말 잘한 거였을까…","fields":{"slug":"/get-a-job-with-delivery-hero/"},"frontmatter":{"date":"2023년 12월 22일 14:12","title":"모든 곳에 떨어지고 딜리버리 히어로에 가게 된 이야기","tags":["후기"]},"rawMarkdownBody":"\n우아한테크코스를 수료하고 나서 많은 곳에 인턴 서류를 넣었다. 그 중에는 대학교 연합 동아리 서류도 있었는데, 결과는 다음과 같다. \n\n- 당근마켓 인턴 두 곳 서류 탈락\n- 카카오 인턴 코딩 테스트 탈락\n- 에이블리 인턴 서류 탈락\n- 학교에서 중개해주는 placement 인턴 서류 탈락\n- Nexters 서류 탈락\n\n연이은 서류 탈락들에 어지러웠다.  \n나는 정말 잘한 거였을까? 내가 공부해온 방향은, 옳은 방향이었을까?  \n\n이런 의문이 들 때쯤 Delivery Hero 에서 최종\b합격을 받게 되었다. 최종 합격까지의 과정을 간략하게 정리해보려고 한다. \n\n## 첫 만남\n\nDelivery Hero 를 알게 된 것은 올해 9월 21일이었다. 9월 21일에는 DH CTO 과의 만남이라는 강연 비슷한 프로그램이 있었다. 그 날은 아쉽게도 앞에서 앉아서 강연을 듣지 못했고, 영어를 잘 못했던지라 제대로 들은 문장은 몇 개 없었다.  \n\n그렇지만 그럼에도 느낀 점은 많았다. [[2023-09-21]] 의 TIL 을 보면 그때 기억나는 문장이 나오는데, 바로 `지금 못한다는 건 재미없다는 주장의 이유가 될 수 없다` 라는 말이었다. \n그때 나는 AI 는 재미가 없다고 생각했었는데, 정말로 AI 가 재미가 없었는지, 아니면 못해서 싫어했는지를 돌아볼 수 있었던 것 같다.  \n\n그 뒤에 포이와 에밀은 CTO 분과 더 이야기를 나눴는데, 그게 마냥 신기했었다. 나였다면 영어를 잘했더라도 말을 걸 생각은 못했을 것 같은데, 먼저 다가가서 이야기를 걸고 궁금한 것을 물어보는 모습이 멋있었다.  \n내가 직접 대화에 끼지는 못했지만, 전해 들은 이야기들은 Delivery Hero 에 관심을 가지게 되는 데에 충분했다. 똑똑한 사람들과 같이 일하는 것, 무엇보다 해외에서 일하는 것에 대한 궁금증이 생겼다. Delivery Hero CTO 와의 만남이 있던 날 영어 회화의 필요성을 느꼈고, [[2023-09-25]] 에 강남 YBM 으로 영어 회화 레벨테스트를 보러 갔다. 나 혼자였다면 아마 마음 속으로만 생각하고 안 했을텐데 같이 하는 사람이 있어서 훨씬 더 적극적으로 도전해 볼 수 있었다. 정말 감사한 일이다 😄\n\n## 영어 공부\n\n영어 회화 공부는 당연히 어려울 거라 생각했지만 생각던 것보다 더 쉽지 않았다. 나는 강남 YBM 1:1 영어 회화 수업을 들었는데, 첫 날 레벨 테스트 날에는 정말 쓰레기 같이 말했다. 영어로 말해본 적이 있어야 뭐가 자연스러운지 아는데, 머릿속이 그냥 새하얬다.  \n링글이라는 화상 영어 수업도 신청해서 들었다. 아이비리그 대학생들, 졸업생들과 40분동안 주제 하나를 가지고 영어로 이야기하는 형식이다. 첫 수업 때는 너무 긴장하기도 했고 잘 안 들려서 정말 횡설수설 하기만 했던 것 같다.  \n\n그냥 처음부터 못하는 입장이니, 중간에는 포기하고 싶은 생각이 들기도 했다. 그런데 지금 포기해버리면 나는 평생 영어 회화 연습은 죽어도 안 할 것 같았다.  \n그렇게 포기하지는 않았지만, 자신감이 없는 나날들이 지나갔다. 난 정말 영어를 못한다는 생각도 했다. \n\n꾸역꾸역 수업을 나가던 중에, 영어 회화 선생님인 Shelby 가 이런 말을 했다.  \n\n> 한국어를 영어로 바꾸는 연습을 머릿속으로 계속하다보면 실력이 나아진다. 내가 한국어를 배울 때 많이 썼던 방법이다. \n\n사실 회화 연습의 가장 큰 문제점은 영어를 일상에서 쓸 일이 전혀 없다는 것이었다. 그러다보니 당연히 영어는 많이 늘지 않았고, 똑같은 실수를 계속할 수 밖에 없었다. 내 기억력이 안 좋은 것도 한 몫 했다.   \n그리고 어려운 단어를 외우는 한국 영어 공부 특성 상, 내가 자주 쓰는 문장을 어떻게 말하는지 몰랐다. 지하철에서 자주 쓰는 문장인 ‘우리 지금 내려야 해’ 도 영어로 어떻게 말하는지 모른다고 생각하니 망치로 머리를 한 대 맞은 듯 했다. \n당연하다. 내가 자주 사용하는 말도 제대로 못하면서 내가 알고 있는 말을 뭐라도 말해야 하는 면접을 어떻게 보겠는가?\n\n그 날부터 지하철에서 계속 ‘이 문장은 영어로 뭘까?’, ‘이런 뜻은 어떻게 말해야 할까?’ 를 계속해서 생각하고 번역해보기 시작했다. 처음에는 단어가 하나도 생각나지 않았고, 당연히 떠오르지 않는 문장도 많았지만 매일 그러다보니 훨씬 실력이 나아지는 게 느껴졌다.  \n이전에는 한 마디도 제대로 하는 문장이 없었는데, 이 연습을 하고 나서 정확한 표현은 아니더라도 내가 생각하는 문장을 전달할 수는 있는 정도로 영어 실력이 향상된 것을 느꼈다. 이 글을 보시는 여러분들에게도 문장을 만드는 연습이 많이 도움이 된다는 걸 전해드리고 싶다. 나만큼 영어로 말을 못하는 사람은 없었을 거다. 진짜로…\n\n## 지원서 작성\n\n우테코의 배민 설명회가 있던 날, DH 설명회도 같이 열렸다.  \nDH 는 경험 삼아 제출해보는 것이었고, 나는 원래부터 학교를 졸업할 생각이었기 때문에 배민에 지원하지 않았다.  \n\n그 날 들어본 내용은 충격 그 자체였다.  \n가장 처음으로 놀랐던 건 ‘연봉을 저렇게 많이 준다고?’ 라는 생각이었다.  \n베를린으로 이주할 때는 Relocation Fee 까지 준다니, 뭔가 다른 세계를 보는 느낌이었다.  \n\n그렇지만 그 중에서도 가장 당황스러웠던 건 영어였다.  \n각기 다른 나라에서 오신 분들이 각자 이야기를 하는데, 특정 지방 악센트가 섞인 영어는 전혀 알아들을 수 없었다. 정말 큰일났다고 생각했다 ㅋㅋㅋ\n\n그래도 이때는 애써 마음을 가볍게 먹으려고 했다.  \n\nDelivery Hero 에 지원하기 위해서는 꽤나 적어야 하는 게 많았다. Resume, Portfolio, Recommendation Letter 까지…   \n\n영어로 Resume 를 쓰는 건 한글로 쓰는 것보다 몇 배는 어려웠다. 게다가 한국 이력서와 형식, 스타일이 달라서 고생을 했다. 한글로 이력서를 먼저 적고 나서 GPT 와 함께 번역을 다듬는 과정을 수도없이 하고, 이제는 진짜 못 고치겠다 싶을 때 제출했다.  \n같이 지원했던 에코, 포이가 피드백도 자주 해주고 고치면 좋을 방향에 대해 말해줘서 더 수월하게 고칠 수 있었다. 고맙습니다 다들 💙\n\n특히 Recommendation Letter 가 문제였다. 나는 코로나 학번이라 교수님들과도 친하지 않았고, 아는 사람들도 없었다. 아예 내지 말까는 생각도 했지만, Shelby 가 Recommendation Letter 는 생각보다 매우 중요하다고 해서 회사에 다니고 있던 우현 선배한테 Recommendation Letter 를 부탁했다. 동아리 2개를 같이 운영했던 적이 있던 분이라 업무 상의 나에 대해 가장 잘 아는 사람이라고 생각했다.  \n솔직히 어떤 말이 써져있어도 감사했을 것 같은데 너무나도 잘 써줘서 합격한 일등공신은 선배가 아닌가 싶다. 쉽지 않은 부탁이었을 텐데 정말 감사했습니다 🥹 \n\n나도 나중에 후배들한테 이렇게 도움을 줄 수 있는 사람이면 좋겠다고 생각했다. \n\n## 1차 면접\n\n1차 면접은 코딩 테스트라고 해서 많이 긴장했다. 포이, 에코, 제나, 키아라, 콩하나와 함께 코딩 테스트를 준비했다. \n\n면접 준비 스터디 형식도 여러 번 바뀌었다. 처음에는 Mock Interview 를 보고 1:1 로 교대로 인터뷰어와 인터뷰이를 하면서 연습을 했지만, 효율이 좋지 않아서 MIT Algorithm 강좌를 잠깐 봤다. 그러나 그 방법도 내가 영어가 부족하니 내 공부 & 다른 사람들의 공부에 크게 도움이 되는 것 같지 않았다. 결국 어느 정도 알고리즘 실력은 있으니 매일 백준 문제를 하나씩 풀고, 영어로 말하는 연습을 더 하기로 했다. \n\n3개월 회화 공부를 했다고 말하기 실력이 드라마틱하게 늘지는 않는다. (당연함)  \n그나마 내가 알고 있는 단어 몇 개를 더 조합할 수 있게 되었고, 자주 쓰는 문장은 이전보다 잘 말할 수 있게 된 정도였다.  \n당연히, 당연히 너무 불안했다. 나는 준비가 잘 안 된 상황을 잘 인내하지 못하는 편이다. ‘도망가고 싶다’ 는 생각을 수도 없이 했다.  \n\n그러나 난 도망가지 않았다. 두려움과 어려움에 직면하고, 나를 도전에 내던졌다. \n이 천금같은 기회에서 도망가지 않은 것은 최고의 선택이었다고 생각한다.  \n\n---\n\n첫 면접일에는 면접관의 노트북 문제로 일정이 미뤄졌는데, 그 때 왜인지 모르게 눈물이 났다. 당시에는 화가 나서 그랬나 싶었는데, 지금 생각해보면 안도 + 긴장 풀림의 눈물이었던 듯하다.  \n\n다른 사람들에게 면접 후기를 들어보니 프로젝트 관련 질문을 한다기에 답변을 준비해갔는데, 정말로 프로젝트 관련 질문을 하셨다!   \n지금 기억나는 질문들은 다음과 같다.  \n\n- 어떤 프로젝트를 만드셨나요?\n- 프로젝트의 구조를 설명해보세요.\n- 왜 MySQL 을 사용하셨나요?\n- 서비스의 테이블 구조를 설명해보세요.\n\n1차 면접 문제는 두 문자열을 주고, A 문자열을 재배열했을 때 B 문자열이 될 수 있으면 True, 아니면 False 를 리턴하라는 문제가 나왔다.  \n문제는 생각했던 것보다 쉬워서 `Map` 으로 쉽게 풀 수 있었는데, 그 뒤로 optimize 하는 과정에서 조금 당황했다. 대소문자가 섞여 있는 상황에서도 가능한 지 여쭤보셨는데, 전체 문자열을 LowerCase 로 만드는 메서드를 잊어버려서 ASCII 코드로 접근했는데 제대로 안 되었다. 다행히 면접관 분이 `toLowerCase()` 메서드를 사용하라고 힌트를 주셔서 무사히 문제를 풀이할 수 있었다.  \n\n이때 느꼈던 문제점은 영어가 잘 안 들렸다는 점이다. (영원히 고통받는 영어 실력)  \n질문을 잘 못 듣고 동문서답한 내용이 많아서 당연히 떨어질 거라고 생각했는데, 2차 면접을 보게 해주셔서 감사했다!!!\n\n## 2차 면접\n\n2차 면접에서는 전반적으로 프로젝트에 대해 더 많이 물어볼 것 같아서 그 부분 위주로 준비했다. 준비한 질문과 답변들은 [[dh-second-interview-preparation|여기]]에 있다.  \n\n그런데 막상 2차 면접에 들어가니 Java 에 대해 물어보셔서 조금 당황스러웠다.  \n기억나는 질문들은 다음과 같다.  \n전반적으로 내 Resume 에 적은 내용을 기반으로 물어보셨다. \n\n- Spring 을 사용한 이유에 대해 설명해주세요.\n- Java Collection 에 대해 설명해주세요.\n- List 와 Set 의 차이점에 대해 말해주세요.\n- List, Set 과 Map 의 차이점에 대해 말해주세요. \n- 서비스를 간단하게 소개해주세요. \n- 서비스를 운영하면서 겪었던 가장 challenging 한 문제는 무엇이었나요?\n\t- Scalability 를 어떻게 고려할 수 있을까요?\n\t- 동시성 문제는 어떻게 해결했나요?\n- 팀 내부에서 맡았던 역할은 무엇이었나요?\n- VPC, NAT 에 대해 설명해주세요.\n- Java 를 제외한 다른 언어 써볼 생각 있으신가요?\n\n면접 분위기는 매우 좋았고, 내 긴장을 풀어주시기 위해 도와주시려는 모습이 보였다.  \n그때 당시 조금 불안했던 것은 총 1시간이었던 면접 시간 중에 30분 동안만 기술 면접을 보았고, 15분 동안은 그냥 내가 인터뷰어에게 질문하는 시간을 가졌다는 것이다. 불안해서 혹시 면접 피드백을 줄 수 있냐고 여쭤봤는데, 모든 질문에 잘 대답했고 더 이상 물어볼 질문이 없어서 여기서 마무리한다는 답변을 받았다. 지금 생각해보면 긍정적인 시그널이 많았던 것 같다. \n\n## 합격\n\n2차 면접을 보고 나니 아무것도 손에 안 잡혔다. 무엇을 해야 할 지도 모르겠고, 결과가 어떻게 나올 지 몰라 인턴 서류만 접수했는데 그마저도 다 떨어졌다. 그렇게 지옥같은 일주일이 지나고, Offer Letter 를 받았다! \n\n학교를 조기졸업 한다면 9월에 졸업할 수 있는데, Delivery Hero 에서 그때까지 기다려줄 수 있다고 해서 9월에 온보딩을 할 예정이다 :) 너무 즐거울 것 같고 새로운 환경이라니 벌써 두근거린다.  \n무엇보다 영어 실력을 빠르게 늘릴 수 있는 환경이니 내가 훨씬 더 많이 성장하지 않을까 싶다.  \nDelivery Hero 에서 어떤 경험을 하게 될 지, 어떤 일을 하고 내가 얼마나 성장할 지 기대된다.  \n\n나는 아직 목표가 없다. 열심히 찾는 중이지만, 아직 내가 뭘 하며 살아야 하고, 무엇을 위해 살아야 하는지 아직 모른다.  \n그렇지만 이제 하나는 배웠다. 나를 최대한 새로운 환경에 노출시키고, 많은 걸 경험하며 내가 좋아하는 것, 싫어하는 것을 알아가는 것이다.  \n절대 빠르게 포기하지 말자. 지금 아무것도 못한다고 해서 앞으로도 아무것도 못하는 건 아니다. 그러나 지금부터 아무것도 하지 않는다면 나는 앞으로 아무것도 못할 것이다.  \n\n항상 이 생각을 명심하며 살아가야겠다.  "},{"excerpt":"School 2024년 1학기를 마친 뒤 조기졸업한다. 과목 전공 15학점, 교양 5학점 → 20학점 캡스톤디자인(2) 멀티코어컴퓨팅 데이터베이스시스템 네트워크응용설계 인간과 컴퓨터 상호작용 디지털시대의공감 SPEECH IN ENGLISH 졸업 한자 4급 학부 연구생 TOPCIT 지도교수 상담 4회 졸업 요건 충족 여부 전공학점 84학점, 전공주제 60학…","fields":{"slug":"/berlin-relocation-plan/"},"frontmatter":{"date":"2023년 12월 21일 03:12","title":"베를린 이주 계획","tags":null},"rawMarkdownBody":"\n## School\n\n2024년 1학기를 마친 뒤 조기졸업한다.\n\n### 과목\n\n전공 15학점, 교양 5학점 → 20학점\n\n- 캡스톤디자인(2)\n- 멀티코어컴퓨팅\n- 데이터베이스시스템\n- 네트워크응용설계\n- 인간과 컴퓨터 상호작용\n- 디지털시대의공감\n- SPEECH IN ENGLISH\n\n### 졸업\n\n- 한자 4급\n- 학부 연구생\n- TOPCIT \n- 지도교수 상담 4회\n\n#### 졸업 요건 충족 여부\n\n전공학점 84학점, 전공주제 60학점\n\n1. ~~코딩부트캠프 교과목 통과~~\n2. 영어교과목 2과목 필수 이수\n3. ~~학부 연구생 활동을 수행한다.~~\n4. TOPCIT 시험 응시\n5. ~~오픈소스개발자 커뮤니티에 1건 이상 개방~~\n6. ~~전공 영어강좌 3과목 이상 이수~~\n\n#### 전공학점\n\n- 전공 기초\n\t- 일반물리(1)\n\t- 일반물리실험(1)\n\t- 미적분학\n\t- 기초컴퓨터프로그래밍\n- 전공 / 전공 주제\n\t- 창의적설계\n\n## 독일 이주 준비\n\n- 집 구하기\n- 비자 서류 준비\n- 영어 공부\n- 독일어 공부\n\n### Residence\n\nDelivery Hero: Oranienburger Str. 70\n\n#### Places where I will live\n\n- Märkisches Viertel\n- Wilhelmsruh\n- Wittenau\n\n## 한국에서 준비할 것\n\n- 운전면허\n- 건강검진\n- 집 계약 해지\n- 휴대폰 요금제 변경 및 eSIM 알아보기\n\n## Visa\n\n### 테어민\n\n- 취소표는 7시에 열리고, 정규표는 8시에 열린다. \n- 1달 전부터 신청 가능\n\n### 취업 비자\n\n#### 서류\n\n- 완벽하게 기재 및 서명이 된 **비자신청서 2부 [online](http://videx-national.diplo.de/videx/visum-erfassung/#/videx-langfristiger-aufenthalt)**\n- 유효한 여권 (인적사항이 기재된 페이지 사본 **2부** 첨부)\n- 최신 여권사진 2매 (3,5 x 4,5 cm, 밝은 배경으로, 6개월 이내촬영)\n- 경우에 따라 유효한 한국 **외국인등록증**\n- 독일 고용주의 **근로계약서** 사본 2부 (계약서가 있는 경우)\n- 고용주가 작성한 “[Erklärung zum Beschäftigungsverhältnis](https://seoul.diplo.de/blob/2455342/b708bfc238eb07c230d2c3e73fd24784/erklaerung-zum-beschaeftigungsverhaeltnis-data.pdf \"Erklärung zum Beschäftigungsverhältnis\")\" (고용관계에 관한 확인서) 원본 및 사본 2부 (회사 직인이 찍혀있어야 함); 해외파견인 경우, 추가적으로 [해당 첨부파일](https://seoul.diplo.de/blob/2455344/cb6c1483bf3e4447565ed838ae896faa/feg-ah-anlage-10-data.pdf \"FEG AH Anlage 10\")을 작성해 주십시오.\n- 학력/경력 증명서 (대학졸업, 연수, 경력 등) **2부**\n- 이력서 **2부**\n- 독일 고용인측의 초청장 **원본1부, 사본 1부**  (회사 주소 및 담당자 기재)\n\n**주의사항**  \n\n- 비자 수속은 일반적으로 **4-6 주** 정도 소요되지만 개별적인 경우에 따라 더 짧거나 길 수도 있습니다. 이를 참고하여 서류신청을 미리 하도록 한다.  \n- 비자신청 수수료는 75유로이며, 신청 시 이를 원화(당일 환율)로 지불해야 한다. (비자, 마스터 - 신용카드 결제시 유로화로 결제됨)  비자 발급이 거부당하거나 신청자가 신청을 취소하는 경우에도 수수료는 환급되지 않는다.  \n- 비자 발급은 주한독일대사관 영사과에서 독일의 관할 외국인청, 독일연방노동청과 함께 이를 검토한 후 발급 여부를 결정한다. 긍정적인 검토가 이루어진 경우, 대사관은 3개월 비자를 발급해주며, 입국 후 비자가 만료되기 전에 관할 외국인청에서 비자기간을 연장 하도록 한다.\n\n#### 독일 서류\n\n- 여권\n- 증명 사진\n- 계약서\n- 졸업증명서\n- 거주증명서\n- 어학증명서\n- 건강보험증명서\n- 비자신청서\n- 고용관계 선언\n\n#### 참고\n\n[주한독일대사관 취업 비자 안내](https://seoul.diplo.de/kr-ko/service/visa-einreise/-/1890394)\n\n### 가족 동반 비자\n\n아래의 서류를 본인이 직접 독일대사관 영사과에 제출하도록 한다.  \n동반 가족(남편/아내) 및 12세 이상 미성년자는 지문인식을 위해 직접 방문해야 한다.  \n\n- 완벽하게 기재 및 서명이 된 **비자신청서 2부 ([online](https://videx-national.diplo.de/videx/visum-erfassung/#/videx-langfristiger-aufenthalt \"VIDEX nationales Visum\") / [PDF](https://seoul.diplo.de/blob/1762268/f9342033f2933dc05da54151efe283db/visa-antrafgsformular-ko-data.pdf \"비자신청양식(다운로드)\"))**\n- 유효한 **여권** (인적사항이 기재된 페이지 사본 **2 부** 첨부)\n- 최신 **여권 사진 2매** (3.5 x 4.5 cm, 밝은 배경으로, 6개월 이내 촬영)\n- 자녀 동반 시 **가족관계증명서**, **기본증명서** / 배우자 동반 시 **혼인관계증명서**(원본과 독일어 번역본) * 원본에 [아포스티유](http://www.0404.go.kr/consulate/consul_apo.jsp \"외교부 해외안전여행 홈페이지 바로가기\") 확인 필요\n- 배우자가 독일에 거주하고 있는 경우: **가족의 여권 사본**. 독일 거주 가족이 독일 국적을 갖고 있지 않은 경우에는 **독일 체류허가서 사본**도 첨부.\n- 배우자가 독일인인 경우: **간단한 독일어 능력 증명서** (독일국적의 미성년 자녀 동반 시에는 불필요)\n* 경우에 따라서 다른 서류의 제출도 요구할 수 있다.\n\n**주의사항**  \n\n- 일반적으로 수속기간은 약 8주 소요된다. 이를 참고하여 서류 신청을 미리 하도록 한다.\n- 비자신청 수수료는 75유로이며, 신청 시 이를 원화(당일 환율)로 지불해야 한다. 비자 발급이 거부당하거나 신청자가 신청을 취소하는 경우에도 수수료는 환급되지 않는다. 독일이나 EU 국적자를 따라 독일로 가는 경우, 수수료는 면제된다.  \n- 비자 발급에 대해서는 주한독일대사관 영사과에서 독일의 관할 외국인청과 함께 이를 검토한 후 발급 여부를 결정한다.\n- 한국 국적자는 무비자로 독일에 입국할 수 있으며, 입국 후 3개월 이내에 외국인청에 체류 허가를 신청하면 된다. 입국 전에 관할 외국인청과 사전 연락을 취할 것을 권장한다.\n\n**!!!!무비자 입국 후, 독일에서 신청 가능하다!!!!**\n\n#### 자격 요건\n\n- 해당 외국인은 독일연방공화국에 영주권 또는 체류권을 갖고 있어야 한다.\n- 충분한 주거 공간을 갖고 있어야 한다.\n- 생계보장이 확실해야 한다.\n\n한국인의 경우, 독일어 능력을 반드시 증명하지 않아도 된다. [참고](https://seoul.diplo.de/kr-ko/service/visa-einreise/-/2102278?openAccordionId=item-2102284-2-panel)\n#### 참고\n\n[주한독일대사관 가족 동반 비자 안내](https://seoul.diplo.de/kr-ko/service/visa-einreise/-/1890408)\n\n### 블루 카드\n\n- 독일 대학 및 이에 준하는 인증된 외국대학 졸업자\n- 독일 내 기업에서 이미 확실한 일자리가 정해져 있음 (고용계약서 및 구속력 있는 채용 허가가 있어야 함)\n- 해당 일자리가 신청자의 능력(대학 전공)과 일치함\n- IT 최소 연봉 조건 39,411 유로 (23.11 기준)\n\n### 순서\n\n- 한국에서 취업 비자 3개월 발급\n- 독일로 출국\n- 거주지 등록\n- 은행 계좌 등록\n- 세금 번호 발급\n- 블루 카드 발급\n\n### 참고\n\n- [독일 베를린 취업 - 비자준비부터 집구하기까지](https://yippeee.tistory.com/82?category=1103580)"},{"excerpt":"트랜스포트 계층 서비스 및 개요 트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신을 제공한다. 논리적 통신은 애플리케이션의 관점에서 보면 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보인다는 것을 의미한다. 트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다. 송신 측의 트랜스포…","fields":{"slug":"/top-down-approach-ch3/"},"frontmatter":{"date":"2023년 12월 14일 14:12","title":"3. 트랜스포트 계층","tags":["컴퓨터-네트워킹-하향식-접근"]},"rawMarkdownBody":"\n## 트랜스포트 계층 서비스 및 개요\n\n트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 **논리적 통신**을 제공한다. 논리적 통신은 애플리케이션의 관점에서 보면 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보인다는 것을 의미한다.  \n\n트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다. 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지를 **트랜스포트 계층 세그먼트** 라고 알려진 트랜스포트 계층 패킷으로 변환한다. \n트랜스포트 계층은 송신 종단 시스템에 있는 네트워크 계층으로 세그먼트를 전달하고, 여기서 세그먼트가 네트워크 계층 패킷 안에 캡슐화되어 목적지로 전달된다.  \n\n네트워크 라우터는 오로지 데이터그램의 네트워크 계층 필드에 대해 동작한다는 것을 유념해야 한다. (즉, 라우터는 데이터그램 안에 캡슐화된 트랜스포트 계층 세그먼트의 필드를 검사하지 않는다.)\n\n네트워크 애플리케이션에는 하나 이상의 트랜스포트 계층 프로토콜을 사용할 수 있다. 이러한 프로토콜은 서비스를 요청하는 애플리케이션에게 트랜스포트 계층에서 각기 다른 서비스 집합을 제공한다. \n\n### 트랜스포트 계층과 네트워크 계층 사이의 관계\n\n트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 *프로세스*들 사이의 논리적 통신을 제공하지만, 네트워크 계층 프로토콜은 *호스트들*사이의 논리적 통신을 제공한다. \n\n트랜스포트 계층 프로토콜들은 종단 시스템에 존재한다. 종단 시스템 안에서 트랜스포트 프로토콜은 애플리케이션 프로세스에서 네트워크 경계까지 메시지를 운반하며, 반대 방향으로 네트워크 계층에서 애플리케이션 프로세스로 메시지를 운반한다. 그러나 트랜스포트 프로토콜은 메시지가 네트워크 계층 내부에서 어떻게 이동하는지는 언급하지 않는다.  \n\n컴퓨터 네트워크는 애플리케이션에서 서로 다른 서비스를 제공하도록 하는 개별 프로토콜을 갖는 다양한 트랜스포트 프로토콜을 만들 수 있게 한다. \n\n트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토콜의 서비스 모델에 의해 제약받는다. 네트워크 계층 프로토콜이 호스트 사이에서 전송되는 트랜스포트 계층 세그먼트에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메시지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다. \n\n하위 네트워크 프로토콜이 상응하는 서비스를 제공하지 못할 때도, 특정 서비스는 트랜스포트 프로토콜에 의해 제공될 수 있다. 트랜스포트 프로토콜은 네트워크 계층을 트랜스포트 계층 세그먼트의 기밀성을 보장할 수 없을 때도 침입자가 애플리케이션 메시지를 읽지 못하도록 암호화를 사용할 수 있다. \n\n### 인터넷 트랜스포트 계층의 개요\n\n인터넷은 애플리케이션 계층에게 두 가지 구별되는 트랜스포트 계층 프로토콜을 제공한다. 하나는 비신뢰적이고 비연결형인 서비스를 요청한 애플리케이션에게 제공하는 **UDP(User Datagram Protocol)** 이고, 다른 하나는 신뢰적이고 연결지향형 서비스를 요청한 애플리케이션에게 제공하는 **TCP(Transmission Control Protocol)** 다. 네트워크 애플리케이션을 설계할 때 애플리케이션 개발자는 이 두 가지 트랜스포트 프로토콜 중 하나를 명시해야 한다. \n\n인터넷에서 트랜스포트 계층 패킷을 **세그먼트**라고 한다. 그러나 인터넷 문서에서는 TCP 에 대한 트랜스포트 계층 패킷을 세그먼트로 나타내면서, UDP에 대한 패킷을 데이터그램으로 표현하기도 한다. \n\n인터넷의 네트워크 계층 프로토콜은 인터넷 프로토콜 (Internet Protocol, IP) 이라는 이름을 갖는다. IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 **최선형 전달 서비스**이다. 이것은 IP 가 통신하는 호스트들 간에 세그먼트를 전달하기 위해 최대한 노력하지만, 어떠한 보장도 하지 않는 것을 의미한다. 특히, IP 는 세그먼트의 전달을 보장하지 않고 세그먼트가 순서대로 전달되는 것을 보장하지 않는다. 또한 IP 는 세그먼트 내부 데이터의 무결성을 보장하지 않는다. 이러한 이유로 IP 를 **비신뢰적인 서비스** 라고 부른다. 또한 모든 호스트가 적어도 하나의 IP 주소로 불리는 네트워크 계층 주소를 갖는다. \n\nUDP와 TCP의 가장 기본적인 기능은 종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다. 호스트 대 호스트 전달을 프로세스 대 프로세스 전달로 확장하는 것을 **트랜스포트 계층 다중화**와 **역다중화**라고 부른다. UDP와 TCP는 헤더에 오류 검출 필드를 포함함으로써 무결성 검사를 제공한다. 이러한 최소한의 두 가지 트랜스포트 계층 서비스 (프로세스 대 프로세스 데이터 전달과 오류 검출)가 UDP가 제공하는 유일한 두 가지 서비스다. 여기서 UDP는 IP와 마찬가지로 비신뢰적인 서비스다. UDP는 하나의 프로세스에 의해 전송된 데이터가 손상되지 않고 목적지 프로세스에 도착한다는 것을 보장하지 않는다. \n\n반면, TCP는 애플리케이션에 몇 가지 추가적인 서비스를 제공한다. 가장 먼저 TCP는 **신뢰적인 데이터 전송**을 제공한다. 흐름 제어, 순서 번호, 확인 응답, 타이머를 사용함으로써 TCP는 송신하는 프로세스로부터 수신하는 프로세스에게 데이터가 순서대로 정확하게 전달되도록 확실하게 한다. 이처럼 TCP는 종단 시스템 간에 IP의 비신뢰적인 서비스를 프로세스 사이의 신뢰적인 데이터 전송 서비스로 만들어준다. 또한 TCP는 **혼잡 제어**를 사용한다. 혼잡 제어는 인터넷에 대한 통상적인 서비스처럼 야기한 애플리케이션에게 제공되는 특정 서비스가 아니라, 전체를 위한 일반 서비스다. 즉, 한 TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 혼잡하게 하는 것을 방지하는 것이 TCP 혼잡 제어다. TCP는 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하도록 해준다. 이것은 송신 측의 TCP가 네트워크에 보낼 수 있는 트래픽을 조절함으로써 수행된다. 반면, UDP 트래픽은 조절되지 않는다. UDP 트랜스포트 프로토콜을 사용하는 애플리케이션은 허용이 되는 한 그것이 만족하는 어떤 속도로든 전송할 수 있다. \n\n## 다중화와 역다중화\n\n네트워크 계층이 제공하는 호스트 대 호스트 전달 서비스에서 호스트에서 동작하는 애플리케이션에 대한 프로세스 대 프로세스 전달 서비스로 확장하는 것을 살펴본다.  \n\n목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신한다. 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 진다. 컴퓨터의 트랜스포트 계층이 하위의 네트워크 계층으로부터 데이터를 수신할 때, 트랜스포트 계층은 프로세스 중 하나에게 수신한 데이터를 전달할 필요가 있다.  \n\n먼저, 네트워크 애플리케이션의 한 부분으로서 프로세스는 **소켓**을 갖고 있다. 이를 통해 네트워크에서 프로세스로 데이터를 전달하고, 또한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 한다. 그러므로 수신 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않고, 중간 매개자인 소켓에게 전달한다. 어떤 주어진 시간에 수신 측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 하나의 유일한 식별자를 갖는다. 식별자의 포맷은 UDP, TCP 소켓인지에 따라 달라진다. \n\n수신측 호스트가 수신한 트랜스포트 계층 세그먼트를 어떻게 적절한 소켓으로 향하게 하는지를 생각해보자. 각각의 트랜스포트 계층 세그먼트는 이러한 목적을 위해 세그먼트에 필드 집합을 갖고 있다. 수신 측의 트랜스포트 계층은 수신 소켓을 식별하기 위해 이러한 필드를 검사한다. 그리고 이 세그먼트를 해당 소켓으로 보낸다. 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 **역다중화(demultiplexing)** 이라고 한다. 출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 **다중화(multiplexing)** 이라고 한다. \n\n![[transport-multiplexing.jpeg]]\n\n중간 호스트의 트랜스포트 계층은 네트워크 계층 아래로부터 수신한 세그먼트를 위쪽의 프로세스 $P_1$ 또는 $P_2$ 로 반드시 역다중화해야 한다. 이는 도착한 세그먼트의 데이터가 이에 상응하는 프로세스의 소켓으로 전달되도록 해서 이루어진다.  \n또한 중간 호스트의 트랜스포트 계층은 프로세스의 소켓으로부터 외부로 나가는 데이터를 모으고, 다음에 트랜스포트 계층 세그먼트들로 만들고, 이 세그먼트들을 아래 네트워크 계층으로 전달해야만 한다.  \n\n트랜스포트 계층 다중화에는 다음 두 가지 요구사항이 있다.  \n1. 소켓은 유일한 식별자를 갖는다. \n2. 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다. \n\n이 특별한 필드라는 것은 **출발지 포트 번호 필드 (source port number field)** 와 **목적지 포트 번호 필드 (destination port number field)** 이다. 각각의 포트 번호는 0~65535까지의 16비트 정수다. 그중에서 0~1023까지의 포트 번호를 **잘 알려진 포트 번호 (well-known port number)** 라고 하여 사용을 엄격하게 제한하고 있다. 새 애플리케이션을 개발할 때는 애플리케이션에 포트 번호를 반드시 할당해야 한다. \n\n호스트의 각 소켓은 포트 번호를 할당 받으며, 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하고 상응하는 소켓으로 세그먼트를 보내게 된다. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다. 이것은 UDP의 기본적인 동작 방식이며 TCP의 다중화/역다중화는 좀 더 많은 의미를 갖고 있다. \n\n#### 비연결형 다중화와 역다중화\n\nPython 에서는 다음과 같이 UDP 소켓을 생성할 수 있다.\n\n```python\nclientSocket = socket(AF_INET, SOCK_DGRAM)\n```\n\n이 방법으로 UDP 소켓이 생성될 때 트랜스포트 계층은 포트 번호를 소켓에게 자동으로 할당한다. 특히 트랜스포트 계층은 현재 호스트에서 UDP 포트로 사용하지 않는 1024~65535 사이의 포트 번호를 할당한다. 다른 방법으로는 우리가 소켓을 생성한 뒤에, 소켓 `bind()` 방식을 사용하여 특정 포트 번호를 UDP 소켓에 할당하기 위해 다음과 같이 작성할 수 있다. \n\n```python\nclientSocket.bind(('', 19157))\n```\n\n만약 코드를 작성하는 애플리케이션 개발자가 ‘잘 알려진 프로토콜’ 의 서버 측을 구현하고 있다면, 개발자는 상응하는 ‘잘 알려진 포트 번호’를 할당해야만 한다. 일반적으로 애플리케이션의 서버 측이 특정 포트 번호를 할당하는 것에 반해, 애플리케이션의 클라이언트 측은 트랜스포트 계층이 포트 번호를 자동으로 할당한다. \n\nUDP 소켓으로 할당된 포트 번호로 UDP 다중화/역다중화는 다음과 같다.  \nUDP 소켓 19157 을 가진 호스트 A의 프로세스가 호스트 B의 UDP 소켓 46428을 가진 프로세스에게 애플리케이션 데이터 전송을 원한다고 가정하자. 호스트 A의 트랜스포트 계층은 애플리케이션 데이터, 출발지 포트 번호(19157), 목적지 포트 번호(46428), 그리고 2개의 다른 값을 포함하는 트랜스포트 계층 세그먼트를 생성한다. 트랜스포트 계층은 만들어진 세그먼트를 네트워크 계층으로 전달한다. 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하고 최선형 전달 서비스로 세그먼트를 수신 호스트로 전달한다. 세그먼트가 수신 호스트 B에 도착하면, 수신 호스트는 세그먼트 안의 목적지 포트 번호 (46428)을 검사하고 그 세그먼트를 포트 46428로 식별되는 소켓에 전달한다. 네트워크로부터 UDP 세그먼트들이 도착하면, 호스트 B는 세그먼트의 목적지 포트를 검사하여 세그먼트를 적절한 소켓으로 보낸다. (역다중화)\n\n출발지 IP 주소와 출발지 포트 번호가 모두 다르거나 출발지 IP 주소와 출발지 포트 번호 중 어느 하나가 다를지라도, 같은 목적지 IP 주소와 목적지 포트 번호를 가지면 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다. \n\n```ad-question\n왜 UDP 는 출발지 IP 주소와 출발지 포트 번호로 호스트를 식별하지 않을까?\n\n(GPT 답변)\nUDP (User Datagram Protocol)는 인터넷 프로토콜 스위트의 핵심 멤버 중 하나로, 주로 간단하고 낮은 지연시간을 요구하는 애플리케이션에서 사용됩니다. UDP가 출발지 IP 주소와 출발지 포트 번호로 호스트를 식별하지 않는 것이 아니라, UDP는 이러한 정보를 포함하지만, 연결 상태를 유지하거나 세션을 관리하지 않는 비연결형 프로토콜입니다. 이로 인해 UDP의 특성과 사용 사례가 결정됩니다:\n\n1. **비연결성**: UDP는 연결을 설정하거나 종료하는 과정이 없습니다. 각 UDP 데이터그램은 독립적으로 처리되며, 이전 또는 이후의 데이터그램과 연관되지 않습니다. 이것은 네트워크 오버헤드를 줄여주고 데이터 전송 속도를 높입니다.\n    \n2. **상태 비저장**: UDP는 상태나 세션 정보를 유지하지 않습니다. 따라서 UDP는 각 데이터그램이 독립적으로 송수신되는 특성을 가집니다. 이는 서버가 동시에 많은 클라이언트와 통신할 때 유리합니다.\n    \n3. **간소화된 오류 처리**: UDP는 패킷 손실, 순서 변경, 중복 패킷 등에 대해 복구하지 않습니다. 오류 복구 및 순서 보장은 애플리케이션 레벨에서 처리됩니다. 이것은 리소스를 적게 소모하지만, 신뢰성이 중요한 애플리케이션에는 적합하지 않을 수 있습니다.\n    \n4. **비신뢰성과 단순성**: UDP는 패킷을 보낸 후 수신 여부를 확인하지 않으며, 데이터 전송에 대한 확인 응답(ACK) 또한 없습니다. 이로 인해 구현이 간단하고, 실시간 스트리밍, 온라인 게임, DNS 조회와 같은 실시간 특성이 요구되는 애플리케이션에서 선호됩니다.\n    \n\nUDP는 출발지 IP 주소와 출발지 포트 번호를 사용하여 송신자를 식별할 수 있지만, TCP와 달리 이러한 정보를 기반으로 한 연결 상태를 유지하거나 관리하지 않습니다. 따라서 UDP는 효율적이고 빠른 데이터 전송을 제공하지만, 신뢰성과 데이터 순서 보장이 필요한 애플리케이션에는 적합하지 않을 수 있습니다.\n```\n\n출발지 포트 번호는 ‘회신 주소’ 의 한 부분으로 사용된다. 즉, B가 세그먼트를 다시 A에게 보내기를 원할 때, B에서 A로 가는 세그먼트의 목적지 포트 번호는 A로부터 B로 가는 세그먼트의 출발지 포트 번호로부터 가져온다. \n\n```ad-question\n포트 번호가 모두 할당되었을 때는 어떻게 할까?\n\n모든 포트 번호가 할당되었다는 것은 시스템에서 사용 가능한 UDP 포트가 모두 다른 프로세스나 서비스에 의해 사용 중이라는 것을 의미하므로, 이런 상황에서는 더 이상 새로운 소켓을 열 수 없다. 이러한 상황은 매우 드물지만, 이런 일이 발생하는 경우 다음과 같은 방법을 사용할 수 있다. \n\n1. 필요하지 않은 소켓이나 프로세스를 종료하여 포트를 해제한다. \n2. 특정 애플리케이션에서는 포트를 공유하거나 동적으로 포트를 할당받는 방식을 고려할 수도 있다. \n```\n\n```ad-question\n목적지의 포트 번호는 어떻게 알아낼 수 있을까?\n\n목적지가 서버인 경우, 서버에서 정의한 포트 번호로 세그먼트를 전달한다. nginx 같은 리버스 프록시 서버에서 포트 번호를 변경해줄 수도 있다. 반대로 서버가 데이터를 다시 돌려보낼 때는 처음에 보냈던 출발지 IP 와 출발지 포트 번호를 사용해서 데이터를 전달할 수 있을 것이다. \n```\n\n#### 연결지향형 다중화와 역다중화\n\nTCP 역다중화를 수행하기 위해서는 TCP 소켓과 TCP 연결 설정을 살펴봐야 한다 .TCP 소켓과 UDP 소켓의 다른 점은 TCP 소켓은 4개 요소의 집합, 즉, 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별된다는 것이다. 그러므로 네트워크로부터 호스트에 TCP 세그먼트가 도착하면, 호스트는 해당하는 소켓으로 세그먼트를 전달하기 위해 4개의 값을 모두 사용한다.  \n특히 UDP 와는 다르게, 다른 출발 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향하게 된다. \n\n- TCP 서버 애플리케이션은 ‘환영 소켓’ 을 갖고 있다. 이 소켓은 포트 번호 12000을 가진 TCP 클라이언트로부터 연결 설정 요청을 기다린다. \n- TCP 클라이언트는 다음과 같은 명령으로 소켓을 생성하고 연결 설정 요청 세그먼트를 보낸다. \n```python\nclientSocket = socket(AF_INET, SOCK_STREAM)\nclientSocket.connect((serverName, 12000))\n```\n- 연결 설정 요청은 목적지 포트 번호 12000과 TCP 헤더에 설정된 특별한 연결 설정 비트를 가진 TCP 세그먼트에 지나지 않는다. 또한 그 세그먼트는 출발지 포트 번호를 포함하는데, 이 출발지 포트 번호는 클라이언트가 선택한 번호다. \n- 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트 12000을 포함하는 연결 요청 세그먼트를 수신하면, 이 세그먼트를 포트 번호 12000으로 연결 수락을 기다리는 서버 프로세스로 보낸다. \n```python\nconnectionSocket, addr = serverSocket.accept()\n```\n- 서버는 연결 요청 세그먼트의 출발지 포트 번호, 출발지 호스트의 IP 주소, 세그먼트 안의 목적지 포트 번호, 목적지 IP 주소에 주목하고, 새롭게 생성된 연결 소켓은 이 값들로 식별된다. 그 다음에 도착하는 모든 세그먼트의 출발지 포트, 출발지 IP 주소, 목적지 포트, 목적지 IP 주소가 이 네 가지 값과 일치하면 세그먼트는 해당 소켓으로 역다중화될 것이다. \n\n서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다. 해당 소켓은 프로세스에 접속되어 있으며, 소켓은 4개 요소의 집합에 의해 식별된다. \n\n#### 웹 서버와 TCP\n\n아파치 웹 서버 같은 웹 서버가 포트 번호 80 상에서 동작하는 호스트를 고려해보자. 클라이언트가 서버로 세그먼트를 보내면, 모든 세그먼트는 목적지 포트 번호 80을 가지고 있을 것이다. 특히, 초기 연결 설정 세그먼트들과 HTTP 요청 메시지를 전달하는 모든 세그먼트는 목적지 포트 80을 가질 것이다. 앞에서 살펴본 것처럼, 서버는 각기 다른 클라이언트가 보낸 세그먼트를 출발지 IP 주소와 출발지 포트 번호로 구별한다.  \n\n웹 서버는 각각의 연결에 대해 새로운 프로세스를 만들고, 해당 프로세스들은 각자 연결 소켓을 가지며 이 연결 소켓을 통해 HTTP 요청을 수신하고, HTTP 응답을 전송한다.  \n그러나 연결 소켓과 프로세스 사이에 항상 1:1 대응이 이루어지는 것은 아니다. 실제로 오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다. 그러면서, 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드를 생성한다. 그런 웹 서버에서는 하나의 같은 프로세스에 붙어 있는 많은 연결 소켓들이 동시에 존재할 수도 있다. \n\n만약 클라이언트와 서버가 지속적인 HTTP 를 사용한다면, 지속적인 연결의 존속 기간에 클라이언트와 서버는 같은 서버 소켓을 통해 HTTP 메시지를 교환할 것이다. 그러나 만약 클라이언트와 서버가 비지속적인 HTTP를 사용한다면, 모든 요청/응답 마다 새로운 TCP 연결이 생성되고 종료될 것이다. 이 빈번하게 발생하는 소켓 생성과 종료는 웹 서버 성능에 심한 부담을 준다. \n\n## 비연결형 트랜스포트: UDP\n\nUDP 는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다. UDP 는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다. UDP 는 애플리케이션 프로세스로부터 메시지를 가져와서 다중화/역다중화 서비스에 대한 출발지 포트 번호 필드와 목적지 포트 번호 필드를 첨부하고 다른 두 필드를 추가한 후에 최종 세그먼트를 네트워크 계층으로 넘겨준다. 네트워크 계층은 트랜스포트 계층 세그먼트를 IP 데이터그램으로 캡슐화하고, 세그먼트를 수신 호스트에 전달하기 위해 최선을 다한다. 만약 세그먼트가 수신 호스트에 도착한다면, UDP 는 세그먼트의 데이터를 해당하는 애플리케이션 프로세스로 전달하기 위해 목적지 포트 번호를 사용한다. UDP 는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 핸드 셰이크를 사용하지 않는다. 이런 이유로 UDP 를 *비연결형* 이라고 한다. \n\nDNS 는 전형적으로 UDP 를 사용하는 애플리케이션 계층 프로토콜이다. 호스트의 DNS 애플리케이션이 질의를 생성할 때, DNS 질의 메시지를 작성하고 UDP에게 메시지를 넘겨준다. 목적지 종단 시스템 상에서 동작하는 UDP 개체와 호스트 측 UDP 는 어떠한 핸드셰이크도 수행하지 않고 메시지에 헤더 필드를 추가한 후에 최종 세그먼트를 네트워크 계층에 넘겨준다. 네트워크 계층은 UDP 세그먼트를 데이터그램으로 캡슐화하고 네임 서버에 데이터그램을 송신한다. 이때 질의 호스트에서의 DNS 애플리케이션은 질의에 대한 응답을 기다린다. 만약 질의 호스트가 응답을 수신하지 못하면, 질의를 다른 네임 서버로 송신하거나 이를 야기한 애플리케이션에게 응답을 수신할 수 없음을 통보한다.  \n\n많은 애플리케이션은 다음과 같은 이유로 UDP 에 더 적합하다. \n\n- 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어를 할 수 있다: 애플리케이션 프로세스가 데이터를 UDP 에 전달하자마자 UDP 는 데이터를 UDP 세그먼트로 만들고, 그 세그먼트를 즉시 네트워크 계층으로 전달한다. 이에 반해 TCP 는 혼잡 제어 메커니즘을 갖고 있다. 이 혼잡 제어 메커니즘은 목적지 호스트들과 출발지 호스트들 사이에서 하나 이상의 링크가 과도하게 혼잡해지면, 트랜스포트 계층 TCP 송신자를 제한한다. 또한 TCP 는 신뢰적인 전달이 얼마나 오래 걸리는지에 관계없이 목적지가 세그먼트의 수신 여부를 확인, 응답할 때까지 데이터의 세그먼트 재전송을 계속할 것이다. 실시간 애플리케이션은 최소 전송률을 요구할 때도 있고, 지나치게 지연되는 세그먼트 전송을 원하지 않으며, 조금의 데이터 손실은 허용할 수도 있으므로 TCP 의 서비스 모델은 이러한 애플리케이션의 요구와는 맞지 않는다. \n- 연결 설정이 없음: UDP 는 연결을 설정하기 위한 어떤 지연도 없다. \n- 연결 상태가 없음: UDP 는 연결 상태를 유지하지 않으며 파라미터 중 어떤 것도 기록하지 않는다. 이러한 이유로 일반적으로 특정 애플리케이션 전용 서버는 애플리케이션 프로그램이 TCP보다 UDP에서 동작할 때 일반적으로 좀 더 많은 액티브 클라이언트를 수용할 수 있다. \n- 작은 패킷 헤더 오버헤드: TCP 는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP 는 단지 8바이트의 오버헤드를 갖는다. \n\n### UDP 세그먼트 구조\n\n애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치한다. UDP 헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다. 포트 번호는 목적지 호스트가 목적지 종단 시스템에서 동작하는 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해준다. 체크섬은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용한다. 길이 필드는 헤더를 포함하는 UDP 세그먼트의 길이를 나타낸다. \n\n### UDP 체크섬\n\nUDP 체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때, UDP 세그먼트 안의 비트에 대한 변경 사항이 있는지 검사하는 것이다. 송신자는 체크섬 안에 있는 모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행하며, 합산 과정에서 발생하는 오버플로는 윤회식 자리 올림(wrap around)을 한다.  \n\n만약 패킷에 어떤 오류도 없다면 수신자에서의 합은 모든 자리가 1이 될 것이다. 비트 중에 하나라도 0이 있다면 패킷에 오류가 발생했음을 알 수 있다.  \n\nUDP 가 체크섬을 제공하는 이유는 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공한다는 보장이 없기 떄문이다. 그러므로 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수 있다. 주어진 링크 간의 신뢰성과 메모리의 오류 검사가 보장되지도 않고, 종단 간의 데이터 전송 서비스가 오류 검사를 제공해야 한다면, UDP 는 *종단 기반으로* 트랜스포트 계층에서 오류 검사를 제공해야만 한다. 이것이 시스템 설계에서의 **종단과 종단의 원칙 (end-end principle)** 이다. \n\nIP는 어떠한 2계층 프로토콜에서도 동작해야 하므로, 트랜스포트 계층은 안전장치로서 오류 검사를 제공하는 것이 유용하다. UDP 는 오류 검사를 제공하지만, 오류를 회복하기 위한 어떠한 일도 하지 않는다. \n\n## 신뢰적인 데이터 전송의 원리\n\n신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않는다. 그리고 모든 데이터는 전송된 순서 그대로 전달된다. 이것이 TCP가 인터넷 애플리케이션에게 제공하는 서비스 모델이다.  \n\n이러한 서비스 추상화를 구현하는 것이 **신뢰적인 데이터 전송 프로토콜 (reliable data transfer protocol)** 의 의무이다. 이 작업은 신뢰적인 전송 프로토콜의 아래에 있는 계층이 신뢰적이지 않을 수 있어서 어려워진다. \n\n여기서는 **단방향 데이터 전송** 의 경우인 송신 측으로부터 수신 측까지의 데이터 전송만을 고려한다. \n\n### 신뢰적인 데이터 전송 프로토콜의 구축\n\n#### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송: rdt1.0\n\n먼저, 하위 채널이 완전히 신뢰적인 가장 간단한 경우를 고려한다.  \n\n![[all-reliable-channel.jpeg]]\n\n이러한 간단한 프로토콜에서는 데이터 단위와 패킷의 차이점이 없다. 또한 모든 패킷의 흐름은 송신자로부터 수신자까지다. 즉, 완전히 신뢰적인 채널에서는 오류가 생길 수 없으므로 수신 측이 송신측에게 어떤 피드백도 제공할 필요가 없다. 또한 수신자는 송신자가 데이터를 송신하자마자 데이터를 수신할 수 있다고 가정했으므로 수신자가 송신자에게 천천히 보내라는 것을 요청할 필요가 없다. \n\n#### 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송: rdt2.0\n\n패킷 안의 비트들이 하위 채널에서 손상되는 모델이다. 전송된 모든 패킷이 송신된 순서대로 수신된다고 계속 가정한다. \n\n컴퓨터 네트워크 설정에서 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 **자동 재전송 요구 (Automatic Repeat reQuest, ARQ) 프로토콜** 로 알려져 있다. \n\n다음과 같은 세 가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다. \n\n- 오류 검출: 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능이 필요하다. \n- 수신자 피드백: rdt2.0 프로토콜은 수신자로부터 송신자 쪽으로 ACK 와 NAK 패킷들을 전송할 것이다. \n- 재전송: 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송된다. \n\n![[bit-error-channel.jpeg]]\n\n가장 왼쪽 상태에서 송신 측 프로토콜은 상위 계층에서 데이터가 전달되기를 기다린다. `rdt_send` 이벤트가 발생하면 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷을 생성하고, 패킷을 `udt_send` 로 전송할 것이다. 가장 오른쪽 상태에서 송신자 프로토콜은 수신자로부터의 ACK, NAK 패킷을 기다린다. ACK 패킷이 수신된다면 송신자는 가장 최근에 전송된 패킷이 정확하게 수신되었음을 알게 된다. NAK 가 수신되면 프로토콜은 마지막 패킷을 재전송하고 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK, NAK 를 기다린다. 송신자는 수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지 새로운 데이터를 전달하지 않을 것이다. 이러한 행동 때문에 rdt2.0과 같은 프로토콜은 **전송 후 대기 (stop-and-wait)** 프로토콜로 알려져 있다.  \n수신자 측 FSM 은 아직 단일 상태를 갖는다. \n\n프로토콜 rdt2.0은 잘 동작하는 것 같지만 실제로는 치명적인 결함이 있다.  \n==ACK, NAK 패킷이 손상되는 경우==는 어떻게 해야 할까? 최소한 그런 오류를 검출하기 위해 ACK, NAK 패킷에 대한 체크섬 비트를 추가할 필요가 있다. 더 어려운 점은 어떻게 프로토콜이 ACK 또는 NAK 패킷 오류로부터 복구되는가이다. ACK, NAK가 손상된다면 송신자는 수신자가 전송된 데이터의 마지막 부분을 올바르게 수신했는지를 알 방법이 없다.  \n\n다음과 같은 세 가지 가능성을 고려해보자.  \n\n1. 수신자의 응답을 이해하지 못했을 때를 위한 새로운 송신자-수신자 패킷을 도입한다.\n2. 송신자가 검출뿐만 아니라 비트 오류로부터 회복할 수 있도록 충분한 체크섬 비트들을 추가한다. \n3. 송신자가 왜곡된 ACK, NAK 패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신하는 것이다. 그러나 이 방식은 송신자에서 수신자 간의 채널로 중복 패킷을 전송하게 된다. 이 경우, 마지막으로 전송된 ACK, NAK가 송신자에게 정확히 수신되었는지를 알 수 없다. 그러므로 도착하는 패킷이 새로운 데이터를 포함하고 있는 것인지 재전송인지를 사전에 알 수 없다. \n\n이 문제의 간단한 해결책은 데이터 패킷에 새로운 필드를 추가하고 이 필드 안에 순서 번호를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙이는 것이다. 일반적으로 패킷을 손실하지 않는 채널을 가정하고 있으므로, ACK와 NAK 패킷 자체는 확인 중인 패킷의 순서 번호를 나타낼 필요는 없다. 송신자는 수신된 ACK와 NAK 패킷이 가장 최근에 전송된 데이터 패킷에 대한 응답으로 발생한 것임을 알 수 있다. \n\n![[bit-error-numbering-sender.jpeg]]\n\n![[bit-error-numbering-receiver.jpeg]]\n\n프로토콜 rdt2.1은 수신자로부터 송신자까지의 긍정 확인 응답과 부정 확인응답을 모두 포함한다. 순서가 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인응답을 전송한다. 손상된 패킷이 수신되면, 수신자는 부정 확인응답을 전송한다. NAK를 송신하는 것 대신에, 가장 최근에 정확하게 수신된 패킷에 대해 ACK를 송신함으로써 NAK 를 송신한 것과 같은 효과를 얻을 수 있다.  \n\n비트 오류를 갖는 채널을 위한 NAK 없는 신뢰적인 데이터 전송 프로토콜은 rdt2.2이다.  \nrtd2.1과 rtd2.2의 미묘한 차이는 수신자가 반드시 ACK 메시지에 의해 확인 응답되는 패킷의 순서 번호를 포함해야 한다는 점이다. 그리고 송신자는 수신된 ACK 메시지에 의해 확인응답된 패킷의 순서 번호를 반드시 검사해야만 한다. \n\n![[bit-error-absent-nak.jpeg]]\n\n#### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송: rdt3.0\n\n비트가 손상되는 것 외에도 인터넷을 포함하는 오늘날의 컴퓨터 네트워크처럼 하위 채널이 패킷을 손실하는 경우를 생각해보자.  \n\n1. 어떻게 패킷 손실을 검출할 것인가\n2. 패킷 손실이 발생했을 때 어떤 행동을 할 것인가\n\n패킷 손실을 다룰 때 여러 가지 접근이 가능하지만, 송신자에게 손실된 패킷의 검출과 회복 책임을 부여해보자.  \n송신자가 데이터 패킷을 전송하고 패킷 또는 수신자의 패킷에 대한 ACK 를 손실했다고 가정해보자. 만약 송신자가 패킷을 잃어버렸다고 확신할 정도의 충분한 시간을 기다릴 수만 있다면 데이터 패킷은 간단히 재전송될 수 있다.  \n\n그러나 송신자가 어떤 패킷을 손실했다는 것을 확신하기 위해 얼마나 오랫동안 기다려야 할까? 송신자는 적어도 송신자와 수신자 사이의 왕복 시간 지연에 수신 측에서 패킷을 처리하는 데 필요한 시간을 더한 만큼 기다린다. 많은 네트워크에서는 이 최악의 최대 지연 시간은 예측하기조차도 매우 어렵다. 실제 상황에서 채택한 접근 방식은 송신자가 패킷 손실이 일어났다는 보장은 없지만 손실이 일어났을 만한 그런 시간을 현명하게 선택하는 것이다.  \n만약 패킷이 유별나게 큰 지연을 갖는다면, 송신자는 비록 데이터 패킷이나 그 패킷에 대한 ACK가 손실되지 않았다고 하더라도 패킷을 재전송할 수 있다. 이것은 송신자 대 수신자 채널에서 중복 데이터 패킷의 가능성을 포함한다. \n\n시간 기반의 재전송 메커니즘을 구현하기 위해, 주어진 시간이 지난 후에 송신자를 인터럽트할 수 있는 **카운트 다운 타이머** 가 필요하다.  \n\n1. 매 패킷 (첫 번째 또는 재전송 패킷)이 송신된 시간에 타이머를 시작함\n2. 타이머 인터럽트에 반응함(적당한 행동을 취함)\n3. 타이머를 멈춤\n\n![[bit-error-alternating-bit.jpeg]]\n\n패킷에 대한 수신 시간은 전송 지연과 전파 지연 때문에 패킷 전송 시간보다 더 늦다. 패킷의 순서 번호가 0과 1이 번갈아 일어나므로, 프로토콜 rdt3.0은 **얼터네이팅 비트 프로토콜 (alternating-bit protocol)** 이라고 부른다.  \n\n### 파이프라이닝된 신뢰적인 데이터 전송 프로토콜\n\nrdt 3.0의 핵심적인 성능 문제는 stop-and-wait 프로토콜이라는 점이다.  \n\n전송 후 대기 방식으로 동작하는 대신, 송신자에게 확인 응답을 기다리지 않고 여러 패킷을 전송하도록 허용하면 성능 문제를 간단히 해결할 수 있다. 많은 전송 중인 송신자-수신자 패킷을 파이프라인에 채워넣음으로써 나타낼 수 있다. 이 기술을 **파이프라이닝** 이라고 부른다.  \n\n파이프라이닝은 신뢰적인 데이터 전송 프로토콜에서 다음과 같은 중요성을 지니고 있다.  \n- 순서 번호의 범위가 커져야 한다. 각각의 전송 중인 패킷은 유일한 순서 번호를 가져야 하고 전송 중인 확인 응답(ACK)이 안 된 패킷이 여럿 있을 수도 있기 때문이다. \n- 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 한다. 최소한 송신자는 전송되었으나 확인응답되지 않은 패킷을 버퍼링해야 한다. 정확하게 수신된 패킷의 버퍼링은 다음에 설명한 것처럼 수신자에게서도 필요하다. \n- 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려 있다. 파이프라인 오류 회복의 두 가지 기본적인 접근 방법으로 **GBN(Go-Back-N)**, **SR(Selective Repeat)** 등이 있다. \n\n### GBN\n\n**GBN 프로토콜** 에서 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다. 그러나 파이프라인에서 확인응답이 안 된 패킷의 최대 허용 수 N보다 크지 말아야 한다.  \n\n확인응답이 안 된 가장 오래된 패킷의 순서 번호를 *base* 로 정의하고 사용되지 않은 가장 작은 순서 번호를 *nextseqnum* 라고 정의한다면 순서 번호의 범위에서 4개의 간격을 식별할 수 있다. 간격 `[0, base - 1]` 에서 순서 번호는 이미 전송되고 확인응답이 된 패킷에 대응된다. 간격 `[base, nextseqnum -1]` 은 송신은 되었지만 아직 확인 응답되지 않은 패킷에 대응된다. 간격 `[nextseqnum, base + N-1]` 은 상위 계층으로부터 데이터가 도착하면 바로 전송될 수 있는 패킷을 위해 사용될 수 있다. 마지막으로, `base+N` 이상의 순서 번호는 파이프라인에서 확인응답이 안 된 패킷의 확인응답이 도착할 때까지 사용될 수 없다.  \n\n아직 확인응답이 안 된 패킷을 위해 허용할 수 있는 순서 번호의 범위는 순서 번호의 범위 상에서 크기가 $N$ 인 ‘윈도’로 나타낸다. 프로토콜이 동작할 때, 이 윈도는 순서 번호 공간에서 오른쪽으로 이동된다. 이러한 이유로 $N$ 을 **윈도 크기** 라고 부르며, GBN 프로토콜은 **슬라이딩 윈도 프로토콜 (sliding-window protocol)** 이라고 부른다.  \n\n그렇다면 왜 확인응답이 안 된 패킷의 수를 무한한 번호를 허용하지 않을까? 실제로 패킷의 순서 번호는 패킷 헤더 안의 고정된 길이 필드에 포함된다. 만약 $k$ 가 패킷 순서 번호 필드의 비트 수라면, 순서 번호의 범위는 $[0, 2^{k}- 1]$ 이 된다. 순서 번호의 제한된 범위에서, 순서 번호를 포함하는 모든 계산은 모듈로 $2^k$ 연산을 사용한다.  \n\n아래의 FSM은 base, nextseqnum 변수에서의 동작과 이러한 변수를 포함하는 조건부 동작을 추가했으므로 이 FSM 을 *확장된 FSM* 이라고 한다.  \n\n![[gbn-extended-fsm.jpeg]]\n\n![[gbn-receiver-fsm.jpeg]]\n\nGBN 송신자는 다음과 같은 세 가지 타입의 이벤트에 반응해야 한다.\n- 상위로부터의 호출: `rdt_send` 가 위로부터 호출되면, 송신자는 우선 윈도가 가득 찼는지, 즉 N개의 아직 확인응답되지 않은 패킷이 있는지를 확인한다. 만약 윈도가 가득 차 있지 않다면 패킷이 생성되고 송신된다. 그리고 변수들이 적절히 갱신된다. 만약 윈도가 가득 차 있다면, 송신자는 윈도가 가득 차 있음을 가리키는 함축적인 의미로 단지 데이터를 상위 계층으로 반환한다. 상위 계층은 나중에 다시 시도할 것이다. 실제적인 구현에서 송신자는 해당 데이터를 버퍼링하거나, 오직 윈도가 가득 차 있지 않을 때만 `rdt_send()` 를 호출하는 동기화 메커니즘 (세마포어나 flag) 을 사용할 것이다. \n- ACK의 수신: GBN 프로토콜에서 순서 번호 n을 가진 패킷에 대한 확인응답은 **누적 확인응답 (cumulative acknowledgment)** 으로 인식된다. 이 누적 확인응답은 수신 측에서 올바르게 수신된 $n$ 을 포함하여 $n$ 까지의 순서 번호를 가진 모든 패킷에 대한 확인 응답이다.\n- 타임아웃 이벤트: 전송 후 대기 프로토콜에서와 같이 타이머는 손실된 데이터 또는 손실된 확인응답 패킷으로부터 회복하는 데 사용된다. 만약 타임아웃이 발생한다면, 송신자는 이전에 전송되었지만 아직 확인응답되지 않은 모든 패킷을 다시 송신한다. 송신자는 가장 오래된 ‘전송했지만, 아직 확인응답 안 된 패킷’ 에 대한 타이머로 생각될 수 있는 단일 타이머를 사용한다. 만일 한 ACK가 수신되었지만 추가로 ‘전송했지만, 아직 확인응답 안 된 패킷’이 아직 존재한다면, 타이머는 다시 시작된다. 만약 아직 확인응답 안 된 패킷이 없다면, 타이머는 멈춘다. \n\nGBN 에서는 수신자의 행동도 단순하다. 만약 순서 번호 n 을 가진 패킷이 오류 없이, 그리고 순서대로 수신된다면(즉, 상위 계층에 마지막으로 전달된 데이터가 순서 번호 n-1 을 가진 패킷으로부터 온 것이라면), 수신자는 패킷 n에 대한 ACK를 송신하고 상위 계층에 패킷의 데이터 부분을 전달한다. 그 외의 경우에는 수신자는 그 패킷을 버리고 가장 최근에 제대로 수신된 순서의 패킷에 대한 ACK를 재전송한다. 패킷이 상위 계층에 한 번에 하나씩 전송되므로, 만일 패킷 k가 수신되고 상위 계층에 전달되었다면, 이때는 이미 k보다 낮은 순서 번호를 가진 모든 패킷 또한 제대로 전달되어 있다는 뜻이다. \n\nGBN 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다. 비록 정확하게 수신된 패킷을 버리는 것이 낭비인 것 같지만, 이런 작업을 수행하는 데는 몇 가지 당연한 이유가 있다.  \n지금 패킷 n이 수신되어야 하지만, 그 사람 다음의 패킷 n + 1 이 먼저 도착했다고 가정하자. 데이터가 순서대로 전달되어야 하므로, 수신자는 패킷 n + 1을 저장하고 나중에 패킷 n이 수신되고 전달된 후에 상위 계층에 이 패킷을 전달한다. 그러나 만일 패킷 n이 손실된다면 송신자에서 GBN 재전송 규칙에 따라 패킷 n과 n + 1 이 모두 재전송될 것이다. 이런 접근의 이점은 수신자 버퍼링이 간단하다는 것이다. 즉, 수신자는 어떤 순서가 잘못된 패킷에 대해 버퍼링을 할 필요가 없다. 그러므로 송신자는 윈도 상위와 하위 경계와 이 윈도 안에 있는 nextseqnum 위치를 유지해야 하지만, 수신자가 유지해야 하는 것은 단지 다음 순서 패킷의 순서 번호다. 물론, 올바르게 수신된 패킷을 버리는 것의 단점은 그 패킷의 재전송이 손실되거나 왜곡될 수 있으므로 많은 재전송이 필요할 수도 있다는 것이다. \n\n어떤 한 프로토콜 스택에서 이러한 프로토콜의 구현은 확장된 FSM의 구현과 유사한 구조를 갖는다. 또한 이 구현은 발생할 수 있는 다양한 이벤트에 대한 대응으로 취할 수 있는 동작을 구현하는 다양한 절차들과 유사하다. 이러한 **이벤트 기반 프로그래밍 (event-based programming)** 에서의 다양한 프로시저들은 프로토콜 스택에서 다른 프로시저에 의해 야기되거나 인터럽트의 결과로 요청될 것이다. 송신자에서 이러한 이벤트는 `rdt_send()` 를 호출하기 위한 상위 계층 개체로부터의 호출, 타이머 인터럽트, 패킷이 도착했을 때 `rdt_rcv()` 를 호출하기 위한 하위 계층으로부터의 호출이다. \n\n### SR\n\nGBN 프로토콜은 송신자가 패킷으로 파이프라인을 채우는 것을 가능하게 하여, 전송 후 대기 프로토콜에서 채널 이용률 문제를 피하도록 하고 있다. 그러나 GBN 자체에도 성능 문제를 겪는 시나리오들이 존재한다. 특히 윈도 크기와 대역폭 지연 (bandwidth-delay) 곱의 결과가 모두 클 때, 많은 패킷이 파이프라인에 있을 수 있다. 그러나 GBN은 패킷 하나의 오류 때문에 많은 패킷을 재전송하므로, 많은 패킷을 불필요하게 재전송하는 경우가 발생한다. 채널 오류의 확률이 증가할수록 파이프라인은 불필요한 재전송 데이터로 채워진다. \n\nSR 프로토콜은 수신자에서 오류가 "},{"excerpt":"TODO 컴퓨터 네트워킹 하향식 접근 2장 완료   [scheduled:: 2023-12-13]  [completion:: 2024-06-16T19:15] 백준 1949번 풀이 백준 1086번 풀이   [scheduled:: 2023-12-13]  [completion:: 2024-06-16T19:15] LOG 동계 인턴에 탈락했다. 이것도 어쩔 수 없지…","fields":{"slug":"/2023-12-14/"},"frontmatter":{"date":"2023년 12월 14일 08:12","title":"2023년 12월 14일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 컴퓨터 네트워킹 하향식 접근 2장 완료   [scheduled:: 2023-12-13]  [completion:: 2024-06-16T19:15]\n- [x] 백준 1949번 풀이\n- [x] 백준 1086번 풀이   [scheduled:: 2023-12-13]  [completion:: 2024-06-16T19:15]\n\n## LOG\n\n- 동계 인턴에 탈락했다. 이것도 어쩔 수 없지… 이제 B 플랜이었던 학부 연구생으로 넘어가야 할 것 같다.\n- DH 면접 보고 나서 공부가 손에 잘 안 잡힌다. 그래도 이것만 보고 있을 순 없으니 뭐라도 얼른얼른 해야 한다. 오늘 결과가 나오면 좋겠지만 아니라면 내일이라도 알려주라 ㅠㅠ\n- 이제는 영어로 생각하는 것이 조금 더 수월한 느낌이다. Shelby Thanks a lot…!\n- 단계별로 풀어보기 트리에서의 동적 계획법을 완료했다. \n\n## 배운 것\n\n- [[english-speaking-dec-2week]] 를 정리했다.\n\n## 느낀 것"},{"excerpt":"표현 I’m very relieved It is what it is : 어쩔 수 없지 I’m not suitable for the positions Even though it might not be a problem, I’m still nervous. just wing it: 그냥 해봐, give it a try I’m not sure but … : 확실…","fields":{"slug":"/english-speaking-dec-2week/"},"frontmatter":{"date":"2023년 12월 14일 08:12","title":"영어 회화 12월 2주차","tags":["english-speaking"]},"rawMarkdownBody":"\n## 표현\n\n- I’m very relieved\n- It is what it is : 어쩔 수 없지\n- I’m not suitable for the positions\n- Even though it might not be a problem, I’m still nervous.\n- just wing it: 그냥 해봐, give it a try\n- I’m not sure but … : 확실하진 않지만~\n- heard right: 맞게 듣다.\n- by the end of this week: 금요일\n- I thought there were twelve. : 나는 12명이 있었다고 생각했다.\n- answered the questions well : 질문에 잘 대답했다.\n- didn’t know the answers: (몰라서) 대답하지 못했다\n- they were easier than I thought: 질문들이 생각했던 것보다 쉬웠다.\n- I don’t know if the interview can accurately judge our abilities\n- What happens if ~ : ~하면 뭐하지? / 어떡하지?\n- There is nothing special to talk about\n- might be announced later: 나중에 전달될 것이다\n- common / normal / typical in (나라) : (나라) 에서는 일반적이다.\n- sue: 소송하다"},{"excerpt":"2.4 도메인 영역의 주요 구성 요소 도메인: 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다. 밸류: 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다…","fields":{"slug":"/domain-driven-development-start/"},"frontmatter":{"date":"2023년 12월 13일 11:12","title":"도메인 주도 개발 시작하기 - DDD 핵심 개념 정리부터 구현까지","tags":["도메인-주도-개발-시작하기","책","개발","DDD"]},"rawMarkdownBody":"\n## 2.4 도메인 영역의 주요 구성 요소\n\n- 도메인: 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다. \n- 밸류: 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다. \n- 애그리거트: 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것\n- 리포지터리: 도메인 모델의 영속성을 처리한다.\n- 도메인 서비스: 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다. \n\n### 엔티티와 밸류\n\n도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다.  \n도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.  \n\n### 애그리거트\n\n엔티티와 밸류 개수가 많아질수록 모델은 점점 더 복잡해진다.  \n도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 *애그리거트*다. \n\n애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다. 이를 통해 큰 틀에서 도메인 모델을 관리할 수 있다.  \n\n애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.  \n애그리거트를 사용하는 코드는 애그리거트 루트를 통해 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근한다.  \n\n### 리포지터리\n\n도메인 객체를 지속적으로 사용하기 위해 물리적인 저장소에 도메인 객체를 보관해야 하는데, 이런 구현을 위한 도메인 모델이다.  \n\n리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.  \n\n리포지터리를 사용하는 주체가 응용 서비스이기 때문에 리포지터리는 응용 서비스가 필요로 하는 기능을 제공한다.  \n- 애그리거트를 저장하는 메서드\n- 애그리거트 루트 식별자로 애그리거트를 조회하는 메서드\n\n## 3.1 애그리거트\n\n애그리거트는 일관성을 관리하는 기준도 된다. 복잡한 도메인을 단순한 구조로 만들 수 있다.  \n\n한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다. 도메인 규칙에 따라 최처 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다. \n\n애그리거트는 *경계*를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.  \n\n경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.  \n도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다. 또한 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.  \n\n‘A가 B를 갖는다’로 해석할 수 있는 요구사항이 있다고 하더라도 이것은 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다. 좋은 예시에는 상품과 리뷰가 있다.  \n\n## 애그리거트 루트\n\n애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.  \n애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.  \n\n### 도메인 규칙과 일관성\n\n애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않게 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.  \n\n애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다.  \n\n불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.  \n- 단순히 필드를 변경하는 set 메서드를 public 으로 만들지 않는다. \n- 밸류 타입은 불변으로 구현한다.  \n\n### 애그리거트 루트의 기능 구현\n\n애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.  \n애그리거트 루트는 기능 실행을 위임하기도 한다.  \n\n### 트랜잭션 범위\n\n트랜잭션 범위는 작을수록 좋다.  \n한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한 번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어진다.  \n\n한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.  \n\n부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다. \n\n## 3.3 리포지터리와 애그리거트\n\n애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.  \n동일하게 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.  \n\n애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.  \n\n## 3.4 ID를 이용한 애그리거트 참조\n\n애그리거트를 직접 참조할 때 발생할 수 있는 문제점은 편리함을 오용할 수 있다는 것이다. 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.  \n애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다.  \n또한 확장에서도 불리하다.\n\n이런 문제를 완화하기 위해 ID를 이용해서 다른 애그리거트를 참조하는 것이다.  \nID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다. 이는 애그리거트의 경계를 명화갛게 하고 애그리거트간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다. 또한 애그리거트 간의 의존을 제거하여 응집도를 높여준다. \n\n### ID를 이용한 참조화 조회 성능\n\nID 참조 방식을 사용하면서 N + 1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하면 된다.  \n"},{"excerpt":"TODO 백준 2533 풀이   [scheduled:: 2023-12-10]  [completion:: 2024-06-16T19:15] LOG 오늘 내내 인터뷰 준비만 했다. 그래도 말하는 감자였던 어제보다는 좀 더 아는 게 생긴 것 같다. 다행인건가..? 얕은 지식만 잔뜩 는 느낌이다 ㅠ 서울의 봄을 봤다. 생각보다는 화가 나지는 않았는데, 조금 개탄스…","fields":{"slug":"/2023-12-11/"},"frontmatter":{"date":"2023년 12월 10일 11:12","title":"2023년 12월 11일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 백준 2533 풀이   [scheduled:: 2023-12-10]  [completion:: 2024-06-16T19:15]\n\n## LOG\n\n- 오늘 내내 인터뷰 준비만 했다. 그래도 말하는 감자였던 어제보다는 좀 더 아는 게 생긴 것 같다. 다행인건가..? 얕은 지식만 잔뜩 는 느낌이다 ㅠ\n- 서울의 봄을 봤다. 생각보다는 화가 나지는 않았는데, 조금 개탄스럽기는 했다. 나라의 의사 결정을 내리는 사람은 현명하고 지혜로워야 한다는 생각을 했다. 그렇다면 어떻게 그런 사람들을 뽑을 수 있을까? 만약 내가 사장이라면, 지혜롭게 생각하고 옳은 판단을 하는 사람들을 어떻게 선별할 수 있을지 고민해봐야겠다. \n- 에이블리 인턴에 탈락했다. 아쉽지만 어쩔 수 없지\n- 내가 지원한 인턴 모집 기간이 오늘까지였다. 과연 이후에 연락이 올 것인지… 안 되면 어쩔 수 없이 학부 연구생을 해야만 한다.\n\n## 배운 것\n\n- [[dh-second-interview-preparation|인터뷰 준비]]를 했다.\n\n## 느낀 것\n\n- 무능한 건 사람을 화나게 한다. \n- 내일은 정말로 DH 인터뷰 마지막이다. 어떻게 마무리가 될 지 궁금하다. 최선을 다하자. 끝나면 마음은 편할 거 같다. 인터뷰 과정이 끝나면 이젠 좀 더 여유있는 마음으로 공부를 할 수 있지 않을까..? 아자자 아자자\n- 내가 우아한테크코스를 진행하면서 썼던 회고들을 쭉 돌아봤다. 재밌긴 했다 ㅋㅋ 근데 확실히 예전보다 더 좋아하는 것이 많아졌고, 하고 싶은 것들도 생겼고, 작은 목표도 생겼다. 거참 신기하죠. 무엇보다 가장 큰 것은 노력하는 것이 멋지다고 생각하게 된 것이다. 우코랑 말할 때도 이야기 했었는데, 원래 나는 천재만 멋지다고 생각했다. 아무도 생각하지 못한 생각을 혼자 해내는 사람이 제일 멋있었다. 그런데 최근에 블루 자이언트라는 영화를 보고 생각이 변했다. 자신의 인생을 걸고 노력하는 사람도 천재만큼 멋진거구나! 그래서 이제는 노력할 수 있다. 나는 언제나 멋진 걸 하고 싶었으니까. 어쩌면 나는 계속해서 멋진 사람을 향해 한 걸음씩 나아가고 있는 거 아닐까, 라는 멋진 생각을 해봤다.\n"},{"excerpt":"TODO LOG 드디어 13511 번을 풀었다. 솔직히 내 힘으로 온전하게 푼 건 아니지만 아이디어 자체는 떠올렸어서 예전보다 성장한 거 같다. 13511 번을 푸니 플레 4가 되었다. 올해 멋모를 때 작성했던 목표인 플레 2에는 미치지 못했지만 그래도 최선을 다했다! 앞으로도 열심히 하자. DH 2차 인터뷰를 준비하고 있다. 잘 대답할 수 있을까… 준비…","fields":{"slug":"/2023-12-10/"},"frontmatter":{"date":"2023년 12월 10일 08:12","title":"2023년 12월 10일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 드디어 13511 번을 풀었다. 솔직히 내 힘으로 온전하게 푼 건 아니지만 아이디어 자체는 떠올렸어서 예전보다 성장한 거 같다. 13511 번을 푸니 플레 4가 되었다. 올해 멋모를 때 작성했던 목표인 플레 2에는 미치지 못했지만 그래도 최선을 다했다! 앞으로도 열심히 하자. \n- DH 2차 인터뷰를 준비하고 있다. 잘 대답할 수 있을까… 준비를 열심히 하는 게 내가 할 수 있는 최선인 거 같다.\n\n## 배운 것\n\n- [[lca]] 내용을 보강했다. \n\n## 느낀 것"},{"excerpt":"Project Spring Framework 를 사용한 이유 RDBMS 과 NoSQL 의 차이점 RDBMS and NoSQL databases differ primarily in their data structure, scalability, and query language. RDBMS uses a structured table format with ro…","fields":{"slug":"/dh-second-interview-preparation/"},"frontmatter":{"date":"2023년 12월 09일 12:12","title":"DH 인터뷰 준비","tags":["dh"]},"rawMarkdownBody":"\n## Project\n\n- Spring Framework 를 사용한 이유\n- RDBMS 과 NoSQL 의 차이점\n\t- RDBMS and NoSQL databases differ primarily in their data structure, scalability, and query language. RDBMS uses a structured table format with rows and columns, making it ideal for complex queries and data integrity in relational data. On the other hand, NoSQL databases are designed for unstructured and semi-strucutured data with flexible schemas. They are highly scalable and suitable for handling large volumes of data and high user loads. \n- MySQL 을 사용한 이유\n- 가장 challenging 했던 문제는 무엇인가?\n\t- 기술적으로 challenging 했던 문제\n\t\t- 최근에 만든 서비스에 전체 노래를 좋아요, id 순으로 정렬해야 하는 쿼리가 있었다. 데이터베이스에서 정렬하고 데이터를 가져올 때 오랜 시간이 걸리는 것이 문제였다. 이를 해결하기 위해 데이터를 로컬에 캐싱하여 성능을 10배 가량 개선할 수 있었다. 그 과정에서 다양한 어려움이 있었던 거 같다.\n\t\t- In a recent project, we faced a significant challenge with a database query that required sorting songs by likes and ID. The issue was the substantial time it took to sort and retrieve data from the database, impacting our application's performance. To address this, we implemented a strategy to cache the data locally. This solution dramatically improved our performance, with a tenfold increase in data retrieval speed. However, The implementation process did present various challenges, concurrency and data consistency. \n\t\t- 동기화 문제는 어떻게 해결했나?\n\t\t\t- Given that our current setup involves only one server, using the synchronized keyword for data synchronization seemed like an effective strategy. However, in a scenario with multiple servers, a more scalable solution like a dedicated cache server would be preferable to synchronize data across different instances. \n\t- 전체적으로 challenging 했던 문제\n\t\t- 유저의 페인 포인트를 파악한 뒤에 우리 서비스에서 어떻게 적용해야 하는지 고민하는 것이 전체 개발 과정에서 가장 어려웠다. 최근에 사람들이 노래의 좋은 파트들부터 듣고 좋은 노래인지 판단할 수 있게 하는 서비스를 만들었다. 이때 사람들이 우리 서비스에 원하는 것이 무엇일지, 서비스를 통해 어떤 것을 제공해줄 수 있을지 많은 고민을 했다. 이를 위해 많은 기획 회의를 거쳤고, 처음 서비스의 컨셉을 잡기까지 2달이라는 시간이 소요되었다. 페르소나와 사용자 스토리를 만들며 유저 입장에서 좋은 서비스를 만들기 위해 노력했다. \n\t\t- One of the most challenging aspects of my recent development process was translating user pain points into actionable features within our service. I developed a service that enables users to determine the preference of a song by previewing its bests parts. To ensure this service truly resonated with user needs, we invested significant effort in understanding what users sought from our service and what we could feasibly deliver. This involved extensive planning and numerous meetings over two months to finalize our initial service concept. By creating detailed personas and user stories, our focus was to design the service from a user-centric perspective, ensuring it was both engaging and valuable to our target audience.\n- 인덱스란 무엇인가?\n\t- an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book. \n\t- 인덱스를 사용하는 이유\n\t\t- Indexes are used to quickly locate data without having to search every row in a database table every time a database table is accessed.\n\t- 인덱스를 사용했을 때의 장단점\n\t\t- Using indexes in databases primarily enhances query performances. They allow the database to find and retrieve specific rows much faster than without an index. But indexes can lead to increased storage usage, as they require additional space beyond the data itself. Also, while they speed up read operations, they can slow down write operations like insertions, updates, and deletions. \n\t- 인덱스를 적용했던 적이 있는지?\n\t\t- Because we didn’t use Foreign Key, we were able to improve performance by using indexes when writing simple look up queries. \n\t- 외래 키를 사용하지 않은 이유가 무엇인가?\n\t\t- In our project, the decision not to use foreign keys was driven by the need for performance optimization and scalability. Foreign keys are excellent for maintaining referential integrity, but they can add overhead to write operations such as insertions and updates. \n- 인덱스 실행 계획이란?\n- 트랜잭션이란 무엇인가?\n\t- a transaction refers to a sequence of operations performed as a single logical unit of work. \n\t- ACID 속성에 대해 설명해주세요.\n\t\t- First Atomicity ensures that all operations within a transaction are completed or aborted completely. Second, consistency is a property that guarantees a transaction will bring the database from on valid state to another. Third, Isolation is a property that all transactions runs independently of other transactions, maintaining data integrity when multiple transactions occur concurrently. At last, Durability is the results of transaction are permanently stored in the database system. \n- RDBMS 란 무엇인가?\n\t- A Relational Database Management System, is a type of DBMS that stores data in a structured format, using rows and tables. This structure enables a clear definition of data types and relationships among different data entities \n- VCS 란?\n\t- Version Control System is a tool that helps manage changes to source code over time. It keeps track of every modification to the code in a special kind of database. \n\t- 장점\n\t\t- I think the most advantage of VCS is VCS allows you to keep a record of all changes made to the code, including who made the changes, why they were made, and references to issues or bugs. Because we use the VCS, we can remain all changes in code. That’s a great advantages of VCS. \n- 클라우드 컴퓨팅이란?\n\t- Cloud computing is a technology that allows us to access and use computing resources over the internet. Cloud computing enables us to use computer resources rather than having to build and maintain computing infrastructures in-house. \n\t- 장점\n\t\t- Cloud computing can be scaled up or down based on demand. And it reduces the need for upfront capital investment in hardware and software. Organizations pay only for the resources they use, often leading to lower operational costs.\n- CI/CD 란 무엇인가?\n\t- 프로젝트에서 CI/CD 를 적용한 경험이 있는가?\n\t\t- 최근 프로젝트에서는 GitHub Actions를 사용하여 CI(지속적 통합)를 구성하고 GitHub의 자체 호스팅 실행기를 통해 CD(지속적 배포)를 설정했습니다. 이 설정은 개발 파이프라인을 자동화하고 효율성을 향상하며 코드 품질을 보장하는 데 필수적이었습니다. 그러나 GitHub Flow를 사용하고 동일한 저장소에 프런트엔드 및 백엔드 코드가 모두 있기 때문에 문제에 직면했습니다. 우리의 워크플로는 여러 가지의 변경 사항을 동기화하기 위해 기본 분기에 자주 병합해야 했습니다. 이로 인해 불완전한 프런트 엔드 기능을 병합해야 하는 상황이 발생하여 배포 프로세스를 완전히 자동화하는 능력에 영향을 미치는 경우가 많았습니다. 결과적으로 지속적인 전달을 달성했지만 이 설정에서는 완전히 자동화된 지속적인 배포가 불가능했습니다.\n\t\t- In our recent project, we configured continuous integration using github actions and set up CD through github’s self-hosted runners. This setup was integral to automating our development pipeline, enhancing efficiency, and ensuring code quality. However, we encountered a challenge due to our use of GitHub Flow and having both front-end and back-end code in the same repository. Our workflow required frequent merges into the main branch to synchronize changes across different branches. This often led to situations where incomplete front-end features had to be merged, impacting our ability to fully automate the deployment process. As a result, while we achieved Continuous Delivery, fully automated Continuous Deployment wasn’t feasible under this setup.\n\t- GitHub Flow 란?\n\t\t- Github Flow is a streamlined workflow designed for projects that require frequent deployments. It begins with creating a feature branch off the main branch, where all development work occurs. Once a set of changes is ready, a pull request is opened for code review and discussion with the code. After review, the branch can be deployed to a staging or production environment for testing. \n\t\t- In our project, we faced challenges with synchronizing deployment timing because we were developing both the front-end and back-end simultaneouly within a single repository. This complexity led us to consider Git Flow, which could potentially offer a more structured approach to managing parallel development streams and their integration. \n\t- Git Flow 와 비교했을 때 장단점은?\n- 서비스 구조는 어떻게 구성되어 있는가?\n\t- In our service, we’ve structured our infrastructure on AWS using two EC2 instances. First instance has nginx, spring application, github self hosted runner. And Second instance has our RDBMS. And our spring application is designed with a layered architecture. \n\t- 계층형 아키텍쳐란 무엇인가?\n\t\t- layered architecture is a way of organizing code into distinct sections, each with a specific responsibility. Each layer in the architecture focuses on a specific aspect of the application. This separationi makes the application more manageable, as changes in one part of the code have minimal impact on others. There are four layers, presentation layer, business layer, data access layer, database layer. \n- RESTful 한 API 란 무엇인가? \n- REST란 무엇인가?\n\t- REST is an architectural style for designing networked applications. It relies on a stateless, client-server communication model, and is used primarily in the development of web services. In REST, everything is a resource identified by a unique URI. \n- DBMS 란?\n\t- A Database Management System is software that provides an efficient, secure, and convenient way to store, retrieve and manage data in databases. It serves as an interface between the database and its users or the application programs, ensuring that the data is consistently organized and remain easily accessible. \n\n## Software Engineering\n\n- OOP 란 무엇인가?\n\t- Object Oriented Programming is a programming paradigm based on the concept of objects, which can contain data and code. Data in the form of fields and code in the form of procedures. OOP has some key concepts, encapsulation, abstraction, polymorphism. \n\t- Encapsulation means bundling the data and methods that operate on the data with one object. It helps in hiding the internal state of the object from the outside world and only exposing a defined interface. Abstraction allows focusing on what an object does instead of how it does it. It helps in managing complexity by hiding the detailed implementation and showing only the necessary features of an object. Polymorphism enables a single interface to represent different underlying data types, methods or functions. \n- Clean Code 란 무엇이라고 생각하는가?\n\t- Clean Code refers to a concept in software engineering where the code written is well-organized, easily understandable, and maintainable. First, clean code should be easily readable and understandable. Second, Clean code should be efficient in terms of resource usage. \n- SOLID 란 무엇인가?\n\t- SOLID is a set of five design principles in object-oriented programming that guide developers in creating more maintainable, understandable, and scalable code. First, Single Responsibility Principle states that a class should have on and only one reason to change, meaning it should have a single responsibility. Second, Open-Closed Principle suggests that software entities like classes modules, and functions should be open for extension but closed for modification.Third, Liskov substitution implies that objects of a superclass should be replaceable with objects of its subclasses without altering the correctness of the program. It ensures that a subclass can stand in for its parent class. Fourth, Interface Segregation Principle means it’s better to have many specific interfaces than a single, general-purpose interface. Fifth, Dependency Inversion Principle advocates for high-level modules not to depend on low-level modules, but both should depend on abstractions. It encourages decoupling in the code, which increases modularity and flexibility. \n\t- extension 과 modification 의 차이점은 무엇인가?\n\t- Scalability 란 무엇인가?\n\t\t- Scalability in software engineering refers to a system’s ability to handle an increasing amount of work or to be readily expanded to accommodate that growth. There are two main types of scalability. Vertical scalability involves adding more resources to the existing infrastructure. Horizontal Scalability involves adding more machines or nodes to handle increased load. Scalability ensures that the application can continue to function efficiently as its user base grows, data volumes increase, or operational demands rise. \n- 테스트의 종류에는 무엇이 있는가?\n\t- In my project, we adopted three testing techniques, acceptance test, unit test, integration test. First, Acceptance test focused on ensuring that the software meets the end users’ needs and compiles with the business requirements. Thorough integration testing has helped us to identify and resolve any issues arising from the interaction of individual components. And Unit Testing is a test focuses on individual units or components of the software to ensure that each part works as intended. \n\t- 테스트 커버리지는 어느 정도인가?\n\t\t- Our team has rigorously performed both acceptance testing and integration testing on the project, leading to test coverage of 96%. \n- 리팩토링이란 무엇인가?\n\t- 프로그램이 동일한 동작을 하지만, 내부의 코드의 가독성을 높이고 구조를 개선하는 것을 말한다. 리팩토링을 하게 되면 이후 유지보수를 할 때 큰 도움이 된다.\n\t- Refactoring is a disciplined technique for restructing an existing body of code, altering its internal structure without changing its external behavior. Its main purpose is to make the code more efficient, readable, and maintainable, while also improving its overall design. \n- 언제 리팩토링을 해야 하는가?\n\t- 코드를 이해하거나 유지 관리하기 어려워지는 경우 리팩토링이 필요하다고 생각합니다. 복잡한 로직에서 변수와 함수의 이름을 개선하고, 길이가 긴 메서드를 더 작고 관리하기 쉬운 메서드로 분할하는 과정으로 리팩토링할 수 있습니다. 또한 성능 병목 현상이 일어날 때 리팩토링이 필요하다고 생각합니다. 실제로 프로젝트에서 성능 병목 현상이 일어나서 성능 최적화를 위한 코드 리팩토링을 진행해보았습니다.\n\t- In my view, refactoring becomes essential when code is challenging to understand or maintain. For instance, tackling complex logic can be managed by enhancing the clarity of variable and function names, and by dividing lengthy methods into shorter, more manageable methods. This approach not only improves readability but also eases maintenance. Additionally refactoring is crucial in addressing performance issues. For example, in a recent project, we analyzed codes contributing to the performance bottleneck and proceeded optimization. As a result of these refinements, we successfully enhanced the performance by refactoring the codes. \n\n## Team\n\n- 코드 리뷰를 할 때 어떤 부분을 중점적으로 보는가?\n- 팀원과 협업하면서 있었던 어려움이 있었는가?\n\t- We had many long meetings. It made us exhausted. So I suggested reading before the meeting documents that we would need to be discussed at the meeting. By adopting this strategy, we not only saved time but also enhanced the efficiency and effectiveness of our meetings.\n- 팀에서 어떤 역할을 수행했고, 어떤 부분에 기여했는가?\n\t- 나는 백엔드 개발자로서 프론트엔드 개발자와 소통해야 했다. 나는 기술적인 용어를 쓸 때 동료가 이해할 수 있는 말로 풀어서 설명하려고 노력했다. 대부분의 오해는 말을 잘못 이해하는 것으로 시작되기 때문이다. 또한 동료가 요청하는 것이 있으면 빠르게 반영하려고 노력했다. 이렇게 했을 때 동료들과 효과적으로 협업 활동을 할 수 있었다.\n\t- As a back-end developer, I needed to communicate with front-end developer. When I used technical terms, I tried to break them down into words that my coworkers could understand. Because most misunderstandings starts with a misunderstanding of words. I also tried to be responsive to their requests. By doing this, I was able to collaborate effectively with my coworkers.\n- How do you approach learning new technologies or programming languages?\n\t- First, I try to understand why this technology is needed and in what situation it will be useful. I don’t introduce technology blindly, I try to introduce it when I think the technology is necessary for service. I tend to study technology by reading official document and making some sample projects myself.\n\n## 그 외 답변\n\n- 지원 동기\n\t- I believe that Delivery Hero will expose me to a variety of problems and allow me to solve them. I applied because I want to work in a new environment with different people. \n\n## 질문\n\n- Could you say that again, please? \n- Would you mind slowing down a little bit? I'm still adapting to fast-paced English and would appreciate the favor if you can.\n- May I correct my previous answer?\n- 인터뷰 결과는 언제 안내 되나요?\n\t- When will the results of the interview be announced?\n- 일하시면서 좋은 점과 힘든 점이 있으셨나요? 저에게 소개해주실 수 있나요?\n\t- Did you have any good or difficult points while working? Can you introduce it to me?\n\n## 질문\n\n- 자기 소개\n- Spring 을 사용한 이유\n- 간단하게 서비스 소개\n\t- 서비스 구조는 어떻게 구성되어 있는가?\n\t- 개발하면서 가장 challenging 했던 문제\n\t- 동시성은 어떻게 해결할 수 있는가?\n\t- 사람들이 더 많아지면 모두 캐싱할 수는 없지 않나?\n\t- scale up 만이 답인가?\n- Collection 설명해보라고 함\n\t- List 와 Set 의 차이점\n\t- List, Set 과 Map 의 차이점 → Map 은 key 로 값 가져온다 그렇게만 말함..ㅋㅋ\n- NAT, VPC 란 무엇인가?\n- Java 를 제외한 다른 언어 써볼 생각 있는지\n\n전체적으로 분위기는 좋았고, 긴장하지 않게 많이 애써주셨던 것 같다. 다만 인터뷰를 30분 밖에 하지 않아서 왜 이렇게 빨리 끝났는지 의문이다. 15분 동안은 내가 질문하고 답변하는 시간을 가졌다. 질문도 크게 어렵지 않았고 Java 와 서비스에 대한 basic 한 질문들이 대부분이었다. "},{"excerpt":"애그리거트 Song Artist ArtistName ArtistSynonym ProfileImageUrl AlbumCoverUrl Genre SongLength SongTitle SongVideoId Part song_id PartLength StartLength count KillingPart part_id MemberPart part_id member…","fields":{"slug":"/shook-domain-model/"},"frontmatter":{"date":"2023년 12월 08일 11:12","title":"S-HOOK 도메인 모델 파악하기","tags":["도메인-주도-개발-시작하기"]},"rawMarkdownBody":"\n## 애그리거트\n\n- Song\n    - Artist\n        - ArtistName\n        - ArtistSynonym\n        - ProfileImageUrl\n    - AlbumCoverUrl\n    - Genre\n    - SongLength\n    - SongTitle\n    - SongVideoId\n- Part\n    - song_id\n    - PartLength\n    - StartLength\n    - count\n- KillingPart\n    - part_id\n- MemberPart\n    - part_id\n    - member_id\n- Member\n    - Email\n    - Nickname\n- KillingPartLike\n    - part_id\n- KillingPartComment\n- Synonym\n    - type\n        - Song, Artist\n    - value\n    - target_id (Long)\n\n## 주요 기능\n\n### Song\n\n- id\n- SongTitle title\n- SongVideoId video_id\n- AlbumCoverUrl albumCoverUrl\n- Artist artist\n    \n    ### Artist\n    - id 아티스트 아이디\n    - ProfileImageUrl 프로필 이미지 링크\n    - ArtistName 아티스트 이름\n    - createdAt\n    - 기능\n        - 아티스트를 통해 노래를 조회한다.\n- SongLength length\n- Genre genre\n- createdAt\n- **score ← 전체 PartCount 를 합한 값**\n- 기능\n    - 생성\n        - 생성 정보: title, video_id, image_url, artist_id, length, genre\n        - artist_id 로 Artist가 존재하는지 확인\n        - Song 생성 후 저장\n    - 좋아요 많은 순 정렬된 노래 조회\n        - score 순으로 10 개\n    - 스와이프 노래 조회\n\n### Part\n\n- **PartLength** length 파트 길이\n    - 5~15초 사이여야 한다.\n- Long song_id 노래 아이디\n    - null check\n    - 노래의 킬링파트 개수 제한은 제거한다.\n- StartSecond startSecond 시작 초\n    - int startSecondValue, int songLength, int partLength 받아서 비교하는 생성자 필요\n        - 시작 초에 파트 길이를 더했을 때 노래 길이를 넘는지 확인한다.\n- count 파트 등록 횟수. 기본값은 0\n- 노래 아이디 + 파트 길이 + 시작 초의 조합은 유니크해야 함.\n\n### Member\n\n**한 멤버가 한 노래당 하나의 MemberPart 만 등록할 수 있다.**\n\n- Identifier\n- Nickname\n- 기능\n    - 닉네임 변경 API\n    - 소셜 로그인 시 회원 가입이 필요한 회원의 경우 닉네임을 받아야 할까? 논의 해보기\n    - **Member 가 삭제될 때 (NEW)**\n        - PartLog, PartComment, PartLike 를 삭제하는 이벤트 발행 (비동기)\n\n해당 part_id를 갖는 MemberPart 가 0개이면 Part 는 삭제된다.\n\nMemberPart 가 생성되었을 때, Part 가 없으면 Part 를 생성한다.\n                          있으면 Part 의 count 를 1 증가시킨다.\n\nMemberPart 가 삭제될 때, Part 의 count 를 1 감소시킨다.\nPart 의 count 가 0이 되면, Part 는 삭제된다.\n\n### PartLog (MemberPart)\n\n- Long song_id\n- Long part_id\n- Long member_id\n- 기능\n    - 생성\n        - 이 노래에 MemberPart 를 등록한 적이 있는지 확인\n        - Part 의 count 증가 (이벤트)\n    - 조회\n\n**MemberPart 와 Part 가 같은 애그리거트일 때 → 이게 맞는 거 같긴 함**\n\n- MemberPart 가 등록될 때\n    - 등록 정보 : member_id, song_id, startSecond, PartLength\n    - member_id, song_id 로 이미 이 노래에 MemberPart 를 등록했는지 검사\n    - startSecond, song_id, PartLength 해당 정보를 갖는 Part 가 있는지 확인한다.\n        - Part 가 없으면 Part 를 생성하고, MemberPart 를 생성한다. Part 의 count 를 증가한다.\n        - Part 가 있으면 해당 part_id 로 MemberPart 를 생성하고, 이벤트를 통해 Part 의 count 를 증가시킨다.\n\n**다른 애그리거트일 때**\n\n- MemberPart 가 등록될 때\n    - 등록 정보 : member_id, song_id, startSecond, PartLength\n    - member_id, song_id 로 이미 이 노래에 MemberPart 를 등록했는지 검사\n    - startSecond, song_id, PartLength 해당 정보를 갖는 Part 가 있는지 확인한다.\n        - Part 가 있으면 해당 part_id 로 MemberPart 를 생성하고, 이벤트를 통해 Part 의 count 를 증가시킨다.\n        - Part 가 없으면, Part 를 생성하고, MemberPart 를 생성하고, 이벤트를 통해 Part 의 count 를 증가시킨다.\n\n### PartLike\n\n- id\n- is_deleted\n- part_id\n- member_id\n- created_at\n- updated_at\n- 기능\n    - 생성\n        - 등록 정보: is_deleted, part_id, member_id\n        - part가 존재하는지 확인\n        - 좋아요 생성 요청인가?\n            - 생성요청임\n                - 해당 정보로 Like 가 존재하는지 확인 → 존재하면 가져오고, 없으면 KillingPartLike 생성\n                - 기존 KillingPartLike 가 삭제되었으면 true 로 변경\n                    - InMemory like → Part 의 count 올리는 이벤트로 대체 가능\n                    - likeRepository pressLike\n            - 삭제 요청임\n                - 해당 정보로 Like 존재하는지 확인\n                - 존재하면\n                    - InMemory unlike → Part 의 count 내리는 이벤트로 대체 가능\n                    - likeRepository cancelLike\n    - 특정 멤버가 좋아요한 파트 정보를 조회한다.\n        - 조회 정보: member_id\n        - 이 멤버가 좋아요한 KillingPartLike, Song, Part 정보를 repository 에서 조회\n        - 최신 등록 순 정렬\n\n### PartComment\n\n- id\n- PartCommentContent content\n- part_id\n- member_id\n- created_at\n- 기능\n    - 등록\n        - 등록 정보: member_id, part_id, content\n        - part_id 로 Part 조회\n            - 존재하면 PartComment 생성\n    - 조회\n        - 조회 정보: part_id\n        - part_id 로 PartCommentRepository 에서 최신순으로 쿼리\n\n### Synonym\n\n- id\n- target_id\n    - song_id\n    - artist_id\n- Enum type\n- value\n- 기능\n    - **Admin 을 위한 Synonym 생성**\n    - 조회\n        - 조회 정보: type, keyword\n        - type 으로 어떤 Repository 를 선택할 지 결정\n            - artist\n                1. keyword 로 ArtistRepository 조회 → `List<Artist>`\n                2. keyword 로 SynonymRepository type, keyword로 조회 → `List<SynonymArtistDto>`\n                    - Artist, Synonym\n                3. 중복 결과 제거 후 `List<Artist>` 반환\n\n## 질문들\n\n### Part\n\n- Part 는 얼마나 보여줄 것인가?\n    - KillingPart 와 Part 는 무슨 차이가 있는가?\n        - KillingPart 를 선정하는 기준이 만약 점수라면, 굳이 업데이트가 잦을 KillingPart 가 존재할 필요가 있는가?\n- 좋아요와 중복 Part 등록의 점수를 다르게 할 것인가?\n- Part 를 구분하는 기준을 시간 초로 잡는 건 어떤가?\n    - 2초 ~ 10초, 2초 ~ 11초, 2초 ~ 8초\n    - 이 경우라면 MemberPart 가 PartLength 를 가져야 한다.\n    - 시작초: 2초, 파트 길이를 ???\n    - **파트 길이를 구하는 방식**\n        - 시작초가 같은 모든 파트 길이의 합을 평균낸다.\n        - 시작초가 같은 파트 길이 중에 최댓값으로 정한다.\n            - startSecond + PartLength\n                - startSecond 만 유니크하다.\n                - PartLength:PartLength 의 개수를 Map 으로 갖고 있다.\n            - Part 가 startSecond 만 갖고, MemberPart 가 PartLength 를 갖는다.\n                - Part 는 startSecond 만 유니크하고, MemberPart 는 part_id 를 가짐으로써 나중에 Part 를 조회하게 될 때 Memberpart 를 취합해서 가장 최대 길이인 것을 함께 조회\n        - 시작초를 필수로 하고, 파트 길이를 정하는 것을 사용자에게 선택 사항으로 주기 ⇒ 사용자의 의견이 실제로 킬링파트 합산에 기여를 하고 있다는 느낌을 줄 수 있지 않을까\n    \n    **⇒ 파트를 어떻게 정렬해서 KillingPart 를 보여줄까?**\n\n### Member\n\n- Member 가 부정 행위를 한 경우, 제재를 할 수 있는 수단이 없다.\n- Member 생성 시 닉네임을 입력하게 할 것인가?\n\n### MemberPart\n\n- Member 는 곡 하나 당 MemberPart 하나만 만들 수 있는가?\n- MemberPart 는 여전히 나한테만 보이는 Part 인가?\n- MemberPart 이름 변경 필요 혼란스러움.\n- song_id 가지고 있을 것인가?\n    - 노래 하나당 한 번만 등록할 수 있다면 어떻게 그것을 DB에서 판별할 것인가?\n    - song_id 없으면 조인 해야 함.\n\n### KillingPartLike\n\n- Member 를 ArgumentResolver 에서 파싱해서 주면 어떨까\n- LikeRepository 메서드 변경 의견\n    - pressLike → like\n    - cancelLike → unlike\n\n### Song\n\n- Song 은 Part 없이 만들어질 수 있는가?\n- Song 에 score 라는 반정규화 컬럼을 추가할 것인가? (성능 이슈 때문에)\n    - **전체 PartCount 를 합한 값을 저장한다.**\n    - 어떻게 정렬 기준을 정할 것인가?\n- 좋아요 / 파트 등록 / 취소가 될 때마다 Song 에 score 를 증가/감소 시키는 이벤트 발행이 필요\n- 좋아요 순 노래 조회 시, Repository 에서 Part 가 포함되는 경우, 양방향 의존을 갖게 되는 문제가 있다.\n- Genre 와 Song 은 다대다 아닌가?\n\n### Artist\n\n- Song 과 다대다인가?\n- Song 애그리거트와 분리해야 하는가? → 일단 분리 안 하는 것으로 결론\n- (같은 애그리거트인 경우) 양방향 관계를 가질 경우 중간 테이블을 두거나 해서 노래 중복 데이터를 없애야 함.\n\n### 기타\n\n- Synonym 추가를 위한 Admin 페이지 개발\n- 이벤트 재시도 로직을 어떻게 구현할 것인가\n    - 이벤트 큐 - kafka\n    - 재시도 로직 직접 구현\n"},{"excerpt":"2023-12-01 2023-12-04 2023-12-05 2023-12-07 2023-12-10 2023-12-11 2023-12-14","fields":{"slug":"/2023-12/"},"frontmatter":{"date":"2023년 12월 07일 12:12","title":"2023년 12월","tags":["TIL"]},"rawMarkdownBody":"\n- [[2023-12-01]]\n- [[2023-12-04]]\n- [[2023-12-05]]\n- [[2023-12-07]]\n- [[2023-12-10]]\n- [[2023-12-11]]\n- [[2023-12-14]]"},{"excerpt":"TODO 컴퓨터 네트워킹 하향식 접근 2장 마무리하기   [scheduled:: 2023-12-06]  [completion:: 2024-06-16T19:15] LCA 정리하기 3584번 풀기 17435번 풀기 11438번 풀기 에이블리 지원 완료 LOG 배운 것 모든 정수는 2의 거듭제곱의 합으로 표현될 수 있다. lca 를 학습했다. 느낀 것 lca …","fields":{"slug":"/2023-12-07/"},"frontmatter":{"date":"2023년 12월 07일 05:12","title":"2023년 12월 07일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 컴퓨터 네트워킹 하향식 접근 2장 마무리하기   [scheduled:: 2023-12-06]  [completion:: 2024-06-16T19:15]\n- [x] LCA 정리하기\n- [x] 3584번 풀기\n- [x] 17435번 풀기\n- [x] 11438번 풀기\n- [x] 에이블리 지원 완료\n\n## LOG\n\n## 배운 것\n\n- 모든 정수는 2의 거듭제곱의 합으로 표현될 수 있다.\n- [[lca]] 를 학습했다.\n\n## 느낀 것\n\n- lca 는 좀 어렵다…"},{"excerpt":"LCA 알고리즘이란? 두 정점 u, v 에서 가장 가까운 공통 조상을 찾는 알고리즘을 말한다. 일반적인 LCA 풀이 루트 노드를 기준으로, DFS 탐색을 하며 각 노드의 트리의 depth 와 부모 노드를 저장한다. LCA 를 구하기 위한 a, b번 노드가 주어지면, 해당 두 노드의 상위 노드를 조회하며 노드의 h 를 같은 높이로 맞춘다. 각 부모 노드가 …","fields":{"slug":"/lca/"},"frontmatter":{"date":"2023년 12월 06일 11:12","title":"최소 공통 조상 (Lowest Common Ancestor)","tags":["algorithms"]},"rawMarkdownBody":"\n## LCA 알고리즘이란?\n\n두 정점 u, v 에서 가장 가까운 공통 조상을 찾는 알고리즘을 말한다.  \n\n## 일반적인 LCA 풀이\n\n1. 루트 노드를 기준으로, DFS 탐색을 하며 각 노드의 트리의 depth 와 부모 노드를 저장한다. \n2. LCA 를 구하기 위한 a, b번 노드가 주어지면, 해당 두 노드의 상위 노드를 조회하며 노드의 h 를 같은 높이로 맞춘다. \n3. 각 부모 노드가 일치할 때까지 비교하며 구한다. (최상위 LCA는 루트노드인 1)\n\n이러한 풀이를 매우 편향된 트리에 적용하게 되면, 엄청나게 많은 반복 횟수로 값을 구해야 한다는 단점이 있다.\n\n```python\nimport sys  \n  \nsys.setrecursionlimit(10 ** 5)  \ninput = sys.stdin.readline  \n  \n  \nclass Node:  \n    def __init__(self, key):  \n        self.key = key  \n        self.parent = None  \n  \n  \ndef get_depth(node):  \n    depth = 0  \n    while node is not None:  \n        node = node.parent  \n        depth += 1  \n    return depth  \n  \n  \ndef find_lca(node1, node2):  \n    # 두 노드의 깊이를 맞춥니다.  \n    depth1 = get_depth(node1)  \n    depth2 = get_depth(node2)  \n    while depth1 > depth2:  \n        node1 = node1.parent  \n        depth1 -= 1  \n    while depth2 > depth1:  \n        node2 = node2.parent  \n        depth2 -= 1  \n  \n    # 두 노드가 만날 때까지 부모를 따라 올라갑니다.  \n    while node1 != node2:  \n        node1 = node1.parent  \n        node2 = node2.parent  \n  \n    return node1  \n  \n  \nt = int(input().strip())  \nfor _ in range(t):  \n    n = int(input().strip())  \n    graph = [Node(i) for i in range(n + 1)]  \n    for _ in range(n - 1):  \n        a, b = map(int, input().strip().split())  \n        graph[b].parent = graph[a]  \n    one, two = map(int, input().strip().split())  \n    node = find_lca(graph[one], graph[two])  \n    print(node.key)\n```\n\n노드 객체를 생성하는 데 $O(N)$, 트리를 구성하기 위해 n-1 개의 간선에 대해 루프를 돌며 부모 노드를 설정하는 데 $O(N)$ 이 걸린다. \n\n`get_depth` 함수는 한 노드의 루트 깊이를 찾는 데 $O(h)$ 의 시간이 걸린다. 두 노드에 대해 이를 수행하기 때문에, 최악의 경우 $O(2h)$ 가 된다.  \n\n트리가 균형적으로 구성되어 있으면 h 는 $logN$ 에 가깝지만, 최악의 경우 h 는 n에 가까워진다. 따라서 전체 시간 복잡도는 $O(n + 2h)$ 가 되며, 최악의 경우 $O(2n)$ 이 걸릴 수 있다.  \n\n## 비트마스킹과 DP 로 LCA 구하기\n\nLCA 의 시간 복잡도를 결정하는 것은 각 노드의 깊이를 구하는 과정과 LCA 를 구하는 과정이다.  \nDP 를 사용하면 각 노드의 깊이를 구하는 과정의 시간 복잡도는 증가하지만, LCA 를 구하는 쿼리의 시간 복잡도를 효과적으로 줄일 수 있다.  \n\n### 구현\n\n```python\nimport math  \n  \n  \nclass Node:  \n    def __init__(self, value, children=None):  \n        self.value = value  \n        self.children = children if children is not None else []  \n  \n  \nclass LCAFinder:  \n    def __init__(self, root, n):  \n        self.max_depth = math.ceil(math.log2(n))  \n        self.ancestor = [[-1 for _ in range(self.max_depth)] for _ in range(n)]  \n        self.depth = [0] * n  \n        self.dfs(root, -1, 0)  \n  \n    def dfs(self, node, parent, depth):  \n        if node is None:  \n            return  \n        self.ancestor[node.value][0] = parent  \n        self.depth[node.value] = depth  \n        for child in node.children:  \n            self.dfs(child, node.value, depth + 1)  \n        for i in range(1, self.max_depth):  \n            if self.ancestor[node.value][i - 1] != -1:  \n                self.ancestor[node.value][i] = self.ancestor[self.ancestor[node.value][i - 1]][i - 1]  \n  \n    def find_lca(self, u, v):  \n        if self.depth[u] < self.depth[v]:  \n            u, v = v, u  \n        for i in range(self.max_depth - 1, -1, -1):  \n            if self.depth[u] - (1 << i) >= self.depth[v]:  \n                u = self.ancestor[u][i]  \n        if u == v:  \n            return u  \n        for i in range(self.max_depth - 1, -1, -1):  \n            if self.ancestor[u][i] != self.ancestor[v][i]:  \n                u = self.ancestor[u][i]  \n                v = self.ancestor[v][i]  \n  \n        return self.ancestor[u][0]\n```\n\n### 설명\n\n- 왜 $2^i$ 번째 조상을 찾기 위해 $2^{i-1}$ 번째 조상의 $2^{i-1}$ 번째 조상이 필요할까?\n\n트리가 다음과 같이 구성되어 있다고 가정하자.  \n\n```markdown\n         1\n       /   \\\n      2     3\n     / \\   / \\\n    4   5 6   7\n```\n\n각 노드의 $2^0$ 번째 조상은 자기 자신의 부모 노드이므로, `self.ancestor[node.value][0]` 은 `parent` 이다.  \n노드 4의 $2^1$ 번째 조상을 찾기 위해, 먼저 노드 4의 $2^0$ 번째 조상인 노드 2를 찾는다. 그러고 나서, 노드 2의 $2^0$ 번째 조상인 노드 1을 찾는다. 즉, 노드 4의 $2^1$번째 조상은 노드 1이다. 결국 찾고자 하는 노드의 $2^{i-1}$ 번째 조상의 다시 $2^{i-1}$ 조상을 찾게 되면 $2^{i-1} + 2^{i-1} = 2^i$ 로 찾고자 하는 노드의 $2^i$ 번째 조상을 찾을 수 있다. \n\n그렇다면 $2^i$ 번째 조상이 존재하지 않을 때는 어떻게 될까?\n\n노드 4의 $2^2$번째 조상을 찾기 위해, 먼저 노드 4의 $2^1$ 번째 조상인 노드 1을 찾는다. 그리고 나서, 노드 1의 $2^1$번째 조상을 찾는다. 하지만 노드 1은 루트 노드이므로 더 이상 조상이 없기 때문에, 노드 4의 $2^2$ 번째 조상은 존재하지 않는다. \n\n- `find_lca` 에서 첫 번째 반복문을 지났을 때 u, v 의 깊이는 언제나 같은가?\n\n`find_lca` 에서 첫 번째 for 문을 지나고 나면, 반드시 u와 v의 깊이는 같아진다.  \n`depth[u]` 에서 `1 << i` 값을 뺀 값이 여전히 `depth[v]` 보다 깊다면 조상 노드로 거슬러 올라가는 과정을 계속해서 진행하는데, 이때 모든 정수는 2의 거듭제곱으로 표현 가능하기 때문에 해당 반복문을 지나고 나면 반드시 u, v는 같아지게 된다. u의 깊이가 v보다 깊은 경우에는 이미 조상 노드로 거슬러 올라가기 때문이다.  \n\n## K 번째 조상으로 거슬러 올라가기\n\n```python\nfor j in range(max_depth):  \n    if k & (1 << j):  \n        u = parent[u][j]\n```\n\n## 중요한 것\n\ni 번째 노드의 j 번째 조상이 갖는 값을 어떻게 추상화할 지 고민해야 한다.  \n\n### K 번째 조상까지 가는 길의 cost 계산하기\n\n먼저 sparse table 을 초기화해야 한다. \n\n```python\nfor j in range(1, max_depth):  \n    for i in range(1, n + 1):  \n        j_1th_parent = parent[i][j - 1]  \n        way_costs[i][j] = way_costs[i][j - 1] + way_costs[j_1th_parent][j - 1]  \n```\n\n`way_costs[i][j]` 란 i 번째 노드의 $2^j$ 번째 조상이 가지고 있는 cost 를 의미한다.  \n해당 값은 i 번째 노드의 $2^{j-1}$ 번째 조상이 가지고 있는 cost + i 번째 노드의 $2^{j-1}$ 조상 노드에서 $2^{j-1}$ 조상까지의 cost 로 표현할 수 있다.  \n이렇게 값을 계산할 때도 $log(N)$ 으로 효율적으로 계산하기 위해서는 계산할 값의 sparse table 도 필요하다. \n\n```python\ndef print_cost(u, v):  \n    lca = find_lca(u, v)  \n    u_diff, v_diff = depth[u] - depth[lca], depth[v] - depth[lca]  \n    total = 0  \n    for j in range(max_depth):  \n        if u_diff & (1 << j):  \n            total += way_costs[u][j]  \n            u = parent[u][j]  \n        if v_diff & (1 << j):  \n            total += way_costs[v][j]  \n            v = parent[v][j]  \n    print(total)\n```\n\n올라갈 때는 k 에 해당하는 cost 를 계산하며 올라가준다.  "},{"excerpt":"표현 we do know that 49 climbers were evacuated on Monday. 단어 casualties: 사상자 fertility: 출산력 (가임 연령의 여성 수에 대한 일년 동안의 출생수의 비율) strand: 꼼짝 못하게 하다. 놓치다. tidy: 정돈하다 figurative: 비유적인 unaccounted for: 행방불명의 …","fields":{"slug":"/english-speaking-dec-1week/"},"frontmatter":{"date":"2023년 12월 05일 10:12","title":"12월 1주차 영어 회화","tags":null},"rawMarkdownBody":"\n## 표현\n\n- we do know that 49 climbers were evacuated on Monday.\n\n## 단어\n\n- casualties: 사상자\n- fertility: 출산력 (가임 연령의 여성 수에 대한 일년 동안의 출생수의 비율)\n- strand: 꼼짝 못하게 하다. 놓치다.\n- tidy: 정돈하다\n- figurative: 비유적인\n- unaccounted for: 행방불명의\n- evacuate: 대피시키다"},{"excerpt":"TODO 포트폴리오 다듬기   [scheduled:: 2023-12-04]  [completion:: 2024-06-16T19:15] 위상정렬 문제 하나 풀기 LOG 배운 것 느낀 것","fields":{"slug":"/2023-12-05/"},"frontmatter":{"date":"2023년 12월 04일 15:12","title":"2023년 12월 05일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 포트폴리오 다듬기   [scheduled:: 2023-12-04]  [completion:: 2024-06-16T19:15]\n- [x] 위상정렬 문제 하나 풀기\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO 링글 수업 준비 LOG 딜리버리 히어로 1차 면접을 완료했다. 솔직히 동문서답한 거 엄청 많고 문제도 막 잘 푼 건 아닌 거 같지만… 그래도 마음은 후련하다! 베이리스 인턴 자소서를 제출했다. 제발 되게 해주세요… 인턴으로 그만 고생하고 싶어요 🥲 배운 것 위상 정렬에 대해 정리했다. 느낀 것 후련하다!","fields":{"slug":"/2023-12-04/"},"frontmatter":{"date":"2023년 12월 04일 08:12","title":"2023년 12월 04일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n- [x] 링글 수업 준비\n\n## LOG\n\n- 딜리버리 히어로 1차 면접을 완료했다. 솔직히 동문서답한 거 엄청 많고 문제도 막 잘 푼 건 아닌 거 같지만… 그래도 마음은 후련하다!\n- 베이리스 인턴 자소서를 제출했다. 제발 되게 해주세요… 인턴으로 그만 고생하고 싶어요 🥲\n\n## 배운 것\n\n- [[topological-sorting|위상 정렬]]에 대해 정리했다.\n\n## 느낀 것\n\n- 후련하다!"},{"excerpt":"위상 정렬이란? 방향 그래프에서 간선으로 주어진 정점 간 선후관계를 위배하지 않도록 정렬하는 것이다. 특징 Directed Acyclic Graph 에만 적용이 가능하다. 즉, 사이클이 발생하지 않는 방향 그래프에서만 사용할 수 있다. 그래프에 사이클이 있으면서 두 정점 u, v 가 사이클 속에 위치한 정점일 경우, 정점 u가 정점 v보다 먼저 오거나, …","fields":{"slug":"/topological-sorting/"},"frontmatter":{"date":"2023년 12월 03일 08:12","title":"위상 정렬","tags":["algorithms"]},"rawMarkdownBody":"\n## 위상 정렬이란?\n\n방향 그래프에서 간선으로 주어진 정점 간 선후관계를 위배하지 않도록 정렬하는 것이다. \n\n## 특징\n\nDirected Acyclic Graph 에만 적용이 가능하다. 즉, 사이클이 발생하지 않는 방향 그래프에서만 사용할 수 있다.\n\n그래프에 사이클이 있으면서 두 정점 u, v 가 사이클 속에 위치한 정점일 경우, 정점 u가 정점 v보다 먼저 오거나, v가 u보다 먼저 올 수 있기 때문이다. (주어진 정점 간 선후관계의 모순이 발생한다.)\n\n## 구현\n\n1. in-degree 가 0인 노드를 큐에 넣는다.  \n2. 큐가 빌 때까지 다음의 과정을 반복한다.  \n\t1. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다. \n\t2. 새롭게 진입차수가 0이 된 노드를 큐에 삽입한다. \n\n즉, 각 노드가 큐에 들어온 순서가 위상 정렬을 수행한 결과가 된다. \n\n2252 번 줄 세우기 문제의 답과 동일하다.\n\n```python\nfrom collections import defaultdict, deque  \n  \nn, m = map(int, input().split())  \ngraph = defaultdict(list)  \nin_degree = [0] * (n + 1)  \nfor _ in range(m):  \n    a, b = map(int, input().split())  \n    graph[a].append(b)  \n    in_degree[b] += 1  \nqueue = deque()  \nresult = []  \nfor i in range(1, n + 1):  \n    if in_degree[i] == 0:  \n        queue.append(i)  \n        result.append(i)  \n  \nwhile queue:  \n    prev = queue.popleft()  \n    for node in graph[prev]:  \n        in_degree[node] -= 1  \n        if in_degree[node] == 0:  \n            queue.append(node)  \n            result.append(node)  \n  \nprint(*result)\n```"},{"excerpt":"TODO LOG 처음으로 내 손으로 플레4 문제를 풀었다! 너무너무 뿌듯한 걸 배운 것 trie 에 대해서 배웠다. 개념은 쉬운데 여기저기 써먹을 수 있는 알고리즘 같다. 느낀 것","fields":{"slug":"/2023-12-01/"},"frontmatter":{"date":"2023년 12월 01일 12:12","title":"2023년 12월 01일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 처음으로 내 손으로 플레4 문제를 풀었다! 너무너무 뿌듯한 걸\n\n## 배운 것\n\n- [[trie]] 에 대해서 배웠다. 개념은 쉬운데 여기저기 써먹을 수 있는 알고리즘 같다.\n\n## 느낀 것"},{"excerpt":"트라이란? 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조.\n문자열을 탐색할 때 전부 비교하며 탐색하는 것보다 시간 복잡도 측면에서 훨씬 더 효율적이다. 그러나 각 노드에서 자식에 대한 포인터들을 배열로 모두 저장하고 있기 때문에 저장 공간의 크기가 커서 메모리 측면에서는 비효율적일 수 있다. 구현 시간 복잡도 제일 긴 문자열의 길이가 ,…","fields":{"slug":"/trie/"},"frontmatter":{"date":"2023년 12월 01일 11:12","title":"트라이 알고리즘","tags":["algorithms"]},"rawMarkdownBody":"\n## 트라이란?\n\n문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조. \n문자열을 탐색할 때 전부 비교하며 탐색하는 것보다 시간 복잡도 측면에서 훨씬 더 효율적이다.  \n\n그러나 각 노드에서 자식에 대한 포인터들을 배열로 모두 저장하고 있기 때문에 저장 공간의 크기가 커서 메모리 측면에서는 비효율적일 수 있다. \n\n## 구현\n\n```python\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.children = dict()\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.head = Node(None)\n\n    def insert(self, string):\n        current_node = self.head\n        for char in string:\n            if char not in current_node.children:\n                current_node.children[char] = Node(char)\n            current_node = current_node.children[char]\n        current_node.is_end = True\n```\n\n## 시간 복잡도\n\n제일 긴 문자열의 길이가 $L$, 총 문자열의 수를 $M$ 이라고 할 때 시간복잡도는 다음과 같다.  \n\n- 생성 시 시간복잡도: $O(M*L)$, 모든 문자열을 넣어야 하니 $M$개에 대해 트라이에 넣는 것은 가장 긴 문자열 길이만큼 걸리니 $O(M*L)$ 이다. 삽입 자체는 $O(L)$\n- 탐색 시 시간 복잡도: $O(L)$. 트리를 타고 들어가봤자 가장 긴 문자열의 길이만큼만 탐색한다. "},{"excerpt":"표현 그것은 영어로 수행된다. It’s done / conducted / given in English 나는 다른 나라의 사람들과 함께 일할 것이다. I will work with people from other countries. 나는 우리가 캠을 켜야 한다고 추측한다. I guess we have to be on camera. in real time …","fields":{"slug":"/english-speaking-nov-4week/"},"frontmatter":{"date":"2023년 11월 30일 14:11","title":"11월 4주차 영어 회화","tags":["english"]},"rawMarkdownBody":"\n## 표현\n\n- 그것은 영어로 수행된다.\n\t- It’s done / conducted / given in English\n- 나는 다른 나라의 사람들과 함께 일할 것이다.\n\t- I will work with people from other countries. \n- 나는 우리가 캠을 켜야 한다고 추측한다.\n\t- I guess we have to be on camera.\n- in real time != in live\n\t- in live 는 live streaming 이나 broadcasting 의 느낌이 더 강하다.\n- speak of the devil: 호랑이도 제 말하면 온다.\n- 나는 누군가에게 전화를 받았다.\n\t- I **got a call** **from** someone\n- 들다: pick up\n- 누군가를 목적으로 하는 scam 이다.\n\t- It’s a scam that target older people.\n- 나와 동일한 포지션에 지원한 지원자는 12명이다. \n\t- There are twelve applicants who applied for the same position as me.\n- 나는 대학원에 갈 계획이다.\n\t- I’m planning to get my masters.\n- 나는 휴학을 2년 연장할 수 있다.\n\t- I can extend my leave of absence for two more years.\n\n## 단어\n\n- 답답하다\n\t- musty\n\t- stuffy\n- 바르다 / (옷을) 쓰다 / 차다 / 입다 : put on\n- 기름진\n\t- (피부가): oily\n\t- 그 외: greasy\n- 초봉: starting/base salary\n- 나는 유로로 급여를 받을 것이다.\n\t- I will ==be paid== in Euro.\n- 나는 매달 7일 돈을 받는다.\n\t- I’m paid on the 7th each/per month.\n- 우리는 언제 급여를 받아?\n\t- When will we be paid?\n- in-person == offline\n- get a raise: 인상하다\n- leave of absence: 휴학"},{"excerpt":"집에 어떻게 가지? How do I get home? 집에서 학교까지 얼마나 걸릴까? How do I get from my house to school? 이건 오늘 안에 끝내야 해. This needs to be done today. EC2 를 설정할 때 문제가 발생했다. I had a problem setting up EC2 집에 도착해서 네트워크 공부…","fields":{"slug":"/english-speaking-pattern-11-28/"},"frontmatter":{"date":"2023년 11월 30일 13:11","title":"11/28 영어 문장 구조 연습","tags":["english"]},"rawMarkdownBody":"\n- 집에 어떻게 가지?\n\t- How do I get home?\n- 집에서 학교까지 얼마나 걸릴까?\n\t- How do I get from my house to school?\n- 이건 오늘 안에 끝내야 해.\n\t- This needs to be done today.\n- EC2 를 설정할 때 문제가 발생했다.\n\t- I had a problem setting up EC2\n- 집에 도착해서 네트워크 공부를 할 거야.\n\t- I will study the network when I get home.\n- 나는 그 문제의 해결 방법을 고민했다.\n\t- I thought about how to solve that problem.\n- 나는 친구들과의 약속을 잊어버렸어.\n\t- I forgot an appointment with my friends.\n- 점심으로 무엇을 먹을까?\n\t- What's for lunch? / What to have for lunch?\n- 이 문제는 너무 어려워서 풀기 힘들어.\n\t- This problem is too hard to solve.\n- 오늘 풀어야 하는 문제를 다 풀었어.\n\t- I've solved all the problems I needed to solve today.\n- 내 생각에는 이 부분에서 문제가 있을 것 같다.\n\t- I think this part may occur a problem.\n\t- I think this is where the problem lies.\n- 이 역에서 내려야 해\n\t- I need to get off at this station.\n- 오늘은 영어 수업이 있는 날이야\n\t- Today is English class day\n- 이 문제를 어떻게 해결할 수 있을까?\n\t- How can we solve this problem?\n- 이 문제에 대해 어떻게 생각해?\n\t- 내 문장: How do you think about this problem?\n\t- What do you think about this issue? / What are you thoughts on this issue?\n- 날씨가 추워져서 옷을 껴입어야 해.\n\t- 내 문장: As the weather is cold, I need to put on more clothes.\n\t- It's getting cold and I need to bundle up.\n- 지금부터 공부를 하자.\n\t- 내 문장 Let's study from now.\n\t- Let's get to work\n- 내일은 젠킨스에 대해 공부해올게\n\t- I'll study about jenkins tomorrow\n\t- Tomorrow I'll study jenkins\n- 우리는 오늘까지 이 일을 마무리해야 해.\n\t- We need to finish this work today.\n\t- We need to wrap this up by today\n- 여러 가지 일이 있었지만 결국 우리는 해냈다.\n\t- There were many things but finally we accomplished.\n\t- It was a lot of work, but we did it.\n- 방금 질문은 멍청한 질문이었어요.\n\t- I think previous question is dumb question.\n\t- That was a dumb question to ask.\n- 알고리즘을 공부하는 것은 어렵지만 흥미롭다. \n\t- Studying algorithms is difficult but interesting.\n\t- Studying algorithms is challenging but interesting.\n- 우리는 우리 서비스의 쿼리를 최적화해야 해.\n\t- We need to optimize our service's queries.\n\t- We need to optimize the queries of our service.\n- 나는 그 부분에서 문제가 발생할 것이라고 예측했다.\n\t- I guessed the part can make the problem.\n\t- I predicted that's where I would run into trouble.\n\t- I predicted that would be a problem. (What's the difference?)\n- 나는 그 문제를 해결하기 위해 fetch join 을 사용했다.\n\t- I used the fetch join to solve the problem. / I used fetch join to fix the problem.\n- 나는 영어 공부를 하는 것은 긴 터널을 걷는 것과 같다고 생각한다.\n\t- I think studying english is the same as walking into the long tunnel.\n\t- I believe that learning English is like walking through a long tunnel.\n- 불변식은 여기서 성립해야 한다.\n\t- The invariant should be established here.\n- 나는 코딩 테스트 공부를 열심히 해야 한다.\n\t- I need to study hard coding test.\n\t- I need to study hard for my coding test.\n- 삽입 정렬은 거의 정렬된 배열을 정렬할 때 효과적이다.\n\t- Insertion sort is effective when I sort the nearly sorted array.\n\t- Insertion sorting works well for sorting nearly sorted arrays.\n- 우리 회의 언제해야 할까?\n\t- When should we get meeting?\n\t- When should we have our meeting?\n- 나는 인터뷰 할 아직 마음의 준비가 안 됐어.\n\t- I'm not quite ready for the interview.\n- 나는 아침을 먹으면 안 된다.\n\t- I should not have / eat breakfast\n- 다음에 당신 남자친구와 함께 만나요.\n\t- Let's meet next with your boyfriend \n\t- I'll see you and your boyfriend next time.\n- 내게 경험을 기록하는 것은 중요한 일이다.\n\t- It is important for me to note my experience.\n\t- It's important to me to document my experiences\n- 발이 시렵다.\n\t- My foot is cold.\n\t- My feet are itchy.\n- 나는 지금 이걸 찾아봐야 해\n\t- I need to find this now\n\t- I need to look this up now\n- 내일은 리크루터 콜이 있는 날이야.\n\t- Tomorrow is recruiter call day.\n\t- Tomorrow is the day of the recruiter call. \n- 내가 어떤 팀에 채용되는지는 인터뷰를 하면서 알게 되나요?\n\t- Do I know what team want me when I proceed the interview process?\n\t- Will I find out what team I'm being hired for during my interview?\n- **모든 지원자가 모든 채용 프로세스를 진행할 수 있나요? 아니면 1차 면접에 합격한 사람들만 2차 면접을 진행할 수 있나요?**\n\t- Can all candidates proceed the whole hiring process? Or Can only the people who accepted in the first interview proceed the second tech interview?\n\t- Can all candidates go through the entire hiring process? Or can only those who pass the first round of interview proceed to the second round?\n- 아무것도 아니야.\n\t- Nothing.\n\t- It's nothing.\n- 너는 그 회사에 가고 싶어?\n\t- Do you want to be hired by the company?\n\t- Do you want to work for that company?\n- 나는 열정적인 동료가 있는 회사, 적극적으로 소통할 수 있는 회사에서 일하고 싶다.\n\t- I want to work for the company where have passionate companions and can communicate actively with them.\n\t- I want to work for a company with passionate coworkers and with whom I can actively communicate.\n- 나는 그 정도 연봉은 합리적이라고 생각합니다.\n\t- I think that salary is reasonable\n- 나는 이제 궁금한 것이 없습니다.\n\t- I don't have any questions now.\n\t- I have no questions now.\n- 나는 어떤 것을 물어봐야 할 지 잘 모르겠습니다.\n\t- Well, I don't know what I will ask.\n\t- I'm not sure what to ask.\n- 그 부분은 제 생각과 약간 다릅니다.\n\t- The part is little different to my thought.\n\t- The part is a little different than I thought.\n- **답변하는 것이 어렵네요. 조금 더 생각해보고 말씀드려도 될까요?**\n\t- Responding to the question is quite hard. Would you mind I think a little more?\n\t- I'm having a hard time answering this, can I think about it a bit more?\n\t- I'm having a hard time answering that question, can I give it a little more thought?\n- 나는 영어로 생각하는 것을 열심히 하려고 노력했다.\n\t- I tried my best to think in English.\n\t- I tried hard to think in English.\n- 여러 가지 문장을 생각하는 것은 영어 공부에 도움이 되었다.\n\t- Thinking about various sentences was useful for learning english.\n\t- Thinking about various sentences helped me learn English.\n- **내가 도저히 문장을 생각해내지 못할 때에는 번역기로 한국어 문장을 영어로 번역했다.**\n\t- When I had a hard time to think about the sentence, I translated the Korean sentence into the English sentence using a translator.\n\t- When I couldn't come up with a sentence, I used a translator to translate the Korean sentence into English.\n- 나는 어제 리크루터 콜을 받았다.\n\t- I received the recruiter call yesterday.\n\t- I got a recruiter call yesterday.\n- 나는 링글이라는 1대 1 화상 영어 공부 플랫폼으로 매주 영어로 말하는 것을 연습해오고 있다.\n\t- I practiced speaking in english using the ringle which is the one-to-one online english study platform for every week.\n\t- I've been practicing speaking English every week with a one-on-one video English learning platform called Ringle.\n\t- I've been practicing speaking English every week with a one-on-one video English study platform called Ringle. (Which one is more fluent?)\n- 어떤 것이 더 자연스럽습니까?\n\t- Which one is more fluent?\n\t- Which is more natural?\n- 말할 때는 억양도 중요하다고 생각한다. 억양을 먼저 연습하는 것이 좋을까 아니면 유창하게 말하는 것을 연습하는 것이 좋을까?\n\t- I think intonation is important when I speak in Enlgish. What is better for me whether practicing intonation or practicing to speak fluently?\n\t- I think intonation is also imporatant when speaking. Is it better to work on intonation first or to work on speaking fluently?\n- 내 말이 정리되지 않았을 때, 생각할 시간을 달라는 말을 어떻게 하면 정중하게 말할 수 있을까?\n\t- When I can't organize words, How can I ask formally can you give me more minutes?\n\t- How do I politely ask for time to think when my words are not organized?\n- 나는 단어는 충분히 알고 있는 것 같은데, 단어를 조합하는 것이 어렵다.\n\t- I think I know sufficient words, but it is difficult to me to combine words.\n\t- I seem to know the words well enough, but putting them together is the hard part.\n- 나는 Shelby 가 한국어를 잘한다고 생각한다.\n\t- I think Shelby is good at speaking in Korean.\n\t- I think Shelby speaks Korean well.\n- 네가 말한 것이 옳은 것 같다.\n\t- It seems right what you told.\n\t- I think what you said is correct. / It looks like what you said is correct.\n- 내가 느끼기에 영어로 생각하는 것을 연습하기 전보다 영어 문장이 잘 떠오르는 것 같다.\n\t- As I feel, I can come up with english sentences well than when I don't practivie thinking in english.\n\t- I feel like I can think of English sentences better than before I started practicing thinking in English.\n- 나는 특정한 문장들을 외우는 것이 영어 공부에 도움이 된다고 느꼈다.\n\t- I felt like memorizing specific sentences helped me learn english.\n\t- I found that memorizing certain sentences helped me learn English.\n- 조언을 해준 당신에게 감사하다.\n\t- I appreciate you to give advices. (advices 가 아니군)\n\t- Thanks to you for the advice.\n- 벌써 11시가 되었다.\n\t- It's already eleven.\n- 나는 할 일을 거의 다 한 것 같다.\n\t- It seems like I did almost all works which I have to do.\n\t- I think I've pretty much done what I needed to do.\n- **나는 내일 건강검진 때문에 빵을 먹고 싶지만 참아야 한다.**\n\t- I want to eat some bread now, but I shouldn't eat because of tomorrow's health check.\n\t- I want to eat bread, but I have to hold back because I will have a medical checkup.\n\t- bojun: I want to eat bread, but I can't. Because I'll have a medical checkup tomorrow.\n- 오늘은 시간이 빨리 갔다.\n\t- Time flew by today. / Time has flow today.\n- 그렇지만 나는 내일 링글 수업 예습을 해야 한다.\n\t- But I need to preview for the tomorrow Ringle class.\n\t- I have to do some preliminary work for my Ringle class tomorrow.\n- 난 이제부터 물도 마시면 안 된다.\n\t- I shouldn't drink water since now.\n\t- I shouldn't even drink water from now on.\n- 나는 내일 병원 예약을 취소해야 한다.\n\t- I need to cancel the reservation of hospital tomorrow.\n\t- I need to cancel my doctor's appointment tomorrow.\n"},{"excerpt":"TODO LOG 내일은 DH 면접일이다. 과연… 어떻게 될 것인가… 최근에 하는 게임에서 멋진 용이 나와서 샀다. 굉장히 만족스러운 소비였다. 배운 것 느낀 것 약을 안 먹는 시간에는 꽤 졸리고 멍하다는 사실을 알게 됐다. 내일 병원에 가니 이 부분에 대해서 여쭤봐야 할 것 같다.","fields":{"slug":"/2023-11-30/"},"frontmatter":{"date":"2023년 11월 30일 10:11","title":"2023년 11월 30일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 내일은 DH 면접일이다. 과연… 어떻게 될 것인가…\n- 최근에 하는 게임에서 멋진 용이 나와서 샀다. 굉장히 만족스러운 소비였다.\n\n## 배운 것\n\n## 느낀 것\n\n- 약을 안 먹는 시간에는 꽤 졸리고 멍하다는 사실을 알게 됐다. 내일 병원에 가니 이 부분에 대해서 여쭤봐야 할 것 같다."},{"excerpt":"면접 준비 잘 모르는 부분인데, 설명을 부탁드려도 될까요? I'm not familiar with this, could you explain it to me? 내 생각에는 이 부분을 바꾸면 동작할 것 같습니다. I think changing this part should make it work. 시간 복잡도는 O log N 입니다. The time com…","fields":{"slug":"/english-speaking-pattern-11-30/"},"frontmatter":{"date":"2023년 11월 30일 09:11","title":"11/30 영어 문장 구조 연습","tags":["english"]},"rawMarkdownBody":"\n## 면접 준비\n\n- 잘 모르는 부분인데, 설명을 부탁드려도 될까요?\n\t- I'm not familiar with this, could you explain it to me?\n- 내 생각에는 이 부분을 바꾸면 동작할 것 같습니다.\n\t- I think changing this part should make it work. \n- 시간 복잡도는 O log N 입니다.\n\t- The time complexity is O log N\n- 내 풀이에 잘못된 부분이 있을까요?\n\t- Is there anything wrong with my solution?\n- 만약 내가 이분 탐색을 사용한다면 시간 복잡도를 줄일 수 있습니다.\n\t- If I use binary search, I can reduce the time complexity.\n- 만약 값이 커진다면 문제가 발생할 수도 있습니다.\n\t- If the size of the array increases, it could lead to problems.\n- Java 의 ArrayList 의 삽입은 O(1) 의 시간 복잡도를 갖습니다.\n\t- The insertion in Java’s ArrayList has a time complexity of O of one.\n- 간단한 자기소개를 해주세요.\n\t- 저는 지난 주에 우아한형제들에서 진행하는 Tech Academy 인 우아한테크코스를 수료했습니다. 현재 백엔드 개발과 Java 에 관심을 가지고 있습니다.\n\t- Last week, I completed the woowa tech course, a tech academy program conducted by woowa bros. Currently, I’m interested in backend development and Java.\n\n## 기술\n\n- 백엔드에 관심을 갖게 되신 이유는 무엇인가요?\n\t- 저는 화면에 보이는 것보다는 뒤에서 데이터를 가공하고 조작하는 것이 더 흥미로웠습니다. 그러다보니 자연스럽게 백엔드에 관심을 갖게 되었습니다.\n\t- I found myself more interested in processing and manipulating data behind the scenes than what appears on the screen. As a result, I naturally became interested in backend development.\n- Java 를 사용하신 이유는 무엇인가요?\n\t- Java 는 다양한 환경에서 호환된다는 것이 장점이고, 객체지향 프로그래밍을 채택하여 코드 재사용성, 유지보수성, 확장성에서 이점이 있습니다. 또한 방대한 레퍼런스로 디버깅이 용이합니다. 그래서 자바를 사용하게 되었습니다. \n\t- A key advantage of Java is its compatibility across various environments, and its adoption of object-oriented programming provides benefits in terms of code reusability, maintainability, and scalability. Additionally, its extensive references make debugging more easy. That’s why we chose to use Java.\n- Spring 을 사용하신 이유는 무엇인가요?\n\t- Spring 은 IoC나 DI 같은 개발자가 기능을 편하게 개발할 수 있는 기능들을 제공해줍니다. 그리고 무엇보다 팀원들이 스프링에 가장 익숙하다는 점이 선택하게 된 가장 큰 이유입니다.\n\t- Spring provides features like IoC and DI that make it convenient for developers to build functionalities. Moreover, the most significant reason for choosing it is that our team members are most familiar with Spring.\n- DBMS 란 무엇인가요?\n\t- 데이터베이스를 운영하고 관리하는 소프트웨어이다. \n\t- DBMS is the software to operate and manage databases.\n- 트랜잭션이란 무엇인가요?\n\t- 하나의 논리적인 작업 단위를 의미한다. 트랜잭션을 통해 데이터의 정확성과 신뢰성을 보장할 수 있다.\n\t- It represents a single logical unit of work. Through transactions, the accuracy and reliability of data can be ensured. \n- ACID 속성에 대해 이야기 해보세요.\n\t- 먼저 트랜잭션은 원자적이어야 한다. 트랜잭션은 전부 완료되거나 전혀 실행되지 않는 둘 중의 하나의 상태만을 가진다. 두 번째로 일관적이어야 한다. 트랜잭션이 실행되기 전과 후의 데이터베이스의 일관성이 유지되어야 한다. 세 번째로 독립적이어야 한다. 동시에 실행되는 여러 트랜잭션이 서로에게 영향을 주면 안 된다. 마지막으로 지속적이어야 한다. 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 데이터베이스에 반영되어야 한다. \n\t- Firstly, a transaction must be atomic. It should either be fully completed or not executed at all. Secondly, it should be consistent. The consistency of the database should be maintained before and after the transacion. Thirdly, it should be isolated. Multiple transactions running concurrently should not affect each other. Lastly, it needs to be durable. If a transaction successfully completed, the result must be permanently reflected in the database. \n- OOP 의 장점은 무엇인가요?\n\t- 어떤 지점의 변화가 다른 지점에 영향을 끼치는 것을 줄일 수 있다. \n\t- \bIt can reduce the impact of changes at one point affecting other points. \n- OOP 의 단점은 무엇인가요?\n\t- 우리는 객체지향을 지키기 위해 과도하게 복잡한 설계를 할 수도 있으니 주의해야 한다. 또한 확장성을 높이기 위해 복잡성을 증가시킬 수 있다는 단점도 있다.\n\t- We need to be careful not to adopt excessively complex designs in our effort to adhere to object-oriented principles. Additionally, there is a disadvantage in that increasing complexity to enhance scailability is also possible.\n\n## 프로젝트\n\n### 답변\n\n- 어떤 서비스를 개발하셨나요?\n\t- 저는 노래의 좋은 부분을 사람들과 공유하고, 그 과정에서 노래를 빠르게 찾을 수 있는 서비스를 개발했습니다.\n\t- I have developed a service that allows people to share the best parts of songs and quickly find the good song in the process.\n- 서비스의 구조를 설명해보세요.\n\t- 먼저 서비스는 2개의 인스턴스로 구성되어 있습니다. 2개는  production 서버 하나와 데이터베이스 서버 하나입니다. production 서버는 nginx 와 스프링 서버, self hosted runner 로 구성되어 있습니다. 데이터베이스는 MySQL 을 사용했습니다.\n\t- First, our service consists of two EC2 instances. First is the production server, second is a database server. The production server consists of nginx, spring application, github self hosted runner. And we used MySQL as DBMS.\n- 서비스에서 발생한 문제는 무엇이었고, 어떻게 해결했나요?\n\t- 데이터베이스에서 정렬이 필요한 쿼리가 있었는데, 이 쿼리의 실행 시간이 너무 오래걸리는 문제가 있었다. 해당 쿼리에서 자주 사용하는 데이터를 로컬에 캐싱하여 실행 시간을 줄일 수 있었다.\n\t- There was a query that required sorting whole datas in database. In that case, the problem was that the query took too long to execute. We were able to reduce the execution time by caching the frequently used data from that query locally. \n- 그 쿼리의 속도는 얼마 정도였나요?\n\t- 1만 개의 항목 중 21개 항목을 가져오려고 시도하는 데 약 310밀리초가 걸렸습니다. 캐싱을 적용하고 나서 31ms 로 개선되었습니다. / 캐싱을 적용하고 나서 10배의 성능 개선을 할 수 있었습니다.\n\t- When attempting to retrieve twenty-one items out of ten thousand, it took approximately three-hundred ten milliseconds. After applying the caching, it improved to thirty-one milliseconds. / After applying the caching, we can achieve  a tenfold improvement in performance.\n- 어떻게 캐싱을 적용했나요?\n\t- 단순하게 서버에 id 와 데이터로 이루어진 Map 을 생성해서 데이터를 저장하는 방식을 선택했다.\n\t-  I selected straightforward method involving the establishment of Map on the server. It consists of identifiers and corresponding data.\n- 동시성 문제가 있을 것 같은데 어떻게 해결했나?\n\t- 그 부분은 아직 해결 중이다. synchronized 키워드를 사용하거나 ReentrantLock 을 사용하여 동시성을 해결해볼 예정이다. \n\t- We are still solving the problem. We plan to address the concurrency issue by using the syncrhonized keyword or by employing ReentrantLock.\n- 정확한 원리는 모르지만 아는 대로 설명하겠습니다.\n\t- I don’t know the exact principle, but I will explain as much as I know.\n- 물어보고 싶은 게 있습니다. I have something I would like to ask.\n- 팀에서 갈등 상황이 있었을 때 어떻게 해결했나요?\n\t- 팀원들이 프로젝트에 쏟을 수 있는 시간이 다르다는 문제가 있었습니다. 그런 문제가 있었을 때 다른 팀원들은 이 주제에 대해 말하기 망설였습니다. 저는 이 문제가 심각하다고 생각했고, 그래서 적극적으로 회의를 주최했습니다. 회의를 하는 동안 이 문제에 대해 깊게 이야기했습니다. 회의가 끝나고 나서, 우리는 합의할 수 있었습니다. 많은 문제가 있을 때는 솔직하게 대화하는 것이 중요하다고 생각합니다.\n\t- \"There was an issue where team members had different amounts of time they could dedicate to the project. When such a problem arose, other team members hesitated to speak about this topic. I thought this issue was serious, so I proactively organized a meeting. During the meeting, we discussed this issue in depth. After the meeting, we were able to reach an agreement. I believe that honest communication is important when there are many problems.\n- 우아한테크코스에서 뭘 배웠나요?\n\t- 개발을 공부하는 방법을 알 수 있었습니다. 또한 주위의 사람들과 대화하면서 다양한 관점을 배울 수 있었다는 것이 가장 큽니다.\n\t- I learned how to study programming, and most importantly, I learned different perspectives by talking to people around me.\n\n## etc\n\n- I want to work for a company with passionate coworkers and with whom I can actively communicate.\n- I’m looking forward to this interview.\n- 지원 동기\n\t- I believe that Delivery Hero will expose me to a variety of problems and allow me to solve them. I applied because I want to work in a new environment with different people. \n\n## 질문\n\n- 딜리버리 히어로에서 어떤 일을 하시나요?\n\t- What do you do at Delivery Hero?\n- 어떤 문제들을 주로 해결하시나요?\n\t- What kinds of problems do you mainly solve?\n- 인터뷰 결과는 언제 안내 되나요?\n\t- When will the results of the interview be announced?"},{"excerpt":"TODO LOG 배운 것 느낀 것 kmp 왤케 어렵냐 실패 함수 쓰는 거는 익숙해져야 잘 쓸 수 있을 거 같다… 홧팅","fields":{"slug":"/2023-11-29/"},"frontmatter":{"date":"2023년 11월 29일 08:11","title":"2023년 11월 29일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n## 느낀 것\n\n- kmp 왤케 어렵냐 실패 함수 쓰는 거는 익숙해져야 잘 쓸 수 있을 거 같다… 홧팅"},{"excerpt":"네트워크 애플리케이션의 원리 네트워크 애플리케이션 개발의 중심은 다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램을 작성하는 것이다. 여러분이 새로운 애플리케이션을 개발할 때는 여러 종단 시스템에서 실행되는 소프트웨어를 작성해야 한다. 중요한 것은 우리가 라우터나 링크 계층 스위치처럼 네트워크 코어 장비에서 실행되는 소프트웨어까…","fields":{"slug":"/top-down-approach-ch2/"},"frontmatter":{"date":"2023년 11월 27일 11:11","title":"2. 애플리케이션 계층","tags":["컴퓨터-네트워킹-하향식-접근"]},"rawMarkdownBody":"\n## 네트워크 애플리케이션의 원리\n\n네트워크 애플리케이션 개발의 중심은 다른 위치의 종단 시스템에서 동작하고 네트워크를 통해 서로 통신하는 프로그램을 작성하는 것이다.  \n\n여러분이 새로운 애플리케이션을 개발할 때는 여러 종단 시스템에서 실행되는 소프트웨어를 작성해야 한다. 중요한 것은 우리가 라우터나 링크 계층 스위치처럼 네트워크 코어 장비에서 실행되는 소프트웨어까지 작성할 필요는 없다는 점이다. \n\n이와 같이 종단 시스템에만 애플리케이션 소프트웨어가 존재한다는 기본 설계 방식은 인터넷 애플리케이션들이 빠르고 널리 발전하는 원동력이 되었다. \n\n### 네트워크 애플리케이션 구조\n\n애플리케이션 구조는 네트워크 구조와 분명히 다르다. **애플리케이션 구조**는 애플리케이션 개발자가 설계하며, 또한 애플리케이션이 다양한 종단 시스템에서 어떻게 조직되어야 하는지를 알려준다. \n애플리케이션 구조를 선택할 때 애플리케이션 개발자는 현대 네트워크 애플리케이션에서 사용되는 두 가지 잘 알려진 구조 중 하나로 선택할 수 있다.\n\n**클라이언트-서버 구조**에서 항상 동작하고 있는 호스트를 *서버*라고 부르는데, 서버와의 서비스는 *클라이언트*라는 다른 호스트들로부터 서비스 요청을 보낸다 . \n클라이언트-서버 구조에서 클라이언트는 서로 직접적으로 통신하지 않는다. 또한 클라이언트-서버 구조에서는 서버가 고정 IP 주소라는 잘 알려진 주소를 갖는다는 것이다. 서버는 항상 동작하고 있으므로 클라이언트는 서버 주소로 패킷을 보내서 언제든지 서버에 연결할 수 있다. \n\n때로는 클라이언트-서버 애플리케이션에서 하나의 서버 호스트가 자신의 클라이언트로부터 오는 모든 요청에 다 응답하는 것은 불가능하다. 이러한 이유로 많은 수의 호스트를 갖춘 **데이터 센터**가 강력한 가상의 서버를 생성하는 역할로 사용된다. \n\n**P2P 구조**에서는 항상 켜져 있는 인프라스트럭처 서버에 최소로 의존하거나 전혀 의존하지 않는다. 대신에 애플리케이션은 *피어*라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하게 한다. 피어는 서비스 제공자가 소유하지 않고, 사용자들이 제어하는 데스크탑과 랩탑이다.  \n특정 서버를 통하지 않고 피어가 통신하므로, 해당 구조를 peer-to-peer 라고 한다.  \nP2P 구조는 자가 확장성이라는 특성을 갖는다. 또한 P2P 구조는 일반적으로 상당한 서버 인프라스트럭처와 서버 대역폭을 요구하지 않기 때문에 비용 효율적이다.  \n그러나 고도의 분산 구조 특성으로 인해 보안, 성능, 신뢰성 면에서 도전을 맞이하고 있다. \n\n### 프로세스 간 통신\n\n운영체제 용어에서 실제 통신하는 것은 프로그램이 아니라 **프로세스**다. 프로세스는 종단 시스템에서 실행되는 프로그램이다.  \n통신 프로세스가 같은 종단 시스템에서 실행될 때 그들은 서로 프로세스 간에 통신한다.   \n\n2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 **메시지** 교환으로 서로 통신한다.  \n송신 프로세스는 메시지를 만들어서 네트워크로 보낸다. 수신 프로세스는 메시지를 받고 역으로 메시지를 보냄으로써 응답한다.\n\n#### 클라이언트와 서버 프로세스\n\n네트워크 애플리케이션은 네트워크에서 서로 메시지를 보내는 두 프로세스로 구성된다.  \n통신하는 프로세스 각 쌍에 대해 일반적으로 클라이언트의 프로세스와 서버의 프로세스 중 하나로 이름을 짓는다.  \n\n> 두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 클라이언트라고 하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.\n\n#### 프로세스와 컴퓨터 네트워크 사이의 인터페이스\n\n대부분의 애플리케이션은 두 프로세스가 메시지를 서로에게 보내는 통신 프로세스 쌍으로 구성된다.  \n하나의 프로세스로부터 다른 프로세스로 보내는 메시지는 네트워크를 통해 움직인다.  \n\n프로세스는 **소켓**을 통해 네트워크로 메시지를 보내고 받는다.  \n소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스다.  \n또한 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, 애플리케이션과 네트워크 사이의 API 라고도 한다.  \n\n애플리케이션은 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만, 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다.  \n트랜스포트 계층에 대한 애플리케이션 개발자의 통제는 (1) 트랜스포트 프로토콜의 선택, (2) 최대 버퍼와 최대 세그먼트 크기 같은 약간의 트랜스포트 계층 매개변수의 설정뿐이다.  \n\n#### 프로세스 주소 배정\n\n한 호스트상에서 수행되고 있는 프로세스가 패킷을 다른 호스트에서 수행되고 있는 프로세스로 패킷을 보내기 위해서는 수신 프로세스가 주소를 갖고 있을 필요가 있다.  \n\n수신 프로세스를 식별하기 위해서는 다음과 같은 두 가지 정보가 명시되어야 한다.\n1. 호스트의 주소\n2. 목적지 호스트 내의 수신 프로세스를 명시하는 식별자\n\n인터넷에서 호스트는 IP 주소로 식별된다. IP 주소는 32비트로 구성되며, 호스트를 유일하게 식별한다.  \n메시지가 전달되어야 하는 호스트의 주소를 아는 것과 더불어 송신 호스트는 수신 호스트에서 수행되고 있는 수신 프로세스도 식별해야 한다. 목적지 포트 번호는 일반적으로 한 호스트가 많은 네트워크 애플리케이션을 수행할 수 있기 때문에 사용된다.  \n\n### 애플리케이션이 이용 가능한 트랜스포트 서비스\n\n송신 측의 애플리케이션은 소켓을 통해 메시지를 보낸다. 소켓의 반대편에서 트랜스포트 프로토콜은 네트워크를 통해 그 메시지를 수신 프로세스의 소켓으로 이동시킬 책임이 있다. \n\n인터넷을 포함해서 많은 네트워크는 하나 이상의 트랜스포트 프로토콜을 제공한다. 애플리케이션을 개발할 때는 사용 가능한 트랜스포트 프로토콜 중에서 하나를 선택해야 한다.  \n\n트랜스포트 계층 프로토콜은 넓은 범위에서 신뢰적 데이터 전송, 처리율, 시간, 보안이라는 네 가지 차원의 서비스를 제공할 수 있다. \n\n#### 신뢰적 데이터 전송\n\n전자메일, 파일 전송, 원격 호스트 접속, 재무 애플리케이션 같은 애플리케이션의 경우 데이터의 손실이 위험한 결과를 초래할 수 있다. 이를 위해 트랜스포트 계층 프로토콜은 프로세스 간 **신뢰적 데이터 전송** 서비스를 제공할 수 있다.  \n트랜스포트 프로토콜이 이 서비스를 제공할 때, 송신 프로세스는 데이터를 소켓으로 보내고, 그 데이터가 오류 없이 수신 프로세스에 도착할 것이라는 확신을 갖는다.   \n\n트랜스포트 계층 프로토콜이 신뢰적 데이터 전송을 제공하지 않을 때, 송신 프로세스가 보낸 데이터는 수신 프로세스에 전혀 도착하지 않을 수 있다. 이는 **손실 허용 애플리케이션**의 경우, 즉, 어느 정도의 데이터 손실을 참아낼 수 있는 실시간 오디오/비디오 혹은 저장 오디오/비디오 같은 멀티미디어 애플리케이션에서는 받아들여질 수 있다. \n\n#### 처리율\n\n처리율은 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율을 나타낸다.  \n다른 세션들이 네트워크 경로를 따라 대역폭을 공유하고, 이 세션들이 생겼다 없어졌다 하기 떄문에 가용한 처리율은 시간에 따라 변동한다.  \n\n애플리케이션은 r비트/초 의 보장된 처리율을 요구할 수 있고, 트랜스포트 프로토콜은 가용한 처리율이 항상 적어도 r bps 임을 보장한다.  \n\n처리율 요구 사항을 갖는 애플리케이션은 대역폭 민감 애플리케이션이라고 한다. 반면 탄력적 애플리케이션은 가용한 처리율을 많으면 많은 대로 적으면 적은 대로 이용할 수 있다. 전자메일, 파일 전송, 웹 전송이 융통성 있는 애플리케이션이다. \n\n#### 시간\n\n트랜스포트 계층 프로토콜은 시간 보장을 제공할 수 있다.  \n인터넷 전화, 가상 환경, 원격회의, 다자간 게임과 같은 실시간 상호작용 애플리케이션이 효과적으로 동작하기 위해서는 데이터 전송에 엄격한 시간 제한 조건이 요구된다.  \n\n비실시간 애플리케이션의 경우 낮은 지연이 항상 높은 지연보다 선호되지만 종단 간 지연에 엄격한 제약을 받는 것은 아니다. \n\n#### 보안\n\n트랜스포트 프로토콜은 애플리케이션에 하나 이상의 보안 서비스를 제공할 수 있다.  \n\n송신 호스트에서 트랜스포트 프로토콜은 송신 프로세스가 전송하는 모든 데이터를 암호화할 수 있고, 수신 호스트에서 트랜스포트 프로토콜은 그 데이터를 수신 프로세스로 전달하기 전에 데이터의 암호를 해독할 수 있다.   \n이러한 서비스는 데이터가 송신과 수신 프로세스 사이에서 어느 정도 관찰된다 하더라도 두 프로세스 사이에 기밀성을 제공한다. 그 외에도 데이터 무결성과 종단 인증 등을 포함할 수 있다. \n\n### 인터넷 전송 프로토콜이 제공하는 서비스\n\n인터넷은 애플리케이션에게 2개의 전송 프로토콜, 즉 UDP (User Datagram Protocol) 와 TCP (Transmission Control Protocol) 을 제공한다.  \n\n#### TCP 서비스\n\nTCP 서비스 모델은 연결지향형 서비스와 신뢰적인 데이터 전송 서비스를 포함한다. \n\n- 연결지향형 서비스: 애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하게 한다. 이러한 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도달할테니 준비하라고 알리는 역할을 한다. 핸드셰이킹 단계 후, **TCP 연결**이 두 프로세스의 소켓 사이에 존재한다고 말한다. 이 연결은 두 프로세스가 서로에게 동시에 메시지를 보낼 수 있기에 전이중 (full-duplex) 연결이라고 한다. 애플리케이션이 메시지 전송을 마치면 연결을 끊어야 한다.\n- 신뢰적인 데이터 전송 서비스: 통신 프로세스는 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP 에 의존한다. TCP 는 애플리케이션의 한 쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림이 손실되거나 중복되지 않게 수신 소켓으로 전달한다. \n\n또한 TCP 는 혼잡 제어 방식, 즉 통신하는 프로세스의 직접 이득보다는 인터넷의 전체 성능 향상을 위한 서비스를 포함한다.\n\n#### UDP 서비스\n\nUDP 는 최소의 서비스 모델을 가진 가장 간단한 전송 프로토콜이다.  \nUDP 는 비연결형이므로 두 프로세스가 통신을 하기 전에 핸드셰이킹을 하지 않는다.  \nUDP 는 비신뢰적인 데이터 전송 서비스를 제공한다. 즉, 하나의 프로세스가 UDP 소켓으로 메시지를 보내면, UDP 는 그 메시지가 수신 소켓에 도착하는 것을 보장하지 않는다. 게다가 수신 소켓에 도착하는 메시지들의 순서가 뒤바뀔 수도 있다.  \n\nUDP 는 혼잡 제어 방식을 포함하지 않는다. 따라서 UDP 의 송신 측은 데이터을 원하는 속도로 하위 계층(네트워크 계층)으로 보낼 수 있다.\n\n#### 인터넷 트랜스포트 프로토콜이 제공하지 않는 서비스\n\nTCP 는 신뢰적 종단 간 데이터 전송을 제공하며, 보안 서비스를 제공하기 위해 애플리케이션 계층에서 TLS 를 통해 쉽게 강화될 수 있다.  \n\n그러나 TCP 와 UDP 에서 처리율 혹은 시간 보장에 대한 언급은 빠졌다.  \n그렇지만 인터넷은 여러 해 동안 시간 민감 애플리케이션을 서비스해오고 있고, 그런 보장이 없는 경우에도 가능한 한 잘 대처할 수 있도록 설계되었기 때문에 상당히 잘 작동하고 있다. 그럼에도 불구하고 현명한 설계도 공중 인터넷에서 흔히 있는 경우처럼 지연이 과도할 때는 한계가 있다.  \n즉, 오늘날의 인터넷은 때로 시간 민감 애플리케이션에게 만족스러운 서비스를 제공할 수는 있으나 시간 혹은 대역폭 보장을 제공할 수 없다.  \n\n인터넷 전화 애플리케이션은 보통 패킷 손실을 허용하지만 효율성을 위해 최소의 전송률을 필요로 하기 때문에 인터넷 전화 애플리케이션 개발자들은 일반적으로 UDP 상에서 자신들의 애플리케이션을 수행하는 것을 선호하며, 그렇게 함으로써 TCP 의 혼잡 제어 방식과 패킷 오버헤드를 회피할 수 있다. 그러나 많은 방화벽이 UDP 트래픽을 차단하도록 설정되어 있기 때문에, 인터넷 전화 애플리케이션은 UDP 통신이 실패할 경우를 대비하여 TCP 를 사용하도록 설계되어 있다. \n\n### 애플리케이션 계층 프로토콜\n\n**애플리케이션 계층 프로토콜**은 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의한다.  \n\n- 교환 메시지 타입 (ex. 요청 메시지와 응답 메시지)\n- 여러 메시지 타입의 문법 (ex. 메시지 내부의 필드와 필드 간의 구별 방법)\n- 필드의 의미, 즉 필드에 있는 정보의 의미\n- 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙\n\n여러 애플리케이션 계층 프로토콜은 RFC에 명시되어 있으므로 공중 도메인에서 찾을 수 있다. ex. HTTP  \n다른 많은 애플리케이션 계층 프로토콜은 독점이며 (비개방적임) 공중 도메인에서 구할 수 없다. \n\n애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 요소일 뿐이다. \n\n### 이 책에서 다루는 네트워크 애플리케이션\n\n- 웹\n- 전자메일\n- 디렉터리 서비스, DNS\n- P2P 애플리케이션, CDN\n\n## 웹과 HTTP\n\n### HTTP 개요\n\n웹의 애플리케이션 계층 프로토콜인 **HTTP(HyperText Transfer Protocol)** 은 웹의 중심이다.  \n\nHTTP 는 클라이언트 프로그램과 서버 프로그램으로 구현된다. 각기 다른 종단 시스템에서 수행되는 클라이언트와 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다. HTTP 는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의하고 있다.\n\n- 웹 페이지는 객체들로 구성된다.\n- 객체는 단순히 단일 URL로 지정할 수 있는 하나의 파일이다.\n\n대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다.  \n\n`http://www.someSchool.edu/someDepartment/picture.gif`\n\n여기에서 `www.someSchool.edu` 는 호스트 이름이고, `/someDepartment/picture.gif` 는 경로 이름이다. \n\n**웹 브라우저**는 HTTP의 클라이언트 측을 구현하기 때문에 웹의 관점에서 브라우저와 클라이언트라는 용어를 혼용해서 사용할 것이다.  \nHTTP의 서버 측을 구현하는 웹 서버는 URL로 각각을 지정할 수 있는 웹 객체를 갖고 있다.  \n\nHTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다. \n\nHTTP는 **TCP**를 전송 프로토콜로 사용한다. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다. 연결이 이루어지면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다.  \n클라이언트 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP 응답을 받는다. 마찬가지로 HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.  \nHTTP 는 데이터의 손실 또는 TCP가 어떻게 손실 데이터를 복구하고 네트워크 내부에서 데이터를 올바른 순서로 배열하는지 걱정할 필요가 없다. 이것은 TCP와 프로토콜 스택의 하위 계층들이 하는 일이다. \n\nHTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로, HTTP를 **비상태 프로토콜 (stateless protocol)**이라고 한다.  \n\n현재 HTTP 트랜잭션의 대부분은 HTTP/1.1 을 사용하고 있지만, 점차 많은 브라우저와 웹 서버가 HTTP/2 를 지원하고 있다.  \n\n### 비지속 연결과 지속 연결\n\n클라이언트-서버 상호작용이 TCP 상에서 발생할 때 애플리케이션 개발자는 중요한 결정을 해야 한다.  \n각 요구/응답 쌍이 *분리된* TCP 연결을 통해 보내져야 하는가? 혹은 모든 요구와 해당하는 응답들이 *같은* TCP 연결 상으로 보내져야 하는가?  \n\n전자 방식을 비지속 연결이라고 하고, 후자 방식을 지속 연결이라고 한다.  \nHTTP는 디폴트 모드로 지속 연결을 사용하지만 HTTP 클라이언트와 서버는 비지속 연결을 사용하도록 설정될 수 있다. \n\n#### 비지속 연결 HTTP\n\n페이지가 기본 HTML 파일과 10개의 JPEG 이미지로 구성되고, 이 11개의 객체가 같은 서버에 있다고 가정하자.  \n\n```\nhttp://www.someSchool.edu/someDepartment/home.index\n```\n\n연결 수행 과정은 다음과 같다. \n\n1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80을 통해 `www.someSchool.edu` 서버로 TCP 연결을 시도한다. TCP 연결과 관련하여 클라이언트와 서버에 각각 소켓이 있게 된다. \n2. HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다. 이 요청 메시지는 `/someDepartment/home.index` 경로 이름을 포함한다. \n3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메시지를 받는다. 저장 장치로부터 `/someDepartment/home.index` 객체를 추출한다. HTTP 응답 메시지에 그 객체를 캡슐화한다. 그리고 응답 메시지를 소켓을 통해 클라이언트로 보낸다. \n4. HTTP 서버는 TCP 에게 TCP 연결을 끊으라고 한다. (그러나 실제로 TCP 클라이언트가 응답 메시지를 올바르게 받을 때까지 연결을 끊지 않는다.)\n5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다. 메시지는 캡슐화된 객체가 HTML 파일인 것을 나타낸다. 클라이언트는 응답 메시지로부터 파일을 추출하고 HTML 파일을 조사하고 10개의 JPEG 객체에 대한 참조를 찾는다.\n6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복한다. \n\n```ad-info\nTCP 클라이언트가 응답 메시지를 올바르게 받을 때까지 연결을 끊지 않는 이유는 신뢰성 있는 데이터 전송을 보장하기 위해서이다. \n\n서버가 연결을 끊기 전에 클라이언트가 모든 데이터 패킷을 올바르게 받았는지 확인해야 한다. \n```\n\nHTTP/1.0 은 비지속 연결을 지원한다. 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다. 따라서 이 예시에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결이 만들어진다.  \n\n클라이언트가 기본 HTML 파일을 요청하고 그 파일이 클라이언트로 수신될 때까지의 시간을 측정해보자. 이를 위해 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간인 RTT (round-trip time) 를 정의한다.  \nRTT는 패킷 전파 지연, 중간 라우터와 스위치에서의 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다.  \n\n사용자가 하이퍼링크를 클릭하면 브라우저가 브라우저와 웹 서버 사이에 TCP 연결을 시도하게 한다. 이는 three-hand way shake 를 포함한다. 즉, 클라이언트가 작은 TCP 메시지를 서버로 보내고, 서버는 작은 메시지로 응답하고, 마지막으로 클라이언트가 다시 서버에게 응답한다.  (91p 참고)\n따라서 총 응답 시간은 2 RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간을 더한 것이다. \n\n#### 지속 연결 HTTP\n\n비지속 연결은 몇 가지 단점이 있다.  \n\n1. *각 요청 객체*에 대한 새로운 연결이 설정되고 유지되어야 한다. TCP 버퍼가 할당되어야 하고, TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다. 이는 수많은 클라이언트 요청을 동시에 서비스하는 웹 서버에게 심각한 부담을 줄 수 있다.\n2. 앞서 언급한 대로 각 객체는 2 RTT를 필요로 한다.\n\nHTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다. 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다. 특히, 전체 웹 페이지를 하나의 지속 TCP 연결을 통해 보낼 수 있다. 또한 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다.  \n이들 객체에 대한 요구는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다.  \n\n일반적으로 HTTP 서버는 일정 기간(타임 아웃 기간) 사용되지 않으면 연결을 닫는다. 서버가 연속된 요구를 수신할 때, 서버는 객체를 연속해서 보낸다. HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용한다. \n\n### HTTP 메시지 포맷\n\n#### HTTP 요청 메시지\n\n```http\nGET /somedir/page.html HTTP/1.1\nHost: www.someshool.edu\nConnection: close\nUser-agent: Mozilla/5.0\nAccept-language: fr\n```\n\nHTTP 요청 메시지의 첫 줄은 **요청 라인**이라고 하고, 이후의 줄들을 **헤더 라인**이라고 부른다.  \n요청 라인은 3개의 필드, 즉 method 필드, URL 필드, HTTP 버전 필드를 갖는다.  \n방식 필드는 GET, POST, HEAD, PUT, DELETE 를 포함하는 여러 가지 값을 가질 수 있다.  \n\nHost 는 객체가 존재하는 호스트를 명시하고 있다. 호스트 헤더 라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다. \nConnection 은 브라우저가 서버에게 지속 연결 사용을 원하지 않는다는 것을 말하고 있다.  \nUser-agent 는 서버에게 요청하는 브라우저 타입을 명시하고 있다.  \nAccept-language 헤더는 사용자가 객체의 프랑스어 버전을 원하고 있음을 나타낸다. 이것이 존재하지 않으면 서버는 기본 버전을 보낸다.  \n\nHEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답하는데, 요청 객체는 보내지 않는다.  \n애플리케이션 개발자는 흔히 디버깅을 위해 HEAD 방식을 많이 사용한다. \nPUT 방식은 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용된다.  \nDELETE 방식은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다. \n\n#### HTTP 응답 메시지\n\n```http\nHTTP/1.1 200 OK\nConnection: close\nDate: Tue, 18 Aug 2015 15:44:05 GMT\nServer: Apache/2.2.3 (CentOS)\nLast-Modified: Tue, 18 Aug 2015 15:11:03 GMT\nContent-Length: 6821\nContent-Type: text/html\n\n(데이터 데이터 데이터 데이터 데이터 ...)\n```\n\n**초기 상태 라인**, 6개의 **헤더 라인**, **개체 몸체**로 이루어져 있다.  \n개체 몸체는 요청 객체를 포함한다.  \n상태 라인은 3개의 필드, 즉 프로토콜 ‘버전 필드’, ‘상태 코드’, ‘해당 상태 메시지’를 갖는다.  \n상태 라인은 서버가 HTTP/1.1 을 사용하고 있고, 모든 것이 양호함을 나타낸다.  \n\n1. Connection: 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는 데 사용\n2. Date: HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다. 서버가 파일 시스템으로부터 객체를 추출하고 응답 메시지에 그 객체를 삽입하여 응답 메시지를 보낸 시간을 의미한다. \n3. Server: 메시지가 아파치 웹 서버에 의해 만들어졌음을 나타낸다. \n4. Last-Modified: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다. 객체를 로컬 클라이언트와 네트워크 캐시 서버 캐싱에 매우 중요하다. \n5. Content-Length: 송신되는 객체의 바이트 수를 나타낸다. \n6. Content-Type: 개체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다. \n\n### 사용자와 서버 간의 상호작용: 쿠키\n\n서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원하므로 웹사이트가 사용자를 확인하는 것이 바람직할 때가 있다. 이를 위해 HTTP 는 **쿠키**를 사용한다. \n\n쿠키 기술은 다음과 같은 요소들을 가지고 있다.\n\n1. HTTP 응답 메시지 쿠키 헤더 라인\n2. HTTP 요청 메시지 쿠키 헤더 라인\n3. 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일\n4. 웹사이트의 백엔드 데이터베이스\n\nHTTP 응답 메시지에 `Set-Cookie` 헤더는 식별 번호를 담는다. HTTP 요청에는 `Cookie` 에 쿠키의 식별 번호를 포함하는 쿠키 헤더 파일을 넣는다.  \n\n쿠키는 사용자 식별에 사용할 수 있다. 즉, 비상태 HTTP 위에서 사용자 세션 계층을 생성하는 데 이용될 수 있다. \n\n### 웹 캐싱\n\n**웹 캐시 (프록시 서버)** 는 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체다. 웹 캐시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다. \n\n1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다. \n2. 웹 캐시는 객체의 사본이 자신에게 저장되어 있는지 확인한다. 만일 저장되어 있다면 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다. \n3. 만약 웹 캐시가 객체를 갖고 있지 않으면, 웹 캐시는 기점 서버로 TCP 연결을 설정한다. 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 이런 요청을 받은 후에 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다. \n4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다. \n\n캐시는 서버이면서 클라이언트이다.  \n일반적으로 웹 캐시는 ISP 가 구입하고 설치한다. \n\n웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다. 특히 클라이언트와 기점 서버 사이의 병목 대역폭이 클라이언트와 캐시 사이의 병목 대역폭에 비해 매우 작을 때 더욱 효과적이다.  \n웹 캐시는 한 기관에서 인터넷으로의 접속하는 링크상의 웹 트래픽을 대폭 줄일 수 있다. 또한 웹 캐시는 인터넷 전체의 웹 트래픽을 실질적으로 줄임으로써 모든 애플리케이션을 위한 성능을 개선한다. \n\n**콘텐츠 전송 네트워크 (Content Distribution Network, CDN)** 의 사용을 통해 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다. CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며, 이를 통해 많은 트래픽을 지역화하고 있다. \n\n#### 조건부 GET\n\n웹 캐싱은 사용자가 느끼는 응답 시간을 줄일 수 있지만, 새로운 문제를 야기한다. 캐시 내부에 있는 객체의 복사본이 새 것이 아닐 수 있다는 것이다.  \n\nHTTP 는 클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서도 캐싱을 하게 해주는 방식을 갖고 있다. 이를 **조건부 GET** 이라고 한다. \n\nHTTP 요청 메시지가 GET 방식을 사용하고, `If-Modified-Since` 헤더라인을 포함하고 있다면, 조건부 GET 메시지이다. \n\n조건부 GET 은 다음과 같이 동작한다.  \n\n1. 브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보낸다. \n2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다. \n3. 캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게도 객체를 저장한다. 캐시는 객체와 더불어 마지막으로 수정된 날짜를 함께 저장한다. \n4. 브라우저는 조건부 GET으로 갱신 조사를 수행한다. `If-modified-since: Wed, 9 Sep 2015 09:23:24` 의 헤더 라인을 보냈을 때 웹 서버가 응답 메시지에 요청된 객체를 포함하지 않는 경우, 이는 클라이언트에게 요청 객체의 캐싱된 복사본을 사용하라는 것을 의미한다.\n\n### HTTP/2\n\n2015년에 표준화된 HTTP/2 는 1997년에 표준화된 HTTP/1.1 이후 새로운 첫 번째 HTTP 버전이다.  \n\nHTTP/2의 주요 목표는 하나의 TCP 연결 상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는 데 있으며, 요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다. 클라이언트와 서버 간의 데이터 포맷 방법과 전송 방법도 변경되었다.  \n\nHTTP/1.1은 지속적인 TCP 연결을 이용하여 하나의 TCP 연결 상에서 서버로부터 클라이언트로 보내지는 웹 페이지를 허용한다. 웹 페이지당 오직 하나의 TCP 연결을 가짐으로써, 서버의 소켓 수를 줄이며 전송되는 각 웹 페이지는 공정한 데이터 대역폭을 가질 수 있다.  \n\n그러나 하나의 TCP 상에서 웹 페이지에 있는 모든 객체를 보내면 **HOL (Head of Line) 블로킹** 문제가 발생할 수 있다.\n\n큰 비디오 클립이 위치하고, 비디오 아래 많은 수의 작은 객체들을 포함하는 하나의 웹 페이지를 생각해보자. 또한 서버와 클라이언트 사이에 저속에서 중간 속도의 병목 링크가 있다고 가정했을 때, 하나의 TCP 연결을 사용하면 비디오 클립은 병목 링크를 통과하는 데 오랜 시간이 걸리지만 작은 객체들은 비디오 객체 뒤에서 기다림이 길어진다. 즉, 비디오 클립이 뒤에 오는 작은 객체들을 블로킹하게 되는 것이다. \n\nHTTP/1.1 브라우저에서는 여러 개의 병렬 TCP 연결을 열어서 HOL 블로킹 문제를 해결해왔다. TCP 혼잡 제어 또한 하나의 지속적인 연결 대신 여러 개의 병렬 TCP 연결을 사용함으로써 브라우저에게 예상치 못한 혜택을 주게 된다. TCP 혼잡 제어는 각 TCP 연결이 공정하게 병목 링크를 공유하여 같은 크기의 가용한 대역폭을 공평하게 나누게 해준다. 많은 HTTP/1.1 브라우저들은 6개까지 병렬 TCP 연결을 열 수 있으며 HOL 블로킹을 막을 뿐만 아니라 더 많은 대역폭을 사용할 수 있게 해준다. \n\nHTTP/2 의 주요 목표는 하나의 웹 페이지를 전송하기 위한 병렬 TCP 연결의 수를 줄이거나 제거하는 데 있다.  \n\n#### HTTP/2 의 프레이밍\n\nHTTP/2는 각 메시지를 작은 프레임으로 나누고, 같은 TCP 연결에서의 요청과 응답 메시지를 인터리빙한다. HTTP 메시지를 독립된 프레임으로 쪼개고 인터리빙하고 반대편 사이트에서 재조립하는 것이야말로 HTTP/2의 가장 중요한 개선점이다.  \n\n프레이밍은 HTTP/2 프로토콜의 프레임으로 구현된 다른 프레이밍 서브 계층에 의해 이루어진다. 응답은 프레이밍 서브 계층에 의해 처리되며 프레임들로 나눠지고, 응답의 헤더 필드는 하나의 프레임이 되며 메시지 본문은 하나의 프레임으로 쪼개진다. 응답 프레임들은 서버의 프레이밍 서브 계층에 의해 인터리빙된 후 하나의 지속적인 TCP 연결상에서 전송된다. 프레임들이 클라이언트에 도착하면 프레이밍 서브 계층에서 처음 응답 메시지로 재조립되며 브라우저에 의해 처리된다.  \n\n프레이밍 서브 계층은 파싱 효율성과 작은 프레임 크기, 에러에 강건한 구조를 위해 프레임을 바이너리 인코딩한다. \n\n#### 메시지 우선순위화 및 서버 푸싱\n\n메시지 우선순위화는 개발자들로 하여금 요청들의 상대적 우선순위를 조정할 수 있게 함으로써 애플리케이션의 성능을 최적화할 수 있도록 해준다.  \n\n클라이언트가 한의 특정 서버로 동시에 여러 개의 요청을 할 때, 각 메시지에 1~256 사이의 가중치를 부여함으로써 요청에 우선순위를 매길 수 있다. (높은 숫자일수록 높은 우선순위를 의미한다.) 서버는 가장 높은 우선순위의 요청을 위한 프레임을 제일 먼저 보낼 수 있고, 클라이언트 역시 각 의존도에 따라 메시지의 ID를 지정함으로써 서로 다른 메시지들 간의 의존성을 나타낼 수 있다. \n\nHTTP/2는 서버로 하여금 특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 해준다. 처음 요청에 대한 응답 외에도, 서버는 클라이언트의 요청 없이도 추가적인 객체를 클라이언트에게 *푸시*하여 보낼 수도 있다.  \n\n#### HTTP/3\n\n**QUIC** 은 UDP 프로토콜 위에 위치하는 애플리케이션 계층에 구현된 새로운 트랜스포트 프로토콜이다. 메시지 멀티플렉싱(인터리빙), 스트림별 흐름 제어, 저지연 연결 확립과 같은 HTTP 에 의미 있는 여러 특징을 갖는다. HTTP/3 은 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜이다. \n\n## 인터넷 전자메일\n\n인터넷 메일 시스템은 사용자 에이전트, 메일 서버, SMTP 라는 3가지의 주요 요소를 갖는다.  \n\n사용자 에이전트는 사용자가 메시지를 읽고, 응답하고, 전달하고, 저장하고, 구성하게 해준다.  \n\n메일 서버는 전자메일 인프라스트럭처의 중심이다. 수신자는 메일 서버 안에 메일박스를 갖고 있고, 메일박스는 수신자의 메시지를 유지하고 관리한다. 일반 메시지는 송신자의 사용자 에이전트에서 전달되고, 송신자의 메일 서버를 거친 후에 수신자의 메일 서버로 전달된 후, 수신자의 메일박스에 저장된다. 수신자의 메일 서버가 고장난 경우, 송신자의 메일 서버는 메시지를 메시지 큐에 보관하고 메시지를 전달하기 위해 재시도한다. \n\nSMTP 는 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜이다. SMTP 는 TCP 의 신뢰적인 데이터 전송 서비스를 이용한다. \n\n### SMTP\n\nSMTP 는 송신자의 메일 서버로부터 수신자의 메일 서버로 메시지를 전송한다.  \nSMTP는 여러 장점이 있으나, 낡은 특성을 가진 오래된 기술이다. 그 중 하나로, 모든 메일 메시지의 몸체는 단순한 7비트 ASCII여야 한다는 단점이 있다. \n\nSMTP 는 다음과 같이 동작한다. \n\n1. 송신자는 전자메일 사용자 에이전트를 수행하고 수신자의 전자메일 주소를 제공하고, 메시지를 작성한 뒤 사용자 에이전트에게 메시지를 보내라고 명령한다. \n2. 송신자의 사용자 에이전트는 메시지를 수신자의 메일 서버에게 보내고, 메시지는 메시지 큐에 놓인다.\n3. 송신자의 메일 서버에서 동작하는 SMTP 의 클라이언트 측은 메시지 큐에 있는 메시지를 본다. 수신자의 메일 서버에서 수행되고 있는 SMTP 서버에게 TCP 연결을 설정한다.\n4. 초기 SMTP 핸드셰이킹 이후에 SMTP 클라이언트는 송신자의 메시지를 TCP 연결로 보낸다. \n5. 수신자의 메일 서버 호스트에서 SMTP 서버 측은 메시지를 수신한다. 수신자의 메일 서버는 그 메시지를 수신자의 메일박스에 놓는다.\n6. 수신자는 편한 시간에 그 메시지를 읽기 위해 사용자 에이전트를 시동한다. \n\nSMTP 는 메시지를 송신 메일 서버에서 수신 메일 서버로 어떻게 전송할까?\n\n1. 클라이언트 SMTP 는 서버 SMTP 의 25번 포트로 TCP 연결을 설정한다. 연결이 설정되면, 서버와 클라이언트는 애플리케이션 계층 핸드셰이킹을 수행한다. \n2. SMTP 핸드 셰이킹 과정 동안에 SMTP 클라이언트는 송신자의 전자메일 주소와 수신자의 전자메일 주소를 제공한다. \n3. 클라이언트는 메시지를 전송한다.\n4. SMTP는 서버에 오류 없이 메시지를 전송하기 위해 TCP 의 신뢰적인 데이터 전송 서비스에 의존한다. \n5. 서버에 보낼 다른 메시지가 있으면 클라이언트는 이 과정을 **같은** TCP 연결 상에서 반복하고, 그렇지 않으면 TCP 에게 연결을 닫을 것을 명령한다. \n\n클라이언트는 `HELO`, `MAIL FROM`, `RCPT TO`, `DATA`, `QUIT` 명령을 내린다. 또한 클라이언트가 하나의 점으로 된 라인을 송신하면, 메시지의 끝을 의미한다.  \n\nSMTP 는 지속 연결을 사용한다. 송신 메일 서버가 같은 수신 메일 서버로 보내는 여러 메시지를 갖고 있다면, 같은 TCP 연결을 통해 모든 메시지를 전달할 수 있다. \n\n### 메일 메시지 포맷\n\n헤더 라인과 메시지 몸체는 빈 줄(CRLF)로 분리된다. 각 헤더라인은 키워드, 콜론, 값의 순서로 구성되고 읽을 수 있는 텍스트를 포함한다.  \n\n모든 헤더는 From 헤더와 To 헤더를 반드시 가져야 한다. \n\n### 메일 접속 프로토콜\n\n전자메일 메시지가 송신자 사용자 에이전트로부터 수신자 메일 서버로 전송될 때, 전자메일 메시지는 어떤 경로를 가지게 될까?\n\n송신자의 사용자 에이전트는 송신자의 메일 서버로 전자메일 메시지를 SMTP 또는 HTTP 를 통해 보낸다. 또한 송신자의 메일 서버는 SMTP 를 사용하여 수신자의 메일 서버로 전자메일 메시지를 중계한다. 송신자의 메일 서버를 통해 중계하지 않으면, 송신자의 사용자 에이전트는 목적지 메일 서버에 도달할 수 없다.  \n송신자의 메일 서버는 수신자의 메일 서버로 30분마다 반복해서 보내려고 한다.  \n\n로컬호스트 PC에서 사용자 에이전트를 수행하는 수신자는 자신의 ISP 내부의 메일 서버에 있는 자신의 메시지를 어떻게 얻을 수 있을까? 수신자의 사용자 에이전트는 메시지를 얻기 위해 SMTP 를 사용할 수 *없다*. 이는 SMTP 가 푸시 프로토콜인 반면, 메시지를 얻는 것은 풀 동작이기 때문이다. \n\n수신자가 메시지를 얻는 방법은 두 가지가 있다. \n첫 번째는 웹 기반 전자메일 등을 사용하고 있다면 사용자 에이전트는 수신자의 전자메일을 확인하기 위해 HTTP를 사용할 것이다. 이 경우, 수신자의 메일 서버는 송신자의 메일 서버와 통신하기 위해 SMTP 인터페이스는 물론이고 HTTP 인터페이스를 갖고 있어야 한다.  \n두 번째는 메일 클라이언트를 사용하는 방법인데, RFC 3501 에 정의된 **인터넷 메일 접근 프로토콜 (Internet Mail Access Protocol, IMAP)** 을 사용하게 된다.  \n\n## DNS: 인터넷의 디렉터리 서비스\n\n인터넷 호스트의 식별자 중 하나는 **호스트 이름**이다. 호스트는 흔히 말하는 IP 주소로도 식별된다. \n\n### DNS가 제공하는 서비스\n\n사람은 기억하기 쉬운 호스트 이름 식별자를 좋아하지만, 라우터는 고정 길이의 계층 구조를 가진 IP 주소를 좋아한다. 이를 절충하기 위해 호스트 이름을 IP 주소로 변환해주는 디렉터리 서비스가 필요하다. 이것이 인터넷 DNS 의 주요 임무다.  \n\nDNS는 DNS 서버들의 계층구조로 구현된 분산 데이터베이스이고, 호스트가 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜이다.  \n\n**DNS 서버**는 주로 BIND(Berkeley Internet Name Domain) 소프트웨어를 수행하는 유닉스 컴퓨터다. DNS 프로토콜은 UDP 상에서 수행되고, 포트번호 53을 이용한다.  \n\nDNS는 다른 애플리케이션 프로토콜들이 HTTP, SMTP, FTP 등 사용자가 제공한 호스트 이름을 IP 주소로 변환하기 위해 주로 이용한다. 다음과 같이 수행된다. \n\n1. 같은 사용자 컴퓨터는 DNS 애플리케이션의 클라이언트 측을 수행한다. \n2. 브라우저는 URL로부터 호스트 이름을 추출하고 그 호스트 이름을 DNS 애플리케이션의 클라이언트 측에 넘긴다. \n3. DNS 클라이언트는 DNS 서버로 호스트 이름을 포함하는 질의로 보낸다. \n4. DNS 클라이언트는 결국 호스트 이름에 대한 IP 주소를 가진 응답을 받게 된다.\n5. 브라우저가 DNS로부터 IP 주소를 받으면, 브라우저는 해당 IP 주소와 그 주소의 80 번 포트에 위치하는 HTTP 서버 프로세스로 TCP 연결을 초기화한다. \n\nDNS 는 호스트 이름을 IP 주소로 변환하는 것 이외에 다음과 같은 중요한 추가 서비스를 제공한다. \n\n1. host aliasing: 복잡한 호스트 이름을 가진 호스트는 하나 이상의 별명을 가질 수 있다. DNS는 호스트의 IP 주소 뿐만 아니라 제시한 별칭 호스트 이름에 대한 정식 호스트 이름을 얻기 위해 이용될 수 있다.\n2. 메일 서버 aliasing: 전자메일 주소는 기억하기 쉬운 것이 좋다. DNS는 호스트의 IP 주소 뿐만 아니라 제공된 별칭 호스트 이름에 대한 정식 호스트 이름을 얻기 위해 메일 애플리케이션에 의해 수행된다. \n3. 부하 분산: DNS는 중복 웹 서버 같은 여러 중복 서버 사이에 부하를 분산하기 위해서도 사용되고 있다. 중복 웹 서버의 경우, 여러 IP 주소가 하나의 정식 호스트 이름과 연관되어 있는데, DNS 데이터베이스는 이 IP 주소 집합을 가지고 있다. 클라이언트가 주소 집합으로 매핑하는 호스트 이름에 대한 DNS 질의를 하면, 서버는 IP 주소 집합 전체를 가지고 응답한다. 각 응답에서의 주소는 순환식으로 보낸다. 클라이언트는 대체로 주소 집합 내부의 첫 번째 IP 주소로 HTTP 요청 메시지를 보내므로, DNS 의 순환 방식은 여러 중복 서버들 사이에서 트래픽을 분산하는 효과를 낸다. \n\n### DNS 동작 원리 개요\n\nDNS는 전 세계에 분산된 많은 DNS 서버 뿐만 아니라 DNS 서버와 질의하는 호스트 사이에서 어떻게 통신하는지를 명시하는 애플리케이션 계층 프로토콜로 구성되어 있다. \n\nDNS 의 간단한 설계로 모든 매핑을 포함하는 하나의 인터넷 네임 서버를 생각할 수 있다.  \n중앙 집중 방식에서 클라이언트는 모든 질의를 단일 네임 서버로 보내고, DNS 서버는 질의 클라이언트에게 직접 응답한다. 이 방식의 문제점은 다음과 같다. \n\n1. 서버 고장: 네임 서버가 고장나면, 전체 인터넷이 동작하지 않는다.\n2. 트래픽 양: 단일 DNS 서버가 모든 DNS 질의를 처리해야 한다.\n3. 먼 거리의 중앙 집중 데이터베이스: 단일 DNS 서버가 모든 질의 클라이언트로부터 가까울 수만은 없다. 이는 심각한 지연을 발생시킬 수 있다.\n4. 유지 관리: 중앙 집중 데이터베이스는 거대해지고 모든 새로운 호스트를 반영하기 위해 자주 갱신되어야만 한다. 또한 중앙 집중 데이터베이스에 호스트를 등록할 수 있도록 사용자에게 허용하는 것과 관련된 인증 문제가 있다. \n\n즉, 단일 DNS 서버에 있는 중앙 집중 데이터베이스는 확장성이 전혀 없다.  \n\n#### 분산 계층 데이터베이스\n\nDNS는 많은 서버를 이용하고 이들을 계층 형태로 구성하여 전 세계에 분산시킨다.  \n여기에는 계층으로 구성된 세 유형의 DNS 서버가 존재한다. \n\n1. 루트 DNS 서버\n\t1000개 이상의 루트 서버 인스턴스가 전 세계에 흩어져 있다. 루트 서버들은 13개의 다른 루트 서버 복사체이고, 12개의 다른 기관에서 관리되며, 인터넷 할당 번호 관리기관에 의해 조정된다. \n2. 최상위 레벨 도메인 네임 (top-level domain, TLD) DNS 서버\n\tcom, org, net, edu, gov 같은 상위 레벨 도메인과 kr, uk, fr, ca, jp 같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버 (또는 서버 클러스터)가 있다. TLD 서버는 책임 DNS 서버에 대한 IP 주소를 제공한다.\n3. 책임(authoritative) DNS 서버\n\t인터넷에서 접근하기 쉬운 호스트를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다. 기관의 책임 DNS 서버는 이 DNS 레코드를 가지고 있다. 또한 기관은 이 레코드를 갖도록 자신의 책임 DNS 서버의 구현을 선택할 수 있고, 일부 서비스 제공자의 책임 DNS 서버에 이 레코드를 저장하도록 비용을 지불한다.  \n\nDNS 의 또 다른 중요한 형태 중 로컬 DNS 서버가 있다.  \nISP 들은 로컬 DNS 서버를 갖는다. 호스트가 ISP 에 연결될 때, ISP 는 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공한다 (DHCP 를 통해).  \n호스트가 DNS 질의를 보내면, 이 질의는 먼저 프록시로 동작하는 로컬 DNS 서버에 전달되고, 로컬 DNS 서버는 이 질의를 DNS 서버 계층으로 전달한다.  \n\n이전 예시에서 TLD 서버는 호스트 이름에 대한 책임 서버를 안다고 가정했지만, 일반적으로는 그렇지 않다. 대신에 TLD 서버는 호스트 이름에 대한 책임 DNS 를 아는 중간 DNS 서버만을 알고 있다. \n\n이론상, DNS 질의는 **반복적**이고, **재귀적**일 수 있다. 요청하는 호스트로부터 로컬 DNS 서버까지의 질의는 재귀적이고, 나머지 질의는 반복적이다.  \n\n#### DNS 캐싱\n\nDNS 는 지연 성능 향상과 네트워크의 DNS 메시지 수를 줄이기 위해 캐싱을 사용한다.  \n질의 사슬에서 DNS 서버가 DNS 응답을 받을 때, 로컬 메모리에 응답에 대한 정보를 저장할 수 있다. 호스트 DNS 와 IP 주소 사이의 매핑과 호스트는 영구적인 것이 아니기 때문에 DNS 서버는 어떤 기간 (흔히 2일) 이후에 저장된 정보를 제거한다.  \n\n캐싱으로 인해 로컬 DNS 서버는 두 번째로 질의한 호스트에게 다른 DNS 서버로의 질의 없이 즉시 IP 주소를 보낼 수 있다. 로컬 DNS 서버는 또한 TLD 서버의 IP 주소를 저장할 수 있기 때문에, 이는 로컬 DNS 서버가 질의 사슬에서 루트 DNS 서버를 우회할 수 있도록 한다. \n\n### DNS 레코드와 메시지\n\nDNS 분산 데이터베이스를 구현한 DNS 서버들은 호스트 이름을 IP 주소로 매핑하기 위한 **자원 레코드 (Resource Record, RR)** 을 저장한다.  \n각 DNS 는 하나 이상의 자원 레코드를 가진 메시지로 응답한다.  \n\n자원 레코드는 다음과 같은 필드를 포함하는 4개의 튜플로 되어 있다.  \n\n```text\n(Name, Value, Type, TTL)\n```\n\nTTL 은 자원 레코드가 캐시에서 제거되는 시간을 결정한다.  \nName 과 Value 의 의미는 Type 에 따른다.  \n\n- Type이 A이면, Name 은 호스트 이름이고 Value는 호스트 이름에 대한 IP 주소다. 즉, Type A 레코드는 표준 호스트 이름의 IP 주소 매핑을 제공한다. \n\t- (relay1.bar.foo.com, 145.37.93.126, A)\n- Type이 NS면, Name 은 도메인이고 Value 는 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 아는 책임 DNS 서버의 호스트 이름이다.  \n\t- (foo.com, dns.foo.com, NS)\n- Type 이 CNAME 이면, Value 는 별칭 호스트 이름 Name 에 대한 정식 호스트 이름이다. 이 레코드는 질의 호스트에게 호스트 이름에 대한 정식 이름을 제공한다.  \n\t- (foo.com, relay1.bar.foo.com, CNAME)\n- Type이 MX 이면, Value 는 별칭 호스트 이름 Name 을 갖는 메일 서버의 정식 이름이다.\n\t- (foo.com, mail.bar.foo.com, MX)\n\n한 DNS 서버가 특별한 호스트 이름에 대한 책임 서버이면, 그 DNS 서버는 그 호스트 이름에 대한 Type A 레코드를 포함한다. 서버가 호스트 이름에 대한 책임 서버가 아니라면 그 서버는 호스트 이름을 포함하는 도메인에 대한 Type NS 레코드를 포함할 것이고, NS 레코드의 Value 필드에 DNS 서버의 IP 주소를 제공하는 Type A 레코드도 포함할 것이다.  \n\n#### DNS 메시지\n\nDNS 메시지 내부의 여러 필드의 의미는 다음과 같다.  \n\n- 처음 12바이트는 *헤더 영역*으로, 여러 필드를 갖고 있다.\n\t- 첫 필드는 질의를 식별하는 16비트 숫자다. 이 식별자는 질의에 대한 응답 메시지에 복사되어, 클라이언트가 보낸 질의와 수신된 응답 간의 일치를 식별하게 한다. 플래그 필드에는 여러 개의 플래그가 있다.\n\t\t- 1비트의 질의/응답 플래그는 메시지가 질의(0) 인지 응답(1)인지를 구별하게 한다. \n\t\t- 1비트의 책임 플래그는 DNS 서버가 질의 이름에 대해 책임 서버일 때 응답 메시지에 설정된다.\n\t\t- 1비트의 재귀 요구 플래그는 DNS 서버가 레코드를 갖지 않을 때 재귀적 질의를 수행하기를 클라이언트가 원할 때 설정된다.\n\t- 1비트로 된 재귀 가능 필드는 DNS 서버가 재귀 질의를 지원하면 응답에 설정된다. 헤더에 4개의 ‘개수’ 필드가 있다. 이들 필드는 헤더 다음에 오는 데이터 영역의 네 가지 타입의 발생 횟수를 나타낸다. \n\t\t- 질문의 수, 답변 RR의 수, 추가 RR의 수, 추가 RR의 수\n- *질문 영역*은 현재 질의에 대한 정보를 포함한다. 이 영역은 질의되는 이름을 포함하는 이름 필드와, 이름에 대해 문의되는 질문 타입을 나타내는 타입 필드를 포함한다.  \n- DNS 서버로부터의 응답에서 *답변 영역*은 원래 질의된 이름에 대한 자원 레코드를 포함한다. 응답으로 여러 개의 RR을 보낼 수 있다. 호스트 이름은 여러 개의 IP 주소를 가질 수 있기 때문이다. \n- *책임 영역*은 다른 책임 서버의 레코드를 포함한다.\n- *추가 영역*은 다른 도움이 되는 레코드를 포함하고 있다. \n\t- MX 질의에 대한 응답에서 응답 필드는 전자메일 서버의 정식 호스트 이름을 제공하는 자원 레코드를 갖고 있다. 추가 영역은 메일 서버의 정식 호스트 이름에 대한 IP 주소를 포함하는 Type A 레코드를 포함한다.\n\n어떻게 DNS 질의 메시지가 우리가 작업하는 호스트로부터 DNS 서버로 곧장 보내기 위해 nslookup 프로그램을 사용할 수 있다.\n\n#### DNS 데이터베이스에 레코드 삽입\n\n처음에 어떻게 레코드를 데이터베이스에 넣을까?  \n\n가장 먼저 도메인 네임을 등록기관에 등록한다. **등록기관**은 도메인 네임의 유일성을 확인하고, 그 도메인 이름을 DNS 데이터베이스에 넣고, 그 서비스에 대한 약간의 요금을 우리로부터 받는 상업기관이다.  \n\n우리의 도메인 네임을 어떤 등록기관에 등록할 때, 등록 기관에 주책임 서버와 부책임 서버의 이름과 IP 주소를 등록기관에 제공해야 한다. 두 책임 DNS 서버 각각에 대해 등록 기관은 Type NS와 Type A 레코드가 TLD 서버에 등록되도록 확인한다.  \n\n이러한 단계가 끝나고 나면 사람들은 우리의 웹사이트를 방문할 수 있고 우리 회사의 직원들에게 전자메일을 보낼 수도 있다. \n\n```ad-tip\nDNS 취약점\n\n루트 DNS 서버에 대한 DDoS 대역폭 플러딩 공격, 모든 최상위 도메인 서버들에게 다량의 DNS 질의를 보내는 것, 중간자 공격, DNS 중독 공격 등 여러 공격으로부터 공격받을 잠재성이 존재한다. \n```\n\n## P2P 파일 분배\n\n웹, 전자메일, DNS 등은 모두 항상 켜져 있는 인프라스트럭처 서버에 상당히 의존하는 클라이언트-서버 구조를 채택하고 있다. P2P 구조는 항상 켜져 있는 인프라스트럭처 서버에 최소한으로 의존한다. 대신 간헐적으로 연결되는 호스트 쌍들이 서로 직접 통신한다. \n\n#### P2P 구조의 확장성\n\n서버와 피어들이 접속 링크로 인터넷에 연결되어 있다고 가정하자.  \n서버의 접속 링크 업로드 속도 = $u_s$\ni 번째 피어의 접속 링크 업로드 속도 = $u_i$\ni 번째 피어의 접속 링크 다운로드 속도 = $d_i$\n분배되는 파일의 크기 = $F$ (bit)\n파일의 복사본을 얻고자 하는 피어들의 수 = $N$\n\n**분배 시간**은 모든 N 개의 피어들이 파일의 복사본을 얻는 데 걸리는 시간이다.  \n클라이언트-서버와 P2P 구조 모두 인터넷 코어가 풍부한 대역폭을 갖고 있고, 또한 클라이언트-서버의 모든 업로드와 다운로드 접속 대역폭은 이 파일 분배에 모두 사용된다고 가정한다.  \n\n먼저 클라이언트-서버 구조에 대한 분배 시간 ($D_{cs}$) 을 계산할 때 어떤 피어도 파일을 분배하는 데 도움을 줄 수 없다.\n- 서버는 파일 복사본을 N개의 피어 각각에게 전송해야 한다. 즉, 서버는 $NF$ 비트를 전송해야 한다. 서버의 업로드 속도가 $u_s$ 이기 때문에 파일을 분배하는 시간은 적어도 $NF/u_s$ 이다. \n- $d_{min}$이 가장 낮은 다운로드 속도를 가진 피어의 다운로드 속도를 나타낸다고 하자. 즉, $d_{min} = min\\{d_1, d_2, ... , d_N\\}$ 이다. 가장 낮은 다운로드 속도를 가진 피어는 $F/d_{min}$ 초보다 적은 시간에 파일의 모든 F 비트를 얻을 수 없다. 따라서 최소 분배 시간은 적어도 $F/d_{min}$ 이다. \n\n이를 결합하면 다음과 같은 수식을 얻을 수 있다.  \n$$D_{cs} \\ge max \\{ \\frac{NF}{u_{s}} , \\frac{F}{d_{min}}\\}$$\n\n이는 클라이언트-서버 구조에 대한 최소 분배 시간의 하한값을 제공한다.  \n충분히 큰 N에 대해 클라이언트-서버 분배 시간은 $NF/u_s$ 로 주어진다는 사실을 알 수 있다. 즉, 분배 시간은 N에 따라 선형적으로 증가한다.  \n\nP2P 구조에서는 각 피어들이 서버가 파일을 분배하는 데 도움을 줄 수 있다.  \n특히 한 피어가 파일 데이터 일부를 수신할 때, 피어는 그 데이터를 다른 피어들에게 재분배하는 데 자신의 업로드 용량을 이용할 수 있다.  \n- 분배가 시작되면 서버만이 파일을 갖고 있다. 이 파일이 피어 커뮤니티에 도달할 수 있도록 하기 위해 서버는 적어도 한 번 접속 링크로 파일의 각 비트를 보내야 한다. 즉, 최소 분배 시간은 적어도 $F/u_s$이다. \n- 클라이언트-서버 구조와 마찬가지로 다운로드 속도가 가장 낮은 피어는 $F/d_{min}$ 초보다 적은 시간 안에 파일의 모든 F 비트를 받을 수 없으므로, 최소 분배 시간은 적어도 $F/d_{min}$ 이다. \n- 시스템의 전체 업로드 용량은 전체적으로 서버의 업로드 속도와 각 피어들의 업로드 속도를 더한 것이다. 즉, $u_{total} = u_{s}+ u_{1}+ ... + u_N$ 이다. 시스템은 N개 피어들 각각에게 F 비트를 전달해야 한다. 이는 $u_{total}$ 보다 더 빠르게 할 수 없으므로, 최소 분배 시간은 적어도 $NF/(u_{s}+ u_{1}+ ... + u_N)$ 이다. \n\n이를 결합하면 P2P에 대한 최소 분배 시간 $D_{P2P}$ 는 다음과 같다.  \n$$D_{P2P} \\ge max \\{ \\frac{F}{u_{s}}, \\frac{F}{d_{min}}, \\frac{NF}{u_{s}+ \\sum\\limits_{i=1}^Nu_i} \\}$$\n\n클라이언트-서버의 경우 피어의 수가 증가함에 따라 최소 분배 시간이 선형적으로, 한계없이 증가하지만 P2P 구조의 경우 최소 분배 시간이 클라이언트-서버 구조의 분배 시간보다 항상 작지는 않다. 따라서 P2P 구조를 가진 애플리케이션은 자가 확장성을 갖는다.  \n\n#### 비트토렌트\n\n비트토렌트 용어로 특정 파일의 분배에 참여하는 모든 피어의 모임을 *토렌트*라고 부른다. 토렌트에 참여하는 피어들은 서로에게서 같은 크기의 *청크*를 다운로드한다.  \n피어가 청크를 로드할 때 피어는 또한 청크를 다른 피어들에게 업로드한다.  \n\n비트토렌트는 *트래커*라는 인프라스트럭처 노드를 갖고 있다. 한 피어가 토렌트에 가입할 때 트래커에 자신을 등록하고 주기적으로 자신이 아직 토렌트에 있음을 알린다. 이러한 방식으로 트래커가 토렌트에 참여하는 피어들을 추적할 수 있다.  \n\n새로운 피어 A가 토렌트에 가입할 때 트래커는 참여하고 있는 피어 집합에서 임의로 피어들의 부분집합을 선택하여 해당 피어들의 IP 주소를 A에게 보낸다. A는 이 목록에 있는 모든 피어와 동시에 TCP 연결을 설정하고, 이 피어들을 ‘이웃 피어’ 라고 하자.  \n시간이 지남에 따라 피어들 중 일부는 떠나고 다른 피어들이 A와 TCP 연결을 시도하는 등 시간에 따라 변동될 수 있다. \n주기적으로 A는 이웃 피어들 각각에게 그들이 갖고 있는 청크 목록을 요구한다.  \n\nA는 이웃으로부터 어떤 청크를 먼저 요구할까? 이때 가장 드문 것 먼저 (rarest first) 라는 기술을 사용한다. A가 갖고 있지 않은 청크 중에서 이웃 가운데 가장 드문 청크를 결정하고 요구하는 것이다.  \n어느 요청에 A가 응답할지를 결정하기 위해 비트토렌트는 현명한 교역(trade) 알고리즘을 사용한다. A가 *가장 빠른 속도*로 A에게 데이터를 제공하는 이웃에게 우선순위를 주는 것이다. 특히 A의 각 이웃에 대해 A는 계속해서 A가 비트를 수신하는 속도를 측정하고 가장 빠르게 전송하는 4개의 피어를 결정한다. 그러고 나서 A는 이 4개의 피어에게 청크를 보냄으로써 보답한다. A는 10초마다 속도를 재계산하고 4개의 피어 집합을 수정한다. 비트토렌트 용어로 이러한 4개의 피어를 **활성화**되었다고 한다.  \n\n또한 A는 30초마다 임의로 피어 하나를 추가로 선택하여 청크를 보낸다. 임의로 선택된 피어를 B라고 하자. 비트토렌트 용어로 B는 **낙관적으로 활성화**되었다고 한다. A가 B에게 데이터를 보내고 있기 때문에 A는 B의 4개 업로더 중 하나가 될 수 있다.  \n30초마다 A는 임의로 새로운 교역 파트너를 선택하고 그 파트너와 교역을 시작한다. 두 피어들이 교역에 만족하면 그들은 서로를 4개의 목록에 넣을 것이고 피어 중 누구 하나가 더 좋은 파트너를 만날 때까지 서로와 교역을 계속할 것이다.  \n또한 임의의 이웃 선택은 새로운 피어들이 청크를 얻게 하여 그들이 교역할 수 있는 무엇인가를 가질 수 있다. 이러한 5개 피어 외의 모든 이웃 피어는 비활성화되어 있다.  \n\n기술한 교역을 위한 보상 방식을 **TFT(tit-for-tat)** 라고 한다. 이 보상 방식은 회피할 수 있지만, 비트토렌트 생태계는 매우 성공적이며, 수십만 개의 토렌트에서 동시에 수백만의 피어들이 능동적으로 파일을 공유하고 있다.  \n\n## 비디오 스트리밍과 콘텐츠 분배 네트워크\n\n### 인터넷 비디오\n\n스트리밍 비디오 애플리케이션에서 녹화된 비디오는 서버에 저장되어 사용자가 비디오 시청을 서버에게 *온디맨드*로 요청한다.  \n\n비디오는 이미지의 연속으로서 일반적으로 초당 24개 또는 30개의 이미지로 일정한 속도로 표시된다. 압축되지 않은 디지털 인코딩된 이미지는 픽셀 단위로 구성되며, 각 픽셀은 휘도와 색상을 나타내는 여러 비트들로 인코딩된다.  \n비디오의 중요한 특징은 압축될 수 있다는 것인데, 비디오 품질과 비트 전송률은 서로 반비례한다.  \n\n네트워킹 측면에서 비디오의 가장 두드러진 특성은 높은 비트 전송률이다. 압축된 인터넷 비디오는 일반적으로 고화질 동영상을 스트리밍하기 위해 100 kbps 에서 4 Mbps 이상으로 구성된다.  \n\n지금까지 스트리밍 비디오에서 가장 중요한 성능 척도는 평균 종단 간 처리량이다. 연속재생을 제공하기 위해, 네트워크는 압축된 비디오의 전송률 이상의 스트리밍 애플리케이션에 대한 평균 처리량을 제공해야 한다.  \n\n또한 압축을 사용하여 동일한 비디오를 여러 버전의 품질로 만들 수 있다. 사용자는 현재 사용 가능한 대역폭을 선택하여 보고 싶은 버전을 결정할 수 있다.  \n\n### HTTP 스트리밍 및 DASH\n\n인터넷 비디오 회사에서 스트리밍 서비스를 제공하는 가장 단순한 방법은 단일한 거대 데이터 센터를 구축하고 모든 비디오 자료를 데이터 센터에 저장한 뒤 전 세계의 사용자에게 비디오 스트림을 데이터 센터로부터 직접 전송하는 것이다.  \n\n그러나 이 방법은 중대한 문제점들이 있다.  \n1. 클라이언트가 데이터 센터로부터 지역적으로 먼 지점에 있는 경우, 서버로부터 클라이언트의 패킷 경로는 많은 다양한 통신 링크와 ISP 를 거쳐가게 되는데, 이 링크들 중 하나라도 비디오 소비율보다 낮은 전송용량을 갖는다면 종단 간 처리율이 낮아진다. 종단 간 경로 길이가 길어질수록 이런 현상은 증가한다. \n2. 인기 있는 비디오는 같은 통신 링크를 통해 여러 번 반복적으로 전송된다. 이는 네트워크 대역폭의 낭비는 물론이고 인터넷 비디오 회사가 회선을 제공하는 ISP 들에게 동일한 바이트를 전송하는 것에 대해 중복 비용을 지불해야 한다. \n3. 단일한 데이터 센터를 구축하면 한 번의 장애로 인해 전체 서비스가 중단될 수 있는 위험이 있다. \n\n거의 대부분의 비디오 스트리밍 회사들은 **콘텐츠 분배 네트워크 (Content Distribution Network, CDN)** 를 이용한다. CDN 은 다수의 지점에 분산된 서버들을 운영하며, 비디오 및 다른 형태의 웹 콘텐츠 데이터의 복사본을 이러한 분산 서버에 저장한다. 사용자는 최선의 서비스와 사용자 경험을 제공할 수 있는 지점의 CDN 서버로 연결된다.  \n\nCDN은 콘텐츠 제공자가 소유한 사설 CDN 일 수 있으며, 또는 제3자가 운영하는 CDN 을 통해 다수의 콘텐츠 제공자가 서비스할 수도 있다. \n\nCDN은 일반적으로 서버의 위치에 대해 두 가지 철학 중 하나를 채용하고 있다. \n- Enter Deep: 서버 클러스터를 세계 곳곳의 접속 네트워크에 구축함으로써 ISP 의 접속 네트워크로 깊숙이 들어가는 것이다. 서버를 최대한 사용자 가까이에 위치시켜 사용자와 CDN 서버 사이의 링크 및 라우터 수를 줄이고 사용자가 경험하는 지연 시간 및 처리율을 개선한다. 그러나 고도로 분산된 설계로 인해 서버 클러스터를 유지 관리하는 비용이 커진다.\n- Bring Home: 좀 더 적은 수의 핵심 지점에 큰 규모의 서버 클러스터를 구축하여 ISP 를 Home 으로 가져오는 개념이다. 접속 ISP 에 연결하는 대신, 이러한 CDN 들은 일반적으로 그들의 클러스터를 인터넷 교환 지점 (Internet Exchange Point, IXP) 에 배치된다. 클러스터 유지 및 관리 비용이 줄어드는 대신에 사용자가 느끼는 지연 시간과 처리율은 상대적으로 나빠진다. \n\n서버 클러스터의 위치가 정해지면 CDN 은 콘텐츠의 복사본을 클러스터에 저장한다. CDN 은 클러스터에 대해 푸시 방식이 아닌 풀 방식을 사용한다. 어떤 사용자가 지역 클러스터에 없는 비디오를 요청하면, 해당 비디오를 중앙 서버나 다른 클러스터로부터 전송받아 사용자에게 서비스하는 동시에 복사본을 만들어 저장한다. 인터넷 캐시와 마찬가지로 클러스터의 저장 공간이 가득 차면 자주 사용되지 않는 비디오 데이터는 삭제된다.  \n\n#### CDN 동작\n\n사용자의 호스트가 웹 브라우저가 URL 을 지정함으로써 특정 비디오의 재생을 요청하면 CDN은 그 요청을 가로채서 (1) 그 시점에서 클라이언트에게 가장 적당한 CDN 클러스터를 선택하고, (2) 클라이언트의 요청을 해당 클러스터의 서버로 연결한다. \n\n대부분의 CDN 은 사용자의 요청을 가로채고 다른 곳으로 연결하는 데 DNS 를 사용한다.  \n1. 사용자가 NetCinema 의 웹 페이지를 방문한다.\n2. 사용자가 `http://video.netcinema.com/6Y34kJ` 링크를 클릭하면 사용자의 호스트는 `video.netcinema.com` 에 대한 DNS 질의를 보낸다.\n3. 사용자의 지역 DNS 서버 (LDNS) 는 호스트 이름의 `video` 를 감지하고 해당 질의를 `NetCinema` 의 책임 DNS 서버로 전달한다. NetCinema 책임 DNS 서버는 해당 질의를 KingCDN으로 연결하기 위해 IP 주소 대신에 KingCDN의 호스트 이름을 LDNS 에게 알려준다.\n4. 이 시점부터 DNS 질의는 KingCDN의 사설 DNS 구조로 들어가게 된다. 사용자의 LDNS는 `a1105.kingcdn.com` 에 대한 두 번째 질의를 보내고 이는 KingCDN의 DNS에 의해 KingCDN 콘텐츠 서버의 IP 주소로 변환되어 LDNS 에게 응답된다. 이때 클라이언트가 콘텐츠를 전송받게 될 서버가 결정된다.\n5. LDNS는 콘텐츠를 제공할 CDN 서버의 IP 주소를 사용자 호스트에게 알려준다.\n6. 클라이언트는 KingCDN 서버의 IP 주소를 얻고 나면, 해당 IP 주소로 직접 TCP 연결을 설정하고 비디오에 대한 HTTP GET 요청을 전송한다. 만약 DASH 가 사용된다면 서버는 먼저 각기 다른 버전의 비디오에 대한 URL 목록을 포함하는 매니페스트 파일을 클라이언트에게 전송하고 클라이언트는 동적으로 각기 다른 버전의 비디오 조각 단위 데이터를 선택할 수 있다. \n\n#### 클러스터 선택 정책\n\nCDN 구축의 핵심 중 하나는 **클러스터 선택 정책**이다. 이는 클라이언트를 동적으로 어떤 서버 클러스터 또는 CDN 데이터 센터로 연결하는 방식이다.  \n\nIP 주소를 알아낸 CDN 은 해당 IP 주소에 기초해 최선의 클러스터를 선택할 필요가 있다. 일반적으로 CDN 은 각기 고유한 클러스터 선택 정책을 사용한다.  \n\n간단한 클러스터 정책의 하나로 클라이언트에게 **지리적으로 가장 가까운** 클러스터를 할당하는 기법이 있다. 상용 지리정보 데이터베이스를 이용하면 LDNS 의 IP 주소는 지리적으로 매핑될 수 있다. DNS 질의가 특정 LDNS 로부터 도착하면 CDN은 해당 LDNS에서 가장 가까운 클러스터를 선택한다.  \n\n일부 클라이언트에서는 위와 같은 방식이 잘 동작하지 않는데, 그 이유는 지리적으로는 가장 가까운 클러스터가 네트워크 경로의 길이 홉의 수에 따라 가장 가까운 클러스터가 아닐 수 있기 때문이다.  \n또한 DNS 기반 방법에 내재된 문제로서, 일부 사용자는 상당히 멀리 있는 DNS 서버를 LDNS로 사용하도록 설정할 수 있다. 이 경우 LDNS IP 주소를 기반으로 선택한 클러스터는 사용자 호스트로부터 멀리 위치하게 된다. 또한 이 방법은 인터넷 경로의 지연이나 가용 대역폭의 변화 등은 무시하고 항상 같은 클러스터를 클라이언트에게 할당하게 된다. \n\n현재의 네트워크 트래픽 상황을 반영한 최선의 클러스터를 선택하기 위해 CDN 은 주기적으로 클러스터와 클라이언트 간의 지연 및 손실 성능에 대한 **실시간 측정**을 수행하기도 한다.  \n\n## 소켓 프로그래밍: 네트워크 애플리케이션 생성\n\n일반적인 네트워크 애플리케이션은 2개의 종단 시스템에 존재하는 클라이언트 프로그램과 서버 프로그램으로 구성된다. 이러한 두 프로그램을 수행하면 클라이언트와 서버 프로세스가 생성되고, 두 프로세스가 소켓으로부터 읽고, 소켓에 쓰기를 통해 서로 통신한다. 네트워크 애플리케이션을 생성할 때 개발자의 주 업무는 클라이언트와 서버 프로그램 모두에 대한 코드를 작성하는 것이다.  \n\n클라이언트-서버 애플리케이션에는 두 가지 형태가 있다. 한 형태는 RFC에 정의된 표준 프로토콜을 구현하는 클라이언트-서버 애플리케이션이다. 이러한 애플리케이션은 개방형으로 불린다. 그 동작을 규정하는 규칙들이 모두에게 알려져 있다. 그 경우 클라이언트와 서버 프로그램은 RFC에 정의된 규칙을 따라야 한다. \n마찬가지로 서버 프로그램도 HTTP 서버 프로토콜을 구현할 수 있다. \n\n오늘날 대부분의 네트워크 애플리케이션은 독립 개발자가 개발한 클라이언트와 서버 프로그램 간의 통신을 포함한다.  \n\n다른 형태의 네트워크 애플리케이션은 개인의 독점적인 네트워크 애플리케이션이다. 이 경우 클라이언트와 서버 프로그램은 RFC 또는 다른 곳에 공식적으로 출판되지 않은 애플리케이션 계층 프로토콜을 채택한다. 개인 개발자는 클라이언트와 서버 프로그램을 모두 생성하고, 이 개발자는 코드에 무엇을 사용할지를 완전히 제어한다. 그러나 그 코드는 공개된 프로토콜로 구현되지 않기 때문에, 다른 독립 개발자는 이 애플리케이션과 상호작용하는 코드를 개발할 수 없다. \n\n개발 단계 동안 개발자가 우선해야 할 결정 중의 하나는 그 애플리케이션이 TCP 를 이용하는지, UDP 를 이용하는지에 대한 것이다. TCP 는 연결지향형 서비스이고 신뢰적 바이트 스트림 채널을 제공하는데, 이 채널을 통해 데이터가 두 종단 시스템 사이를 흐르게 된다. UDP 는 비연결형이고 한 종단 시스템에서 다른 곳으로 데이터를 독립적인 패킷으로 만들어서 보내는데, 전송에 대한 보장은 하지 않는다.  \n클라이언트 또는 서버 프로그램이 RFC에 정의된 프로토콜을 구현할 때, 그 프로토콜과 연관된 잘 알려진 포트 번호를 사용해야 한다. 역으로, 독점적인 애플리케이션을 개발할 때 개발자는 잘 알려진 포트 번호를 사용하지 않도록 유의해야 한다. \n\n### UDP 를 이용한 소켓 프로그래밍\n\n다른 컴퓨터에서 수행되는 프로세스 간의 통신은 소켓에 메시지를 보냄으로써 실행한다. 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 제어권을 갖지만 트랜스포트 계층 쪽에 대한 제어권은 거의 없다.  \n\n송신 프로세스가 데이터의 패킷을 소켓 문밖으로 밀어내기 전에, UDP를 사용할 때 먼저 패킷에 목적지 주소를 붙여넣어야 한다. 이 패킷이 송신자의 소켓을 통과한 후 인터넷은 이 목적지 주소를 이용하여 그 패킷을 인터넷을 통해 수신 프로세스에 있는 소켓으로 라우트할 것이다. 패킷이 수신 소켓에 도착하면 수신 프로세스는 소켓을 통해 그 패킷을 추출하고 다음에 패킷의 콘텐츠를 조사하고 적절한 동작을 취한다. \n\n패킷에 붙여지는 목적지 주소는 그 목적지 호스트의 IP 주소가 목적지 주소의 일부가 된다. 패킷에 목적지 주소를 포함함으로써 인터넷의 라우터는 목적지 호스트로 인터넷을 통해 패킷을 라우트할 수 있다. 그러나 호스트는 하나 혹은 그 이상의 소켓을 갖는 많은 네트워크 애플리케이션 프로세스를 수행하고 있을 수 있기 때문에 목적지 호스트 내의 특정한 소켓을 식별할 필요가 있다. 소켓이 생성될 때 **포트 번호**라고 하는 식별자가 소켓에 할당된다. 즉, 패킷의 목적지 주소는 소켓의 포트 번호도 포함한다.  \n\n송신 프로세스는 목적지 호스트의 IP 주소와 목적지 소켓의 포트 번호로 구성된 목적지 주소를 패킷에 붙인다. 더 나아가, 송신자의 출발지 주소도 패킷에 붙여짐을 볼 수 있다. 그러나 출발지 주소를 패킷에 붙이는 것은 일반적으로 UDP 애플리케이션 코드가 아닌 하부 운영체제가 자동으로 실행한다. \n\n### TCP 소켓 프로그래밍\n\nTCP는 연결지향 프로토콜로, 클라이언트와 서버가 서로에게 데이터를 보내기 전에 먼저 TCP 연결을 설정할 필요가 있음을 의미한다. TCP 연결의 한쪽은 클라이언트 소켓에 연결되고 다른 쪽은 서버 소켓에 연결된다. TCP 연결을 생성할 때 클라이언트 소켓 주소와 서버 소켓 주소를 연결과 연관시킨다. TCP 연결이 설정된 후 한쪽에서 다른 쪽으로 데이터를 보내려면 소켓을 통해 데이터를 TCP 연결로 보내면 된다. \n\n클라이언트는 서버로의 접속을 먼저 시도한다. 서버는 클라이언트의 초기 접속에 응대할 수 있도록 준비하고 있어야 하는데, 여기에는 두 가지 의미가 있다. \n1. UDP에서와 마찬가지로 TCP 서버는 클라이언트가 접속을 시도하기 전에 프로세스를 먼저 수행하고 있어야 한다. \n2. 서버 프로그램은 임의의 컴퓨터에서 수행되고 있는 클라이언트로부터의 초기 접속을 처리하는 특별한 출입문을 가져야 한다. \n\n서버 프로세스가 수행되면 클라이언트 프로세스는 서버로의 TCP 연결을 시도한다. 이는 클라이언트 프로그램에서 TCP 소켓을 생성함으로써 가능하다. 클라이언트는 TCP 소켓을 생성할 때 서버의 IP 주소와 소켓의 포트 번호를 명시한다. 소켓을 생성한 후 클라이언트는 세 방향 핸드셰이크를 하고 서버와 TCP 연결을 설정한다. 트랜스포트 계층에서 일어나는 세 방향 핸드셰이크를 클라이언트와 서버 프로그램은 전혀 인식하지 못한다. \n\n애플리케이션 관점에서 볼 때 클라이언트의 소켓과 서버의 연결 소켓은 파이프에 의해 직접 연결된다. 클라이언트 프로세스는 자신의 소켓으로 임의의 바이트를 보낼 수 있으며 보낸 순서대로 서버 프로세스가 바이트를 수신하도록 TCP가 보장한다 .따라서 TCP는 클라이언트와 서버 프로세스간에 신뢰적 서비스를 제공한다. 또한 클라이언트 프로세스는 소켓으로 바이트를 보낼 수 있을 뿐만 아니라 소켓으로부터 바이트를 수신할 수 있다. 마찬가지로 서버 프로세스도 연결 소켓으로부터 바이트를 수신할 수 있을 뿐만 아니라 연결 소켓으로 바이트를 보낼 수 있다. \n"},{"excerpt":"내용 이주 비용 지원 질문 내가 어떤 팀에 채용되는지는 인터뷰를 하면서 알게 되나요? Will I find out what team I'm being hired for during my interview? yes. 끝나고 나서 알 수 있게 된다. skill set 에 따라 평가 된다.어떤 팀인지 어떤 것을 찾고 어떤 것이 잘 맞는지 변경할 것이 있는지 미…","fields":{"slug":"/dh-recruiter-call/"},"frontmatter":{"date":"2023년 11월 27일 09:11","title":"DH 리크루터 콜","tags":null},"rawMarkdownBody":"\n## 내용\n\n- 이주 비용 지원\n- \n\n## 질문\n\n- 내가 어떤 팀에 채용되는지는 인터뷰를 하면서 알게 되나요?\n\t- Will I find out what team I'm being hired for during my interview?\n\t- yes. 끝나고 나서 알 수 있게 된다. skill set 에 따라 평가 된다.어떤 팀인지 어떤 것을 찾고 어떤 것이 잘 맞는지 변경할 것이 있는지 미래 매니저가 알려줄 것이다. \n- 모든 지원자가 모든 채용 프로세스를 진행할 수 있나요? 아니면 1차 면접에 합격한 사람들만 2차 면접을 진행할 수 있나요?\n\t- Can all candidates go through the entire hiring process? Or can only those who pass the first round of interview proceed to the second round?\n\t- coding + hiring manager 모두 진행할 예정이지만 아마 별로면 취소할 거다. \n- 그렇다면 제가 1차 면접 합격 여부는 언제 알 수 있을까요?\n\t- So when will I know if I made it to the first round of interviews?\n\t- 바로 뒤에 받을 것이다. 속도를 높이려고 노력 중. 2차 면접 결과는 12/15~18 가능하다면.\n- 저의 1차 코딩 인터뷰 날짜는 언제로 정해졌을까요?\n\t- When is my first coding interview date set?\n- 1차 인터뷰는 어떻게 진행될까요?\n\t- How does the pair programming for the first round of interviews work?\n\n## 답변\n\n- 저는 대학교 3학년이며, 휴학 중입니다. DH 에 합격하게 된다면 휴학을 연장할 예정입니다.\n\t- I am a senior in college and am on a leave of absence. I plan to extend my leave of absence if I am accepted to DH.\n- 독일 이주 계획이 있습니다.\n\t- If I am accepted to DH, I can move to Germany.\n- 추가 질문은 없습니다.\n\t- I have no further questions. That's all.\n- 나는 열정적인 동료가 있는 회사, 적극적으로 소통할 수 있는 회사에서 일하고 싶다.\n\t- I want to work for a company with passionate coworkers and with whom I can actively communicate.\n- 나는 그 정도 연봉은 합리적이라고 생각합니다.\n\t- I think that salary is reasonable\n- 나는 이제 궁금한 것이 없습니다.\n\t- I have no questions now.\n- 이 정도면 충분하다고 생각해요.\n\t- I think that's good enough.\n- 잘 못 들었는데, 혹시 다시 한 번 말해주실 수 있을까요?\n\t- Sorry, could you say that again, please?\n\n내일 live coding senior 엔지니어가 challenge\nworking communicate 중요. 질문하고, 어떻게 하고 있는지 \n힌트도 줌. code clean, readable, testable, scabable, leetcode 확인할 것.  \n코딩 스케줄을 \n\n## 질문\n\n- 한 학기가 남았는데 \n\t- I have one semester left in school, is it possible to start in September? \n- 정확히 언제 입사하나요?\n\t- What is my exact start date?\n- 입사 전에 어떤 것을 준비해야 할까요?\n\t- Is there anything I need to prepare before joining?\n- probation 기간 동안 어떤 평가가 이루어지나요?\n\t- What assessments are made during the probationary period?\n\npintech.\n62000 euro. 3000 euro.\nbank account\napartment\n6 month\n3 month notice period\n4/1\n\n40 hours / week\n27 days / years\nboucher lunch\n480 euros lunch\ngym memberships\n\nhow can you learn quickly?\ndeliver?\nwe understand \nproactive to learning\ntry to curious\n"},{"excerpt":"서론 현재 S-HOOK 의 배포는 github self hosted runner 로 자동화되어 있다. 그러나 self-hosted runner 는 롤백을 수행하기 불편하다. 이전의 jar 파일을 우리가 버전 별로 관리해야 해서 관리 지점이 늘어난다. 또한 로그를 자세히 제공해주지 않는다는 점도 불편하다. 종종 배포가 실패하더라도 어떤 부분에서 에러가 발생…","fields":{"slug":"/jenkins-migration/"},"frontmatter":{"date":"2023년 11월 26일 08:11","title":"젠킨스 마이그레이션","tags":["shook"]},"rawMarkdownBody":"\n## 서론\n\n현재 S-HOOK 의 배포는 github self hosted runner 로 자동화되어 있다.  \n그러나 self-hosted runner 는 롤백을 수행하기 불편하다. 이전의 jar 파일을 우리가 버전 별로 관리해야 해서 관리 지점이 늘어난다.\n\n또한 로그를 자세히 제공해주지 않는다는 점도 불편하다. 종종 배포가 실패하더라도 어떤 부분에서 에러가 발생했는지에 대한 자세한 로그는 확인하기 어렵다. \n\nshell 스크립트로 배포가 이루어지기 때문에 버전관리가 필요한데, 현재는 버전관리가 되고 있지 않아 이번 서버를 이전할 때 이전 기록을 보며 기억을 되짚으면서 (...) 재배포했다. \n\n이런 부분에서 애로 사항을 느껴 자동 배포 툴을 self-hosted runner 에서 젠킨스로 마이그레이션하려고 한다.\n\n## Jenkins 란?\n\n젠킨스는 소프트웨어 개발 시 지속적 통합 서비스를 사용하는 툴이다. 모든 언어의 조합과 소스 코드 레포지토리에 대한 지속적인 통합과 지속적 배포 환경을 구축하기 위한 도구이다. \n\n우리는 별도의 EC2에 jenkins 를 설치하려고 한다.  \n**EC2 사양은 t4g.small 인스턴스에 우분투 22.04 ARM 64 이다.**\n\n## 설치 환경 설정\n\n### Java 설치\n\n젠킨스 설치를 위해서는 Java 설치가 필요하다.  \n먼저 Java 를 설치해주자. \n\n```bash\nwget -O- https://apt.corretto.aws/corretto.key | sudo apt-key add - \nsudo add-apt-repository 'deb https://apt.corretto.aws stable main' \nsudo apt-get update; \nsudo apt-get install -y java-17-amazon-corretto-jdk\n```\n\n### 도커 설치\n\n도커를 사용하지 않고 젠킨스를 우분투에 직접 설치하면 해주어야 하는 환경 설정이 많다.  \n이를 간소화하기 위해 도커를 사용해보자.  \n\n[도커 공식 문서](https://docs.docker.com/engine/install/ubuntu/) 를 참고하였다.\n\n#### Docker `apt` repository 설정\n\n```bash\n# Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n\n# Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\nsudo apt-get update\n```\n\n#### Latest ver ) Docker Package 설치\n\n```bash\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n\n도커 엔진이 잘 설치되었는지 확인하기 위해 `hello-world` 이미지를 실행해본다. \n\n```bash\nsudo docker run hello-world\n```\n\n### 젠킨스 컨테이너 실행\n\n#### 젠킨스 이미지 다운로드\n\nJenkins LTS 버전 이미지를 다운로드한다. \n\n```bash\nsudo docker pull jenkins/jenkins:lts\n```\n\n#### docker-compose 로 젠킨스 실행하기\n\ndocker-compose 를 설치한다. \n\n```bash\nsudo apt-get install docker-compose\n```\n\n도커 실행 경로에 `docker-compose.yml` 파일을 만들고, 내용을 작성해준다. \n\n```yaml\nversion: \"3\"\nservices:\n  jenkins: # 컨테이너 이름\n    image: jenkins/jenkins:lts\n    user: root  # root 로 실행\n    volumes:\n      - ./jenkins:/var/jenkins_home\n    ports:\n      - 8080:8080\n```\n\n- `volumes`: 도커 컨테이너의 데이터를 보존하기 위해 `/var/jenkins_home` 디렉토리를 호스트의 `/jenkins` 와 마운트한다.\n- `ports`: 컨테이너 외부 / 내부의 포트를 포워딩한다. \n\n이제 다음과 같은 명령어로 jenkins 컨테이너를 실행할 수 있다.\n\n```bash\nsudo docker-compose up -d\n```\n\n## Jenkins 설정\n\n이제 Jenkins 컨테이너에 퍼블릭 IP 로 외부에서 접속할 수 있게 되었다.  \n\n아래 명령을 사용하여 Jenkins 컨테이너에 출력된 로그에 적힌 initial admin password 를 확인할 수 있다. \n\n```bash\nsudo docker logs jenkins\n```\n\n추천하는 플러그인들을 설치했다. \n\n### Project 생성하기\n\nFreestyle project 로 생성했다.\nitem 이름은 경로에도 포함되므로 영어로 적는 것이 좋다.\n\n![[jenkins-freestyle-project.png]]\n\n우리는 Github Project 로 생성할 것이기 때문에 Github project 를 체크해준다. \n\nproject url 에는 팀 깃허브 주소를 넣어준다.\n\n![[jenkins-project-url.png]]\n\n소스 코드 관리는 Git 으로 하게 되는데, Repositories 에 Github .git 주소를 넣어주고, Username 과 password 로 Credentials 를 설정해준다. password 에는 token 을 넣어주면 된다. \n\n어떤 브랜치를 빌드할 때 사용할 것인지 정해준다.\n\n![[jenkins-repositories-branches.png]]\n\n### submodule 설정\n\nS-HOOK 에서는 submodule 을 사용하기 때문에 Additional Behaviours 에 submodule 관련 설정을 추가해주었다. \n\n![[jenkins-submodule-settings.png]]\n\n### 빌드 유발\n\n현재 S-HOOK 은 main 에 머지된 커밋들이 바로 빌드되어도 되는 변경 사항들이 아니기 때문에 설정해주지 않았다. \n\n### Build Steps\n\nInvoke Gradle script 를 생성해서, gradlew 을 사용하도록 설정해준다.  \n어떤 명령어로 실행할 것인지도 아래에 적어준다. \n\n![[jenkins-gradle-script.png]]\n\n그리고 아래 고급 설정에서 Build file 이 어디에 있는지 명시해준다. \n\n![[jenkins-build-gradle-file.png]]\n\n### Send files or execute commands over SSH 설정\n\n젠킨스 서버에서 빌드한 jar 파일을 prod 서버로 보내야 하기 때문에 아래의 설정이 반드시 필요하다. \n\n먼저 Publish Over SSH 라는 플러그인을 설치해야 한다. \n\n![[jenkins-publish-over-ssh.png]]\n\n그다음 Jenkins 관리 > System 의 맨 아래에 있는 Publish over SSH 설정을 적어준다. \n\nKey 에는 SSH 접속 시 필요한 pem 키를 적어주면 되고, SSH Servers 에 설정을 적어주면 된다. \n- Hostname: 보낼 서버 IP 주소\n- Username: 연결할 username (우리는 ubuntu 를 적어주었다.)\n- Remote Directory: 연결 될 디렉터리 위치. 반드시 존재해야 되고 생성되지 않는다. 기본 디렉터리라고 생각하면 된다. 우리는 /home/ubuntu 로 설정해주었다.\n\n이제 다시 구성으로 돌아와서 아까 설정해둔 Server Name 으로 연결할 서버를 찾는다.\n\n![[jenkins-ssh-server.png]]\n\n그런 다음 transfers 에 다음과 같이 적는다.\n\n![[jenkins-ssh-transfers.png]]\n\n- Source files: 보낼 파일의 경로를 적어준다.\n- Remove prefix: 파일의 경로를 삭제하고 실제 파일 이름만 남게 한다.\n- Remote directory: 어떤 폴더에 파일을 저장할 지 지정한다. 기본 링크는 /home/ubuntu 로 지정되어 있다. (즉, /application-jar 는 ~/application-jar 에 저장될 것이다.)\n- Exec command: 파일을 옮긴 뒤 어떤 것을 실행할 지 정한다. 우리는 bash 파일을 실행하고, bash 를 실행하며 발생한 로그를 파일에 기록한 뒤 띄우는 방식을 선택했다. 이러면 배포가 완료되면 Jenkins 에 로그 파일 내용이 출력된다.\n\n전체 스크립트는 다음과 같다.\n\n```shell\n# 로그 파일 경로 설정\nLOG_FILE=\"/home/ubuntu/application-jar/deployment.log\"\n\n# 배포 로그 저장\nbash /home/ubuntu/backend-deploy.sh > $LOG_FILE\n\n# 배포 완료 후 로그 파일 내용을 출력하고 삭제\ncat $LOG_FILE\nrm $LOG_FILE\n```\n\n### bash로 파일을 실행하지 않은 이유\n\n그렇다면 `bash ./deploy.sh` 처럼 바로 파일을 실행하면 되는 거 아닐까? 나도 그렇게 생각했다.  \n그러나 이렇게 하면 bash 명령이 끝나지 않아서 배포가 종료되지 않는 문제가 있었다.  \n\n따라서 로그를 다른 파일에 저장해두고, 배포가 끝나면 파일을 출력한 다음 로그 파일을 삭제하는 방식으로 실행했다. "},{"excerpt":"TODO LOG 배운 것 get ready for: 이미 준비를 마친 느낌으로 사용. 또는 마음가짐만 준비된 느낌 prepare: 이제부터 준비하는 느낌 느낀 것","fields":{"slug":"/2023-11-26/"},"frontmatter":{"date":"2023년 11월 26일 08:11","title":"2023년 11월 26일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n- get ready for: 이미 준비를 마친 느낌으로 사용. 또는 마음가짐만 준비된 느낌 prepare: 이제부터 준비하는 느낌\n\n## 느낀 것"},{"excerpt":"KMP 알고리즘이란? 문자열 A 안에 문자열 B가 들어있는지를 판단하는 알고리즘. 즉, 불일치가 발생하기 직전까지 같았던 부분은 다시 비교하지 않고 패턴 매칭을 진행하자는 것이다. 이를 통해 비교 횟수를 줄이고, 검색 알고리즘의 효율성을 높일 수 있다. 실패 함수 F(x) 문자열  에서 접두사와 접미사가 일치하는 최대 길이 실패 함수의 값은 접두사와 접미…","fields":{"slug":"/kmp-algorithm/"},"frontmatter":{"date":"2023년 11월 26일 08:11","title":"KMP 알고리즘","tags":["algorithms"]},"rawMarkdownBody":"\n## KMP 알고리즘이란?\n\n문자열 A 안에 문자열 B가 들어있는지를 판단하는 알고리즘.\n\n즉, 불일치가 발생하기 직전까지 같았던 부분은 다시 비교하지 않고 패턴 매칭을 진행하자는 것이다. 이를 통해 비교 횟수를 줄이고, 검색 알고리즘의 효율성을 높일 수 있다. \n\n## 실패 함수 F(x)\n\n문자열 `S[0:x + 1]` 에서 접두사와 접미사가 일치하는 최대 길이\n\n실패 함수의 값은 접두사와 접미사가 일치하는 최대 길이를 의미하지만, 동시에 인덱스 관점에서 ==아직 확신할 수 없는== 다음 문자를 의미하기도 한다. (길이 = 인덱스 + 1)\n\n실패 함수는 다음과 같은 과정으로 이해할 수 있다. (0-index 이다.)\n\n![[failure-function.png]]\n\n미래의 나에게 도움이 되기를 바라며...\n\n### 코드\n\n```python\ndef make_fail_function(s):\n\tf = [0] * len(s)\n\tj = 0\n\tfor i in range(1, len(s)):\n\t\twhile j > 0 and s[i] != s[j]:\n\t\t\tj = f[j-1]\n\t\tif s[i] == s[j]:  # i 와 j 가 가리키는 글자가 같은지 확인한다.\n\t\t\tj += 1 # s[i]와 s[j] 가 같아지는 시점에서 f[j-1] 의 값 + 1 \n\t\t\t# f[j-1] 이란 s[0:j] 의 접두사와 접미사가 일치하는 최대 길이\n\t\t\tf[i] = j # f[i]에 일치하는 최대 길이를 저장한다.\n\treturn f\n```\n\n## KMP 알고리즘\n\n실패 함수를 응용하면 KMP 알고리즘을 구현할 수 있다!!\n\n```python\ndef kmp(failure, a, b):  \n    count = [0] * len(a)  \n    result = []  \n    j = 0  # j 는 b 를 가리키는 인덱스임과 동시에 일치하는 최대 길이가 된다.\n    for i in range(len(a)):  # 모든 a 안의 index i 를 돌면서\n        if a[i] == b[j]:  # 서로 같을 때\n            j += 1  \n            count[i] = j  # count[i]에 일치하는 최대 길이인 j 를 저장한다.\n        else:  \n            while j > 0 and a[i] != b[j]:  # 만약 a[i] 와 b[i] 가 같지 않다면 실패함수를 이용해서 계속해서 접두사와 접미사를 이동시킨다.\n                j = failure[j - 1]  \n            # 이 시점에서 j 가 0이거나, a[i] 와 b[j] 가 같게 된다.\n            if a[i] == b[j]:  # 그 중 a[i] 와 b[j] 가 같은 경우는 마찬가지로 최대 길이를 저장해준다.\n                j += 1  \n                count[i] = j  \n        if count[i] == len(b):  # 만약 b 를 끝까지 비교했는데 모두 같다면\n            result.append(i - len(b) + 2)  # (선택) 같은 인덱스를 저장한다. (이때는 1-index 사용해서 +2를 해주었다. 취향 차이.)\n            j = failure[j - 1]   # 바로 이전 문자의 접두사를 끌어온다.\n    # 명심할 것. j 는 언제나 *다음 비교에서 실패할 수도 있는 b의 인덱스* 이다.\n    return result\n```\n\ncount 배열은 i에서 최대로 일치하는 문자열의 길이가 담겨있다.  \n즉, `len(b)` 가 count 에서 몇 번 나타나는지 알면 문자열이 최대 몇 개가 일치하는지 알 수 있는 것이다. \n\n## 실패 함수의 성질\n\n### 반복되는 문자열의 길이 L 은 `문자열 길이 - failure[문자열 길이-1]` 로 구할 수 있다\n\n`failure[문자열 길이 - 1]` 은 맨 끝 문자까지의 부분 문자열에서 접두사이자 접미사인 최장 부분 문자열의 길이를 나타낸다.  \n근데 증명은 못하겠다… 너무 어려워요 나중에 이해되면 추가해보겠습니다.\n\n백준 1305 번에서 사용됩니다\n\n\n## 시간 복잡도\n\n시간 복잡도는 $O(N + M)$ 이다. \n\n## 참고\n\n- https://www.youtube.com/watch?v=9bkbV-VANQ0\n- https://ps.mjstudio.net/kmp"},{"excerpt":"사랑은 다른 사람에게 적극적으로 침투하는 것이고, 이러한 침투를 통해 알려고 하는 나의 욕망은 합일에 의해 만족을 얻는다. 낮과 밤은 겉으로는 적이지만 동일한 목적에 이바지 하고 있고, 서로의 일을 완성하기 위해 밤과 낮은 서로 사랑하고 있다. 중요한 것은 이러한 일을 알아차리고, 이러한 일을 합리화하는 무수한 방법이 있더라도 결코 합리화하지 않는 것이다…","fields":{"slug":"/book-love-skill/"},"frontmatter":{"date":"2023년 11월 25일 14:11","title":"사랑의 기술","tags":["book"]},"rawMarkdownBody":"\n> 사랑은 다른 사람에게 적극적으로 침투하는 것이고, 이러한 침투를 통해 알려고 하는 나의 욕망은 합일에 의해 만족을 얻는다.\n\n> 낮과 밤은 겉으로는 적이지만 동일한 목적에 이바지 하고 있고, 서로의 일을 완성하기 위해 밤과 낮은 서로 사랑하고 있다.\n\n> 중요한 것은 이러한 일을 알아차리고, 이러한 일을 합리화하는 무수한 방법이 있더라도 결코 합리화하지 않는 것이다. 더 나아가 자기 자신의 내면의 소리에 귀를 기울이는 것이다. 자기 자신의 내면의 소리는 왜 내가 불안하고 우울하고 조바심내는가를 말해줄 것이다.\n\n> 이러한 신앙은 자기 자신의 경험과 자기 자신의 사고력, 관찰력, 판단력에 대한 확신에 뿌리박고 있다. \n\n> 자아의 지속성에 대해 신앙을 갖지 못하면 동일성에 대한 우리의 감정을 위협받고, 우리는 다른 사람에게 의존하게 되며, 이때는 다른 사람의 찬성이 동일성에 대한 우리 감정의 기초가 된다. 자기 자신에 대한 신앙을 갖고 있는 사람만이 다른 사람에게도 성실할 수 있다.\n\n> 곤란과 좌절과 슬픔을 '우리'에게 일어나서는 안 될 부당한 처벌이라기보다는 오히려 우리를 강하게 만들기 위해 극복해야 할 도전으로 받아들이려면 신앙과 용기가 필요하다.\n\n"},{"excerpt":"TODO LOG 요즘 TIL 에 소홀했다. 어제 오리가 블로그 쓴다기에 오리 블로그를 처음 봤는데, 담백한 어투가 참 오리답다고 생각했다. 나도 다시 TIL 을 열심히 써보려 한다. 땡큐 오리. 카카오 코테 2.9솔 했다. 시간이 좀 더 있었다면 한 문제 더 풀 수 있었을텐데 아쉽다. 역시 알고리즘은 연습이 필요하다. 코테도 좋은 경험이었다. 떨어지더라도…","fields":{"slug":"/2023-11-25/"},"frontmatter":{"date":"2023년 11월 25일 14:11","title":"2023년 11월 25일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 요즘 TIL 에 소홀했다. 어제 오리가 블로그 쓴다기에 오리 블로그를 처음 봤는데, 담백한 어투가 참 오리답다고 생각했다. 나도 다시 TIL 을 열심히 써보려 한다. 땡큐 오리.\n- 카카오 코테 2.9솔 했다. 시간이 좀 더 있었다면 한 문제 더 풀 수 있었을텐데 아쉽다. 역시 알고리즘은 연습이 필요하다. 코테도 좋은 경험이었다. 떨어지더라도 괜..괜찮아...\n- 에리히 프롬의 사랑의 기술을 다 읽었다. \n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"인덱스란?","fields":{"slug":"/what-is-index/"},"frontmatter":{"date":"2023년 11월 23일 05:11","title":"인덱스란 무엇인가?","tags":["database","미완"]},"rawMarkdownBody":"\n## 인덱스란?\n\n"},{"excerpt":"이관 과정 DB dump 및 마이그레이션 레포지토리 이관 운영 서버 설정 self-hosted-runner 설정 기존 레포지토리에 러너를 추가한다. Linux, ARM 으로 설정해준다. self-hosted-runner 에 명시되어 있는 대로 진행한다. runner 그룹 이름은 엔터로 하고, 러너 이름을 설정해준다. 라벨은 shook-production …","fields":{"slug":"/shook-migration/"},"frontmatter":{"date":"2023년 11월 22일 07:11","title":"S-HOOK EC2 마이그레이션하기","tags":["shook","우테코"]},"rawMarkdownBody":"\n## 이관 과정\n\n1. DB dump 및 마이그레이션\n2. 레포지토리 이관\n3. 운영 서버 설정\n\n## self-hosted-runner 설정\n\n기존 레포지토리에 러너를 추가한다.  \nLinux, ARM 으로 설정해준다. \n\nself-hosted-runner 에 명시되어 있는 대로 진행한다.  \nrunner 그룹 이름은 엔터로 하고, 러너 이름을 설정해준다.\n\n라벨은 shook-production 만 추가하면 기본 라벨들은 추가된다. \n\n## Github Action 변경\n\n일단 젠킨스 배포 전까지는 무중단 배포를 중단하기로 했다.  \n\n### 배포 스크립트 설정\n\n먼저 `~/application-jar` 디렉토리를 만든 후, 기존 배포 스크립트를 설정했다.\n\n```shell\necho \"> 현재 구동중인 애플리케이션 pid 를 조회합니다.\"\nCURRENT_PID=$(pgrep -f shook)\n\nif [ -z \"$CURRENT_PID\" ]; then\n        echo \"> 구동중인 애플리케이션이 없습니다.\"\nelse\n        while [ -n \"$CURRENT_PID\" ]\n        do\n\t\t\t    echo \"> 현재 구동중인 애플리케이션 pid: $CURRENT_PID\"\n                echo \"> kill -15 $CURRENT_PID\"\n                sudo kill -15 $CURRENT_PID\n                sleep 5\n                CURRENT_PID=$(pgrep -f shook)\n        done\nfi\n\necho \"> 구동중인 애플리케이션 종료가 완료되었습니다.\"\n\n# 애플리케이션 배포\necho \"> 애플리케이션 배포를 시작합니다.\"\nJAR_NAME=$(ls -t ~/application-jar/ | grep jar | head -n 1)\n\necho \">> $JAR_NAME 를 통한 배포 실행\"\nsudo nohup java -jar ~/application-jar/$JAR_NAME --spring.profiles.active=prod1 2>&1 &\n\nsleep 20\nCURRENT_PID=$(pgrep -f shook)\necho \">> 실행된 애플리케이션 pid: $CURRENT_PID\"\n\necho \"> 애플리케이션 배포가 완료되었습니다.\"\n```\n\nsecurity 서브모듈 설정을 위해 서브모듈이 있는 계정에 Authentication Key 를 추가했다.\n\n### 로깅용 디렉터리 추가\n\n`/var/log` 에 `app` 디렉터리를 생성한다.  \n\napp 디렉터리 내부에 warn, error, info 디렉터리를 생성한다.\n\n### 자바 설치\n\n똑같이 자바를 설치하는 걸 까먹은 우리 팀\n또 다시 설치해준다. \n\n### npm 설치\n\n`sudo apt-get install npm` 으로 npm 을 설치해준다.\n\n### nginx 권한을 root 로 변경\n\n이렇게 실행하면 nginx 에서 index.html 을 못 찾는다는 문제가 발생한다.  \nnginx 의 권한이 root 가 아니기 때문에 발생하는 문제다.\n\n`/etc/nginx` 의 nginx.conf 파일에서 user 를 root 로 변경해준다. \n\n### certbot 설정하기\n\n기존 운영 서버에서 인증서를 삭제한다.  \n\n### 서버 시간 설정하기\n\n`timedatectl list-timezones` 로 변경 가능한 Time Zone 들을 리스트업 할 수 있다.\n\n`Asia/Seoul` 로 TZ 을 변경한다. \n\n```bash\nsudo timedatectl set-timezone Asia/Seoul\n```\n\n`timedatectl` 로 변경된 TZ 를 볼 수 있다.\n\n```bash\n               Local time: Tue 2023-11-28 14:11:46 KST\n           Universal time: Tue 2023-11-28 05:11:46 UTC\n                 RTC time: Tue 2023-11-28 05:11:47\n                Time zone: Asia/Seoul (KST, +0900)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n```\n"},{"excerpt":"인터넷이란 무엇인가 인터넷의 구성요소를 기술하는 것 분산 애플리케이션에 서비스를 제공하는 네트워킹 인프라스트럭처 관점에서의 인터넷 구성요소로 본 인터넷 인터넷은 전 세계적으로 수십억 개의 컴퓨팅 장치를 연결하는 컴퓨터 네트워크이다. 데스크톱 PC, 리눅스 워크스테이션, TV, 게임 콘솔, 가전제품, 안경, 자동차 ... 같은 사물들이 인터넷에 연결되고 있…","fields":{"slug":"/top-down-approach-ch1/"},"frontmatter":{"date":"2023년 11월 20일 13:11","title":"1. 컴퓨터 네트워크와 인터넷","tags":["컴퓨터-네트워킹-하향식-접근"]},"rawMarkdownBody":"\n## 인터넷이란 무엇인가\n\n1. 인터넷의 구성요소를 기술하는 것\n2. 분산 애플리케이션에 서비스를 제공하는 네트워킹 인프라스트럭처 관점에서의 인터넷\n\n### 구성요소로 본 인터넷\n\n인터넷은 전 세계적으로 수십억 개의 컴퓨팅 장치를 연결하는 컴퓨터 네트워크이다.  \n\n데스크톱 PC, 리눅스 워크스테이션, TV, 게임 콘솔, 가전제품, 안경, 자동차 ... 같은 사물들이 인터넷에 연결되고 있다. 이러한 모든 장치를 인터넷 용어로 **호스트(host)** 혹은 종단 시스템 (end system) 이라고 부른다. \n\n종단 시스템은 통신 링크와 패킷 스위치의 네트워크로 연결된다.  \n링크들은 동축 케이블, 구리선, 광케이블, 라디오 스펙트럼을 포함한 다양한 물리 매체로 구성된다.  \n\n각각의 링크들은 다양한 전송률(링크 대역폭, transmission rate) 을 이용하여 데이터를 전송하며, 전송률은 초당 비트 수를 의미하는 bps (bit per second) 단위를 사용한다.\n\n한 종단 시스템이 다른 종단 시스템으로 보낼 데이터를 갖고 있을 때, 송신 종단 시스템은 그 데이터를 **세그먼트**로 나누고, 각 세그먼트에 **헤더**를 붙인다.  \n이렇게 만들어진 정보 패키지는 컴퓨터 네트워크에서 **패킷(packet)** 이라고 한다.\n\n패킷 교환기(스위치)는 입력 통신 링크의 하나로, 도착하는 패킷을 받아 출력 통신 링크의 하나로 패킷을 전달한다.  \n패킷 스위치는 많은 형태와 특징이 있는데, 오늘날 가장 널리 사용되는 라우터와 링크 계층 스위치가 있다. 링크 계층 스위치는 보통 접속 네트워크에서 사용되고 라우터는 네트워크 코어에서 사용된다.\n\n패킷이 송신 종단 시스템에서 수신 종단 시스템에 도달하는 동안 거쳐온 일련의 통신 링크와 패킷 스위치를 네트워크상의 **경로(route 혹은 path)** 라고 한다.\n\n종단 시스템은 **ISP(Internet Service Provider)** 를 통해 인터넷에 접속한다.  \nISP 는 다음과 같은 종류가 있다.  \n- 가정 ISP, 법인 ISP, 대학 ISP\n- 와이파이 접속을 제공하는 ISP\n- 이동 접속을 제공하는 셀룰러 데이터 ISP\n\n각 ISP 는 패킷 스위치와 통신 링크로 이루어진 네트워크이다.  \nISP 는 종단 시스템에게 다양한 네트워크 접속을 제공한다. 또한 웹사이트와 비디오 서버를 인터넷에 직접 연결하도록 CP(content provider) 에게 인터넷 접속을 제공한다.  \n종단 시스템에 접속을 제공하는 ISP 들도 서로 연결되어야 하고, 하위 계층 ISP 는 국가, 국제 상위 계층 ISP 를 통해 서로 연결하고, 상위 계층 ISP 들은 서로 직접 연결된다.  \n상위 계층 ISP 는 광 링크로 연결된 고속 라우터로 구성된다. 각 ISP 네트워크들은 따로 관리되고, IP 프로토콜을 수행하며, 네이밍과 주소배정 방식을 따른다.\n\n종단 시스템, 패킷 스위치를 비롯한 인터넷의 다른 구성요소는 인터넷에서 정보 송수신을 제어하는 여러 **프로토콜**을 수행한다. TCP 와 IP 가 인터넷에서 가장 중요한 프로토콜이다. \n\n인터넷 표준은 IETF(Internet Engineering Task Force) 에서 개발하며, IETF 표준 문서를 RFC(requests for comment) 라고 한다. 이들은 TCP, IP, HTTP, SMTP 같은 프로토콜을 정의한다. \n\n### 서비스 측면에서 본 인터넷\n\n애플리케이션에 서비스를 제공하는 인프라스트럭처로서 인터넷을 기술할 수 있다.  \n인터넷 애플리케이션은 인터넷 메시징, 지도 서비스, 게임, 위치기반 추천 시스템을 포함하는 모바일 스마트폰과 태블릿 애플리케이션을 포함한다. 이런 애플리케이션은 서로 데이터를 교환하는 많은 종단 시스템을 포함하고 있기 떄문에 **분산 애플리케이션**(distributed application) 이라고 부른다.  \n인터넷 애플리케이션은 종단 시스템에서 수행된다. \n\n인터넷에 접속된 종단 시스템들은 한 종단 시스템에서 수행되는 프로그램이 어떻게 인터넷 인프라 스트럭처에 다른 종단 시스템에서 수행되는 특정 목적지 프로그램으로 데이터를 전달하도록 요구하는지를 명시하는 **소켓 인터페이스**를 제공한다.  \n인터넷 소켓 인터페이스는 송신 프로그램이 따라야 하는 규칙의 집합이며, 인터넷은 이 규칙에 따라 데이터를 목적지 프로그램으로 전달하게 된다. \n\n인터넷 송신 프로그램은 데이터를 목적지 프로그램으로 전달할 수 있도록 따라야 하는 소켓 인터페이스를 갖고 있다. 또한 인터넷은 여러 서비스를 애플리케이션에 제공한다. \n\n### 프로토콜이란 무엇인가?\n\n> 프로토콜은 둘 이상의 통신 개체 간에 교환되는 메시지 포맷과 순서뿐만 아니라, 메시지의 송수신과 다른 이벤트에 따른 행동들을 정의한다.\n\n네트워크 프로토콜은 메시지를 교환하고 행동을 취하는 개체가 장치들의 하드웨어나 소프트웨어 구성요소이다. 통신하는 둘 이상의 원격 개체가 포함된 인터넷에서의 모든 활동은 프로토콜이 제어한다.  \n\n물리적으로 연결된 두 컴퓨터의 네트워크 접속 카드에서 하드웨어로 구현된 하드웨어로 구현된 프로토콜은 컴퓨터로 사이에 연결된 선로상의 비트 흐름을 제어한다.  \n라우터에서 프로토콜은 출발지에서 목적지까지 패킷 경로로 설정한다. \n\n## 네트워크의 가장자리\n\n종단 시스템은 웹 브라우저 프로그램, 웹 서버 프로그램, 전자메일 서버 프로그램 같은 애플리케이션을 수행하므로 **호스트**라고 부른다. 즉, 호스트는 종단 시스템이다. \n\n호스트는 클라이언트와 서버로 구분된다. 비공식적으로 클라이언트는 데스크톱, 이동 PC, 스마트폰들을 의미한다. 서버는 웹 페이지를 저장하고 분배하고 비디오를 스트림하며 전자메일을 릴레이하는 더 강력한 기능을 갖춘 컴퓨터다. \n\n### 접속 네트워크\n\n> 접속 네트워크란 종단 시스템을 그 종단 시스템으로부터 먼 거리에 있는 다른 종단 시스템까지의 경로상에 있는 첫 번째 라우터(edge router 라고도 한다.) 에 연결하는 네트워크이다. \n\n#### 가정 접속: DSL, 케이블, FTTH, 5G 고정 무선\n\n가장 널리 보급된 광대역 가정 접속 유형은 **DSL(digital subscriber line)** 과 케이블이다. 일반적으로 가정은 유선 로컬 전화 서비스를 제공하는 같은 지역 전화 회사 (telco)로부터 DSL 인터넷 접속 서비스를 받는다. 따라서 DSL 을 사용할 때 고객의 telco 가 ISP 도 된다.  \n\n각 DSL 모뎀은 텔코의 지역 중앙국 (central office, CO)에 위치한 DSLAM (digital subscriber line access multiplexer) 과 데이터를 교환하기 위해 기존 전화 회선을 이용한다. 가정의 DSL 모뎀은 디지털 데이터를 받아서 전화선을 통해 CO 로 전달하기 위해 고주파 신호로 변환한다. 여러 가정으로부터의 아날로그 신호는 DSLAM 에서 디지털 포맷으로 다시 변환된다.\n\n가정 전화 회선은 데이터와 전통적인 전화 신호를 동시에 전달하며 이들은 다른 주파수 대역에서 인코딩된다. \n\n- 고속 다운스트림 채널: 50kHz ~ 1 MHz 대역\n- 중간 속도의 업스트림 채널: 4~50 kHz 대역\n- 일반적인 양방향 전화 채널: 0~4 kHz 대역\n\n단일 DSL 링크가 3개의 분리된 링크인 것처럼 보이게 하여 하나의 전화 회선과 인터넷 연결이 동시에 DSL 링크를 공유할 수 있게 한다.  \n\nDSL 표준은 24 Mbps 와 52 Mbps 속도의 다운스트림과 3.5 Mbps 와 16 Mbps 속도의 업스트림을 포함하는 여러 전송률을 정의한다. 최신 표준은 업스트림과 다운스트림을 결합한 1 Gbps 속도의 정의하고 있다. 다운스트림과 업스트림 속도가 다르기 때문에 이 접속 방식을 비대칭(asymmetric) 이라고 한다. 실제 다운스트림과 업스트림 속도는 위의 속도와 비교했을 때 작을 수 있다. \n\nDSL 이 텔코의 기존 로컬 전화 인프라스트럭처를 이용하는 반면, 케이블 인터넷 접속은 케이블 TV 회사의 기존 케이블 TV 인프라스트럭처를 이용한다.  \n가정은 케이블 TV 서비스를 제공하는 같은 회사로부터 인터넷 접속 서비스를 받는다. 광케이블은 케이블 헤드엔드를 이웃 레벨 정션(junction) 에 연결하며 이로부터 개별 가정과 아파트에 도달하는 데 전통적인 동축케이블이 사용된다. 광케이블과 동축케이블 모두 이 시스템에서 채택하고 있기 때문에 흔히 **HFC** 라고 부른다.\n\n케이블 인터넷 접속은 케이블 모뎀이라고 하는 특별한 모뎀이 필요하다. 케이블 모뎀은 보통 외장형 장치이고, 이더넷 포트를 통해 가정 PC 에 연결된다. 케이블 모뎀은 HFC 네트워크를 2개의 채널, 다운스트림과 업스트림 채널로 나눈다. DSL 에서와 마찬가지로 접속은 비대칭이며, 보통 다운스트림 채널이 업스트림 채널보다 빠른 전송률이 할당된다. 낮은 전송 속도 계약 혹은 미디어 손실로 인해 최대 가능 속도가 실현되지 않을 수도 있다.  \n케이블 인터넷의 한 가지 중요한 특성은 공유 방송 매체라는 것이다. 헤드엔드가 보낸 모든 패킷이 모든 링크의 다운스트림 채널을 통해 모든 가정으로 전달된다. 그리고 가정에서 보낸 모든 패킷은 업스트림 채널을 통해 헤드엔드로 전달한다. 이러한 이유로, 여러 사용자가 다운스트림 채널에서 다른 비디오 파일을 동시에 수신하고 있다면 각 사용자가 비디오 파일을 수신하는 실제 수신율은 다운스트림 전송률보다 상당히 작아진다. 업스트림 채널도 공유되므로 분산 다중 접속 프로토콜은 전송을 조정하고 충돌을 피하기 위해 필요하다. \n\nDSL 과 케이블 네트워크가 미국의 가정 광대역 접속 주류를 이루고 있으나 좀 더 빠른 속도를 제공하는 미래 기술은 FTTH (fiber to the home) 이다. FTTH 는 CO 로부터 가정까지 직접 광섬유 경로를 제공하고, 잠재적으로 Gbps 의 인터넷 접속 속도를 제공할 수 있다. \n\nCO 로부터 가정까지 광신호를 분배하는 여러 경쟁적인 기술이 있다.  \n가장 간단한 광신호 분배 네트워크는 각 가정으로 CO 에서 하나의 광섬유를 제공하는데, 다이렉트 광섬유라고 한다. 좀 더 일반적으로, CO에서 시작되는 각 광섬유는 실질적으로 여러 가정이 공유한다. 가정에 가까운 곳까지 하나의 광섬유로 와서 이곳에서 고객별 광섬유로 분리된다. 이러한 스플리팅을 수행하는 두 가지 경쟁적인 광신호 분배 네트워크 구조가 AON(active optical network) 과 PON(passive optical network) 이다. \n\nPON 분배 구조를 이용하는 FTTH를 살펴보자.  \n각 가정은 ONT (optical network terminator) 를 갖고 있으며, 이는 지정된 광섬유로 이웃 스플리터에 연결된다. 스플리터는 여러 가정을 하나의 공유 광섬유로 결합하고, 이를 텔코의 CO에 있는 OLT (optical line terminator) 에 연결한다. 광신호와 전기신호 간의 변환을 제공하는 OLT는 텔코 라우터를 통해 인터넷에 연결된다. 가정에서 사용자는 홈 라우터(일반적으로 무선 라우터)를 ONT에 연결하고, 이 홈 라우터를 통해 인터넷에 접속한다. PON 구조의 OLT에서 스플리터로 송신된 모든 패킷은 스플리터에서 복제된다. \n\nDSL, 케이블, FTTH 외에 5G 고정 무선 기술이 구축되고 있다. 5G-FW 는 고속 가정 접속뿐만 아니라 전화회사 중심국에서 가정까지의 비용이 들고 고장이 잘 나는 케이블 포설 작업을 하지 않아도 되게 해줄 것이다. \n\n#### 기업 (그리고 가정) 접속: 이더넷과 와이파이\n\nLAN (local area network) 는 일반적으로 종단 시스템을 edge router 에 연결하는 데 사용된다. 여러 유형의 LAN 기술이 있지만 이더넷 기술이 가장 널리 사용되는 접속 기술이다. \n\n이더넷은 이더넷 스위치에 연결하기 위해 꼬임쌍선을 이용한다.  \n이더넷 접속에서 사용자는 보통 이더넷 스위치에 100 Mbps 부터 10 Gbps 까지의 속도로 접속하고, 서버는 1 Gbps 부터 10 Gbps 까지의 속도로 접속한다. \n\n무선 랜 환경에서 무선 사용자들은 기업 네트워크에 연결된 AP (access point) 로 패킷을 송/수신하고 이 AP 는 유선 네트워크에 다시 연결된다. 무선 랜 사용자들은 일반적으로 AP 의 수십 미터 반경 내에 있어야 한다. 와이파이라고 더 잘 알려진 IEEE 802.11 기술에 기반한 무선 랜 접속은 이제 거의 모든 곳에 존재한다. \n\n#### 광역 무선 접속: 3G와 LTE 4G와 5G\n\n이동 전화망 사업자들이 운영하는 기지국을 통해 패킷을 송수신하는 데 사용하는 것과 같은 무선 인프라스트럭처를 채택하고 있다. 와이파이와 달리, 사용자는 기지국의 수십 킬로미터 반경 내에 있으면 된다. \n\n### 물리 매체\n\n비트가 출발지에서 목적지로 전달될 때, 일련의 송신기-수신기 쌍을 거친다. 각 송신기-수신기 쌍에 대해 이 비트는 물리 매체 상에 전자파나 광 펄스를 전파하여 전송한다. 물리 매체는 여러 형태이며 경로상의 각 송신기-수신기 쌍에 대해 같은 유형일 필요는 없다. \nex. 꼬임쌍선, 동축케이블, 다중모드 광섬유 케이블, 지상파와 위성파\n\n1. 유도 매체\n광섬유 케이블, 꼬임쌍선 혹은 동축케이블 같은 견고한 매체를 따라 파형을 유도한다. 비유도 매체는 무선 랜 혹은 디지털 위성 채널의 경우처럼 대기와 야외 공간으로 파형을 전파한다. \n- **꼬임쌍선**\n\t가장 싸고 가장 많이 이용하는 전송 매체이다. 100년 넘게 전화망에 사용되었다. UTP(unshielded twisted pair) 는 빌딩의 컴퓨터 네트워크, 즉 LAN 에 가장 많이 사용하는 매체이다. 꼬임 쌍선을 이용하는 LAN 의 데이터 전송률은 10 Mbps 에서 10 Gbps 에 이른다. 가능한 데이터 전송률은 전송선의 두께와 송신기와 수신기 사이의 거리에 따라 다르다. \n- **동축 케이블**\n\t2개의 구리선으로 되어 있으나 두 구리선이 평행하지 않고 동심원 형태를 이루고 있다. 꼬임쌍선보다 더 높은 데이터 전송률을 얻을 수 있다. 케이블 TV 와 케이블 인터넷 접속에서 송신기는 디지털 신호를 특정 주파수 대역으로 이동시키고 그 결과 아날로그 신호는 송신기로부터 하나 이상의 수신기로 전송된다. 동축 케이블은 유도 매체로 사용할 수 있고, 여러 종단 시스템은 케이블에 직접 연결할 수 있으며 모든 종단 시스템은 다른 종단 시스템이 전송하는 모든 것을 수신한다. \n- **광섬유**\n\t비트를 나타내는 빛의 파동을 전하는 가늘고 유연한 매체. 단일 광섬유는 초당 10~100기가 비트에 이르는 놀라운 비트율을 지원할 수 있다. 전자기성 간섭에 영향을 받지 않으며 100 km 까지는 신호 감쇠 현상이 매우 적고 태핑하기 어렵다. 이런 특성 때문에 광역 유도 전송 매체로 널리 이용하는데, 특히 해저 링크에 광섬유를 사용한다. 그러나 송신기, 수신기, 스위치 등의 광 장비는 고가이므로 LAN 이나 가정처럼 근거리 전송에는 이용하기 어렵다. \n- 지상 라디오 채널\n\t전자기 스펙트럼으로 신호를 전달한다. 라디오 채널은 물리 선로를 설치할 필요가 없고, 벽을 관통할 수 있고, 이동 사용자에게 연결성을 제공하고 먼 거리까지 신호를 전달할 수 있다는 가능성 때문에 매력적이다. 전파 환경과 신호가 전달되는 거리에 많은 영향을 받는다. 주변 환경은 경로 손실과 섀도 페이딩 (shadow fading, 신호가 먼 거리를 지나감에 따라 혹은 방해 물질을 돌아가거나 통과함에 따라 신호 강도가 약해지는 현상), 다중 경로 페이딩, 간섭을 결정한다. \n- 위성 라디오 채널\n\t통신 채널은 지상 스테이션이라는 둘 이상의 지상 기반 마이크로파 송신기/수신기를 연결한다. 위성은 한 주파수 대역으로 전송 신호를 수신하고, 리피터를 이용하여 그 신호를 재생하며 해당 신호를 다른 주파수 대역으로 전송한다. 위성은 초당 기가비트의 전송률을 제공할 수 있다. 통신에는 정지 위성 / 저궤도 위성이 이용된다.\n\n## 네트워크 코어\n\n### 패킷 교환\n\n네트워크 애플리케이션에서 종단 시스템들은 서로 메시지를 교환한다. 메시지에는 애플리케이션 설계자가 원하는 무엇인가가 포함될 수 있다.\n\n출발지 종단 시스템에서 목적지 종단 시스템으로 메시지를 보내기 위해 송신 시스템은 긴 메시지를 **패킷(packet)** 이라고 하는 작은 데이터 덩어리로 분할한다. 송신 측과 수신 측 사이에서 각 패킷은 통신 링크와 패킷 스위치 (packet switch - 라우터와 링크 계층 스위치의 두 가지 유형이 있음)를 거치게 된다. \n\n패킷은 링크의 최대 전송률과 같은 속도로 각각의 통신 링크에서 전송된다.  \n즉 출발지 종단 시스템 혹은 패킷 스위치가 $R비트/초$의 속도로 링크에서 L비트의 패킷을 송신한다면 그 패킷을 전송하는데 걸리는 시간은 $L/R$초다.\n\n#### 저장-후-전달\n\n대부분의 패킷 스위치는 저장-후-전달 전송 (store-and-forward transmission) 방식을 이용한다. 저장-후-전달은 스위치가 출력 링크로 패킷의 첫 비트를 전송하기 전에 전체 패킷을 받아야 함을 의미한다.\n\n라우터는 보통 여러 개의 링크를 갖는다. 라우터의 기능이 입력되는 패킷을 출력 링크로 교환하는 것이기 때문이다.  \n라우터는 저장-후-전달 전송을 채택하고 있기 때문에 라우터가 패킷의 모든 비트를 수신한 후에만 출력 링크로 그 패킷을 전송하기 시작한다.\n\n출발지부터 목적지 노드까지 N개의 링크로 구성되고 각각은 전송률이 R인 경로를 통해 하나의 패킷을 전송하는 일반적인 경우, 종단 간 지연은 다음과 같다.\n\n$$\nd_{종단간지연 }= N * \\frac{L}{R}\n$$\n\n#### 큐잉 지연과 패킷 손실\n\n각 패킷 스위치는 접속된 여러 개의 링크를 갖고 있다. 각 링크에 대해 패킷 스위치는 출력 버퍼 (output buffer, 출력 큐 (output queue) 라고도 한다.)를 갖고 있으며 그 링크로 송신하려고 하는 패킷을 저장하고 있다.  \n\n출력 버퍼는 패킷 교환에서 중요한 역할을 한다.  \n도착하는 패킷이 한 링크로 전송되어야 하는데 그 링크가 다른 패킷을 전송하고 있다면 도착하는 패킷은 출력 버퍼에서 대기해야 한다. 따라서 저장-후-전달 지연뿐 아니라 패킷은 출력 버퍼에서 큐잉 지연을 겪게 된다.  \n버퍼 공간의 크기가 유한하기 때문에 도착하는 패킷은 버퍼가 전송을 위해 대기 중인 다른 패킷들로 꽉 차 있는 경우를 당할 수 있는데, 이 경우 패킷 손실이 발생한다. \n\n#### 포워딩 테이블과 라우팅 프로토콜\n\n인터넷에서 모든 종단 시스템은 IP 주소라고 하는 주소를 갖는다. 출발지 종단 시스템이 패킷을 목적지 종단 시스템으로 보내고자 할 때 출발지는 패킷의 헤더에 목적지의 IP 주소를 포함한다.  \n\n각 라우터는 목적지 주소(혹은 목적지 주소의 일부)를 라우터의 출력 링크로 매핑하는 포워딩 테이블을 갖고 있다. 패킷이 라우터에 도착하면 라우터는 올바른 출력 링크를 찾기 위해 주소를 조사하고, 이 목적지 주소를 이용하여 포워딩 테이블을 검색한다. 그 다음 라우터가 그 패킷을 출력 링크로 보낸다. \n\n인터넷은 자동으로 포워딩 테이블을 설정하는데 이용하는 여러 특별한 라우팅 프로토콜을 가지고 있다. \n\n### 회선 교환\n\n링크와 스위치의 네트워크를 통해 데이터를 이동시키는 방식에는 회선 교환과 패킷 교환이라는 두 가지 기본 방식이 있다. \n\n회선 교환 네트워크에서 종단 시스템 간에 통신을 제공하기 위해 경로상에 필요한 자원 (버퍼, 링크 전송률) 은 통신 세션 동안에 확보 또는 예약된다. 패킷 교환 네트워크에서는 이런 자원을 예약하지 않는다.\n\n회선 교환 네트워크의 예시로 전통적인 전화망이 있다. 송신자가 정보를 보내기 전에 네트워크는 송신자와 수신자 간의 연결을 설정해야 하고, 이는 송신자와 수신자 간의 경로에 있는 스위치들이 해당 연결 상태를 유지해야 하는 연결이다. 이 연결을 **회선**이라고 한다.  \n네트워크가 회선을 설정할 때, 그 연결이 이루어지는 동안 네트워크 링크에 일정한 전송률을 예약한다. 주어진 전송률이 송신자-수신자 연결을 위해 예약되므로 송신자는 수신자에게 보장된 일정 전송률로 데이터를 전송할 수 있다. \n\n#### 회선 교환 네트워크에서의 다중화\n\n링크 내 한 회선은 **주파수 분할 다중화 (frequency-division multiplexing, FDM)** 혹은 시 분할 다중화 (time-division multiplexing, TDM) 로 구현된다. \n\nFDM 에서 링크를 통해 설정된 연결은 그 링크의 주파수 스펙트럼을 공유한다. 또한 그 링크는 연결되는 동안 각 연결에 대해 주파수 대역을 고정 제공한다. 일반적으로 4kHz 폭을 갖는다. 이런 대역의 폭을 **대역폭**이라고 한다. \n\nTDM 링크의 경우는 시간을 일정 주기의 프레임으로 구분하고 각 프레임은 고정된 수의 시간 슬롯으로 나뉜다. 네트워크가 링크를 통해 하나의 연결을 설정할 때, 이들 슬롯은 이 연결을 위해 사용되도록 할당되고 그 연결의 데이터를 전송하기 위해 모든 프레임에 하나의 시간 슬롯을 갖게 된다. \n\nTDM 회선의 전송률은 한 슬롯 안의 비트 수에 프레임 전송률을 곱한 것과 같다. \n\n#### 패킷 교환 대 회선 교환\n\n패킷 교환은 왜 효율적인가? 회선 교환의 경우, 사용자들의 비활동 시간이 긴 경우에도 항상 일정 전송률이 사용자에게 예약된다. 그러나 패킷은 동시 사용자가 많지 않은 경우 (혹은 동시 사용자가 있는 확률이 매우 작은 경우에) 패킷 교환은 거의 항상 회선 교환과 대등한 지연 성능을 가지면서도 높은 사용자 수를 허용할 수 있다. \n\n즉, 회선 교환이 요구에 관계 없이 미리 전송 링크의 사용을 할당하는 반면, 패킷 교환은 요구할 때만 링크의 사용을 할당한다.\n\n### 네트워크의 네트워크\n\n종단 시스템은 접속 ISP 를 통해 인터넷에 연결된다. 접속 ISP 는 다양한 접속 기술을 이용하여 유선, 무선 연결을 제공한다.  \n그러나 종단 사용자들과 콘텐츠 제공자들을 접속 ISP 로 연결하는 것은 인터넷을 구성하는 수십억 개의 종단 시스템을 연결하는 퍼즐의 해결 방법 중 극히 일부에 해당한다. 이를 위해서는 접속 ISP 들이 서로 연결되어야 한다. 이를 위해 **네트워크의 네트워크**가 탄생하게 되었다. \n\n점진적으로 네트워크 구조를 만들어보자. \n\n1. 네트워크 구조1\n\t모든 접속 ISP 를 하나의 *글로벌 통과(transit) ISP* 와 연결한다. 글로벌 ISP 는 라우터와 전 세계에 이르고 적어도 수십만 개의 접속 ISP 와 가까운 곳에 있는 라우터를 갖는 통신 링크의 네트워크다. 이런 확장된 네트워크를 구축하는 데는 매우 많은 비용이 들기 때문에 글로벌 ISP는 접속 ISP 에게 요금을 부과할 것이다. 즉, 접속 ISP 는 고객이고 글로벌 ISP 는 제공자가 된다. \n\n어느 회사가 수익을 내는 글로벌 ISP 를 구축하고 운영한다면, 다른 회사가 자신만의 글로벌 ISP 를 구축하고 또 다른 글로벌 ISP 와 경쟁할 수 있을 것이다.\n\n2. 네트워크 구조 2\n\t수십만 개의 접속 ISP 와 다중의 글로벌 ISP 로 구성되는 *2계층 구조*이다. 접속 ISP 는 가격과 서비스를 비교하며 경쟁하는 여러 글로벌 통과 서비스 제공자들 중에서 선택할 수 있기 때문에 네트워크 구조 2를 선호할 것이다. 그러나 글로벌 ISP 들은 하나의 글로벌 ISP 와 연결된 접속 ISP 가 다른 글로벌 통과 서비스 제공자에게 연결된 접속 ISP 와 연결하기 위해 서로 연결되어야 한다.\n\n그러나 현실적으로 전 세계의 모든 도시에 존재하는 ISP 는 없다. 대신 어느 주어진 지역에서 그 지역에 있는 접속 ISP 들이 연결하는 지역 ISP 가 있다. 각 지역 ISP 들은 1계층 ISP 들과 연결된다. 1계층 ISP 들은 글로벌 ISP 와 유사하지만, 전 세계적으로 모든 도시에 존재하지는 않는다는 점에서 차이를 갖는다. (대략적으로 12개 정도의 1계층 ISP 가 있다.)\n\n3. 네트워크 구조 3\n\t여러 경쟁적인 1계층 ISP 가 존재할 뿐만 아니라 한 지역에 여러 경쟁적인 지역 ISP 들이 있는 *다중계층구조*이다. 각각의 접속 ISP 는 자신이 연결하는 지역 ISP 에게 요금을 지불하고, 각 지역 ISP 는 자신이 연결하는 1계층 ISP 에 요금을 지불한다. (더 복잡한 경우 지역 ISP -> 지방 ISP -> 국가 ISP -> 1계층 ISP 로 연결되는 구조를 가질 수도 있다.)\n\n인터넷과 좀 더 유사한 네트워크를 구축하기 위해서는 PoP, 멀티홈, 피어링, IXP 를 계층적인 네트워크 구조 3에 포함해야 한다.\n\n4. 네트워크 구조 4: 접속 ISP, 지역 ISP, 1계층 ISP, PoP, 멀티홈, 피어링, IXP 로 구성한 구조\n**PoP (points of presence)** : 제공자의 네트워크 내에 있는 하나 혹은 그 이상의 라우터 그룹. 여기서 고객 ISP 가 제공자 ISP 에 연결될 수 있다. 고객은 자신의 라우터 중 하나를 PoP에 있는 라우터에 직접 연결하도록 고속 링크를 제 3자 통신 서비스로부터 임대할 수 있다. \n**멀티홈**: 둘 혹은 그 이상의 제공자 ISP 에 연결하도록 선택하는 것이다. 한 ISP 가 멀티홈을 하면 서비스 제공자 중 하나가 연결되지 않더라도 인터넷으로 패킷을 계속해서 송수신할 수 있다.\n**피어링**: 고객 ISP 가 서비스 제공 ISP 에게 지불하는 요금은 서비스 제공자와 교환하는 트래픽의 양을 반영하기 때문에, 이 비용을 줄이기 위해 같은 계층에 있는 가까운 ISP 들은 \"이들 간에 송수신되는 모든 트래픽을 상위 계층 ISP 를 통하지 않고 직접 송수신할 수 있도록 자신들의 네트워크를 직접 연결할 수 있다\"\n**IXP (Internet Exchange Point)**: 일반적으로 교환기를 갖춘 독자적인 빌딩에 존재한다. 제 3의 회사가 IXP 를 구축할 수 있으며, 이는 다중의 ISP 들이 서로 피어링을 할 수 있는 만남의 장소라고 할 수 있다.\n\n5. 네트워크 구조 5: 네트워크 구조 4 위에 **콘텐츠 제공자 네트워크 (content-provider network)** 를 추가하여 구축한 것이다. \n\t\n오늘날의 인터넷은 복잡하며 12개 정도의 1계층 ISP 들과 수십만 개의 하위 계층 ISP 들로 구성되어 있다. ISP는 그 서비스 영역이 다양하며 여러 대륙과 대양에 걸쳐 서비스하는 것도 있고, 지리적으로 매우 좁은 지역만을 대상으로 하는 것도 있다.  \n사용자와 콘텐츠 제공자는 하위 계층 ISP의 고객이고, 하위 계층 ISP들은 상위 계층 ISP들의 고객이다. 최근에 주요 콘텐츠 제공자도 자신의 네트워크를 구축했고, 가능한 곳에서 하위 계층 ISP들과 직접 연결한다.\n\n## 패킷 교환 네트워크에서의 지연, 손실과 처리율\n\n### 패킷 교환 네트워크에서의 지연 개요\n\n패킷이 경로를 따라 한 노드 (호스트 혹은 라우터)에서 다음 노드(호스트 혹은 라우터)로 전달되므로 그 패킷은 경로상의 각 노드에서 다양한 지연을 겪는다.\n노드 처리 지연, 큐잉 지연, 전송 지연, 전파 지연이 있고, 이러한 지연들이 쌓여서 전체 노드 지연을 일으킨다.\n\n#### 지연 유형\n\n라우터 A가 라우터 B에 이르는 하나의 출력 링크를 갖는다. \n패킷이 업스트림 노드로부터 라우터 A에 도착하면, 라우터 A는 그 패킷에 대한 적당한 출력 링크를 결정하기 위해 패킷 헤더를 조사하고, 선택된 링크로 패킷을 보낸다.  \n패킷은 링크에 현재 전송되는 다른 패킷이 없고, 큐에 자신보다 앞선 다른 패킷들이 없으면 링크로 전송될 수 있다. 만약 링크가 이미 이용되고 있거나 그 링크를 이용하기 위해 큐에서 대기하고 있는 패킷이 있다면 새로 도착하는 패킷은 큐에 들어간다. \n\n#### 처리 지연\n\n패킷 헤더를 조사하고 그 패킷을 어디로 보낼지 결정하는 시간은 처리 지연에 속한다.  \n처리 지연은 업스트림 노드에서 라우터 A로 패킷의 비트를 전송하면서 발생하는 패킷의 비트 레벨 오류를 조사하는 데 필요한 시간과 같은 요소를 포함할 수도 있다.\n\n고속 라우터에서의 처리 지연은 **수 마이크로초**이다.  \n노드 처리 후에 라우터는 그 패킷을 라우터 B에 이르는 링크에 앞선 큐에 보낸다.\n\n#### 큐잉 지연\n\n패킷은 큐에서 링크로 전송되기를 기다리면서 큐잉 지연을 겪는다.  \n특정 패킷의 큐잉 지연 길이는 큐에 저장되어 링크에 전송되기를 기다리는 다른 앞서 도착한 패킷의 수에 의해 결정된다.  \n\n현실에서 큐잉 지연은 **수 마이크로초에서 수 밀리초**에 이른다.\n\n#### 전송 지연\n\n일반적으로 패킷은 앞서 도착한 다른 모든 패킷이 전송된 다음에 전송된다.  \n\n패킷의 길이를 L비트로, 라우터 A에서 라우터 B까지 링크의 전송률은 R bps 로 나타내보자.  \nR은 라우터 B로 가는 링크의 전송률에 의해 결정된다.  \n\n전송 지연은 $L/R$ 으로, 패킷의 모든 비트를 링크로 밀어내는 데 필요한 시간이다.  \n전송 지연은 **수 마이크로초에서 수 밀리초**에 이른다.\n\n#### 전파 지연\n\n링크의 처음부터 라우터 B까지의 전파에 필요한 시간이 전파 지연이다.  \n비트는 링크의 전파 속도로 전파된다. 전파 속도의 범위는 다음과 같다. \n\n$2  * 10^8미터/초$ ~ $3 * 10^8미터 /초$\n\n전파 지연은 두 라우터 사이의 거리를 전파 속도로 나눈 것으로, 즉, 전파 지연은 $d/s$ 이다. (d: 라우터 A와 B 사이의 거리, s: 링크의 전파 속도)\n\n광역 네트워크에서 전파 지연은 일반적으로 **수 밀리초**에 이른다. \n\n#### 전송 지연과 전파 지연 비교\n\n전송 지연은 라우터가 패킷을 내보내는 데 필요한 시간이다.  \n반면, 전파 지연은 비트가 한 라우터에서 다음 라우터로 전파되는 데 걸리는 시간이다. \n\n전체 노드 지연은 다음과 같다.\n\n$$d_{처리지연 } = d_{큐잉지연}+ d_{전송 지연} + d_{전파지연}$$\n\n전파 지연, 전송 지연은 무시할 수 있는 정도에서 상당한 지연에까지 이를 수 있다.  \n처리 지연은 보통 무시될 수 있다. 그러나 라우터의 최대 처리율, 즉 라우터가 패킷을 전달할 수 있는 최대율에는 상당한 영향을 준다. \n\n### 큐잉 지연과 패킷 손실\n\n다른 지연들과 다르게 큐잉 지연은 패킷마다 다를 수 있다. (전송된 첫 패킷은 큐잉 지연을 겪지 않지만, 마지막으로 전송되는 패킷은 상당히 많은 큐잉 지연을 겪을 것이다.)\n\n언제 큐잉 지연이 클까? 트래픽이 큐에 도착하는 비율, 링크의 전송률, 도착하는 트래픽의 특성, 즉 그 트래픽이 주기에 맞춰서 또는 버스트하게 도착하느냐에 의해 주로 결정된다.  \n\n$a$: 패킷이 큐에 도착하는 평균율 (a의 단위는 패킷 / 초)\n$R$: 전송률, 즉 비트가 큐에서 밀려나는 비율 (비트 / 초)\n$L$: 모든 패킷의 크기 (편의상 가정, 비트)\n$La비트/초$: 비트가 큐에 도착하는 평균율\n큐가 매우 커서 무한대 비트를 저장할 수 있다고 가정한다.   \n\n트래픽 강도, 즉 $La / R$ 은 큐잉 지연의 정도를 측정하는 데 매우 중요하다. $La/R$ > 1이면 비트가 큐에 도착하는 평균율이 비트가 큐에서 전송되는 비율을 초과한다. 이 경우 큐는 트래픽으로 증가하고 큐잉 지연은 무한대에 도달한다. 그러므로 트래픽 강도가 1보다 크지 않게 시스템을 설계해야 한다.  \n\n$\\frac{La}{R} <= 1$ 인 경우를 생각해보자. 이 때 도착 트래픽의 특성이 큐잉 지연에 영향을 미친다.  \n모든 패킷이 주기적으로 도착하면, 하나의 패킷이 $L/R$ 초마다 도착한다면 모든 패킷은 빈 큐에 도착할 것이고 큐잉 지연은 없을 것이다.  \n반면 패킷이 몰려서 도착한다면 상당한 평균 큐잉 지연이 생길 것이다.  \n\n트래픽 강도가 1에 접근할수록 평균 큐잉 지연이 급속히 증가한다는 사실이다. 강도에 있어서 작은 비율의 증가는 지연에서 훨씬 큰 비율의 증가를 일으킬 것이다.   \n\n#### 패킷 손실\n\n현실에서 큐의 용량은 스위치 설계와 비용에 크게 의존하며 일반적으로 유한 용량을 갖는다. 큐 용량이 유한하므로 트래픽 강도가 1에 접근함에 따라 패킷 지연이 실제로 무한대가 되지는 않는다.   \n\n패킷을 저장할 수 없는 경우 라우터는 그 패킷을 **버린다**.  \n종단 시스템 입장에서 패킷 손실은 패킷이 네트워크 코어로 전송되었으나 네트워크로부터 목적지에 나타나지 않는 것으로 보일 것이다. 손실 패킷의 비율은 트래픽 강도가 클 수록 증가한다.  \n그러므로 노드에서의 성능은 흔히 지연뿐만 아니라 패킷 손실 확률로도 측정한다. \n\n### 종단 간 지연\n\n출발지 호스트와 목적지 호스트 사이에 N - 1 개의 라우터가 있다고 하자. 그리고 네트워크가 혼잡하지 않으며, 각 라우터와 출발지 호스트의 처리 지연은 $d_{proc}$ 이고, 각 호스트와 출발지 호스트에서의 전송률은 $R비트/초$다. 그리고 각 링크에서의 전파 지연은 $d_{prop}$라고 하자. \n\n$d_{end-end}= N*(d_{proc}+ d_{trans}+ d_{prop})$ \n\n여기서 $d_{trans} = L/R$ 이고, L은 패킷 크기다.  \n이 식은 처리와 전파 지연을 고려하지 않은 식을 일반화한 것이다. \n\n#### 종단 시스템, 애플리케이션 그리고 그 밖의 지연\n\n공유 매체(예: 와이파이 혹은 케이블 모뎀)로 패킷을 전송하고자 하는 종단 시스템은 다른 종단 시스템과 매체를 공유하기 위해 프로토콜의 일부로 전송을 의도적으로 지연시킬 수 있다.  \n\n또한 **VoIP(Voice-over-IP)** 애플리케이션에 있는 미디어 패킷화 지연이다.  \nVoIP에서 송신 측은 먼저 패킷을 인터넷으로 보내기 전에 패킷을 인코딩된 디지털 음성으로 채워야 한다.  \n이 패킷ㅇ르 채우는 시간(패킷화 지연)은 심각할 수 있으며 VoIP 콜의 사용자가 느끼는 품질에 영향을 줄 수 있다. \n\n### 컴퓨터 네트워크에서의 처리율\n\n종단간 처리율(throughput) 이다. 처리율을 정의하기 위해 컴퓨터 네트워크를 통해 호스트 A에서 호스트 B로 커다란 파일을 전송하는 것을 고려해보자. 어느 한 순간에서의 순간적인 처리율은 호스트 B가 파일을 수신하는 비율 (비트/초) 이다.  \n\n만약 파일이 F비트로 구성되고 호스트 B가 모든 $F$비트를 수신하는 데 $T$ 초가 걸린다고 하면 이때 파일 전송의 **평균 처리율 (average throughput)** $F/T$ 비트/초다.  \n\n인터넷 전화 같은 애플리케이션의 경우, 낮은 지연과 순간적인 처리율이 지속적으로 어떤 임곗값을 넘는 것이 바람직하다. 파일 전송을 포함하는 다른 애플리케이션의 경우, 지연은 심각하지 않으나 가능한 한 높은 처리율을 갖는 것이 바람직하다.  \n\n간단한 링크로 구성된 네트워크의 경우, 처리율은 ==병목링크==의 전송률이 처리율이 된다.  \nN개의 링크의 전송률이 각각 $R_1$, $R_2$ ... $R_N$ 이라고 할 때, 서버로부터 클라이언트로 파일을 전송하는 경우의 처리율이 $min \\{R_1, R_2, ... , R_N\\}$ 임을 알 수 있고, 이는 서버와 클라이언트간 경로상에서의 병목 링크의 전송률이다.  \n\n오늘날의 인터넷에 2개의 종단 시스템 (서버, 클라이언트)가 있고, 오늘날의 인터넷의 코어는 작은 혼잡을 경험하는 매우 높은 속도의 링크로 구성되어 있다고 하자. 이때 오늘날의 인터넷에서의 처리율에 대한 제한 요소는 전형적으로 접속 네트워크이다.  \n\n컴퓨터 네트워크의 코어에 연결된 10개의 서버와 10개의 클라이언트가 있고, 10개의 동시 다운로드가 일어난다고 가정하자. 이때 공통 링크의 속도가 서버 링크의 전송률, 클라이언트의 전송률과 같은 수준이고, 10개의 다운로드에 똑같이 전송률을 나누게 되면 각 다운로드에 대한 병목은 코어에서의 공유 링크가 된다. \n\n## 프로토콜 계층과 서비스 모델\n\n### 계층 구조\n\n계층 구조는 크고 복잡한 시스템의 잘 정의된 특정 부분을 논의할 수 있게 해준다. 시스템이 계층 구조를 가질 때, 그 계층이 제공하는 서비스의 구현을 변경하는 것도 매우 쉽다. 한 계층이 상위 계층에 같은 서비스를 제공하고 하위 계층의 서비스를 이용하는 한, 어떤 한 계층의 구현이 변화하더라도 시스템의 나머지 부분은 변하지 않는다.  \n\n#### 프로토콜 계층화\n\n네트워크 프로토콜의 설계 구조를 제공하기 위해 네트워크 설계자느나 프로토콜을 계층으로 조직한다.  \n다시 한 계층이 상위 계층에 제공하는 서비스에 관심을 갖고, 이를 계층의 서비스 모델이라고 한다.  \n\n프로토콜 계층은 소프트웨어, 하드웨어 또는 둘의 통합으로 구현할 수 있다.  \nn계층 프로토콜은 네트워크를 구성하는 종단 시스템, 패킷 스위치, 그 외의 요소 사이에 분산되어 있다. 즉, 각 네트워크 구성요소에는 하나의 n계층 프로토콜이 있다는 것이다.  \n\n프로토콜 계층화는 개념과 구조 측면에서 이점이 있다.  \n계층화는 시스템 구성요소에 대해 논의하기 위한 구조화된 방법을 제공하며, 모듈화는 시스템 구성요소의 갱신을 더 쉽게 해준다.  \n\n다양한 계층의 프로토콜을 모두 합하여 **프로토콜 스택**이라고 한다.  \n\n#### 애플리케이션 계층\n\n네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳이다. HTTP, SMTP, FTP 같은 다양한 프로토콜을 포함한다.  \n\n애플리케이션 계층 프로토콜은 여러 종단 시스템에 분산되어 있어서 한 종단 시스템에 있는 애플리케이션이 다른 종단 시스템에 있는 애플리케이션과 정보 패킷을 교환할 때 이 프로토콜을 사용한다. 애플리케이션 계층에서의 정보 패킷을 ==메시지==라고 한다. \n\n#### 트랜스포트 계층\n\n클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공한다.  \n인터넷에는 TCP, UDP 라는 두 가지 트랜스포트 프로토콜이 있으며 이들은 애플리케이션 계층 메시지를 전달한다.  \n\nTCP 는 애플리케이션에게 연결지향형 서비스를 제공하고, UDP 프로토콜은 애플리케이션에 비연결형 서비스를 제공한다.  \n트랜스포트 계층 패킷을 ==세그먼트==라고 한다. \n\n#### 네트워크 계층\n\n한 호스트에서 다른 호스트로 ==데이터그램==을 라우팅하는 책임을 진다.  \n출발지 호스트에서 인터넷 트랜스포트 계층 프로토콜은 트랜스포트 계층 세그먼트와 목적지 주소를 네트워크 계층으로 전달한다. 그런 다음 네트워크 계층은 목적지 호스트의 트랜스포트 계층으로 세그먼트를 운반하는 서비스를 제공한다.  \n\n인터넷의 네트워크 계층은 IP 데이터그램의 필드를 정의하며 종단 시스템과 라우터가 이 필드에 어떻게 동작하는지를 정의하는 프로토콜을 가지고 있다. 오직 하나의 IP 프로토콜이 있고, 네트워크 계층을 가진 모든 인터넷 요소는 IP 프로토콜을 수행해야 한다.  \n\n또한 인터넷 네트워크 계층은 출발지와 목적지 사이에서 데이터그램이 이동하는 경로를 결정하는 라우팅 프로토콜을 포함한다. 인터넷은 많은 라우팅 프로토콜을 갖고 있다. \n\n#### 링크 계층\n\n경로상의 한 노드에서 다른 노드로 패킷을 이동하기 위해 네트워크 계층은 링크 계층 서비스에 의존해야 한다. 특히 각 노드에서 네트워크 계층은 데이터그램을 아래 링크 계층으로 보내고 링크 계층은 그 데이터그램을 경로상의 다음 노드에 전달한다.  \n\n링크 계층에서 제공하는 서비스는 그 링크에서 채용된 특정 링크 채용 프로토콜에 의해 결정된다. 링크 계층 프로토콜에는 이더넷, 와이파이, 케이블 접속 네트워크의 DOCSIS 프로토콜을 들 수 있다. 데이터그램이 출발지에서 목적지로 가는 데 여러 링크를 거치기 때문에 데이터그램은 경로상의 각기 다른 링크에서 다른 링크 계층 프로토콜에 의해 처리될 수 있다. \n\n링크 계층 패킷을 ==프레임==이라고 한다.  \n\n#### 물리 계층\n\n물리 계층은 프레임 내부의 각 ==비트==를 한 노드에서 다음 노드로 이동하는 것이다.  \n이 계층의 프로토콜들은 링크에 의존하고 더 나아가 링크의 실제 전송 매체에 의존한다. 예를 들어 이더넷은 여러 가지 물리 계층 프로토콜을 갖고 있다.  \n\n### 캡슐화\n\n송신 호스트는 **애플리케이션 계층 메시지**를 트랜스포트 계층으로 전달한다. 트랜스포트 계층은 트랜스포트 계층 헤더 정보를 추가해서 **트랜스포트 계층 세그먼트**를 구성한다.  \n트랜스포트 계층 세그먼트는 애플리케이션 계층 메시지를 캡슐화 하며, 추가된 정보는 수신 측의 트랜스포트 계층이 그 메시지를 적절한 애플리케이션으로 보내게 하는 정보와 메시지들의 비트들이 변경되었는지 아닌지를 수신자가 결정하게 하는 오류 검출 비트를 포함한다. \n\n트랜스포트 계층은 세그먼트를 네트워크 계층으로 보내고, 네트워크 계층은 출발지와 목적지 종단 시스템 주소와 동일한 헤더 정보를 추가하여 **네트워크 계층 데이터그램**을 만든다.   \n\n이 데이터그램은 링크 계층으로 전달되고 링크 계층도 자신의 헤더 정보를 추가하여 **링크 계층 프레임**을 만든다. \n\n이를 통해 각 계층에서 패킷은 헤더 필드와 **페이로드 필드**라는 두 가지 형태의 필드를 갖는다는 것을 알 수 있다. 페이로드는 일반적으로 그 계층 상위로부터의 패킷이다.  \n\n## 공격받는 네트워크\n\n#### 나쁜 친구들은 인터넷을 통해 여러분의 호스트에 멀웨어를 침투시킬 수 있다\n\n인터넷에서 데이터를 송/수신하기 위해 장치를 인터넷에 연결할 때, 멀웨어가 전달 될 수 있다.  \n\n멀웨어는 파일 삭제, 주민번호, 비밀번호 등을 모으는 스파이웨어를 설치하여 해커들에게 다시 보낸다. 면역되지 않은 호스트는 수천의 비슷한 면역되지 않은 장치들로 구성된 네트워크 (botnet) 에 등록될 수 있다. 해커들은 목표로 하는 호스트에 대해 스팸 전자메일 분배 혹은 분산 Dos 공격을 위해 이 봇넷을 제어하고 이용한다.  \n\n오늘날 많은 멀웨어는 자기복제를 수행하여 기하급수적으로 퍼질 수 있다.\n\n#### 나쁜 친구들은 서버와 네트워크 인프라스트럭처를 공격할 수 있다\n\n이는 **Dos (denial-of-service)** 공격으로 알려져 있다.  \nDos 공격은 네트워크, 호스트 혹은 다른 인프라스트럭처의 요소들을 정상적인 사용자가 사용할 수 없게 하는 것이다.  \n\n대부분의 인터넷 Dos 공격은 다음 세 가지 중 하나에 속한다. \n- 취약성 공격: 목표 호스트에서 수행되는 공격받기 쉬운 애플리케이션 혹은 운영체제에 교묘한 메시지를 보내는 것이다. \n- 대역폭 플러딩 (bandwith flooding): 목표 호스트로 수많은 패킷을 보내 목표 호스트의 접속 링크가 동작하지 못하도록 많은 패킷을 보내서 정당한 패킷들이 그 서버에 도달하지 못하도록 한다. \n- 연결 플러딩 (connection flooding): 목표 호스트에 half-open 혹은 fully open 된 TCP 연결을 설정한다. \n\n만약 서버가 R bps 의 접속 속도를 갖고 있다면 공격자는 피해를 주기 위해 대략 R bps 의 속도로 트래픽을 전송하면 된다. 만약 R 이 매우 크면 서버에 영향을 줄 수 있는 트래픽을 발생시킬 수 없고, 모든 트래픽이 하나의 소스에서 방사되면 업스트림 라우터가 그 공격을 발견하고 그 소스로부터의 모든 트래픽을 차단할 수 있다.  \n\n따라서 **분산 DoS(DDos)** 공격에서 공격자는 다중의 소스를 제어하여 각 소스가 목표에 트래픽을 보내도록 한다. 이러한 방법으로 모든 제어 소스에 걸친 통합 트래픽 속도가 서비스를 무능력하게 하기 위해서는 전송률이 약 R이어야 한다.  \n\n#### 나쁜 친구들은 패킷을 탐지할 수 있다\n\n무선 전송장치의 근처에 수동적인 수신자를 위치시킴으로써 수신자가 전송되고 있는 모든 패킷의 사본을 얻을 수 있다. 지나가는 모든 패킷의 사본을 기록하는 수동적인 수신자를 **패킷 스니퍼**라고 한다. \n\n유선 환경에서도 배치될 수 있는데, 많은 이더넷 LAN 과 같은 유선 방송 환경에서 패킷 스니퍼는 LAN 상으로 보내는 모든 패킷의 사본을 얻을 수 있다.  \n\n패킷 스티퍼는 수동적이기 때문에 스니퍼를 탐지하기가 어렵다. 그래서 무선 채널로 패킷을 보낼 때, 어떤 해커가 우리 패킷의 사본을 기록하고 있을 수 있다는 가능성을 받아들여야 한다. 패킷 스니핑을 방지하기 위한 가장 좋은 방어는 암호화를 포함하는 것이다. \n\n#### 나쁜 친구들은 여러분이 신뢰하는 사람인 것처럼 위장할 수 있다\n\n가짜 출발지 주소를 가진 패킷을 인터넷으로 보내는 능력을 **IP 스푸핑**이라고 하며, 한 사용자가 다른 사용자인 것처럼 행동하는 여러 가지 방법 중 하나다. \n\n이를 해결하기 위해서는 **종단 인증**, 즉 메시지가 실제로 와야 할 곳에서 온 것인지 확신할 수 있는 방법이 필요하다.  "},{"excerpt":"개요 S-HOOK 의 모든 노래 정보는 로컬에 캐싱되어 있다. 노래를 DB 에서 매번 정렬하는 쿼리 비용이 컸기 때문에 로컬 캐싱을 도입하게 되었다. 그러나 로컬 캐싱을 도입하면서 문제가 발생했다. 유저가 좋아요를 누르는 순간 노래 데이터는 좋아요 순에 맞춰 재정렬된다. 이때 다음과 같은 상황이 발생할 수 있다.  노래를 정렬하는 중에 다른 좋아요 요청이…","fields":{"slug":"/local-cache-concurrency-problem/"},"frontmatter":{"date":"2023년 11월 20일 09:11","title":"로컬 캐싱 동시성 문제 해결기","tags":["shook","trouble-shooting"]},"rawMarkdownBody":"\n## 개요\n\nS-HOOK 의 모든 노래 정보는 로컬에 캐싱되어 있다. 노래를 DB 에서 매번 정렬하는 쿼리 비용이 컸기 때문에 로컬 캐싱을 도입하게 되었다.\n\n그러나 로컬 캐싱을 도입하면서 문제가 발생했다.  \n유저가 좋아요를 누르는 순간 노래 데이터는 좋아요 순에 맞춰 재정렬된다. \n\n이때 다음과 같은 상황이 발생할 수 있다.\n\n![[inmemory-songs-concurrency-sort.png]]\n\n노래를 정렬하는 중에 다른 좋아요 요청이 들어와서 동일한 리스트를 다시 정렬하는 상황이다. 이 경우 어느 스레드의 작업이 먼저 적용될 지 예측할 수 없고, 결과적으로 데이터의 무결성이 손상될 수 있다.\n\n여러 스레드가 동일한 노래를 업데이트하려고 시도할 때도 문제가 발생할 수 있다. \n좋아요 요청은 InMemorySongs 를 \n\n\n![[inmemory-concurrency.png]]\n\n\n전체 로직은 다음과 같다.\n\n```java\n@RequiredArgsConstructor  \n@Repository  \npublic class InMemorySongs {  \n  \n    private static final Comparator<Song> COMPARATOR =  \n        Comparator.comparing(Song::getTotalLikeCount, Comparator.reverseOrder())  \n            .thenComparing(Song::getId, Comparator.reverseOrder());  \n  \n    private Map<Long, Song> songs = new HashMap<>();  \n    private List<Long> sortedSongIds = new ArrayList<>();  \n  \n    public void refreshSongs(final List<Song> songs) {  \n        this.songs = songs.stream()  \n            .collect(Collectors.toMap(Song::getId, song -> song, (prev, update) -> update, HashMap::new));  \n        this.sortedSongIds = new ArrayList<>(this.songs.keySet().stream()  \n                                                 .sorted(Comparator.comparing(this.songs::get, COMPARATOR))  \n                                                 .toList());  \n    }  \n  \n    private List<Song> getSortedSongsByGenre(final Genre genre) {  \n        return sortedSongIds.stream()  \n            .map(songs::get)  \n            .filter(song -> song.getGenre() == genre)  \n            .toList();  \n    }  \n  \n    public List<Song> getSortedSongsByGenre(final Genre genre, final int limit) {  \n        final List<Song> songsByGenre = getSortedSongsByGenre(genre);  \n  \n        return songsByGenre.subList(0, Math.min(limit, songsByGenre.size()));  \n    }  \n    public void like(final KillingPart killingPart, final KillingPartLike likeOnKillingPart) {  \n        final Song song = songs.get(killingPart.getSong().getId());  \n        final KillingPart killingPartById = findKillingPart(killingPart, song);  \n        final boolean updated = killingPartById.like(likeOnKillingPart);  \n        if (updated) {  \n            reorder(song);  \n        }  \n    }  \n    private static KillingPart findKillingPart(final KillingPart killingPart, final Song song) {  \n        return song.getKillingParts().stream()  \n            .filter(kp -> kp.equals(killingPart))  \n            .findAny()  \n            .orElseThrow(  \n                () -> new KillingPartException.PartNotExistException(  \n                    Map.of(\"killing part id\", String.valueOf(killingPart.getId()))));  \n    }  \n  \n    private void reorder(final Song updatedSong) {  \n        int currentSongIndex = sortedSongIds.indexOf(updatedSong.getId());  \n  \n        if (currentSongIndex == -1) {  \n            return;  \n        }  \n  \n        moveForward(updatedSong, currentSongIndex);  \n        moveBackward(updatedSong, currentSongIndex);  \n    }  \n  \n    private void moveForward(final Song changedSong, final int songIndex) {  \n        int currentSongIndex = songIndex;  \n  \n        while (canSwapWithPreviousSong(changedSong, currentSongIndex)) {  \n            swap(currentSongIndex, currentSongIndex - 1);  \n            currentSongIndex--;  \n        }  \n    }  \n    private boolean canSwapWithPreviousSong(final Song changedSong, final int currentSongIndex) {  \n        return currentSongIndex > 0 && currentSongIndex < sortedSongIds.size() &&  \n            shouldSwapWithPrevious(changedSong,  \n                                   songs.get(sortedSongIds.get(currentSongIndex - 1)));  \n    }  \n  \n    private boolean shouldSwapWithPrevious(final Song song, final Song prevSong) {  \n        final boolean hasSameTotalLikeCountAndLargerIdThanPrevSong =  \n            song.getTotalLikeCount() == prevSong.getTotalLikeCount() && song.getId() > prevSong.getId();  \n        final boolean hasLargerTotalLikeCountThanPrevSong = song.getTotalLikeCount() > prevSong.getTotalLikeCount();  \n  \n        return hasLargerTotalLikeCountThanPrevSong || hasSameTotalLikeCountAndLargerIdThanPrevSong;  \n    }  \n  \n    private void swap(final int currentIndex, final int otherIndex) {  \n        final Long prevIndex = sortedSongIds.get(currentIndex);  \n        sortedSongIds.set(currentIndex, sortedSongIds.get(otherIndex));  \n        sortedSongIds.set(otherIndex, prevIndex);  \n    }  \n  \n    private void moveBackward(final Song changedSong, final int songIndex) {  \n        int currentSongIndex = songIndex;  \n  \n        while (canSwapWithNextSong(changedSong, currentSongIndex)) {  \n            swap(currentSongIndex, currentSongIndex + 1);  \n            currentSongIndex++;  \n        }  \n    }  \n    private boolean canSwapWithNextSong(final Song changedSong, final int currentSongIndex) {  \n        return currentSongIndex < sortedSongIds.size() - 1 && currentSongIndex > 0  \n            && shouldSwapWithNext(changedSong, songs.get(sortedSongIds.get(currentSongIndex - 1)));  \n    }  \n  \n    private boolean shouldSwapWithNext(final Song song, final Song nextSong) {  \n        final boolean hasSameTotalLikeCountAndSmallerIdThanNextSong =  \n            song.getTotalLikeCount() == nextSong.getTotalLikeCount() && song.getId() < nextSong.getId();  \n        final boolean hasSmallerTotalLikeCountThanNextSong = song.getTotalLikeCount() < nextSong.getTotalLikeCount();  \n  \n        return hasSmallerTotalLikeCountThanNextSong || hasSameTotalLikeCountAndSmallerIdThanNextSong;  \n    }  \n  \n    public void unlike(final KillingPart killingPart, final KillingPartLike unlikeOnKillingPart) {  \n        final Song song = songs.get(killingPart.getSong().getId());  \n        final KillingPart killingPartById = findKillingPart(killingPart, song);  \n        final boolean updated = killingPartById.unlike(unlikeOnKillingPart);  \n        if (updated) {  \n            reorder(song);  \n        }  \n    }}\n```\n\n매우 복잡한 로직이다. 좋아요 요청의 대략적인 플로우만 설명하면 다음과 같다.\n\n좋아요 요청인 경우\n1. 좋아요를 누른 킬링파트로 캐싱된 노래를 찾는다.\n2. 캐싱된 노래의 좋아요를 누를 킬링파트를 찾는다.\n3. 만약 킬링파트 좋아요가 업데이트된 경우, 전체 노래를 재정렬한다.\n\n## 테스트 환경\n\n동시 유저는 총 유저 수보다 조금 적은 100명으로 가정하였다.  \n\n지금까지 애널리틱스로 분석한 결과 노래 조회 요청은 약 2800회 요청되었고, 좋아요 요청은 90회 요청되었다.   \n\n이는 약 30:1의 비율이므로, 읽기 요청의 가중치를 30으로, 업데이트 요청의 가중치를 1로 설정하였다. 노래 데이터를 가져오는 API 는 좋아요를 누르는 API 보다 약 30배 가량 자주 실행될 것이다.  \n\n스크립트는 다음과 같다.\n\n```python\nimport random  \n  \nimport json  \nfrom locust import HttpUser, task, between  \nimport random  \n  \n  \nclass Sample(HttpUser):  \n    wait_time = between(1, 1)  \n  \n    def on_start(self):  \n        print(\"start\")  \n  \n    def on_stop(self):  \n        print(\"stop\")  \n  \n    @task(30)  \n    def get_likes(self):  \n        headers = {  \n            'Content-Type': 'application/json;charset=UTF-8',  \n            'Authorization': '1'  \n        }  \n        self.client.get(\"/songs/high-liked\", headers=headers)  \n  \n    @task  \n    def get_song1(self):  \n        headers = {  \n            'Content-Type': 'application/json;charset=UTF-8',  \n            'Authorization': '1'  \n        }    \n        self.send(headers)  \n  \n    def send(self, headers):  \n        rand_value = random.randint(1, 2)  \n        value = True if rand_value == 1 else False  \n        body = {  \n            'likeStatus': value  \n        }  \n        self.client.put(\"/songs/167/parts/500/likes\", json=body, headers=headers)\n```\n\n## synchronized 사용하기\n\n간단하게 노래를 재정렬하는 API 에 `synchronized` 키워드만 추가하면 된다. \n\n```java\nprivate void reorder(final Song updatedSong) {  \n    synchronized (sortedSongIds) {  \n        int currentSongIndex = sortedSongIds.indexOf(updatedSong.getId());  \n  \n        if (currentSongIndex == -1) {  \n            return;  \n        }  \n  \n        moveForward(updatedSong, currentSongIndex);  \n        moveBackward(updatedSong, currentSongIndex);  \n    }  \n}\n```\n\n#### 장점\n\nsynchronized 의 장점은 무엇보다 간단하다는 것이다.  \n또한 lock 관리를 Java 가 해주기 때문에 복잡성이 줄어든다. \n\n#### 단점\n\n그러나 `sortedSongIds` 라는 데이터에 단 하나의 스레드만 접근할 수 있기 때문에, 읽기 요청이 많은 우리 서비스에서 성능 저하가 일어날 가능성이 높다.  \n\n### 테스트 결과\n\n![[synchronized-request-time.png]]\n\n![[concurrency-synchronized-test.png]]\n\n전체 RPS 는 98.8 이다.  \n좋아요 요청의 평균 응답 시간은 31ms, 노래 데이터를 조회하는 요청은 23ms 가 소요된 것을 볼 수 있다.  \n\n## ReadWriteLock\n\n`ReadWriteLock` 이란 읽기 작업과 쓰기 작업에 대해 다른 수준의 잠금을 제공하는 동기화 메커니즘이다.  \n읽기 및 쓰기 작업이 동시에 수행될 때 발생할 수 있는 데이터 일관성 문제를 해결하는 데 도움이 된다.  \n\n읽기 락은 여러 스레드가 가져갈 수 있지만, 쓰기 락은 단 하나의 스레드만 가져가서 사용할 수 있다. 쓰기 락이 걸린 상태에서는 다른 스레드에서 읽기, 쓰기 모두 불가능하다. \n\nfinally 키워드를 사용하여 예외가 발생하거나 메서드에서 조기 반환되는 경우에도 `writeLock` 이 반드시 해제되도록 보장한다.  \n\n```java\npublic List<Song> getSongs() {  \n    readWriteLock.readLock().unlock();  \n    try {  \n        return sortedSongIds.stream()  \n            .map(songs::get)  \n            .toList();  \n    } finally {  \n        readWriteLock.readLock().unlock();  \n    }  \n}\n\nprivate void reorder(final Song updatedSong) {  \n    readWriteLock.writeLock().lock();  \n    try {  \n        int currentSongIndex = sortedSongIds.indexOf(updatedSong.getId());  \n  \n        if (currentSongIndex == -1) {  \n            return;  \n        }  \n  \n        moveForward(updatedSong, currentSongIndex);  \n        moveBackward(updatedSong, currentSongIndex);  \n    } finally {  \n        readWriteLock.writeLock().unlock();  \n    }  \n}\n```\n\n### 테스트 결과\n"},{"excerpt":"TODO LOG 알고리즘 2문제 풀었다. 쉬운 것도 풀고 예전에 했던 잊어버린 문제들을 많이 풀어봐야겠다. 배운 것 느낀 것","fields":{"slug":"/2023-11-20/"},"frontmatter":{"date":"2023년 11월 20일 04:11","title":"2023년 11월 20일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 알고리즘 2문제 풀었다. 쉬운 것도 풀고 예전에 했던 잊어버린 문제들을 많이 풀어봐야겠다.\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"계획이 필요해진 이유 올해 초에 나는 앞으로 행복을 택하면서 살기로 다짐했다. 실제로 요즘은 행복한 일만 있다. 그렇지만 나에게는 목표가 있는 삶이 필요하다. 최근에 결정한 것은 내가 바라는 인생이다. 하고 싶은 걸 하고 살면서도 잘 사는 것. 그러나 아무 노력도 하지 않으면서 바라기만 하는 것은 역시 내 성격에는 맞지 않는다. 바라기만 했는데 잘 되는 …","fields":{"slug":"/level2-eighth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 8주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 계획이 필요해진 이유\n\n올해 초에 나는 앞으로 행복을 택하면서 살기로 다짐했다. 실제로 요즘은 행복한 일만 있다.  \n그렇지만 나에게는 목표가 있는 삶이 필요하다.  \n최근에 결정한 것은 내가 바라는 인생이다. 하고 싶은 걸 하고 살면서도 잘 사는 것. 그러나 아무 노력도 하지 않으면서 바라기만 하는 것은 역시 내 성격에는 맞지 않는다. 바라기만 했는데 잘 되는 건 내가 이룬 것이 아니니까.  \n내 인생은 내가 사는 것이니 어떻게든 잘 살고 싶다. 세우려는 계획도 그 일환이다.  \n물론 나는 노력하는 것을 좋아하지 않고, 자신도 없다. 그렇지만 해야 할 일은 해야지... ㅋㅋㅋ  \n그래서 앞으로 어떻게 살아야 할 지 좀 정해보려고 한다.\n\n## 앞으로의 계획\n\n나는 구체적인 계획이 답답하다. 계획을 잘 지키지도 못하고, 세우는 걸 좋아하지도 않는다.  \n그래서 일단은 두루뭉술하게 정해봤다.\n\n### 가까운 미래\n\n우테코를 수료하면 학교로 돌아갈 것이다. 취업을 할 수 있어서 회사에서 기다려 준다면 가장 좋겠지만, 그렇지 않는다면 다시 학교로 돌아갈 것이다. 21학점 남았으니 1학기에 18학점, 2학기에 3학점을 수강할 예정이다.  \n4학년을 준비하면서 아마도 평범하게 취업 준비를 하지 않을까?  \n다만 걱정되는 것은 내가 취준 생활을 잘 견딜 수 있을지...ㅋㅋㅋ  \n어쨌든 취업 준비는 맞닥뜨리게 될 문제다. 그래서 이번 방학 때는 CS와 알고리즘을 공부할 생각이다.  \n언제나 알고리즘은 나에게 아픈 손가락이었다. 제대로 배우지 않아서 잘할 줄 모르고, 자신도 없었다. 알고리즘 공부만 하면 스트레스 때문에 길어봤자 2달 밖에 공부하지 못했다.  \n\n지금까지는 계속 회피해왔다. 그렇지만 그렇게 피하다가 취업이라는 게 눈 앞에 닥치게 되면 너무 후회할 것 같다.  \n분명 후회할 거라고 생각하고 있는 지금 알고리즘을 다시 시작하려고 한다.  \nCS도 마찬가지다. 사실상 학교에서 배운 내용이 없다 ㅋㅋㅋ 그래서 지금 지식만 가지고는 나중에 기술 면접에서 잘 대답할 자신이 없다. 방학 때 공부하고, 자신감을 키울 예정이다. 오늘 책도 샀다 ㅋㅋ  \n방학 때부터 시작해서 우테코 끝까지 열심히 해보자~  \n\n나는 자신 없는 것들을 최대한 피하거나 하지 않으려고 하는 편이다. 지금이라도 마주할 용기가 생겼으니 방학 때 잘 모르는 나를 마주해보려고 한다. 예전에는 내가 무언가를 못할 때마다 자괴감이 들었다. 자책하고 우울해했다. 분명 공부를 하는데도 느는 느낌도 안 들어서 그 때 마다 슬럼프를 크게 맞았다.  \n그러나 지금은 다르다.  \n지금은 잘 몰라도 괜찮다. 끝까지 잘 모르는 사람은 없다.  \n나는 분명 잘할 수 있다!\n\n### 조금은 먼 미래\n\n사실 이 부분 계획이 아직도 어렵다…  \n아무래도 지금은 하루살이처럼 살아가고 있다보니, 먼 미래를 보기보다는 오늘, 내일에 집중하고 있다.  \n무엇보다 먼 미래를 생각하려면 그때 하고 싶은 걸 정해야 하는데, 그게 지금 나에게 제일 어려운 과제다.  \n뭐라도 해보고 싶다는 마음에 조급해져서 목표를 정하기보다는 나를 돌아보면서 어떤 것을 하고 싶은지 정하고 싶다.\n\n**결론: 아직 없다.**\n\n### 지금은?\n\n지금 하고 싶은 것은 뭐냐! 라고 한다면… 진짜 없다.  \n방금 5분 정도 생각해봤는데 머릿속에 떠오르는 게 아무것도 없다. 그냥 머릿속이 하얗다~  \n근데 이 상태가 괜찮으면 모르겠는데 별로 좋지는 않다. 진짜 되는 대로 사는 것 같아서 ㅋㅋㅋㅋ  \n\n여전히 목표가 있어야 하는 사람인데, 단기 목표는 잃어버린 것 같다. 지금까지도 있다고 착각했을 뿐 사실 내게 단기 목표는 없었던 거 아닐까?  \n중단기 목표는 있지만 그것조차도 어쩌면 모호하다.  \n장기 목표는 없다.  \n\n지금은 목표가 없는 삶을 살고 있다. 바라는 삶은 있지만.  \n여전히 알 수 없다. 나는 무엇을 위해 달리고 있는가?  \n오늘도 생각하고, 내일도 생각하고, 모레도 생각해보자.  \n언젠가는 생기려나~"},{"excerpt":"몇 주 만에 행복이라는 태그가 달리지 않은 회고를 쓰게 되었다. 요즘 꽤나 행복하게 살았구나 나~ 솔직하지 못해 괴로운 나 정확하게는 솔직하지 못해서 괴롭다기보다 내가 솔직하게 행동하지 못했을 때 드는 생각과 발생하는 상황이 괴롭다. 솔직한 사람을 좋아하지만, 정작 나는 솔직하지 않다. 마음대로 살고 싶어하지만 마음대로 살지 못한다. 내가 원하는 대로 살…","fields":{"slug":"/level2-sixth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 6주차 회고","tags":["회고"]},"rawMarkdownBody":"\n몇 주 만에 행복이라는 태그가 달리지 않은 회고를 쓰게 되었다.\n\n요즘 꽤나 행복하게 살았구나 나~\n\n## 솔직하지 못해 괴로운 나\n\n정확하게는 솔직하지 못해서 괴롭다기보다 내가 솔직하게 행동하지 못했을 때 드는 생각과 발생하는 상황이 괴롭다.  \n\n솔직한 사람을 좋아하지만, 정작 나는 솔직하지 않다.  \n마음대로 살고 싶어하지만 마음대로 살지 못한다.  \n내가 원하는 대로 살고 싶지만 나는 내가 원하는 것이 무엇인지 모른다.  \n\n정말 역설적인 생각이다. 가치관과 목표 자체에도 이상에 대한 동경과 공상밖에 없다.  \n언젠가 원하는 게 생길 거니까, 언젠가 뭐라도 하고 싶을 거니까. 언젠가 내가 갖고 싶은 게 있을 거니까.  \n나는 현재를 살고 싶어하면서도 어쩔 수 없이 미래를 기웃거리는 존재다. 그게 나를 화나게 한다.  \n미래를 기대하지 않고 현재에 집중하기로 해놓고도, 그러지 못하고 두 마리의 토끼를 다 잡고 싶어한다.  \n현재에 집중하기 위해서는 나에게 온전히 솔직해야 한다. 지금 내가 하고 싶은 것을 잘 알고, 내가 무슨 생각을 하고 있는지 알아야 한다. 근데 그게 왜 이렇게 힘들까 ㅋㅋ  \n나는 가끔 내가 무슨 생각을 하고 있는지 알고 있으면서도 꽤 힘들이지 않고 그 생각을 외면한다. 언제나 그래왔기 때문에 내 생각을 외면하는 건 꽤나 쉬운 일이다.  \n내가 오늘 점심으로 무엇을 먹고 싶은지, 내가 사고 싶은 옷은 무엇인지, 오늘 내가 하고 싶은 일은 무엇인지, 내가 하고 싶은 말이 무엇인지, 내게는 모두 물음표다. 나에게는 결정된 것이 아무것도 없다. 관측되지 않으면 확률적으로 존재하는 양자처럼.  \n\n그래서 어렵다. 나에게 무엇을 하고 싶은지 물어보는 욕망에 관한 질문들이 어렵다.  \n어쩌면 나는 아직도 내 삶을 살고 있는 것이 아닐지도 모른다. 누군가의 욕망을 나에게 투영하면서 살아가는 것일지도? 그게 내가 원하는 게 아니라는 것을 알면서도 그렇다.  \n하고 싶은 게 많은 삶을 경험해 본 적이 없어 사실 어떻게 해야 하는지도 모르겠다.  \n내 모습에서 계속해서 모순이 발견되다 보니 나 자신이 모순된 사람이 된 것처럼 느껴진다.  \n\n그래도 계속 이렇게 살고 싶지는 않다. 이렇게 사는 건 역시 멋지지 않다.  \n감정을 제대로 표현하는 법부터 시작해보자.  \n그 다음에는 생각을 제대로 표현해보고, 내가 하고 싶은 게 무엇인지 고민해보고, 그냥 받아들이지 않고 돌아보는 연습을 해보자."},{"excerpt":"🌈 이번 주의 생각 💭 토리와 미션하기 어쩌다보니 토리와 페어가 되었다~~ 브라운의 가호에 감사를 😎 이번 미션이 너무 어려웠는데 토리랑 함께여서 어려운 설계도 금방금방 변경할 수 있었다. 사실 이번 주에 약속도 많고 특히 미션하는 화요일, 수요일에 할 일이 많았다. 수요일에는 저녁에 남아서 하지도 못해서 제출 못할까봐 좀 두렵긴 했다 ㅋㅋ 그럼에도 다 …","fields":{"slug":"/level2-fifth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 5주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🌈 이번 주의 생각 💭\n\n### 토리와 미션하기\n\n어쩌다보니 토리와 페어가 되었다~~ 브라운의 가호에 감사를 😎\n\n이번 미션이 너무 어려웠는데 토리랑 함께여서 어려운 설계도 금방금방 변경할 수 있었다. 사실 이번 주에 약속도 많고 특히 미션하는 화요일, 수요일에 할 일이 많았다. 수요일에는 저녁에 남아서 하지도 못해서 제출 못할까봐 좀 두렵긴 했다 ㅋㅋ 그럼에도 다 이해해준 보살 토리에게 감사인사 올립니다 🙇‍♀️\n\n객체지향에 대해 좀 더 돌아보게 된 미션이었다. 처음에는 서비스에서 대부분의 비즈니스 로직을 처리하도록 했다가, 도메인으로 모두 로직을 옮기게 되었다. 굳이 도메인으로 옮겨야 하나? 라는 생각도 잠깐 들었지만, 메인 비즈니스는 도메인이 맡는 것이 맞는 것 같았다. 그렇게 고치고 나니 의외로 기능 구현이 어렵지 않다는 생각이 들었다. 각자에게 할 일을 할당하고, 각 객체마다 어떤 행동을 해야 하는지 정의하고 구현하다보니 나중에는 서로 객체들이 유기적으로 할 일을 나눠하는 신기한 상황이 발생했다. 레벨1을 대충 보낸 것 같진 않아 뿌듯했다.\n\n토리와 고민도 많이 했다. 사실 어려운 질문들이 많아서 결론이 나지 않은 질문들이 많지만, 그럼에도 미션을 하면서 많이 고민하고 생각했다는 점이 마음에 든다. 앞으로도 미션에서 고민했던 부분들을 잘 기록해두고 계속해서 고민해봐야겠다.\n\n### 제대로 음주하기\n\n수요일에는 matzip 4기 분들과 함께 크래프트 아일랜드에서 저녁을 먹었다. 다들 유쾌하신 분들이고 가치관이나 생각도 멋있어서 본받을 부분이 많았다. 현업에서는 어떤 일을 하고 계시는지, 지금은 어떤 것을 하면 좋을지, 주변에서 스터디하는 알고리즘이나 CS를 지금 해도 될지에 대해 많이 여쭤봤다. 그래서 지금은 좀 생각이 정리가 된 듯 하다. 다른 사람들에게 영향을 받는 것도 좋지만 내가 하고 싶은 대로 쭉 나아가는 게 가장 좋은 것 같다. 다른 사람이 아닌 나 자신을 등불로 삼자 🔥\n\n디투, 포이, 홍실과 목요일에 고기를 먹으러 갔는데 너무 빠르게 마셔서 먹다보니 기억이 없다..ㅋㅋㅋㅋ 제대로 음주한 몇 안 되는 날이었는데, 같이 간 사람들 중 포이 빼고는 모두 기억이 없어서 그냥 그날은 묻어두기로 했다 ^^… 그렇지만 오랜만에 술 마신 거기도 하고 그날 너무 재밌었어서 즐거웠다.\n\n즐거운 일들이 이번 주에도 많아서 한 주를 행복하게 지낼 수 있었음에 감사하다.\n\n한강도 가고, T1 Base Camp에서 MSI도 보고 (리벤지 매치 T1이 이겨서 기분도 좋음), 석촌호수도 가고, 행복한 일들이 많았다. 하루하루를 즐겁고 행복하게 살자. 다른 건 아무래도 좋다!\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 토리랑 페어가 되어서 너무너무 행복했다.\n- 다음에도 페어하고 레벨 3때도 페어 하고 싶다.\n\n미션에 집중했다. 사실 미션 집중기간이긴 했지만 ㅋㅋㅋ 그럼에도 미션에 집중할 수 있는 환경과 내 의지(?)에 만족한다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 미션이 어려웠어서 개인 공부를 많이 하지 못했다. 개인공부와 미션의 밸런스를 잘 맞춰보자.\n- 스터디 공부에 시간을 좀 더 투자하자.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- TIL 매일 작성하기\n- 미션과 개인 공부 병행하기\n- 미션에 집중하기\n\n## 🧨 지난주 Try 회고\n\n- 미션을 제출하기 전에 최소 3명의 크루의 리뷰 확인하고 제출하기 → **실..패?**\n    - 장바구니 미션을 제출할 때는 여러 크루의 리뷰를 보고 낼 수 있었는데, 이번 지하철 미션은 너무 할 게 많아서 리뷰를 많이 못 봤다. 아쉽다.\n- TIL 매일 작성하기 (주말은 선택) → **실패**\n    - ㅋㅋㅋㅋㅋ 지킨 게 뭘까… TIL 굉장히 띄엄띄엄 썼다. 슬프네요… 앞으로는 좀 더 열심히 쓰겠습니다."},{"excerpt":"🌈 이번 주의 생각 💭 독감 저번 주 금요일 날 데일리 회식을 하고, 집에 돌아갔는데 그 다음날 너무 컨디션이 안 좋았다. 한 2주 전에 나았을 감기가 여전히 남아있었다고 생각했는데, 생각보다 몸이 안 좋아서 이번에는 병원에 바로 갔다. (저번에 미루다가 2주간 감기 걸린 게 생각나서..ㅋㅋㅋ) 처음 병원에 갔을 때는 기관지염이라고 했다. 그냥 저번과 같…","fields":{"slug":"/level2-fourth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 4주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🌈 이번 주의 생각 💭\n\n### 독감\n\n저번 주 금요일 날 데일리 회식을 하고, 집에 돌아갔는데 그 다음날 너무 컨디션이 안 좋았다. 한 2주 전에 나았을 감기가 여전히 남아있었다고 생각했는데, 생각보다 몸이 안 좋아서 이번에는 병원에 바로 갔다. (저번에 미루다가 2주간 감기 걸린 게 생각나서..ㅋㅋㅋ)\n\n처음 병원에 갔을 때는 기관지염이라고 했다. 그냥 저번과 같은 처방이 나와서 약 잘 먹으면 되겠지? 라고 생각하고 대수롭지 않게 여겼다.\n\n그런데 그 다음날 되니 열도 많이 나고 기침이 심해졌다. 이건 진짜 아닌 것 같아서 다시 병원에 갔더니 독감 검사를 하게 됐다. A형 독감 판정을 받아버렸다… 😂 독감에 걸린 게 몇 년 만인지… 안일하게도 독감 예방 접종도 안 맞은지 오래 돼서 더 그랬을지도 모른다.\n\n아쉬웠던 점은 독감에 걸려서 그 다음날 도저히 잠실에 갈 수 없어 재택을 했던 것이다. 재택을 하게 될 일이 있을까, 했는데 바로 독감에 걸려서 쉬게 되다니 진짜 슬펐다. 생산성도 떨어져서 재택한 날에는 거의 자기만 했다. (ㅋㅋ ㅠ) 앞으로는 몸 관리를 좀 더 철저하게 해야겠다. 그때 공부를 했었다면 미션을 좀 더 빨리 제출할 수 있었을 텐데 아쉽다.\n\n### 소소한 이야기들\n\n- 블로그에 커스텀 도메인을 설정했다. 이제 [vero.wiki](http://vero.wiki) 로 블로그에 접근할 수 있다. 항상 블로그 링크가 마음에 안 들었는데 기분이 좋다 ㅋㅋㅋ\n- 회고 모임에서 한강 갔던 거 너무 좋았다. (체인저 짱) 최근에 사람들과 진지한 이야기를 할 일이 많지 않았는데, 내가 잘해왔던 점에 대해 이야기하니 좀 더 자존감이 올라가고 이전에 비해 이만큼 성장했다는 것을 느낄 수 있어 좋은 시간이었다. 나에 대한 피드백과 채찍질도 어느 정도는 필요하지만, 나를 칭찬해주는 시간도 충분하게 필요하다는 생각을 하게 되었다.\n- 최근에 니체의 책을 읽으면서, 인간 말종과 초인을 비교하는 글을 읽게 되었다. 제대로 된 사람은 삶을 욕망하지만, 인간 말종은 삶을 사랑하지 않고 소일거리에만 매달리는 삶을 산다고 한다. 아무리 나를 돌아봐도 나는 아직 인간 말종에서 벗어나지 못한 삶을 살고 있는 것 같다 ㅋㅋㅋ 그렇다고 인간 말종에서 벗어나고 싶은 것도 아니다(?) 나는 지금이 행복하다~ 인간 말종 베로의 앞으로의 삶도 기대해주세요~\n- 일상이 행복하다. 시답지 않은 이야기 하는 것도, 미션하고 공부하는 것도, 진지한 이야기, 슬픈 이야기하는 것도 즐겁고 행복하다. 예전의 나라면 현재의 즐거움과 행복에 감사할 줄 몰랐겠지만 지금은 이런 일상이 매일 지속된다는 것에 감사함을 느낀다. 내일도, 모레도, 앞으로도 더 좋고 행복한 날들만 있으면 좋겠다. 불행한 날이 있더라도 그 속에서도 행복함을 찾을 수 있는 사람이 되고 싶다.\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 인생에 대한 고찰과 내가 어떻게 살아가고 있는지, 어떻게 살고 싶은지에 대한 생각을 많이 했다. 그냥 흘러가는 대로 사는 것도 좋지만, 살아가는 것에 대한 의미를 계속해서 사유하며 살아가자.\n- 미션을 1순위로 두고 행동했다. 머지되고 나서 다른 공부하지 않고 미션을 구현하는데 집중했다.\n- 술을 많이 자제했다. 독감에 걸린 것도 있지만, 의지로 자제한 것도 있어서 뿌듯하다.\n- 다른 사람의 리뷰를 많이 훔쳐봤다. 정말 도움이 많이 되는 댓글들이 많아서 나도 리뷰 메모해두는 어떤 크루처럼 리뷰 루팡한 걸 정리해보기로 했다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 몸 컨디션 관리하자. 몸이 아프면 아무것도 할 수 없다…\n- 좀 더 미션을 빨리 내서 리뷰를 빨리 받아보자. 이번에는 컨디션 때문에 어쩔 수 없었다고 하더라도 다음에는 미션을 미루지 말고 제출해보자.\n- TIL을 많이 못 썼다. 역시 컨디션의 연장선과 함께 휴일이 많았어서 그런 듯 하다. 배운 것을 많이 찾아보자.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 미션을 제출하기 전에 최소 3명의 크루의 리뷰 확인하고 제출하기\n- TIL 매일 작성하기 (주말은 선택)\n\n## 🧨 지난주 Try 회고\n\n- 내가 만족할 수 있는 PR 리뷰 요청 보내기 → **성공**\n    - 다른 사람의 리뷰를 많이 훔쳐보고 제출해서 그런지 기존에 내가 그냥 생각하고 구현한 것보다 만족스러운 코드를 짰다.\n- 기술 부채 2개 이상 해결하기 → **대실패**\n    - 아쉽게도 컨디션 이슈 + 미션 구현으로 못 했다.\n- TIL 제외한 블로그 글 4개 이상 쓰기 → **대대실패**\n    - 위의 이유와 같은 이유로…ㅋㅋㅋ\n\n## 📚 다음 주 목표\n\n- 페어와 학습 로그 말하기, 페어 회고 꼭 하기\n- 리뷰 훔쳐보고 정리하기\n- 미션에 적극적으로 참여하고 몰입하기\n- 미션하면서 궁금한 내용 2개 이상 블로그 글로 정리하기"},{"excerpt":"약간의 진지글… 😎 🌈 이번 주의 생각 💭 공부 이번 주는 공부하는 게 재밌었다. 레벨 로그 스터디는 내가 생각했던 것보다 훨씬 도움이 많이 된다. 특히 스프링을 사용할 줄만 알고 왜 이렇게 동작하는지 모르는 나에게 더 도움이 많이 됐다. 단순하게 이것을 사용할 수 있다!라는 것보다 근본적인 개념에 집중하고 있는 것 같아 좋다. 이번 레벨2의 목표는 로드…","fields":{"slug":"/level2-third-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 3주차","tags":["회고"]},"rawMarkdownBody":"\n**약간의 진지글… 😎**\n\n## 🌈 이번 주의 생각 💭\n\n### 공부\n\n이번 주는 공부하는 게 재밌었다. 레벨 로그 스터디는 내가 생각했던 것보다 훨씬 도움이 많이 된다. 특히 스프링을 사용할 줄만 알고 왜 이렇게 동작하는지 모르는 나에게 더 도움이 많이 됐다.  \n단순하게 이것을 사용할 수 있다!라는 것보다 근본적인 개념에 집중하고 있는 것 같아 좋다.  \n이번 레벨2의 목표는 로드맵을 잘 따라가는 것이다. 좀 더 넓은 목표로는 내가 사용하는 것이 무엇인지 알고 쓰고 싶다. 어떻게 동작하는지, 왜 이렇게 되는지 알고 쓰는 것이 목표이다. 아직까지는 잘 따라가고 있다.  \n지금은 잘 이해가 되지 않더라도 알게 된 것은 미래에 어떻게든 이해하게 된다. 지금까지 그랬다!  \n처음 배울 때는 이게 뭔가 싶지만 아는 게 많아지면 예전에 몰랐던 것이 이해가 된다. 그래서 조급한 마음은 가지지 않고 있다.  \n좋은 방향으로 공부하고 있다고 생각한다.\n\n### 목표를 정하다\n\n네오와 금요일에 면담을 했다. 커피챗 주제는 `인생의 목표와 가치관을 어떻게 정할 수 있을까` 라는 주제였다.  \n요즘 내가 왜 살고 있는지, 뭘 하면서 살고 싶은지, 무엇을 위해 살아가고 있는지 고민을 많이 했다. 네오는 나보다 더 오래 살았으니(?) 뭐라도 해주고 싶은 말이 있지 않을까 싶어서 면담 주제로 선정하게 되었다.  \n사실 면담하면서 답을 얻고 싶었던 건 아닌데, 대략적인 목표를 정하게 되어서 정말 기뻤다.  \n이야기하다보니 네오와 내가 많이 비슷한 사람이라고 느꼈다. 하고 싶은 게 많지 않은 것도, 죽음을 두려워하지 않는 것도, 하기 싫은 건 절대 안 하는 것도 닮았다 ㅋㅋ 그래서 네오가 하는 말들이 많이 와 닿았다.\n\n**그래서 정한 목표가 뭔데! 라고 말하실 것 같아서…**\n\n면담을 통해서 정하게 된 나의 인생 목표는 `막 살아도 괜찮은 인생을 살자` 이다. 요즘 `남들이 다 하는 건 싫어!` 라는 생각을 많이 한다 ㅋㅋㅋ 그래서 힙스터를 목표로 하고 있다. ~~근데 남들 다 있는 목표가 없는 것도 오히려 좋은데?~~  \n나는 노력하는 것을 즐기지 않는다. 그건 앞으로도 바뀌지 않을 것 같다.  \n그냥 앞으로도 재밌는 걸 하고, 하루 하루 즐겁게 살아가고 싶다. 어쩌다 이렇게 하루살이처럼 살아가게 됐는지 모르겠다. 다른 사람이 본다면 ‘이런 목적 없는 삶이 있나..’ 라고 생각할지도 모른다.  \n\n그런데도 이런 삶이 더 재밌다.  \n과거의 나는 내 분야에서 최고가 되고 싶었다. 멋진 사람도 되고 싶었고, 지금보다 훨씬 더 잘하고 싶었다. 그럴수록 지금의 나와 목표하는 내가 비교됐다. 분명 멋진 목표를 향해 달리고 있지만, 언제나 현재의 나는 목표한 것보다 못난 사람이었다.  \n더 잘하는 사람, 더 멋진 사람이 되려고 애쓰던 과거의 나보다 지금의 내가 훨씬 더 행복하다.  \n내 인생의 종착지는 항상 행복이었으니, 이제는 오늘의 내가 행복한 길로 계속해서 걸어보려고 한다.  \n- TIL을 써두니까 이번 주에 있었던 일이 뭐였는지 기억하기 쉬운 것 같다. 앞으로도 꾸준히 쓰자!  \n++ mat.zip 붙었다! 체인저, 주드와 열심히 지원서 썼는데 잘 돼서 다행이다! 앞으로 열심히 해야겠다 😎\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 이번 미션에 시간을 많이 할애했다. 페어와도 많이 이야기 하고, 다른 사람들은 어떻게 구현했나 PR도 구경했다. 다른 크루들에게 인사이트를 많이 얻어서 내 코드에도 적용했다. 미션에 몰입하니 즐겁다~\n- 공부하는 시간을 즐겼다. 약속이 많아서 그랬는지는 모르겠지만 이번 주 따라 공부하는 게 너무 재밌었다. 앞으로도 즐거운 공부를 하고 싶다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 이번 주는 술자리가 많았다. 수목금은 내내 술을 마셨으니..ㅋㅋㅋ 저녁에 공부를 많이 못해서 아쉽다. 다음 주는 최대한 술자리를 줄여보자고 다짐해본다. 이미 목요일에 술약속이 있긴 하지만 ㅋㅋㅋ 일주일 3번이 1번으로 줄었으니 좀 더 나은 한 주를 보낼 수 있을 것 같다.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 리뷰 받고 나서 2일 안에 다시 리뷰 요청 보내기!\n- 지하철 타고 가면서 토비의 스프링 틈틈이 읽기. 양에 집착하기보다 읽는 것 자체에 집중하자.\n\n## 🧨 지난주 Try 회고\n\n- 저녁 먹고 10시 까지 페어룸에서 공부하기 → **실패**\n    - 9시까지 남아서 공부했다. 수목금은 저녁 약속이 계속 있어서 많이 못했다.\n- 미션에 투자하는 시간을 하루 4시간 이상으로 배치하기 → **반쯤 성공?**\n    - 잠실캠에 남아 있는 시간 동안에는 미션에 몰입했다. 그렇지만 저녁에 남은 시간이 많지 않아 4시간은 아니었다…ㅠ 술약속이 많지 않았다면 지킬 수 있었을지도… 😂\n- 미션에 더 집중하기 → **성공**\n- 미션에서 나오는 키워드를 공부하기 → **성공**\n    - 미션에서 궁금했던 것을 중점적으로 공부했다!\n- 의식적으로 예쁜 말을 골라서 하기 → **성공**\n    - 주변 사람들에게 예쁜 댓글과 말을 하려고 노력했다. 그렇지만 가끔 말이 나쁘게 나오는 건 고쳐야 할 점이다.\n\n## 📚 다음 주 목표\n\n- 내가 만족할 수 있는 PR 리뷰 요청 보내기\n- 기술 부채 2개 이상 해결하기\n- TIL 제외한 블로그 글 4개 이상 쓰기"},{"excerpt":"🌈 이번 주의 생각 💭 감기가 안 나아서 놀고 싶었는데 놀지 못했다. 아쉬운 마음대로 금요일 날 몰 아서 놀기로 했는데, 몸이 안 따라줘서 생각만큼 많이 놀지 못했다. 조금 아쉬웠다~ 그래도 약을 3일간 꾸준히 먹었던 거는 좋았던 거 같다. 브라운에게 강의를 들어야 하느냐고 물어봤다. 요즘 사람들이 다들 김영한님 강의를 듣길래 ㅋㅋ 브라운은 강의를 들어도…","fields":{"slug":"/level2-second-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 2주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🌈 이번 주의 생각 💭\n\n- 감기가 안 나아서 놀고 싶었는데 놀지 못했다. 아쉬운 마음대로 금요일 날 몰 아서 놀기로 했는데, 몸이 안 따라줘서 생각만큼 많이 놀지 못했다. 조금 아쉬웠다~ 그래도 약을 3일간 꾸준히 먹었던 거는 좋았던 거 같다.\n- 브라운에게 강의를 들어야 하느냐고 물어봤다. 요즘 사람들이 다들 김영한님 강의를 듣길래 ㅋㅋ 브라운은 강의를 들어도 좋고, 안 들어도 좋다고 했다. 삽질하기 > 강의 > 책으로 공부하기 순으로 좋다고 생각하신다고 했다. 나는 강의가 가성비가 떨어진다고 생각하는 편인데 (개인적인 생각입니다) 차라리 강의를 들은 크루에게 질문을 하라는 말을 듣고 굉장히 좋은 의견이라고 생각했다. 앞으로 김영한님 강의 듣는 크루들과 이야기를 많이 하면서 인사이트를 얻어가야겠다.\n- 잡생각이 많이 든다. 요즘 공부 외적으로도 생각해야 할 게 많아져서 계속 생각이 분산되는 것 같다. 가끔은 생각에 잡아먹혀서 해야 할 일을 못하기도 한다. 적당히 생각을 정리하고 나서 내가 할 수 있는 일을 해야겠다.\n- 배우고 싶은 것들이 많다. 지식욕일수도, 과욕일수도 있다고 생각한다. 어느 정도로 조절해야 할 지 아직 고민중이다…\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 빠뜨리지 않고 밥을 잘 챙겨 먹었다.\n- 궁금했던 부분에 대해 크루들과 토론하는 시간이 많았다.\n- 집중할 때 혼자 페어룸에서 공부하는 시간을 가졌다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 쓸데없는 공부를 많이 하고 있다. 그냥 문득 궁금한 거나 어디서 나온 키워드 같은 거 공부하느라 미션에 소홀했다. 얼마나 시간을 분배해야 하는지 아직도 잘 감이 안 온다… 내가 하고 싶은 것과 해야 하는 것을 어떻게 분리해야 할까?\n- 말이 날카로워지고 있다. 이렇게 한 번씩 자각을 해야 사람들에게 좀 더 부드럽게 말할 수 있을텐데. 머릿속으로 괜찮은 말과 말투인지 돌아보고 대화해야겠다.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 저녁 먹고 10시 까지 페어룸에서 공부하기\n- 미션에 투자하는 시간을 하루 4시간 이상으로 배치하기\n\n## 🧨 지난주 Try 회고\n\n- 저녁에 운동해보기: 컨디션 난조로 한 번 운동했다가 몸 상태가 안 좋아져서 감기가 나을 때까지 못했다 → **실패**\n- 영양제 먹기: 영양제 택배를 아직 못 뜯어서 못 먹고 있다 → **실패**\n- 사소하게 알게된 것도 블로그에 기록하기: 굉장히 블로그 포스팅을 열심히 했다. 오히려 너무 사소한 것까지 기록하는 바람에 걱정이 되었다. → **성공**\n- 침대에 하루 1시간 이상 누워있지 않기: 이번 주는 피곤하기도 했고, 잠실에서 공부를 하고 와서 침대에서 자기만 했다… → **성공**\n\n## 📚 다음 주 목표\n\n- 미션에 더 집중하기\n- 미션에서 나오는 키워드를 공부하기\n- 의식적으로 예쁜 말을 골라서 하기\n"},{"excerpt":"🐧 이번 주의 생각 💭 오랜만에 사람들을 만나서 좋았다. 방학 초반에 너무 심심했는데 많은 사람들을 보니까 굉장히 신났던 거 같다…ㅋㅋㅋ 생각보다 신났어서 나도 스스로한테 놀랐던 기억이 난다. 감기에 걸렸다. 유행병에 걸리는 거 싫어하는데 유행하는 감기에 걸려버렸다… 감기 안 걸리는 튼튼한 사람이라고 생각해왔는데 올해는 4월만에 깨져버렸다. 아쉽다. 새로…","fields":{"slug":"/level2-first-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨2 1주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🐧 이번 주의 생각 💭\n\n- 오랜만에 사람들을 만나서 좋았다. 방학 초반에 너무 심심했는데 많은 사람들을 보니까 굉장히 신났던 거 같다…ㅋㅋㅋ 생각보다 신났어서 나도 스스로한테 놀랐던 기억이 난다.\n- 감기에 걸렸다. 유행병에 걸리는 거 싫어하는데 유행하는 감기에 걸려버렸다… 감기 안 걸리는 튼튼한 사람이라고 생각해왔는데 올해는 4월만에 깨져버렸다. 아쉽다.\n- 새로운 사람들을 많이 만났다. 요즘에는 반말하는 사람이 많아지다보니 존댓말을 해야 하는 사람들에게도 반말이 나올 뻔한 적이 많다. 그래서 이번 주에는 말 놓은 사람 늘리기를 실천했다.\n- phind 써보니까 좋았다. 브리가 강의 때 추천해 준 검색엔진인데 chat-gpt와는 달리 정보의 출처가 나와서 좋았다. 검색결과와 함께 결과에 대한 요약도 AI가 같이 해줘서 한 눈에 읽기 좋다. 다들 한 번 써보세요 👍\n- 파워블로거 채널에 들어갔다. 이번에 페어가 된 깃짱이 혹시 파워블로거 되어 볼 생각 없냐고 해서 참여하게 됐다 ㅋㅋㅋ 주에 글을 4개 써야 하는데 나는 평소에 TIL을 써서 보통 조건을 만족하기 쉬울 것 같았다. 다시 봐보니 글을 8개나 썼다. 역시 강제력이 있으면 열심히 하기 쉽다.\n- 주드, 체인저와 함께 MATZIP에 지원했다. 실제 사용자가 있는 서비스를 운영해본 적이 없는데, 내가 사용해본 서비스를 직접 유지보수하고 기획, 개발하는 게 굉장히 메리트 있다고 생각해서 지원하게 되었다. 뽑히면 좋겠다 🔥\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 사람들과 적당히 이야기하면서 내 공부도 열심히 했다. 짧은 내용이지만 블로그 포스팅도 많이 했다.\n- TIL을 꾸준히 썼다. 저녁에 TIL을 안 써서 다음 날에 TIL을 쓰기도 했지만 중요한 것은 밀리지 않았다는 것이다.\n- 이번 미션 동안 블로그 글 대신 공식문서를 읽고 이해했다. 공식문서가 어렵지 않고 예제도 많아서 이해하기 훨씬 쉬웠다.\n- 이번 주에 chat-gpt를 질문 해결하는데 많이 썼는데 의외로 만족스러운 대답이 많았다. 키워드를 얻는 용도로 많이 사용해야겠다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 컨디션 관리에 실패했다. 감기에 걸려서 뭔가 할 때 집중이 안 됐다. 특히 집에 가면 컨디션이 더 안 좋아져서 아무것도 못 했다.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 컨디션 관리를 잘하자. 체력을 기르기 위해 하루 30분이라도 운동을 하자.\n- 배운 것을 제대로 기록하고 블로그 포스팅을 열심히 하자. 사소한 내용이라도!\n- 조용히 말하자.\n- chat-gpt, phind를 적극적으로 사용해보자.\n\n## 📚 다음 주 목표\n\n- 저녁에 운동해보기\n- 영양제 먹기\n- 사소하게 알게된 것도 블로그에 기록하기\n- 침대에 하루 1시간 이상 누워있지 않기"},{"excerpt":"이번 주는 한 게 많이 없어서… (약간의 심신미약인) 글로 대체합니다 ˙ᵕ˙ 여러 가지를 생각하는 것 결과가 정해진 일을 2주 동안 생각하고 있다가 어제 홧김에 마무리 지어버렸다. 어떻게든 결판이 났으니 마음이 후련한 것 같다가도, 허전한 것 같다가도, 여전히 나에게는 달라진 것이 없다는 생각이 든다. 여기 와서 내가 많이 바뀌어서 좋았는데 다시 들여다보…","fields":{"slug":"/level1-eighth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨1 8주차 회고","tags":["회고"]},"rawMarkdownBody":"\n이번 주는 한 게 많이 없어서… (약간의 심신미약인) 글로 대체합니다 ˙ᵕ˙\n\n## 여러 가지를 생각하는 것\n\n결과가 정해진 일을 2주 동안 생각하고 있다가 어제 홧김에 마무리 지어버렸다.  \n어떻게든 결판이 났으니 마음이 후련한 것 같다가도, 허전한 것 같다가도, 여전히 나에게는 달라진 것이 없다는 생각이 든다.  \n여기 와서 내가 많이 바뀌어서 좋았는데 다시 들여다보니 아닌 것도 같다.  \n왠지 이번 주의 나는 어제의 나에서 더 이상 나아진 게 없는 듯하다. 유지라도 했다면 다행이다.  \n내내 고민하던 게 해결돼서 잘 지낼 수 있을까? 아니면 내 결정이 발목을 잡게 될까? 여러 가지 생각이 든다.\n\n아이러니하게도 이번 주는 진짜 아무 생각 없이 살았다.  \n놀고 싶을 때 놀아버렸고, 하고 싶은 말은 다 했다.  \nTIL은 열심히 썼다.  \n주변 사람들과 많이 놀았다. 그래서 즐거운 일들이 많았다.  \n노래도 많이 들었다. 좋은 노래도 여러 곡 찾았다.  \n좋은 일이 많다고 해서 기분이 좋아지지는 않는다. 그렇다고 우울한가? 그것도 아니다.  \n이번 주는 내내 그런 상태였다. 적당히 기분 좋지도 안 좋지도 않은 상태.  \n나도 왜 이러는지 모르겠으니 여기서 마무리하자 ㅋㅋ\n\n그럼에도 기쁜 일이 많은 건 좋은 일이다.  \n방학식 때 칭찬 사연을 3개 냈는데 2개가 채택되어 버릴 줄이야… 조금 부끄러웠다 ㅋㅋ  \n칭찬상도 받고 우지컬 우승하고 멋진 무대도 보여준 체인저 축하해~  \n방학식 날에 전날 알코올 이슈로 지각하기는 했지만 점심 시간에 잠깐 있었던 기타 연주 구경은 정말 재밌었다. 다들 기타를 잘 쳐서 나도 기타를 배워보고 싶어졌다 ㅋㅋ 항상 생각만 하고 기타를 배워본 적은 없다.  \n만약 기타를 배운다면 일렉 기타를 배우고 싶다. 굳이 기타가 아니더라도 예전에 배웠던 드럼을 더 배워보고 싶다.  \n하고 싶다고 생각하는 건 많은데 실제로 내가 하고 싶은 건 많지 않다.  \n연애를 할 때 상대방이 가장 많이 물어본 말이 ‘너는 뭐 하고 싶은 거 없어?’ 였을만큼.  \n내가 이걸 하고 싶다고 나한테 최면을 거는건지, 하고 싶은 척을 하는건지 잘 모르겠다.  \n그렇지만 오히려 하고 싶은 게 많지 않으니까, 하고 싶은 게 생기면 진심을 다할 수 있다는 장점이 있다.  \n지금 개발이 그렇다. 지금까지 내가 하고 싶었던 것 중에 가장 오래 가는 관심사가 개발이니까. 그래서 지금 최선을 다하고 싶다.  \n\n레벨1이 끝났으니 레벨1 회고를 해보자.  \n정말 많은 사람들과 빠른 시간 안에 알게 되었다. 살면서 2달 안에 이렇게 많은 사람들을 만난 것도 신기하다. 앞으로도 지금처럼 새로운 사람을 만나는 걸 두려워하지 않고 계속 아는 사람을 넓혀가고 싶다. 친해진 사람들과도 더욱 친해지는 게 목표다 😄  \n자바에 조금 자신감이 생겼다. 항상 얕은 지식만을 쌓는다는 생각에 반복적인 슬럼프가 왔었는데, 여기서는 ‘이게 왜 되지?’, ‘왜 이걸 써야 하지?’에 대한 생각을 지속적으로 하고, 주변 사람들과 의견을 나누다보니 자연스럽게 깊은 지식을 쌓을 수 있게 된다. 그게 나를 크게 성장시키고 있다. 뿌듯하다! 😎  \n자존감이 높아졌다. 자존감을 높이는 방법 중에 ‘일상에서 작은 성공을 자주 경험하기’라는 방법이 있다. 우테코에 와 있는 ‘베로’는 실패보다 성공을 하고 있는 사람이다. 정말 사소한 순간에도 내가 나아지고 있다고 느낀다. 그러다보니 자연스럽게 나에 대한 자신감도 올라가고, 내가 하고 있는 일에 대해서도 실패할 것이라는 생각을 덜 하게 된다. 여기서 얻은 가장 큰 수확 중에 하나다.  \n다만 걱정되는 것은 내가 여기서 어떤 걸 얻어가고 싶은지 아직 갈팡질팡 하고 있다는 것이다. 사람들? 실력? 자신감? 스펙? 잘 모르겠다. 그렇지만 하나 확실한 것은 내가 재밌는 걸 하고 싶다는 것이다. 재밌는 스터디를 하고, 재밌는 일들을 하고, 재밌는 사람들과 같이 지내고 싶다. 일단 1차적인 목표는 그 날 할 일에 최선을 다하자는 것이다. 그것도 지키기 쉽지 않다는 걸 레벨1 하면서 알게 됐다.. 😂 그래도 노력해보자.  \n난 노력하는 걸 잘 못한다. 꾸준히 노력해서 성장하는 게 (다들 그렇겠지만) 나에게는 특히 어려운 일이다. 끈기도 없고, 관심도 오래 지속할 자신이 없다. 그런데 여기는 정말 노력하는 사람이 많다. 그런 사람들이 솔직히 부럽기도 하다. 그렇지만 나에게도 나만의 페이스가 있을 거라고 생각한다. 그러니까 여기까지 올 수 있지 않았을까? 남의 노력에 나를 맞추려 하기보다는 내 속도에 맞게 뛰어서 완주하는 걸 목표하려고 한다. 레벨5 까지!\n\n레벨1이 정말 길 거라고 생각했는데 순식간에 지나가버려서 조금, 아니 많이 아쉽다. 지금 방학도 그렇게 즐겁지는 않다… ㅋㅋㅎㅋㅎ 레벨2가 빨리 시작했으면 하는 마음이다.\n\n다들 레벨1 수고 많으셨습니다 ~ 🥳 저희는 2달이라는 시간 동안 충분히 몰입했으니까 쉴 자격 있다고 생각해요. 방학 동안 푹 쉬시고 레벨2 때 봐요! 🫶🏻\n\n## 📚 다음 주 목표\n\n- 열심히 놀고 열심히 재충전하기\n- 노는 게 지치면 자바 공부하기"},{"excerpt":"🐧 이번 주의 생각 💭 내가 커버할 수 있는 범위의 스터디는 정말 좋다. 나에게 공부를 강제해서 좋은 지식을 쌓을 수 있도록 도와준다 👍 이번 주는 만족할만한 한 주가 아니었다. 외부적, 내부적으로 있는 일들이 나에게 영향을 많이 끼쳐서 내 스스로 만족할만한 퍼포먼스를 내지 못했다. 그게 많이 아쉽다. 내 인생의 목표가 뭘까에 대한 고민을 하고 있다. 우…","fields":{"slug":"/level1-seventh-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨1 7주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🐧 이번 주의 생각 💭\n\n- 내가 커버할 수 있는 범위의 스터디는 정말 좋다. 나에게 공부를 강제해서 좋은 지식을 쌓을 수 있도록 도와준다 👍\n- 이번 주는 만족할만한 한 주가 아니었다. 외부적, 내부적으로 있는 일들이 나에게 영향을 많이 끼쳐서 내 스스로 만족할만한 퍼포먼스를 내지 못했다. 그게 많이 아쉽다.\n- 내 인생의 목표가 뭘까에 대한 고민을 하고 있다. 우테코에는 목표가 확고한 사람들이 많다. 나도 그 사람들처럼 멋진 목표를 세우고, 목표를 향해 달려 나가고 싶다. 그렇지만 아직 뭘 위해 살고 싶은지 알지 못한다. 혹시나 미래에 생길지도 모르는 목표가 과거에 발목 잡히지 않기 위해 열심히 살아가고 있지만, 무엇을 위해 살아가느냐고 물으면 대답할 수 없다. 여기에서 시간을 보내다 보면 멋진 목표가 생길까?\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 지금 하고 있는 스터디를 열심히 준비하자! 사실 급발진해서 만든 스터디였는데 굉장히 학습에 도움이 되어서 뿌듯하다. 앞으로도 내용 열심히 준비해서 잘해보자.\n- 주변 사람들과 좀 더 가까워진 것 같아 기분이 좋았다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 생산적인 토론을 하고 있는 건지 의심스러운 때가 많았다.\n- 나에게 집중하지 못했다. 주변을 더 신경써서 행동했던 때가 많았다. 다음 주는 레벨1이 얼마 남지 않은 만큼 내가 뭘 해야 하는지를 생각해보자. 자리를 옮겨서 다른 사람과도 이야기해봐야겠다.\n- 일이 많다보니 일에 휘둘렸다. 할 일을 끝내는데만 급급했다. 왜인지 시간이 없었다. 열심히 하고 있다고 생각해도 따지고 보면 아니었던 때가 많았다. 여유 없는 마음이 한 몫한 것 같다.\n- 컨디션 관리를 못했다. 입맛도 없고, 스트레스도 많이 받았다. 잠을 줄여가면서 뭔가를 했는데 남는 게 많지 않아서 안 좋은 것만 늘었다. 앞으로는 잠을 줄여가면서 할 일을 하지 말자. 최대한 일은 잠실에서 다 하고 오자.\n- 부수적으로 하는 일이 주객전도가 되지 않도록 조심하자.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 할 일을 정한 날은 꼭 끝내자. 항상 미뤄지는데, 그날 todo 에 쓴 일만큼은 끝내고 간다고 생각하자.\n- 잠을 최소 7시간 이상 자자. 그 이하로 자게 되면 생산성이 크게 떨어진다.\n\n## 📚 다음 주 목표\n\n- 레벨 인터뷰 잘 마치기\n- 좋은 사람들과 좋은 시간 보내기"},{"excerpt":"🐧 이번 주의 생각 💭 체력적으로 힘들었다. 이번 주 체스 미션이 빡세서 계속 남아 있다가 집에 갔는데 거짓말 안 하고 집에 가자마자 쓰러지게 된다. TIL은 적고 자야 해서 쓰다가 아무말 적혀있던 적도 있었다. 체스 미션 때문인지 입맛이 없었다. 밥도 많이 안 먹고 오래 남아있다 보니 체력이 방전되어 나중에는 웃을 힘도 없었다. 밥을 제대로 안 먹은 게…","fields":{"slug":"/level1-sixth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨1 6주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🐧 이번 주의 생각 💭\n\n- 체력적으로 힘들었다. 이번 주 체스 미션이 빡세서 계속 남아 있다가 집에 갔는데 거짓말 안 하고 집에 가자마자 쓰러지게 된다. TIL은 적고 자야 해서 쓰다가 아무말 적혀있던 적도 있었다.\n- 체스 미션 때문인지 입맛이 없었다. 밥도 많이 안 먹고 오래 남아있다 보니 체력이 방전되어 나중에는 웃을 힘도 없었다. 밥을 제대로 안 먹은 게 체력에 많은 영향을 준 거 같다.\n- 주말에 생일이었는데, 놀고 나서 조금 후회했다. 할 건 많은데 시간이 너무 없어서 회고도 1시 25분에 쓰고 있다.. 😂 진짜 몸이 3개였으면 좋겠다고 생각했다.\n- 페어인 루카와 점심을 먹으면서 말을 놓았다. 주노가 추천해준 체크리스트대로 페어프로그래밍 해 봤는데 친해지는게 의견 소통에도 너무 좋았다. 다음에 페어를 하게 된다면 (페어가 동의하는 경우) 말을 놓고 진행하고 싶다. 무엇보다 너무 공손하게 물어보지 않고 궁금한 걸 그때그때 물어볼 수 있어서 좋았다. 소통이 최고다 👍\n- 이번 주 월요일 아침에 주노가 기술부채 모아놓은 거 같이 봤다. 혼자서 공부할 때는 진짜 재미없었는데 서로 자기가 아는 내용 설명하고 책 찾아보다보니 시간이 금방 갔다. 내일도 주노가 있다면 기술부채 같이 보자고 할 생각이다 😄 모르는 개념도 주워들을 수 있어 좋았다.\n- 이번 주는 사람들과 많이 놀았다. 같이 술도 마시러 가고, 이야기도 많이 하고… 그래서 그런지 이번 주도 즐거웠다! 앞으로 공부 때문에 사람들과 많이 어울리지 못하게 되면 슬플 거 같다.\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 이번 주 내내 늦게까지 남아있어 본 결과 시간이 아까워서 뭐라도 하게 된다. 이렇게라도 공부를 좀 더 많이 해보자. 최소 2번은 남아있어 볼 생각이다. 목표는 4번..?\n- 요즘 40-50분 정도 빨리 오는 습관을 들였다. 이번주 내내 7시 20분에 일어나서 버스 타고 지하철 갈아타서 9시 10분 정도에 도착했다. 아침을 빨리 시작하면 기분이 좋아진다.\n- 구현에 대해서 여러 사람의 의견 들어보기. 크루들의 의견을 듣고 왜 그렇게 구현했는지 근거를 들으면서 내 코드에 대한 인사이트도 얻을 수 있어 좋았다. 특히 체스는 다른 크루들과 이야기하면서 얻었던 정보로 만들어진 것 같아 매우 뿌듯했다. 무조건 내 아이디어로만 구현할 필요는 없으니까 ˙ᵕ˙ 좋은 거 있으면 앞으로도 얼른 물어보자.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 날카롭게 말하는 거 고쳐야 한다. 원래 그렇게 말하는 게 습관이다 보니 무의식적으로 그렇게 반응하게 된다. 상처받는 사람들도 있으니 앞으로 정신차려서 의식적으로 부드럽게 말하는 연습을 해야겠다.\n- 잠을 많이 못 자고 있다. 평균 수면시간은 6시간-7시간이라 괜찮아보일지 몰라도 나는 너무 피곤하다. 할 일은 캠퍼스 내에서 얼른 끝내고 집에서는 진짜 TIL 적고 자기만 할 예정이다. (그치만 오늘은 이미 글렀다…)\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 잘 모르는 것을 메모장에 적어두자. 기술부채를 쌓아놓는 것만으로도 자극이 된다. 예전에 쌓아둔 개념들을 아직도 모르면 자괴감(?)이 들어서 공부를 하게 될 거 같다.\n\n## 📚 다음 주 목표\n\n- 첫 스터디 성공적으로 마치기\n- 주위 사람들과 잘 지내기\n- 지하철 탈 때 30분이라도 책 읽기 .. (객사오 아직 다 못 읽었다 😂 몇 주째 읽고 있는건지…)"},{"excerpt":"🐧 이번 주의 생각 💭 학교 동아리(ZeroPage) 새싹교실 강사로 참여했다. 새내기, 공부가 더 필요한 사람들에게 자바를 가르쳐주게 됐다. 6월까지라서 조금 바쁠 수도 있을 것 같은데 그래도 짬을 내서 해보려고 한다. 새싹교실 강사를 벌써 3년째 하고 있다니 감회가 새롭다. 새로운 사람들 앞에 나서는 것을 의식적으로 하고 있다. 다만 우테코, 과외가 …","fields":{"slug":"/level1-fifth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨1 5주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 🐧 이번 주의 생각 💭\n\n- 학교 동아리(ZeroPage) 새싹교실 강사로 참여했다. 새내기, 공부가 더 필요한 사람들에게 자바를 가르쳐주게 됐다. 6월까지라서 조금 바쁠 수도 있을 것 같은데 그래도 짬을 내서 해보려고 한다. 새싹교실 강사를 벌써 3년째 하고 있다니 감회가 새롭다. 새로운 사람들 앞에 나서는 것을 의식적으로 하고 있다. 다만 우테코, 과외가 있어서 비대면으로 진행하게 되어 아쉽다. 나도 대면 수업 하고 싶다… 🥺\n- 생각의 전환을 해봤다. 캠퍼스에 나왔을 때는 사람들의 의견을 많이 들어보고, 집에 와서 그걸 취합해보는 건 어떨까? 집에서 사람들의 의견을 듣기에는 쉽지 않으니까. 그냥 사람들과 더 많이 이야기하고 싶은 핑계일지도… ㅎ\n- tick-tick을 깔았다가 무료 버전은 불편한 부분이 많아서 todo-mate로 갈아탔다. 아기자기하고 귀여운 대신 캘린더 연동이 안 되고 빈 공간 누를 때 다음 달로 넘어가는 게 좀 화난다 ㅋㅋㅋ 맥북 todo list 좋은 거 아시면 추천해주세요 😎\n- 객체 지향의 사실과 오해 책은 78% 읽었다. (80% 읽지 못하다니.. 분발하자) 주말에는 과외 자료 준비하고 미션 하다보니 알고리즘 문제는 풀지 못했다 😭 그러고 보니 학습 로그, 이펙티브 자바도 못 읽었네… 학습과는 거리가 먼 한 주를 보냈던 것 같다… 😂\n- mbti 검사를 다시 해봤는데 entp가 나왔다. 완전 잘 맞는 것 같진 않지만 ㅋㅋㅋ 우테코 한정 ENTP로 살아야겠다.\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 사실 지금 나오는 시간 보다 20분 늦게 나와도 되지만, 약 9시 10분 정도에 캠퍼스에 등교하고 있다. 미리 가서 사람들과 이야기도 하고, 뭐하는지 구경하다보니 아침을 즐겁게 보낼 수 있었다!\n- TIL 열심히 적고 있다. 저번 주보다 쓴 게 많다. 할 말이 많아진다는 건 좋은 일이다 👍\n- 새로운 사람들과 계속해서 친해지려고 노력하고 있다. 이야기 해보고 싶었던 크루한테도 이야기해 보고, 다른 크루들이 이야기할 때 슬쩍 끼어서 이야기하기도 했다. 우테코에서 이루고 싶었던 ‘다른 사람의 의견을 궁금해하기’를 달성하는 중이다 😄 이번 주는 그냥 평범한 얘기하다가 열린 즉석 토론장에서 토론하는 게 제일 재밌었다.\n- 새로운 사람과 이야기 할 때 어떤 이야기를 해야 할 지 감을 잡아가고 있다. 원래는 그냥 머리가 하얬는데 이제는 머릿속에 템플릿이 생기는 기분이다 ㅋㅋㅋ\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 저번 주는 미션에 의욕이 생기지 않았다. 그래서 캠퍼스에서는 미션 구현은 많이 못했다. 의식적으로 미션을 고민하고 어떤 식으로 하면 좋을지 생각하는 시간을 많이 가져야겠다.\n- 말 조심하기. 편한 상태로 말하다 보면 말이 세게 나가버릴 때가 있다. 머릿속으로 다시 한 번 생각하고 말하자.\n- 말을 정리하고 말해야겠다. 정리되지 않은 채로 일단 말을 시작해버리면 “어.. 무슨 말을 하고 싶었더라 까먹었어요 죄송해요” 라고 말하는 걸 알게 됐다. 시간이 좀 걸리더라도 “저 잠깐 정리하고 말할게요” 라고 말한 다음에 생각을 정리하고 나서 말하는게 나을 것 같다.\n- 부정적인 생각을 담아두지 말고 좋은 말로 표현하거나 최대한 그때 털어내자. 계속 그 생각에 사로잡혀 있으니 나아지는 게 없었다. 먼저 나서서 해결하던지, 해결할 수 없다면 빠르게 잊어버리자.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- 더 많은 사람들과 지식을 공유하자. 체인저와 같이 했던 미니 강의 너무 좋았다 👍 당연하긴 하지만 친한 관계에서 불쑥 나오는 이야기가 정말 좋은데, 다른 크루들에게도 배운 것들을 나누고 싶다. 새롭게 알게 된 것을 다른 사람과 공유해보자.\n- 다양한 방법으로 궁금증을 해결하자. 책으로 하는 것보다 크루들과 말하면서 하는 공부가 더 재밌다. 그렇다고 책을 안 읽는 건 문제가 있다. 어떤 주제로 이야기를 한 뒤에 꼭 책이나 문서를 보면서 공부하는 습관을 들이자.\n- 하루에 30분 책을 읽자. 아침에 지하철 탈 때 책을 읽으면서 가면 금방 읽을 것 같다.\n\n## 📚 다음 주 목표\n\n- 객체 지향의 사실과 오해 100% 읽기\n- 학습 로그 1개 이상 쓰기 (다음 주는 꼭…)\n- 체스 미션 페어와 친해지기"},{"excerpt":"Lil Nas X - STAR WALKIN’ 좋네요 🐧 이번 주의 생각 💭 블랙잭 게임 구현은 오래 걸렸다. 시간이 없는 것도 맞았지만 뭔가 잘 안 풀리고 있다는 느낌이 들었다 😂 구현하면서도 느껴졌는데 리팩토링 하다보니 조금 막막해졌다 ㅋㅋㅋ 과외를 다시 시작했다. C++ 알고리즘 수업을 한다. 과외를 하면서 나도 많이 배운다. 가끔 공부하는 에너지를 …","fields":{"slug":"/level1-fourth-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨1 4주차 회고","tags":["회고"]},"rawMarkdownBody":"\nLil Nas X - STAR WALKIN’ 좋네요\n\n## 🐧 이번 주의 생각 💭\n\n- 블랙잭 게임 구현은 오래 걸렸다. 시간이 없는 것도 맞았지만 뭔가 잘 안 풀리고 있다는 느낌이 들었다 😂 구현하면서도 느껴졌는데 리팩토링 하다보니 조금 막막해졌다 ㅋㅋㅋ\n- 과외를 다시 시작했다. C++ 알고리즘 수업을 한다. 과외를 하면서 나도 많이 배운다. 가끔 공부하는 에너지를 받아가기도 한다. 오늘도 수업하고 나서 괜히 공부하고 싶어져서 과외 끝나고도 계속 공부했다.\n- 나를 더 돌아보고 있다. 예전에는 나를 자세히 들여다보는 것을 의식적으로 기피했는데, 요즘에는 조금씩 알아가려고 노력하고 있다. 오히려 지금은 내가 다른 사람에 비해 나를 더 모르는 것 같다. 앞으로 천천히 알아가자. 아자아자‼️\n- 저번 주에는 몰랐던 사람들을 많이 만났다. 굿샷과 뷰티풀샷 강의장에 다들 숨어있었다…ㅋㅋㅋ 이름은 들어봤는데 얼굴은 처음 보는 사람들을 삼일절에 많이 보게 됐다. 새로운 사람을 만나는 것도 재밌었다.\n- 객체지향의 사실과 오해 62% 읽었다. 지하철 타면서 읽으려고 했는데 가방이 너무 무거워서 집중이 잘 안 됐다. 이번 주는 꼭 80%까지 읽자!\n- 버스로 가면 좀 더 빨리 갈 수 있다는 사실을 알게 되었다. 요즘에는 버스로 구로디지털단지까지 가서 지하철을 탄다. 약 10분 정도 빠르게 올 수 있다!\n- 내가 유일하게 하고 싶었던 것은 개발이었다. 다른 사람이 하라고 한 일이 아닌 내가 하고 싶어서 했던 거! about me에 썼던 “나는 개발을 사랑한다” 라는 말이 왠지 나에게 더 큰 울림을 줬다. (내가 한 말인데..ㅋㅋㅋ) 나도 글을 쓰면서 처음 알게 된 걸지도 모르겠다.\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n- 가끔 쓰기 귀찮은 날도 있었지만 꾸준히 TIL을 썼다.\n- 저녁을 잘 챙겨 먹었다. 저번 주는 끝나고 와서 먹는 걸 소홀히 했었어서 거의 하루에 1끼만 먹었었다. 이번 주에는 이모가 반찬을 보내주셔서 반찬을 썩히지 않기 위해 열심히 챙겨 먹었다!\n- 이번에 페어와 그림을 그리며 설계를 시작하니 어떤 구조인지 머릿속에 잘 각인되는 효과가 있었다. 다음 페어 프로그래밍 때도 대략적인 그림을 그려보고 나서 시작하자!\n- 다른 크루에게 인사할까 고민하지 않고 먼저 말을 걸었다. 최대한 상대에게 솔직하게 다가가려 노력하고 있는 모습이 내 스스로 마음에 든다.\n- 누워서 놀고 있지 않고 저녁에도 책상에 앉아 공부를 했다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n- 금요일에 TIL을 안 쓴다. 집에 오자마자 쉬어 버려서 항상 금요일 TIL이 없다 🥺\n- 페어와 이야기할 때 다른 시도를 해보고 싶었던 마음에 많은 부분을 그냥 양보했다. 그래서인지 완성된 블랙잭 구현에 내 코드 스타일이 많이 반영되지 않았다는 생각을 했다. (양보를 많이 했으니 당연함ㅋㅋㅋ)\n- 나중에 이렇게 말할걸이라고 후회하지 말고 바로바로 말했어야 했다. 아니 어쩌면 시간이 없어서 그랬던 걸지도… 😂\n- 항상 미션을 할 때 초반에 시간을 많이 써버려서 제출 당일에 너무 바빠진다. 설계할 때 시간을 너무 많이 쓰지 말자. 개발의 우선순위를 정해야 빠르게 구현할 수 있을 것 같다.\n- 미션할 때 생각했던 것은 그때그때 적어두고 블로그에 기록하자. 항상 글 쓸 때 아 그거 뭐였지?만 하고 있음…\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n- To do list를 쓰는 것을 시도해볼 것이다. 하는 일을 항상 까먹어서 막판에 떠올리는 편인데, 맥북을 자주 쓰는 요즘 노트북에 todo list를 깔면 잘 쓰지 않을까?\n- 주말에 알고리즘 공부를 해 볼 생각이다. C++ 알고리즘 강의 하는 김에 C++도 더 공부하고, C++로 알고리즘 푸는 연습도 할 생각이다. 오리가 알고리즘을 주말에 딱 2시간 푼다고 했는데 나도 한 번 도전!\n\n## 📚 다음 주 목표\n\n- 객체지향의 사실과 오해 80% 읽기\n- 학습 로그 1개 이상 쓰기\n- TIL 금요일 포함해서 꾸준히 쓰기\n- 주말에 알고리즘 2시간 풀기\n- Effective Java Item 2개 이상 읽기"},{"excerpt":"이번 주 느낀 것 더 많은 사람들과 이야기하고, 여러 가지 시도들을 해봤다. 나 의외로 새로운 사람들과 만나는 거 좋아하는 사람이었을지도? 이름 짓는 거 진짜 어렵다. 메서드나 클래스, 변수 이름 짓는 거 때문에 영어 공부하는 거 생각 중이다. TIL 밀리니까 하나도 기억 안 난다. 그 날 졸리더라도 집 가서 바로 눕지 말고 TIL 적고 자자. 긍정적인 …","fields":{"slug":"/level1-third-retrospect/"},"frontmatter":{"date":"2023년 11월 16일 04:11","title":"레벨1 3주차 회고","tags":["회고"]},"rawMarkdownBody":"\n## 이번 주\n\n### 느낀 것\n\n- 더 많은 사람들과 이야기하고, 여러 가지 시도들을 해봤다. 나 의외로 새로운 사람들과 만나는 거 좋아하는 사람이었을지도?\n- 이름 짓는 거 진짜 어렵다. 메서드나 클래스, 변수 이름 짓는 거 때문에 영어 공부하는 거 생각 중이다.\n- TIL 밀리니까 하나도 기억 안 난다. 그 날 졸리더라도 집 가서 바로 눕지 말고 TIL 적고 자자.\n- 긍정적인 게 훨씬 좋은 에너지를 준다. 정말로 내가 할 수 있는 것처럼 느껴진다.\n- 의식적으로 “~인 것 같다”, “~일 수도 있다” 보다 “~이다” 나 “~였다” 라는 말을 쓰려고 한다. 말에 확신이 깃든다는 건 좋은 거니까!\n- 사다리 미션 어려웠지만 오히려 다른 구조로 짜볼 수 있어서 좋았다. 다른 사람의 관점으로 프로그램을 구조화한다는 건 재밌는 일이다.\n- TDD 재밌고 유익하긴 한데 시간이 오래 걸린다는 게 단점이다. 어떤 부분에 TDD를 적용해야 하는지 고민해봐야겠다.\n\n### 배운 것\n\n- chat-gpt 메서드 이름 짓기 좋다.\n- 도메인 클래스에 필드가 하나인 경우에는 암묵적 메서드 네이밍을 사용해도 괜찮다.\n- 굳이? 라고 여겨지는 것들은 한 번씩 의심해본다.\n    - 내가 MVC 패턴 구현을 위해 그냥 controller를 쓴 것은 아닌지 의심해보았다. 미션 1단계까지는 필요 없을 것 같아 삭제했고, 2단계에서는 필요해서 추가했다. “필요하니까” 쓰는 연습을 하자. “그냥”, “남들 다 쓰니까”는 이유가 될 수 없다. 나를 설득해야 남도 설득할 수 있다.\n- 객체가 갖고 있어야 할 것을 먼저 생각하지 말고, 책임의 흐름을 먼저 생각하자. 갖고 있어야 하는 것을 먼저 생각하면 그 생각에 매몰되어 해당 객체에 있어야 할 책임을 제대로 할당하지 못하기도 한다.\n\n## 다음 주\n\n### 해야 할 것\n\n- 블랙잭 미션 시작!\n- TIL 밀리지 않고 쓰기 🧐\n- 내 페이스를 유지하면서 4주차도 잘 지내기 😊\n\n### 하고 싶은 것\n\n- 조급해하지 않고 내 할 일 잘하기\n- “해야 하는 것”을 미루지 않고 잘 이뤄내기\n- 객체지향의 사실과 오해 책 최소 70%까지 읽기\n\n## 잡담\n\n소파 쪽에 앉으면 편하긴 한데 집중은 잘 안 된다 ㅋㅋㅋ 그렇지만 많은 사람들과 더 편하게 이야기할 수 있는 공간이라 좋았던 것 같다 😄\n\n원래 익숙한 거 좋아맨인데 우테코 와서 새로운 도전하고 있으니 나름 재밌다."},{"excerpt":"TODO LOG 배운 것 느낀 것","fields":{"slug":"/2023-11-16/"},"frontmatter":{"date":"2023년 11월 16일 01:11","title":"2023년 11월 16일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"Ringle After completing my degree, I hope to use my skills to create a service that solves problems around the world. I'm taking this leave of absence to develop those skills. I realized our producti…","fields":{"slug":"/english-speaking-nov-3week/"},"frontmatter":{"date":"2023년 11월 14일 07:11","title":"11월 3주차 영어 회화","tags":["english"]},"rawMarkdownBody":"\n## Ringle\n\n- After completing my degree, I hope to use my skills to create a service that solves problems around the world. I'm taking this leave of absence to develop those skills.\n- I realized our productivity in meetings was low because we didn't fully understand the topic before we started.\n- I shared it with my teammates at woowacourse, who used it to understand the function more. They successfully used that knowledge to create and implement a login process.\n- Should be tasks or projects related to my real experience in this field?\n\n### 전치사\n\n- I'm preparing **for** some technical interviews, so I want to focus on that form.\n- I'm taking a leave of absence **from** university, majoring in computer science.\n- I want to make a service to help ~~with~~ other people around the world.\n- When my team has a meeting, we usually discuss ~~about~~ a subject for a long time.\n- I suggested **that** looking over documents before the meeting started was necessary to end the meeting **quickly**.\n- As our meetings proceeded without proficent examining **of** the subject, I analyzed our productivity was lowered **at** that point.\n- **As a result**, ...\n- talking ~~about~~ -> talking **with**\n- I would organize it **into** the writing and share it with my teammates.\n- I can share my knowledge when I am busy working **on** my own tasks\n- my response **to** these questions\n\n### 동사 시제\n\n- When I'm in charge of something, I **will** do my best and do a great job. -> not would\n\n### 불가산 명사\n\n- knowledges (x) -> knowledge\n  \n### 불변화사\n\n- They completely accepted my solution, so we could increase our productivity **by talking about** some topics.\n\t- 이전 버전: .. to talk with ...\n\n## 회화 수업\n\n"},{"excerpt":"It is very important for me to pass the test It seems like you have a crush on her. It's likely that he has lost all his mmoney gambling. It turned out that they've had feellings for each other. It f…","fields":{"slug":"/english-speaking-pattern/"},"frontmatter":{"date":"2023년 11월 14일 06:11","title":"영어 문장 패턴","tags":["english"]},"rawMarkdownBody":"\n- It is very important for me to pass the test\n- It seems like you have a crush on her.\n- It's likely that he has lost all his mmoney gambling.\n- It turned out that they've had feellings for each other.\n- It feels like I was talking to nobody.\n- There is no doubt that you've already got the news.\n- There is no point in helping him out again.\n\n## 명사절\n\n### 주어\n\n- What you do is not that great. \n- What she did to him is not good.\n- What she's been doing is awesome.\n- What she's been doing for him is unbelievable.\n\n### 목적어\n\n- I love what you're doing.\n- I hate what she's been doing so far.\n- You should appreciate what he's doing for your family.\n- I want to know why he did that.\n\n### 전치사의 목적어\n\n- I was thinking about what you said.\n- It depends on whom you're talking to.\n- I will give you some advice on how you can grow your relationships.\n- I'm sick of being treated this way.\n\n## 영어 문장\n\n- I have to ...\n- I don't have to ...\n- I'm gonna have to ...\n- You're gonna have to ...\n- Do I really have to ...\n- Do you have to ...\n- I've been thinking about ...\n- All you have to do is ... (네가 해야 하는 것은 ~ 뿐이다.)\n\n## 자주 말하는 말 정리\n\n- I'm having a hard time answering that question, can I give it a little more thought?\n- The part is a little different than I thought.\n\n## 참고\n\n- https://brunch.co.kr/@reading15m/128\n- https://sonsecurity.tistory.com/103"},{"excerpt":"TODO LOG 배운 것 느낀 것 흑흑 영어 어려워... 이 글 보시는 분들은 미리미리 영어 좀 해두시길 바랍니다... 닥쳐서 하려니 너무 힘들어요","fields":{"slug":"/2023-11-14/"},"frontmatter":{"date":"2023년 11월 14일 05:11","title":"2023년 11월 14일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n## 느낀 것\n\n- 흑흑 영어 어려워... 이 글 보시는 분들은 미리미리 영어 좀 해두시길 바랍니다... 닥쳐서 하려니 너무 힘들어요\n"},{"excerpt":"Set Interface  : given an iterable A, build sequence from items in A return the number of stored items : return the stored item with key k : add x to set(replace item with key x.key if one already ex…","fields":{"slug":"/mit-ocw-sets-and-sorting/"},"frontmatter":{"date":"2023년 11월 14일 01:11","title":"MIT 4. sets and sorting","tags":["mit","algorithms"]},"rawMarkdownBody":"\n## Set Interface\n\n- `build(A), len()` : given an iterable A, build sequence from items in A return the number of stored items\n- `find(k)`: return the stored item with key k\n- `insert(x)`: add x to set(replace item with key x.key if one already exists)\n- `delete(k)`: remove and return the stored item with key k\n- `iter_ord()`: return the stored items one-by-one in key order\n- `find_min()`: return the stored item with smallest key\n- `find_max()`: return the stored item with largest key\n- `find_next(k)`: return the stored item with smallest key larger than k\n- `find_prev(k)`: return the stored item with largest key smaller than k\n\nif the only thing I care about is building up my entire set and searching it once, there's actually a faster algorithm. This is going to be needlessly confusing because we're going to see that this is really not the right way to implement it in about 38 seconds.\n\n## How do I implement it if a set is unordered?\n\n1. Just iterate from beginning to this array and say, is this guy erik? .... and return it.\n\t- in the worst case of really bad luck, your instructor is all the way at the end of the list.\n\t- That means that I have to walk along the entire array before I find him, So that algorithm takes order n time.\n\t- an unordered array is a perfectly reasonable way to implement this set interface. and then searching that array it will take linear time every single time I search\n\n| Data Structure | Container | Static  | dynamic              | Order                  | Order                      |\n| -------------- | --------- | ------- | -------------------- | ---------------------- | -------------------------- |\n|                | build(A)  | find(k) | insert(x), delete(k) | find_min(), find_max() | find_prev(k), find_next(k) |\n| Array          | n         | n       | n                    | n                      | n                          |\n| Sorted Array               | $nlogn$           | $log n$         | n                      | 1                        | $logn$                            |\n\nif I use the binary search, I can find the element which I want to find in $log n$ time\n\n## Set\n\nInput: Array of n numbers/keys A \nOutput: sorted array B\n\nOne is if your sort is destructive, what that means is that rather than reserving some new memory for my sorted array B and then putting a sorted version of A into B, a destructive algorithm is one that just overwrites A with a sorted version of A.\n\nSome sorts are in place, meaning that not only are they destructive, but they also don't use extra memory in the process of sorting. (Uses $O(1)$ extra space)\n\nAny time I just make a temporary variable like a loop counter, that's going to count toward that order 1. But the important thing is that the number of variables I need doesn't scale in the length of the list.\n\n## Permutation Sort\n\n```python\ndef permutation_sort(A):\n\t# Sort A\n\tfor B in permutations(A):\n\t\tif is_sorted(B):\n\t\t\treturn B\n```\n\nI know that if I have an input that's a list of numbers, there exists a permutation of that list of numbers that is sorted by definition because a sort is a permutation of your original list.\n\nlist every possible permutation, and then just double check which one's in the right order.\n\nThere's two key pieces to this particular technique, one is that we have to enumerate the permutations.\n\n1. Enumerate permutations\n\t- If I have a list of n numbers, how many different permutations of n number are there? -> $n!$\n\t- It might be that like actually listing permutations takes a lot of time for some reason, like every permutation.\n\t- at the very least, each one of these things looks like n factorial. $\\Omega(n!)$\n2. check if that particular permutation is sorted\n\t- for i equals 1 to n minus 1, B[i] less than or equal to B[i + 1]\n\t- how long does this algorithm take? -> this step incurs order n time because theta of n time ($\\theta(n)$), \n\n=> our algorithm takes at least n! times n time ($\\Omega(n! *n)$)\nomega means lower bound.\n\n## Selection sort\n\nIt is that everything to the right of this little red line that I've drawn here is in sorted order.\n\n- what does selection sort do?\n\t- it just kept choosing the element which was the biggest and swapping it into the back and then iterating.\n\n### recursive\n\nwe're going to divide it into two chunks.\nOne of them is find me the biggest thing in the first i elements of my array.  \nAnd the next one is to swap it into place and then sort everything to the left.\n\n1. Found the biggest with index less than or equal to i\n2. Swap\n3. Sort 1, ... i-1\n\n```python\ndef prefix_max(A, i):\n\t# Return index of maximum in A[:i+1]\n\tif i > 0:\n\t\tj = prefix_max(A, i-1)\n\t\tif A[i] < A[j]:\n\t\t\treturn j\n\treturn i\n```\n\nBase case: i = 0\n\nif my runtime is a function s, well, for one thing, if my array has one element in it, it returns i.\nSo in other words, it's $\\theta(1)$ \nS of n ($S(n)$) is equal to S of n minus 1 ($S(n-1)$) plus theta of 1 ($\\theta(1)$)\nS of n maybe look something like $cn$ for some constant c that doesn't depend on n.\n\nI've guessed that s of n is theta of n.\n$cn = c(n-1) + \\theta(1)$ (I can subtract cn from both sides)\n=> $c = \\theta(1)$ \n\n```python\ndef selection_sort(A, i = None):\n\tif i is None: i = len(A) - 1\n\tif i > 0:\n\t\tj = perfix_max(A, i)\n\t\tA[i], A[j] = A[j], A[i]\n\t\tselection_sort(A, i - 1)\n```\n\nthe first thing I'm going to do find is find the max element between 0 and i. And then I'm going to swap it into place. Then step3 is I still have to sort everything to the left of index i and that's that recursive call.\n\nlet's call that t for time. \n\n$T(n) = T(n-1) + \\theta(n)$ => $\\theta(n^2)$\n$T(n)^{2}= cn^2$\n$cn^{2} = c(n-1)^{2}+ \\theta(n) = cn^{2}- 2cn + c + \\theta(n)$\n$\\theta(n) = 2cn - c$\n\nby the way, notice that this order n swallowed up the order 1 computations that I had to do to swap and so on.\n\n## merge sort\n\nI'm going to make a new sorted list, which is twice as long.\n\n```python\ndef merge_sort(A, a = 0, b = None):\n\tif b is None: b = len(A)\n\tif 1 < b - a:\n\t\tc = (a + b + 1) // 2\n\t\tmerge_sort(A, a, c)\n\t\tmerge_sort(A, c, b)\n\t\tL, R = A[a:c], A[c:b]\n\t\tmerge(L, R, A, len(L), len(R), a, b)\n```\n\n```python\ndef merge(L, R, A, i, j, a, b):\n\tif a < b:\n\t\tif (j <=0 ) or (i > 0 and L[i-1] > R[j-1]):\n\t\t\tA[b-1] = L[i-1]\n\t\t\ti = i-1\n\t\telse:\n\t\t\tA[b-1] = R[j-1]\n\t\t\tj = j-1\n\t\tmerge(L, R, A, i, j, a, b-1)\n```\n\nFirst of all, how long does it take to sort an array of length 1? $T(1)$ => $\\theta(1)$\n$T(n) = 2T(n/2)+ \\theta(n)$  => $T(n) = \\theta(nlogn)$\n$cnlogn = 2c\\frac{n}{2}log\\frac{n}{2}+ \\theta(n) = cn(logn - log2) + \\theta(n)$\n=> $\\theta(n) = cnlog2$\n\n## 질문\n\n- What is the time complexity of implementing set with a sorted array?\n\t- When I build a set using sorted array, It takes order N log N. And If I want to get element in a set, It takes order log N because of the binary search to find the element. If I insert or delete an element in the set, it takes order n time because the time that copy the original array exists. If I want to find the minimum or the maximum value in the array, It takes O of 1 \n- Can you explain destructive in sorting?\n\t- The destructive sort is to sort original array. So the original array is not preserved. That's the destructive sorting.\n- Can you explain the process of merge sort?\n\t- Merge sort is to sort the array using divide and conquer method. First, I'm going to split the range of the array into half. And then do it again and again until the splitted range size is one. Next, I can sort the size 1 array easily. And next, I'm going to merge two arrays into one array until the merged array size equals the original array. That's the process of the merge sort.\n\t- Can you describe the process of the merge function?\n\t\t- First, I have two pointers to point the ends of two arrays. I call two arrays A and B, and call two pointers p1 and p2. If p1 of a is bigger than p2 of b, I'm going to put it into the end of another array, C. Next, I'll subtract one from p1 and the pointer of C. If p2 of b is bigger than p1 of a, I'm going to put it into the left on the end of C. Then I'll call the method recursively, terminating the recursion when the pointer to C arrives at the beginning of C.\n- Can you explain the process of selection sort?\n\t- First, I'm going to divide it into two chunks. Next, I'll find the biggest thing in the first i elements of my array. And the next, I will swap it into place and then sort everything to the left.\n\t- What is the time complexity of the selection sort?\n\t\t- let's call that t for time. T of one is theta of one. And T of n is t of n minus one plus theta n.\n\n## 단어\n\n- intuition: 직관\n- amortize: 알고리즘이 딱 한 번만 아주 나쁜 시간 복잡도를 가지지만 보통은 다른 시간 복잡도를 가질 때 쓰인다. \n- destructive: 원본 배열이 변경되는 정렬\n- incur: (좋지 않은 결과를) 초래하다.\n- at the end of the day: 결국 가장 중요한 것은\n- in a funny fashion\n- defer: 미루다\n- recitation: 구답\n- tautology: 동어 반복\n- put together: 합치다.\n\ndelete 는 insert 와 같이 취급함.\nis equal to\nreplace to\n"},{"excerpt":"Interface (API / ADT) vs Data Structure Interface specification what you want to do what data can store what operations do / are supported / what they mean data structure presentation how you do it h…","fields":{"slug":"/mit-ocw-data-structure/"},"frontmatter":{"date":"2023년 11월 13일 06:11","title":"MIT 2. Data Structures and Dynamic Arrays","tags":["algorithms","mit"]},"rawMarkdownBody":"\n## Interface (API / ADT) vs Data Structure\n\n- Interface\n\t- specification\n\t- what you want to do\n\t- what data can store\n\t- what operations do / are supported / what they mean\n- data structure\n\t- presentation\n\t- how you do it\n\t- how to store data\n\t- algorithms to support operations\n\nThe idea is we want to store n things!\nThe things will be fairly arbitrary.\n\n## 2 main interfaces\n\n- set\n- sequences\n\n## 2 main DS approaches\n\n- arrays\n- pointer based\n\n## Solution (natural)\n\n### static sequence interface: maintain a sequence of items\n\n- build(x)\n- len()\n- iter_seq()\n- get_at(i)\n- set_at(i)\n- get_first/last()\n- set_first/last(x)\n\n### word RAM\n\nword RAM model of computation is that your memory is an array of w-bit words.\n\nwe have a big memory which goes off to infinity, maybe.\nit's divided into words.\nEach word here is w bits long.\nYou can access this array randomly.\n\nYou can access any of them equally quickly.\n \n- memory = array of w-bit words\n- array = a consecutive chunk of memory. \n- consecutive -> If i want to access the array at position, at index i, then this is the same thing as accessing my memory array at position\n- array[i] = memory[address(array) + i]\n- array access is constant time.\n\n---\nAssume $w >=  log n$, w is the machine promise size.\nwe don't usually think of the machine as getting bigger over time, but you should think of the machine as getting bigger over time.\n\nBecause if I have n things that I\"m dealing with -- n, here, is the problem size -- at the very least, I need to be able to address them.\n\nOtherwise, because the machine is designed to only work with w-bit words in constant time, they'll want to be able to access the ith word in constant time, I need a word size that's at least $logn$ just to address that and n things in my input. \n\neventually, when our n's get really really big, we're going to have to increase w just so we can address that RAM. This is intuition here.\n\nBut this is a way to bridge reallity which are fixed machines, with theory in algorithms, we care about scalability for very large n.\n\nWe want to know what that growth function is and ignore the lead constant factor, that's what asymptotic notation is all about.\n\nWe need a notion of word size also changing in this asymptotic way.\n\n### static array\n\n- $O(1)$ per get_at, set_at / len\n- $O(N)$ per build / iter_seq\n\n### how do you create an array in the beginning?\n\nmemory allocation model: you can allocate an array of size n in $\\theta(n)$ time\n\nif you're just allocating arrays, the amount of space you use is, at most, the amount of time you use. $space = O(time)$\n\n## Dynamic Sequences\n\n### interface\n\nstatic sequence, plus:\n\n- insert_at(i, x): make x the new xi, shifting xi -> xi+1 -> xi+2 ... -> xn-1\n- delete_at(i): shift xi <- xi+1 <- ... <- xn-1\n\nAnd let's say I insert at position 2\nSo I come in with my new x, and I would like x to be the new x2, but I don't want to lose any information.\n\n- insert/delete_first/last(x)/()\n\n---\nthe algorithm for supporting get-first or set-first or in particular, insert-first or insert_last might be more efficient. maybe we can solve this problem better than we can solve insert_at.\n\n## Linked List\n\n- What is a linked List? We store our items in a bunch of nodes.\n- Each node has an item in it and a next field, So you can think of these as class objects with two class variables, the item and the next pointer.\n- In the item fields, we're going to store the actual values that we want to represent in our sequence, x0 through xn-1, in order.\n- And then we're going to use the next pointers to link these all together in that order. \n- The data structure is going to be represented by a head (If you want to, it can store its lengths)\n- That pointers can be stored in a single word, which means we can de-reference them in constant time in word-RAM model.\n- They're in some arbitrary order.\n- what is the address of this little array?\n\t- that say where, in memory, is this thing over here?\n- it's easy to manipulate the order of a linked list, whereas arrays are problematic.\n\n### Dynamic Seq. ops\n\n- static array\n\t- insert and delete anywhere costs $\\theta(N)$ time\n\t\t1. if we're near the front, then we have to do shifting.\n\t\t2. allocation (even if allocating the new array didn't take linear time, you have to copy all the elements over from the old array to new one)\n\t- what about insert or delete the last element of array?\n\t\t- I don't have to do shifting. \n\t- Can I do insert and delete last in constant time in a static array?\n\t\t- our model is that remember allocation model is that we can allocate a static array of size n, it's just a size n I can't just say please make it bigger by 1 I need space to store this extra space. \n\t- If I try to grow this array by 1, there might already be something there. And that's not possible without first shifting. So even though, in the array, I don't have to do any shifting, in memory, I might have to do shifting. You can also de-allocate memory, just to keep space usage small. But the only way to get more space is to ask for a new array.\n=> So static arrays are really bad for dynamic operations.\n- linked list\n\t- Insert and delete_first are $O(1)$\n\t\t- I'm going to set the next pointer here to this one, and I'm going to change this head pointer to point here. \n\t- get and set_at need $O(i)$, in the worst case, $O(n)$\n\t- If I want to get the 10th item in a linked list, I have to follow these pointers 10 times. \n\t- accessing the ith item is going to take order i time.\n\n### amortization\n\noperation takes T(n) amortized time, if any k of those operations take k <= k * T(n) time.\n(averaging over operation sequence)\n\n## Questions\n\n1. Can we do insert and delete last in constant time in a static array?\n\n## Feedback\n\n- length constant time 을 말할 때 문장 구조 점검하기\n- 차근차근\n- 2 to the k\n"},{"excerpt":"자료구조  ->  : 데이터 삽입 : 맨 앞 값 반환 : 맨 앞 값 반환 후 삭제  ->  시간 복잡도 정렬  기본형 데이터 타입에서는 듀얼 피봇 퀵소트를 사용한다. 평균 시간 복잡도는  이다. 표준 퀵소트보다 더 빠르다. 객체 배열에 대해서는 팀소트 알고리즘이 사용된다. 최악의 경우 시간 복잡도가  이다.  내부적으로  를 호출하기 때문에 정렬 알고리즘…","fields":{"slug":"/java-algorithm-tips/"},"frontmatter":{"date":"2023년 11월 09일 06:11","title":"자바 알고리즘 라이브러리","tags":["algorithms"]},"rawMarkdownBody":"## 자료구조\n\n- `Queue` -> `PriorityQueue`\n\t- `add`: 데이터 삽입\n\t- `peek`: 맨 앞 값 반환\n\t- `poll`: 맨 앞 값 반환 후 삭제\n- `Deque` -> `LinkedList`\n\n## 시간 복잡도\n\n### 정렬\n\n- `Arrays.sort()`\n\t- 기본형 데이터 타입에서는 듀얼 피봇 퀵소트를 사용한다. 평균 시간 복잡도는 $O(nlogn)$ 이다. 표준 퀵소트보다 더 빠르다.\n\t- 객체 배열에 대해서는 팀소트 알고리즘이 사용된다. 최악의 경우 시간 복잡도가 $O(nlogn)$ 이다. \n- `Collections.sort()`\n\t- 내부적으로 `Arrays.sort` 를 호출하기 때문에 정렬 알고리즘은 `Arrays.sort()` 와 동일하다.\n\n### 자료구조\n\n- `ArrayList`\n\t- 기본적으로 일정 크기의 배열을 할당하고, 필요에 따라 크기를 재조정 (재할당 및 복사)\n\t- 접근: $O(1)$\n\t- 삽입 / 삭제: $O(N)$ 최악의 경우, 리스트의 시작 또는 중간에 삽입 / 삭제 하는 경우\n\t- 탐색: $O(N)$\n- `LinkedList`\n\t- 이중 연결 리스트. 양방향 순회 가능\n\t- 접근: $O(N)$\n\t- 삽입 / 삭제 : $O(1)$ (노드에 대한 참조가 있을 때)\n\t- 탐색: $O(N)$\n- `HashMap`\n\t- 해시 테이블 사용. 해시 테이블을 사용하여 각 키를 배열 인덱스로 매핑하고, 충돌이 발생한 경우 연결 리스트나 트리를 사용하여 충돌 처리\n\t- 삽입 / 삭제 / 탐색: 평균 $O(1)$, 최악 $O(n)$ (해시 충돌이 많은 경우)\n- `TreeMap`\n\t- 레드-블랙 트리. 데이터가 항상 정렬된 상태로 유지됨.\n\t- 삽입 / 삭제 / 탐색: $O(logn)$\n- `HashSet`\n\t- HashMap 사용. HashSet 내의 각 요소는 HashMap의 키로 저장되고, 모든 값은 동일한 dummy 값이다.\n\t- 삽입 / 삭제 / 탐색: 평균 $O(1)$, 최악 $O(n)$ (해시 충돌이 많은 경우)\n- `TreeSet`\n\t- `TreeMap` 사용. `TreeSet` 내의 각 요소는 `TreeMap` 의 키로 저장되고, 값은 사용되지 않는다.\n\t- 삽입 / 삭제 / 탐색: $O(logn)$\n- `Stack`\n\t- `Vector` 클래스를 확장하여 구현된다. `Vector` 는 동적 배열과 유사하다.\n\t- 삽입 / 삭제: $O(1)$\n\t- 탐색 (Top) : $O(1)$\n- `Queue`\n\t- `LinkedList`, `PriorityQueue` 를 사용하여 구현될 수 있다.\n\t- 삽입: $O(1)$\n\t- 삭제: $O(1)$ (Linked List 기반일 경우)\n\t- 탐색: $O(1)$\n- `Priority Queue`\n\t- 이진 힙을 사용하여 구현된다.\n\t- 삽입: $O(logn)$\n\t- 삭제: $O(logn)$ (최소, 최대 요소 삭제)\n\t- 탐색: $O(1)$ (최소, 최대 요소 탐색)\n\n\n## 유용한 메서드\n\n- array to List\n\t- `Arrays.asList(배열)`\n- List to array\n\t- `리스트.toArray(할당할 배열)`\n\n## 이진 탐색\n\n- `Arrays.binarySearch(배열, 찾으려는 요소, comparator)`\n\t- 찾는 값이 존재하면 인덱스를 반환한다.\n\t- 찾는 값이 존재하지 않는다면 어디에 위치해야 하는지를 알려주는 값을 음수로 반환한다. => - (원래 위치했어야 하는 인덱스 값) - 1"},{"excerpt":"문제 So I'll copy the question right over. Given a non-empty array of integers, return the k most frequent elements. Example 1:\nInput: nums = [1, 1, 1, 2, 2, 3], k = 2\nOutput: [1, 2] Example 2:\nInput: …","fields":{"slug":"/dh-interview-study-11-09/"},"frontmatter":{"date":"2023년 11월 09일 02:11","title":"11/9 DH 면접 스터디","tags":null},"rawMarkdownBody":"\n## 문제\n\nSo I'll copy the question right over.\n\nGiven a non-empty array of integers, return the k most frequent elements.\n\nExample 1:\nInput: nums = [1, 1, 1, 2, 2, 3], k = 2\nOutput: [1, 2]\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nNote: Assume k is always valid. The input array will always have k unique most frequent elements. \n\nFor example, if nums = [1, 1, 2, 2, 3, 3], k *cannot* be 2\nbecause there are no 2 unique most frequent elements. Inthis example, the only valid k is 3.\n\n## mock interview\n\n- https://interviewing.io/mocks/amazon-top-k-frequent-elements"},{"excerpt":"TODO LOG 배운 것  는 스트림을 소비하지 않고 단순히 파이프라인에 연산을 추가하기 때문에 그 자체로  이다.  같은 자료구조 라면 아무 작업도 수행하지 않는다. ->  stream 이 병렬이 아니라면  에 위임한다. ->  stream 이 병렬이면  에 위임한다. ->  Quick Sort 는 불안정정렬이지만, primitive 타입의 경우 안정 …","fields":{"slug":"/2023-11-09/"},"frontmatter":{"date":"2023년 11월 09일 01:11","title":"2023년 11월 09일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n\n## LOG\n\n## 배운 것\n\n- `stream().sorted()` 는 스트림을 소비하지 않고 단순히 파이프라인에 연산을 추가하기 때문에 그 자체로 $O(1)$ 이다.\n\t- `SortedSet` 같은 자료구조 라면 아무 작업도 수행하지 않는다. -> $O(1)$\n\t- stream 이 병렬이 아니라면 `Arrays.sort()` 에 위임한다. -> $O(NlogN)$\n\t- stream 이 병렬이면 `Arrays.parallelSort()` 에 위임한다. -> $O(NlogN)$\n- Quick Sort 는 불안정정렬이지만, primitive 타입의 경우 안정 / 불안정이 상관이 없다. -> `Arrays.sort(primivite type array)` 인 경우에는 Dual Pivot QuickSort 가 사용된다.\n- `Collections.sort()` 는 Timsort 를 사용하기 때문에 안정 정렬이다. 즉, 안정 정렬이 필요한 객체 배열 같은 경우 사용하면 좋다.\n- Quick sort 는 메모리를 덜 사용하지만, Timsort 처럼 배열에서 이미 정렬된 데이터의 실행을 활용할 수 없다.\n- primitive array 는 특정 상황에서만 Quicksort 를 사용한다. 더 큰 배열의 경우, Timsort 처럼 미리 정렬된 데이터의 실행을 먼저 식별하고, 실행 횟수가 특정 임계값을 초과하지 않으면 MergeSort 를 시도한다. 배열의 크기가 작은 경우, 삽입 정렬로 돌아가는 구현을 사용한다.\n\n## 느낀 것"},{"excerpt":"TODO 당근 포트폴리오 [startTime::20:00] [endTime::21:00]   [scheduled:: 2023-11-07T20:00]  [duration:: 1h]  [completion:: 2024-06-16T19:15] mock 인터뷰 [startTime:: 16:00]  [endTime:: 17:00] 이력서 수정 [startTime:…","fields":{"slug":"/2023-11-08/"},"frontmatter":{"date":"2023년 11월 08일 01:11","title":"2023년 11월 08일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n- [x] 당근 포트폴리오 [startTime::20:00] [endTime::21:00]   [scheduled:: 2023-11-07T20:00]  [duration:: 1h]  [completion:: 2024-06-16T19:15]\n- [x] mock 인터뷰 [startTime:: 16:00]  [endTime:: 17:00]\n- [x] 이력서 수정 [startTime:: 13:00]  [endTime:: 15:00]\n- [x] 인터뷰 질문 준비 [startTime:: 11:00]  [endTime:: 12:00]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"질문 If it seems easy, just think of it as a warm-up. So given an array of integers, find the most frequent integer. So in other words write a method that takes an array of integers and returns an inte…","fields":{"slug":"/dh-interview-study-11-08/"},"frontmatter":{"date":"2023년 11월 08일 01:11","title":"11/8 DH 인터뷰 스터디","tags":null},"rawMarkdownBody":"\n## 질문\n\n1. If it seems easy, just think of it as a warm-up. So given an array of integers, find the most frequent integer.\n\t- So in other words write a method that takes an array of integers and returns an integer. How you handle the empty array is up to you. You can throw an exception, that 's not too important to me. So for example so if you were given 1 2 3 3, you would want to return 3. If there is no most frequent integer, if they all occur the same number of times, you can return any one.\n\t- And the array doesn 't have to be sorted.\n\t- yeah so let 's start with that. Um let 's see, so try to think out loud as much as possible and we 'll go from there.\n2. I have another part of the question, so let 's go on to that before we think about optimizing it. \n\t- given an array of integers and an integer n, print out all the pairs of integers whose sum is n.\n\t- your method can return void, it doesn 't have to return a list of pairs or anything, just print them out.\n\t- So for example if you 're given... the output should be 1 9 if you 're given something like 1 9 1 9 and 10 it should print 1 9 new line 1 9\n\t- 1 9 1 9 10 => 1 9 1 9\n\t- I 'm not picky about as long as it 's clear and if you 're given something like 1 9 1 and 10, you would only want to print out 1 9 once, you wouldn 't want to like you know use the 9 more than once, if that makes sense?\n\t- when you have duplicate numbers, you 're allowed to use it and then it 's sort of off limits to be used again. So I hope you can see the difference between the 2nd and 3rd examples.\n\n### 조건\n\n### 추가 질문\n\n- What is the time complexity and space complexity of Arrays.sort?\n- How do we find the max value? \n\n## 말\n\n- 일단 시도해보고, 더 효율적인 해결책을 생각해보죠 \n\t- let 's just try that first, and then we can figure out how to write a more efficient solution because it 's good to start from something that works and optimize it.\n- 시간 복잡도 / 공간 복잡도 \n\t- So what 's the time and space complexity of your code?\n- 모든 정수는 양수이고, n 은 양수이다.\n\t- all of the integers are non-negative and you can also assume that n is positive.\n- 테스트하고 싶은 다른 엣지 케이스가 있나요?\n\t- can you think of any other edge cases that we might want to test?\n"},{"excerpt":"공간 복잡도 프로그램을 실행 및 완료하는 데 필요한 저장공간의 양을 의미한다. 특정한 크기의 입력에 대해 알고리즘의 메모리 사용량을 분석하는 것. 예시 n! 구하기 재귀 함수로 구현하므로 변수 n 에 따라 함수가 n 번 호출된다. 공간 복잡도는  배열에서 n 인덱스 전까지 합 구하기 사용되는 변수는 배열, n, result, i 이다. 배열은 n 보다 큰…","fields":{"slug":"/complexity/"},"frontmatter":{"date":"2023년 11월 07일 04:11","title":"시간, 공간 복잡도","tags":["algorithms"]},"rawMarkdownBody":"\n## 공간 복잡도\n\n프로그램을 실행 및 완료하는 데 필요한 저장공간의 양을 의미한다.  \n특정한 크기의 입력에 대해 알고리즘의 메모리 사용량을 분석하는 것.\n\n### 예시\n\n1. n! 구하기\n\t- 재귀 함수로 구현하므로 변수 n 에 따라 함수가 n 번 호출된다.\n\t- 공간 복잡도는 $O(n)$\n2. 배열에서 n 인덱스 전까지 합 구하기\n\t- 사용되는 변수는 배열, n, result, i 이다. 배열은 n 보다 큰 공간을 할당해야 하기 때문에 $O(n)$\n3. n! 반복문으로 구하기\n\t- 반복문을 통해서 구현할 때 변수 하나에 값을 모두 저장하기 때문에 공간 복잡도는 $O(1)$\n\n## 시간 복잡도\n\n특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간.\n\n"},{"excerpt":"버블 정렬 서로 인접한 두 원소를 검사하여 정렬한다. 인접한 2개의 레코드를 서로 비교해서 크기가 순서대로 되어 있지 않으면 서로 교환한다. 구현 장점 구현이 매우 간단하다.\n제자리 정렬이다.\n안정 정렬로, 중복된 값을 입력 순서와 동일하게 정렬한다. 단점 최악, 최선, 평균 모두  로, 굉장히 비효율적이다. 순서에 맞지 않은 요소를 인접한 요소와 교환한…","fields":{"slug":"/sort-algorithm/"},"frontmatter":{"date":"2023년 11월 07일 04:11","title":"정렬 알고리즘","tags":["algorithms"]},"rawMarkdownBody":"\n## 버블 정렬\n\n서로 인접한 두 원소를 검사하여 정렬한다. 인접한 2개의 레코드를 서로 비교해서 크기가 순서대로 되어 있지 않으면 서로 교환한다.\n\n### 구현\n\n```java\nvoid bubble_sort(int[] list, int n) {\n\tfor(int i = n - 1; i > 0; i--) {\n\t\tfor(int j = 0; j < i; j++) {\n\t\t\ttemp = list[j];\n\t\t\tlist[j] = list[i];\n\t\t\tlist[i] = temp;\n\t\t}\n\t}\n}\n```\n\n### 장점\n\n구현이 매우 간단하다.\n제자리 정렬이다.\n안정 정렬로, 중복된 값을 입력 순서와 동일하게 정렬한다.\n\n### 단점\n\n최악, 최선, 평균 모두 $O(N^2)$ 로, 굉장히 비효율적이다.  \n순서에 맞지 않은 요소를 인접한 요소와 교환한다.  \n하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.  \n특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.  \n\n### 시간 복잡도\n\n- 비교 횟수\n\t- 비교 횟수는 최상, 평균, 최악 모두 일정하다. \n\t- 시간 복잡도는 $O(n(n-1) / 2)$, 즉 $O(N^2)$\n- swap 횟수\n\t- 입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위해 3번의 이동이 필요하므로 $O(3n(n-1) / 2)$\n\t- 입력 자료가 이미 정렬되어 있는 최상의 경우 자료의 이동이 발생하지 않는다.\n\n### 공간 복잡도\n\n$O(N)$\n\n정렬하고자 하는 배열 안에서 교환하는 방식이므로 입력 배열 외에 다른 추가 메모리를 요구하지 않는 정렬 방법이다. \n\n## 삽입 정렬\n\n현재 비교하고자 하는 target 과 그 이전의 원소들과 비교하며 자리를 교환하는 정렬 방법이다.\n\n정렬의 대상이 되는 데이터 외에 추가적인 공간이 필요하지 않기 때문에 제자리 정렬이다. \n\n### 구현\n\n```java\nfor(int i = 1; i<size; i++) {\n\tint target = a[i];\n\tint prev = i - 1;\n\twhile(prev >= 0 && target < a[prev]) {\n\t\ta[j + 1] = a[j];\n\t\tj--;\n\t}\n\ta[j + 1] = target;\n}\n```\n\n### 장점\n\n1. 추가적인 메모리 소비가 적다.\n2. 거의 정렬된 경우 매우 효율적이다. 최선의 경우 $O(N)$ 의 시간복잡도를 갖는다.\n3. 안정 정렬이 가능하다.\n\n### 단점\n\n1. 역순에 가까울수록 비효율적이다. 최악의 경우 $O(N^2)$ 의 시간 복잡도를 갖는다.\n2. 데이터의 상태에 따라 성능 편차가 매우 크다.\n\n### 시간 복잡도\n\n타겟 숫자가 이전 숫자보다 크기 전까지 반복하기 때문에 이미 정렬이 되어 있는 경우 항상 타겟 숫자가 이전 숫자보다 크다. 즉, 최선의 경우 $O(N)$ 의 복잡도를 갖는다.\n\n최악의 경우는 타겟 숫자가 이전 숫자보다 항상 작기 때문에 결국 N 번째 숫자에 대해 N-1 번을 비교해야 한다. 즉, 최악의 경우 $O(N^2)$ 의 시간 복잡도를 보인다.\n\n## 계수 정렬\n\n\n\n### 구현\n\n```java\npublic void radix_sort(int[] arr, int[] counting, int[] result) { // counting 배열은 0으로 초기화되어 있다.\n\tfor(int i = 0; i<arr.length; i++) {\n\t\tcounting[arr[i]]++;\n\t}\n\tfor(int i = 1; i<counting.length; i++) {\n\t\tcounting[i] += counting[i-1];\n\t}\n\n\tfor(int i = arr.length - 1; i >= 0; i--) {\n\t\tint value = arr[i];\n\t\tcounting[value]--;\n\t\tresult[counting[value]] = value;\n\t}\n}\n```\n\n### 단점\n\n- counting 배열이라는 새로운 배열을 선언해야 하기 때문에, max 값의 범위에 따라 counting 배열의 길이가 달라진다. \n\t- 수열의 길이보다 수의 범위가 극단적으로 크면 메모리가 낭비될 수 있다.\n\n### 시간 복잡도\n\n$O(N)$\n\n## Merge Sort\n\n분할 정복 알고리즘이다. \n\n1. 분할: 배열을 반으로 나누어 두 부분으로 분할한다. 하나의 요소가 남을 때까지 계속한다.\n2. 정복: 각 부분을 재귀적으로 정렬한다. 단일 요소 배열은 정렬된 것으로 간주한다. \n3. 결합: 정렬된 부분 배열들을 하나의 배열로 합친다. 이 과정에서 두 배열의 가장 작은 요소들을 비교하면서, 작은 순서대로 새 배열에 복사하여 전체 배열이 정렬된다. \n\n### 구현\n\n```java\npublic class MergeSort {\n\n    // 배열을 정렬하는 메인 메서드\n    public static void sort(int[] array) {\n        if (array.length < 2) {\n            return; // 배열의 크기가 1이하면 정렬할 필요가 없음\n        }\n\n        // 배열을 두 부분으로 나눔\n        int mid = array.length / 2;\n        int[] leftHalf = new int[mid];\n        int[] rightHalf = new int[array.length - mid];\n\n        // 데이터를 두 부분으로 복사\n        System.arraycopy(array, 0, leftHalf, 0, mid);\n        System.arraycopy(array, mid, rightHalf, 0, array.length - mid);\n\n        // 각 부분을 재귀적으로 정렬\n        sort(leftHalf);\n        sort(rightHalf);\n\n        // 정렬된 부분을 합침\n        merge(array, leftHalf, rightHalf);\n    }\n\n    // 두 부분 배열을 합치는 메서드\n    public static void merge(int[] array, int[] leftHalf, int[] rightHalf) {\n        int i = 0, j = 0, k = 0;\n\n        // 왼쪽과 오른쪽 배열을 비교하며 정렬하여 병합\n        while (i < leftHalf.length && j < rightHalf.length) {\n            if (leftHalf[i] <= rightHalf[j]) {\n                array[k++] = leftHalf[i++];\n            } else {\n                array[k++] = rightHalf[j++];\n            }\n        }\n\n        // 남은 요소들을 복사\n        while (i < leftHalf.length) {\n            array[k++] = leftHalf[i++];\n        }\n\n        while (j < rightHalf.length) {\n            array[k++] = rightHalf[j++];\n        }\n    }\n}\n\n```\n\n### 장점\n\n- 안정 정렬이 가능하다. \n- 최악, 평균, 최선의 경우 모두 $O(nlogn)$ 의 시간 복잡도를 갖는다. 대규모 데이터 정렬에 효율적인 알고리즘이다.\n\n### 단점\n\n- 추가적인 배열이 필요하므로, 제자리 정렬 알고리즘보다 더 많은 메모리를 요구한다. \n- 작은 배열에 대해서는 다른 정렬 알고리즘이 더 빠를 수 있다."},{"excerpt":"2023년 11월 당근마켓 인턴 카카오 인턴십 3월 메이커스 창업 동아리 모집 6월 창업 동아리 창업 기업 모집","fields":{"slug":"/2024-school-activity-plan/"},"frontmatter":{"date":"2023년 11월 07일 02:11","title":"2024년 학교 활동 계획","tags":null},"rawMarkdownBody":"\n## 2023년 11월\n\n- [당근마켓 인턴]()\n- [카카오 인턴십]()\n  \n## 3월\n\n- [메이커스 창업 동아리 모집](https://www.cau.ac.kr/cms/FR_CON/BoardView.do?MENU_ID=100&CONTENTS_NO=1&SITE_NO=2&P_TAB_NO=&TAB_NO=&BOARD_SEQ=4&BOARD_CATEGORY_NO=&BBS_SEQ=25879&pageNo=2)\n\n## 6월\n\n- [창업 동아리](https://www.cau.ac.kr/cms/FR_CON/BoardView.do?MENU_ID=100&CONTENTS_NO=1&SITE_NO=2&P_TAB_NO=&TAB_NO=&BOARD_SEQ=4&BOARD_CATEGORY_NO=&BBS_SEQ=26382&pageNo=1)\n- [창업 기업 모집](https://www.cau.ac.kr/cms/FR_CON/BoardView.do?MENU_ID=100&CONTENTS_NO=1&SITE_NO=2&P_TAB_NO=&TAB_NO=&BOARD_SEQ=4&BOARD_CATEGORY_NO=&BBS_SEQ=26461&pageNo=1)\n"},{"excerpt":"","fields":{"slug":"/network-flow/"},"frontmatter":{"date":"2023년 11월 07일 01:11","title":"네트워크 플로우","tags":["algorithms","미완"]},"rawMarkdownBody":""},{"excerpt":"TODO LOG 첫 면접 스터디를 했다. 생각했던 것보다는 잘했는데, 영어 말하기는 여전히 어려운 것 같다... 알고리즘 공부 열심히 하자. dh-interview-study-11-07 배운 것 느낀 것","fields":{"slug":"/2023-11-07/"},"frontmatter":{"date":"2023년 11월 07일 01:11","title":"2023년 11월 07일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 첫 면접 스터디를 했다. 생각했던 것보다는 잘했는데, 영어 말하기는 여전히 어려운 것 같다... 알고리즘 공부 열심히 하자.\n\t- [[dh-interview-study-11-07]]\n\n## 배운 것\n\n\n## 느낀 것\n\n"},{"excerpt":"Problems Given two strings s1 and s2, write a function that returns if the two strings are equal in a case-insensitive way. Expand the first function such that it returns True if the edit distance be…","fields":{"slug":"/dh-interview-study-11-07/"},"frontmatter":{"date":"2023년 11월 06일 13:11","title":"11/7 인터뷰 질문 준비","tags":null},"rawMarkdownBody":"\n## Problems\n\n1. Given two strings s1 and s2, write a function that returns if the two strings are equal in a case-insensitive way.\n2. Expand the first function such that it returns True if the edit distance between s1 and s2 is 1 or lower. \n\t- So are you familiar with edit distance?\n\t- edit distance is a way of quantifying how dissimilar two strings are to one another, that is measured by counting the minimum number of opertaion required to transform one string into the other. You can insert, delete, or modify a single character in a string. For example, the abc and the abcd have an edit distance of 1 because the character d was inserted.\n3. Expand the function to take a third parameter designating the comparison tolerance between s1 and s2 to be 'n' edit distances or lower. \n\n유니코드의 경우에도 동일하게 동작할까요?\n-> Would it behave the same when comparing Unicode?\nI'm just curious how familiar you are with if this was 'ábc' and this was 'ÁBC'. So let's even see if that works.\n\nábc ÁBC\n\n시간 복잡도, 공간 복잡도가 어느 정도인가?\n-> So what is the time and space complexity of this algorithm as you have implemented it?\n\n파이썬의 upper 함수의 시간 복잡도는 어느 정도인가요?\n-> What is the time complexity of the Python upper function?\n\nwhat is the best and worst case runtime and space complexity of this one?\n\n파이썬의 문자열은 불변이기 때문에 upper 를 호출하면 새 문자열을 반환해야 한다. 아까 말한 게 best case, worstcase, always-case 인가요?\n-> Was that best-case, worst-case, or always-case?\n\n가장 좋은 경우에 O(N) 시간이 걸리지 않도록 최적화할 수 있을까요?\n-> Can we optimize it so that it takes O(N) time in the best case?\n\n다음 질문으로 넘어가겠습니다.\n-> For now, let's move on to the next question.\n\n케이스를 여러 개 만들어서 테스트 해주세요.\n-> Please create multiple cases and test them.\n\n## 피드백\n\n- "},{"excerpt":"스터디 dh-interview-study-11-07 dh-interview-study-11-08 표현 I didn't hear you correctly, would you mind repeating that? The time complexity is O of N . I'm not sure if this will work well. So best-case …","fields":{"slug":"/dh-interview-study/"},"frontmatter":{"date":"2023년 11월 06일 13:11","title":"DH 인터뷰 스터디","tags":["study"]},"rawMarkdownBody":"\n## 스터디\n\n- [[dh-interview-study-11-07]]\n- [[dh-interview-study-11-08]]\n\n## 표현\n\n- I didn't hear you correctly, would you mind repeating that?\n- The time complexity is O of N .\n- I'm not sure if this will work well.\n- So best-case is that the first character is different, that would be O(1), worst-case is still O(n)."},{"excerpt":"TODO LOG 급발진으로 8강 경기를 보러갔다. 사실 부산인줄 모르고 예매했는데 부산이어서 부랴부랴 부산으로 떠났다..ㅋㅋㅋㅋ 그래도 다 매진되기 전에 표를 구할 수 있어서 다행이었다. 배운 것 느낀 것","fields":{"slug":"/2023-11-05/"},"frontmatter":{"date":"2023년 11월 05일 07:11","title":"2023년 11월 05일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- 급발진으로 8강 경기를 보러갔다. 사실 부산인줄 모르고 예매했는데 부산이어서 부랴부랴 부산으로 떠났다..ㅋㅋㅋㅋ 그래도 다 매진되기 전에 표를 구할 수 있어서 다행이었다.\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"AVL Tree 란 트리의 높이가 h 일 때 이진탐색트리의 시간복잡도는  이기 때문에 균형된 트리를 만들어 h 를 줄이고자 하는 발상에서 시작했다. 특성 AVL 트리는 이진 탐색 트리의 속성을 갖는다. 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다. 어떤 시점에서 높이 차이가 1보다 커지면 회전을 통해 균형을 잡아 높이 차이를 줄인다. AVL 트리는…","fields":{"slug":"/avl-tree/"},"frontmatter":{"date":"2023년 11월 05일 07:11","title":"AVL Tree","tags":["algorithms"]},"rawMarkdownBody":"\n## AVL Tree 란\n\n트리의 높이가 h 일 때 이진탐색트리의 시간복잡도는 $O(h)$ 이기 때문에 균형된 트리를 만들어 h 를 줄이고자 하는 발상에서 시작했다. \n\n### 특성\n\n- AVL 트리는 이진 탐색 트리의 속성을 갖는다.\n- 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이다.\n- 어떤 시점에서 높이 차이가 1보다 커지면 회전을 통해 균형을 잡아 높이 차이를 줄인다.\n- AVL 트리는 높이를 $logN$ 으로 유지하기 때문에 삽입, 검색, 삭제의 시간 복잡도는 $O(logN)$ 이다.\n\n## Balance Factor\n\n> The difference between the heights of the left subtree and the right subtree for any node is known as the **balance factor** of the node\n\n왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것을 의미한다.  \n두 서브트리의 높이가 같거나 리프 노드라면 BF 는 0이다. \n\n즉, BF 가 클수록 불균형 트리라고 할 수 있다.\n\n## 시간 복잡도\n\n| Operation | Average   | Worst     |\n| --------- | --------- | --------- |\n| Access    | $O(logN)$ | $O(logN)$ |\n| Search    | $O(logN)$ | $O(logN)$ |\n| Insert    | $O(logN)$ | $O(logN)$ |\n| Delete    | $O(logN)$ | $O(logN)$ |\n\nAVL 트리는 높이를 $logN$ 으로 유지하기 때문에 삽입, 검색, 삭제의 시간 복잡도는 $O(logN)$ 이다.\n\n## 회전\n\n검색, 순회 연산은 BF 를 변경하지 않지만, 삽입 삭제에서는 BF 가 변경될 수 있다.  \n삽입, 삭제 시 불균형 상태가 되면 AVL 트리는 불균형 노드를 기준으로 서브트리의 위치를 변경하는 rotation 작업을 수행하여 트리의 균형을 맞추게 된다. \n\n### LL (Left Left) case\n\n> When a node is added into the right subtree of the right subtree, if the tree gets out of balance, we do a single left rotation.\n\ny 는 z 의 왼쪽 자식 노드이고, x는 y 의 왼쪽 자식 노드인 경우 right rotation 을 수행하여 균형을 맞춘다.\n\nright-rotation 수행 과정은 다음과 같다.\n\n1. y 노드의 오른쪽 자식 노드를 z 노드로 변경한다.\n2. z 노드의 왼쪽 자식 노드를 y 노드 오른쪽 서브트리 T2 로 변경한다.\n\n![[left-left-left-rotation.png]]\n\n\n### RR (Right Right) case\n\n> If a node is added to the left subtree of the left subtree, the AVL tree may get out of balance, we do a single right rotation.\n\ny 는 z 의 오른쪽 자식 노드이고, x는 y의 오른쪽 자식 노드인 경우 left rotation 을 수행하여 균형을 맞춘다. \n\nleft rotation 수행 과정\n1. y 노드의 왼쪽 자식 노드를 z노드로 변경\n2. z 노드 오른쪽 자식 노드를 y 노드 왼쪽 서브트리로 변경\n\n![[right-right-left-rotation.png]]\n\n### LR (Left Right) case\n\n> A left-right rotation is a combination in which first left rotation takes place after that right rotation executes. \n\ny 는 z 의 왼쪽 자식 노드이고, x는 y 의 오른쪽 자식 노드인 경우 left, right 순으로 총 두 번의 rotation 을 수행하여 균형을 맞춘다.\n\n![[left-right-left-right.png]]\n\n### RL (Right Left) case\n\n> A right-left rotation is a combination in which first right rotation takes place after that left rotation executes.\n\ny 는 z의 오른쪽 자식 노드이고, x는 y의 왼쪽 자식 노드인 경우, right, left 순으로 총 두 번의 rotation 을 수행하여 균형을 맞춘다. \n\n![[right-left-right-left.png]]\n\n## 적용\n\n1. 데이터베이스의 방대한 레코드를 인덱싱하고 효율적으로 검색할 떄\n2. 집합과 dictionary 를 포함한 모든 유형의 인메모리 컬렉션\n3. 삽입 삭제는 흔하지 않지만, 빈번한 데이터 조회가 필요한 데이터베이스 애플리케이션\n4. 최적화된 검색이 필요한 소프트웨어\n\n## 장단점\n\n### 장점\n\n1. 치우치지 않는다.\n2. 높이는 $log(N)$ 을 초과하지 않는다.\n\n### 단점\n\n1. 구현하기 어렵다.\n2. 일부 연산에 높은 상수 계수 (constant factor) 가 존재한다. \n3. 균형이 엄격하기 때문에 AVL 트리는 회전이 많이 수행될수록 삽입 및 제거 작업이 복잡해진다.\n"},{"excerpt":"이진 탐색 트리란 이진 탐색과 연결 리스트를 결합한 자료구조의 일종이다. 다음과 같은 속성을 갖는다. 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다. 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다. 이 경우, 중복된 값을 가질 수 없다. (위 정의가 변경된다면 가능) 왼쪽 …","fields":{"slug":"/binary-search-tree/"},"frontmatter":{"date":"2023년 11월 05일 07:11","title":"이진 탐색 트리","tags":["algorithms"]},"rawMarkdownBody":"\n## 이진 탐색 트리란\n\n이진 탐색과 연결 리스트를 결합한 자료구조의 일종이다.  \n\n다음과 같은 속성을 갖는다.\n\n- 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.\n- 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.\n- 이 경우, 중복된 값을 가질 수 없다. (위 정의가 변경된다면 가능)\n- 왼쪽 서브트리, 오른쪽 서브트리 또한 이진탐색트리이다.\n\n이진탐색트리를 순회할 때는 중위순회 방식을 사용한다. 이렇게 하면 이진탐색트리 내에 있는 모든 값들을 정렬된 순서대로 읽을 수 있다.\n\n## 복잡도\n\n탐색, 삽입, 삭제의 계산 복잡도는 모두 O(h) 이다. 트리의 높이에 의해 수행 시간이 결정된다.\n\n그러나 균형이 맞지 않는 이진탐색트리의 경우 시간복잡도가 O(N) 이 된다. 이를 해결하기 위해 AVL Tree 가 제안되었다.\n\n"},{"excerpt":"2023-11-02 2023-11-03 2023-11-04 2023-11-05 2023-11-07 2023-11-08 2023-11-09 2023-11-13 2023-11-14 2023-11-16 2023-11-20 2023-11-25 2023-11-26","fields":{"slug":"/2023-11/"},"frontmatter":{"date":"2023년 11월 04일 08:11","title":"2023년 11월","tags":["TIL"]},"rawMarkdownBody":"\n- [[2023-11-02]]\n- [[2023-11-03]]\n- [[2023-11-04]]\n- [[2023-11-05]]\n- [[2023-11-07]]\n- [[2023-11-08]]\n- [[2023-11-09]]\n- [[2023-11-13]]\n- [[2023-11-14]]\n- [[2023-11-16]]\n- [[2023-11-20]]\n- [[2023-11-25]]\n- [[2023-11-26]]"},{"excerpt":"TODO 실행 계획 정리 [startTime:: 15:00]  [endTime:: 16:00] LOG 배운 것 느낀 것 인간의 시간은 원형으로 돌지 않고 직선으로 나아간다.\n행복은 반복의 욕구이기에 인간이 행복할 수 없는 것도 이런 이유 때문이다. 배신한다는 것은 줄 바깥으로 나가는 것이다.\n배신이란 줄 바깥으로 나가 미지의 세계로 떠나는 것이다.\n...…","fields":{"slug":"/2023-11-04/"},"frontmatter":{"date":"2023년 11월 04일 06:11","title":"2023년 11월 04일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n- [x] 실행 계획 정리 [startTime:: 15:00]  [endTime:: 16:00]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것\n\n> 인간의 시간은 원형으로 돌지 않고 직선으로 나아간다.\n> 행복은 반복의 욕구이기에 인간이 행복할 수 없는 것도 이런 이유 때문이다.\n\n> 배신한다는 것은 줄 바깥으로 나가는 것이다. \n> 배신이란 줄 바깥으로 나가 미지의 세계로 떠나는 것이다.\n> ...\n> 그녀를 짓눌렀던 것은 짐이 아니라 존재의 참을 수 없는 가벼움이었다.\n\n- 참을 수 없는 존재의 가벼움을 다 읽었다. 여러 이야기가 있었지만 왜인지 모르게 가장 인상 깊었던 단어는 '배반'인 것 같다. 무언가를 배반함으로써 존재의 참을 수 없는 가벼움을 잊을 수 있다. 잠시뿐이지만.\n\t- 익숙한 것을 배반하고, 미지로 떠나는 거다. \n"},{"excerpt":"통계 정보 테이블 및 인덱스에 대한 통계 정보를 뜻한다. MySQL 서버의 통계 정보 MySQL 5.6 버전부터 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선되었다. 즉, MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 되었다.  시스템 설정 변수의 값을 OFF 로 설정해서 통계 정보가 …","fields":{"slug":"/mysql-execution-plan/"},"frontmatter":{"date":"2023년 11월 03일 06:11","title":"10장. 실행 계획","tags":["mysql","database","real-my-sql"]},"rawMarkdownBody":"\n## 통계 정보\n\n테이블 및 인덱스에 대한 통계 정보를 뜻한다.\n\n### MySQL 서버의 통계 정보\n\nMySQL 5.6 버전부터 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선되었다. 즉, MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 되었다. \n\n`innodb_stats_auto_recalc` 시스템 설정 변수의 값을 OFF 로 설정해서 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. `innodb_stats_auto_recalc` 시스템 설정 변수의 기본값은 ON 이므로 영구적인 통계 정보를 이용하고자 한다면 해당 설정을 OFF 로 변경할 수 있다. \n\n## 히스토그램\n\n5.7 버전까지 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. 이를 메우기 위해 실행 게획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다. \n\n8.0 버전부터 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.\n\n### 히스토그램 정보 수집 및 삭제\n\n히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 수행해 수동으로 수집 및 관리된다. 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드한다. \n\n다음과 같은 두 종류의 히스토그램 타입이 지원된다. \n\n- singleton: 컬럼값 개별로 레코드 건수를 관리하는 히스토그램. Value-based 히스토그램이나 도수 분포라고도 불린다.\n- Equi-Height: 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로 Height-Balanced 히스토그램이라고도 불린다. \n\n히스토그램은 버킷 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리된다. 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며, 높이 균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다. \n\n싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도 비율, 2개 값을 갖는다.  \n반면 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 갖는다. \n\n싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 (히스토그램의 버킷 수보다 적은) 경우 사용된다. \n- [!] 히스토그램의 모든 레코드 건수 비율은 누적으로 표시된다. \n\n높이 균형 히스토그램은 컬럼값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다. 히스토그램의 버킷 범위가 뒤로 갈수록 비율이 높아지는 것으로 보이지만, 사실은 범위별로 비율이 같은 수준에서 hire_date 컬럼의 범위가 선택된 것이다. (즉, 그래프의 기울기가 일정하면 각 범위가 비슷한 값을 갖는다는 것을 알 수 있다.)\n\n생성된 히스토그램은 `DROP HISTOGRAM ON 컬럼 이름` 으로 삭제할 수 있다. 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아닌, 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다. 그러나 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다. \n\n히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 `optimizer_switch` 시스템 변수의 값을 변경하면 된다. \n\n```sql\nSET GLOBAL optimizer_switch='condition_fanout_filter=off';\n```\n\n`optimizer_switch` 시스템 변수의 값을 글로벌로 변경하면 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않는다. 또한 `condition_fanout_filter` 옵션에 의해 영향받는 다른 최적화 기능들이 사용되지 않을 수도 있으니 주의하자.\n\n특정 커넥션 또는 특정 쿼리에서만 히스토그램을 사용하지 않고자 한다면 다음과 같은 방법을 사용하면 된다. \n\n```sql\n-- // 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않도록 설정\n\nSET SESSION optimizer_switch='condition_fanout_filter=off';\n\n-- // 현재 쿼리만 히스토그램을 사용하지 않도록 설정\n\nSELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */ *\nFROM ...\n```\n\n### 히스토그램의 용도\n\n기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 컬럼이 갖는 유니크한 값의 개수 정도였다. 예를 들면 테이블의 레코드가 1000건이고 어떤 컬럼의 유니크한 값 개수가 100개였다면 MySQL 서버는 해당 컬럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측한다. \n\n그러나 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는데, 이전 MySQL 서버의 기존 통게 정보는 이런 정보를 고려하지 못했다. 이를 보완하기 위해 히스토그램이 도입되었다. 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 버킷 별로 레코드의 건수와 유니크한 값의 개수 정보를 갖기 때문에 훨씬 정확한 예측을 할 수 있다.\n\n히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것이라고 예측한다. 하지만 히스토그램 정보가 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다. \n\n인덱싱되지 않은 컬럼들에 히스토그램이 없다면 옵티마이저는 컬럼들의 데이터 분포를 전혀 알지 못하고 실행 계획을 수립하게 된다. 상황에 따라 어떤 테이블이라도 조인의 드라이빙 테이블이 될 수 있는 것이다. \n\n이런 차이로 인해 쿼리의 성능은 10배 정도 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아서 디스크에서 데이터를 읽어야 하는 경우라면 몇 배의 차이가 발생할 수도 있다. 각 컬럼에 대해 히스토그램 정보가 있다면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.\n\n### 히스토그램과 인덱스\n\n히스토그램과 인덱스는 완전히 다른 객체이므로 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 점에서 어느 정도 공통점을 가진다고 볼 수 있다. \n\nMySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree 를 샘플링해서 살펴본다. 이 작업을 인덱스 다이브 (Index Dive) 라고 표현한다.\n\n쿼리의 검색 조건으로 많이 사용되는 컬럼에 대해서는 일반적으로 인덱스를 생성한다. 그런데 이렇게 인덱스된 컬럼에 대해 히스토그램 정보를 수집해두는 것이 좋은지 고민스러울 수 있다. \n\nMySQL 8.0 서버에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우, 그 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다. 이는 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다. 즉, MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용된다. \n\n그러나 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (IN 절에 값이 많이 명시된 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.\n\n### 코스트 모델\n\nMySQL 서버가 쿼리를 처리하려면 다양한 작업이 필요하다.\n\n- 디스크로부터 데이터 페이지 읽기\n- 메모리 (InnoDB 버퍼 풀)로부터 데이터 페이지 읽기\n- 인덱스 키 비료\n- 레코드 평가\n- 메모리 임시 테이블 작업\n- 디스크 임시 테이블 작업\n\nMySQL 서버는 사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다. 이렇게 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다. \n\nMySQL 5.7 버전부터 MySQL 서버의 소스 코드에 상수화되어 있던 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있도록 개선되었다. 그러나 인덱스되지 않은 컬럼의 데이터 분포나 메모리에 상주 중인 페이지의 비율 등 비용 계산과 연관된 부분의 정보가 부족한 상태였다. MySQL 8.0 버전으로 업그레이드 되면서 비로소 컬럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다. \n\nMySQL 8.0 서버의 코스트 모델은 다음 2개 테이블에 저장돼 있는 설정 값을 사용한다. 두 테이블 모두 `mysql` DB 에 존재한다.\n\n- `server_cost`: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리\n- `engine_cost`: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리\n\n두 테이블은 공통적으로 다음의 5개 컬럼을 가지고 있다. `last_updated` 와 `comment` 컬럼의 값은 MySQL 서버 옵티마이저에 영향을 미치는 정보는 아니고, 단순 정보성으로 관리되는 컬럼이다.\n\n- `cost_name`: 코스트 모델의 각 단위 작업\n- `default_value`: 각 단위 작업의 비용(기본값이며, 이 값은 MySQL 서버 소스 코드에 설정된 값)\n- `cost_value`: DBMS 관리자가 설정한 값 (이 값이 NULL 이면 MySQL 서버는 `default_value` 컬럼의 비용을 사용한다.)\n- `last_updated`: 단위 작업의 비용이 변경된 시점\n- `comment`: 비용에 대한 추가 설명\n\n`engine_cost` 테이블은 위의 5개 컬럼에 추가로 다음 컬럼들을 더 가지고 있다. \n\n- `engine_name`: 비용이 적용된 스토리지 엔진\n- `device_type`: 디스크 타입\n\n`engine_name` 컬럼은 스토리지 엔진별로 각 단위 작업의 비용을 설정할 수 있는데, 기본값은 `default` 이다. MEMORY 스토리지 엔진, 그리고 MyISAM 과 InnoDB 스토리지 엔진에 대해 단위 작업의 비용을 달리 설정하고 싶다면 `engine_name` 컬럼을 이용하면 된다. `device_type` 은 디스크의 타입을 설정할 수 있는데, MySQL 8.0 에서는 아직 이 컬럼의 값을 활용하지 않아 \"0\" 만 설정할 수 있다. \n\nMySQL 8.0 버전의 코스트 모델에서 지원하는 단위 작업은 다음과 같다. \n\n- io_block_read_cost: 디스크 데이터 페이지 읽기\n- memory_block_read_cost: 메모리 데이터 페이지 읽기\n- disk_temptable_create_cost: 디스크 임시 테이블 생성\n- disk_temptable_row_cost: 디스크 임시 테이블의 레코드 읽기\n- key_compare_cost: 인덱스 키 비교\n- memory_temptable_create_cost: 메모리 임시 테이블 생성\n- memory_temptable_row_cost: 메모리 임시 테이블의 레코드 읽기\n- row_evaluate_cost: 레코드 비교\n\nrow_evaluate_cost 는 스토리지 엔진이 반환한 레코드가 쿼리의 조건에 일치하는지를 평가하는 단위 작업을 의미한다. row_evaluate_cost 값이 증가할수록 풀 테이블 스캔과 같이 많은 레코드를 처리하는 쿼리의 비용이 높아지고 반대로 레인지 스캔과 같이 상대적으로 적은 수의 레코드를 처리하는 쿼리의 비용이 낮아진다. \n\n코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고, 어떤 실행 계획들이 저비용으로 바뀌는지를 파악하는 것이다.\n\n- key_compare_cost 비용을 높이면 MySQL 서버 옵티마이저가 가능하면 정렬을 수행하지 않는 방향의 실행 계획을 선택할 가능성이 높아진다. \n- row_evaluate_cost 비용을 높이면 풀 스캔을 실행하는 쿼리들의 비용이 높아지고, MySQL 서버 옵티마이저는 가능하면 인덱스 레인지 스캔을 사용하는 실행 계획을 선택할 가능성이 높아진다. \n- disk_temptable_create_cost 와 disk_temptable_row_cost 비용을 높이면 MySQL 옵티마이저는 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.\n- memory_temptable_create_cost 와 memory_temptable_row_cost 비용을 높이면 MySQL 서버 옵티마이저는 메모리 임시 테이블을 만들지 않는 방향의 실행 계획을 선택할 가능성이 높아진다.\n- io_block_read_cost 비용이 높아지면 MySQL 서버 옵티마이저는 가능하면 InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획을 선택할 가능성이 높아진다. \n- memory_block_read_cost 비용이 높아지면 MySQL 서버는 InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적다고 하더라도 그 인덱스를 사용할 가능성이 높아진다.\n\n## 실행 계획 확인\n\n`DESC` 또는 `EXPLAIN` 명령으로 확인할 수 있다.\n\n`FORMAT` 옵션을 사용해서 실행 계획의 표시 방법을 JSON 이나 TREE, 단순 테이블 형태로 선택할 수 있다. \n\n```sql\nEXPLAIN FORMAT=TREE -- 혹은 JSON\n...\n```\n\n### 쿼리의 실행 시간 확인\n\n쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다. 결과는 항상 TREE 포맷으로 보여준다. \n\n명령의 결과에는 실제 소요된 시간, 처리한 레코드 건수, 반복 횟수가 표시된다.\n\n- actual time: 첫 번째 숫자 값은 첫 번째 레코드를 가져오는 데 걸린 평균 시간 (밀리초), 두 번째 숫자 값은 마지막 레코드를 가져오는 데 걸린 평균 시간 (밀리초)\n- rows: 테이블에서 읽은 조건에 일치하는 테이블의 평균 레코드 건수\n- loops: 테이블에서 읽은 컬럼을 이용해서 테이블의 레코드를 찾는 작업이 반복된 횟수\n\n`EXPLAIN ANALYZE` 는 실행 계획만 추출하는 것이 아닌 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여준다. \n\n## 실행 계획 분석\n\n표의 각 라인은 쿼리 문장에서 사용된 테이블의 개수만큼 출력된다. 실행 순서는 위에서 아래로 순서대로 표시된다. 출력된 실행 계획에서 위쪽에 출력된 결과일수록 쿼리의 바깥부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당한다.\n\n### id 컬럼\n\n단위 SELECT 쿼리별로 부여되는 식별자 값이다. 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다. \n\n실행 계획의 id 컬럼은 테이블의 접근 순서를 의미하지는 않는다.\n\n### select_type 컬럼\n\n각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다. \n\n- SIMPLE\n\t- UNION 이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 해당 쿼리 문장의 select_type 은 SIMPLE 로 표시된다. (쿼리에 조인이 포함된 경우도 마찬가지) 쿼리 문장이 아무리 복잡하더라도 실행 계획에서 select_type 이 SIMPLE인 단위 쿼리는 하나만 존재한다.일반적으로 제일 바깥 SELECT 쿼리의 select_type 이 SIMPLE 로 표시된다.\n- PRIMARY\n\t- UNION 이나 서브 쿼리를 가지는 SELEcCT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리는 select_type 이 PRIMARY 로 표시된다. SIMPLE 과 마찬가지로 select_type 이 PRIMARY 인 단위 쿼리는 하나만 존재하며, 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY 로 표시된다.\n- UNION\n\t- UNION 으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type 은 UNION 으로 표시된다. \n\t- UNION의 첫 번째 단위 SELECT 는 select_type 이 UNION 이 아니라 UNION 되는 쿼리 결과들을 모아서 저장하는 임시 테이블 (DERIVED) 이 select_type 으로 표시된다.\n- DEPENDENT UNION\n\t- UNION 과 같이 UNION 이나 UNION ALL 로 집합을 결합하는 쿼리에서 표시된다.\n\t- DEPENDENT 는 UNION 이나 UNION ALL 로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다. 즉, 내부 쿼리가 외부의 값을 참조해서 처리 될 때 DEPENDENT 키워드가 표시된다.\n- UNION RESULT\n\t- UNION RESULT 는 UNION 결과를 담아두는 테이블을 의미한다. 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않는다. (id 가 null 임)\n\t- UNION RESULT 의 table 컬럼의 <union 숫자1, 숫자2> 는 id 가 각각 숫자1, 숫자2인 단위 쿼리의 조회 결과를 UNION 했음을 의미한다. \n\t- UNION ALL 을 사용하면 MySQL 은 임시 테이블에 버퍼링하지 않기 때문에 UNION RESULT 라인이 필요치 않게 된다. \n- SUBQUERY\n\t- FROM 절 이외에서 사용하는 서브 쿼리만을 의미한다. \n\t- FROM 절에 사용된 서브쿼리는 select_type 이 DERIVED 로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 모두 SUBQUERY 라고 표시된다.\n---\n- [i] 서브 쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다. \n- 중첩된 쿼리: SELECT 되는 컬럼에 사용된 서브 쿼리를 Nested Query 라고 한다.\n- 서브 쿼리: WHERE 절에 사용된 경우에는 일반적으로 그냥 SubQuery 라고 한다.\n- 파생 테이블: FROM 절에 사용된 서브 쿼리를 MySQL 에서는 파생 테이블이라고 하고, 일반적으로 RDBMS 에서는 인라인 뷰 또는 서브 셀렉트 (Sub Select) 라고 한다.\n\n서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분하기도 한다.\n- 스칼라 서브쿼리: 하나의 값만 반환하는 쿼리\n- 로우 서브쿼리: 컬럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리\n---\n- DEPENDENT SUBQUERY\n\t- 서브 쿼리가 outer SELECT 쿼리에서 정의된 컬럼을 사용하는 경우, DEPENDENT SUBQUERY 가 표시된다.\n\t- DEPENDENT UNION 과 같이 DEPENDENT SUBQUERY 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행되어야 하므로 DEPENDENT 키워드가 없는 일반 서브쿼리보다는 처리 속도가 느릴 때가 많다.\n- DERIVED\n\t- 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. select_type 이 DERIVED 인 경우에 생성되는 임시 테이블을 파생 테이블이라고도 한다. MySQL 5.6 버전부터는 옵티마이저 옵션에 따라 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.\n---\n- [p] 쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 DERIVED 가 존재하는지 확인해야 한다. 서브쿼리를 조인으로 해결할 수 있는 경우라면 서브쿼리보다는 조인을 사용하는 것을 강력히 권장한다. \n---\n- DEPENDENT DERIVED\n\t- LATERAL JOIN 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 됐다. DEPENDENT DERIVED 키워드는 해당 테이블이 LATERAL JOIN 으로 사용된 것을 의미한다.\n- UNCACHEABLE SUBQUERY\n\t- 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있께 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다. (서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능이다.)\n\t- SUBQUERY 는 outer 의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.\n\t- DEPENDENT SUBQUERY 는 의존하는 Outer 쿼리의 컬럼의 값 단위로 캐시해두고 사용한다.\n\t- 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우에 사용된다.\n\t\t- 사용자 변수가 서브쿼리에 사용된 경우\n\t\t- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우\n\t\t- UUID() 나 RAND() 같이 결괏값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우\n- UNCACHEABLE UNION\n\t- UNION, UNCACHEABLE 의 속성이 혼합된 select_type 을 의미한다.\n- MATERIALIZED\n\t- MySQL 5.6 버전부터 도입된 select_type 으로, FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.\n\t- MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화한 후, 임시 테이블과 다른 테이블을 조인하는 형태로 최적화되어 처리된다.\n\n### table 컬럼\n\nMySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시된다. 테이블 이름에 별칭이 부여된 경우에는 별칭이 표시된다.\n\n'<>' 로 둘러싸인 이름이 명시되는 경우는 임시 테이블을 의미한다.\n\n### partitions 컬럼\n\n파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝이라고 한다.\n\n파티션을 참조하는 쿼리의 경우 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 partitions 컬럼에 표시해준다. \n\n### type 컬럼\n\n일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 type 컬럼은 반드시 체크해야 하는 중요한 정보다.\n\ntype 컬럼의 값은 각 테이블의 접근 방법으로 해석하면 된다.\n\nALL 은 인덱스를 사용하지 않고 테이블을 처음부터 끝까지 읽어서 레코드를 읽는 풀 테이블 스캔 접근 방법을 의미한다. 실행 계획의 각 라인에 접근 방법이 2개 이상 표시되지 않으며, index_merge 이외의 type 에서는 인덱스 항목에도 단 하나의 인덱스 이름만 표시된다.\n\n각 접근 방법을 성능이 빠른 순서대로 나열하면 다음과 같다.\n\n- system\n- const\n- eq_ref\n- ref\n- fulltext\n- ref_or_null\n- unique_subquery\n- index_subquery\n- range\n- index_merge\n- index\n- ALL\n\n#### system\n\n레코드가 1건만 존재하는 테이블이나 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다.\n\nInnoDB 스토리지 엔진을 사용하는 테이블에서는 나타나지 않고, MyISAM 이나 MEMORY 테이블에서만 사용되는 접근 방식이다. 실제 애플리케이션에서 사용되는 쿼리에서는 거의 보이지 않는 실행 계획이다.\n\n#### const\n\n테이블의 레코드 건수와 관계없이 쿼리가 PK 나 유니크 키 컬럼을 사용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식이다. 유니크 인덱스 스캔이라고도 표현한다.\n\n다중 컬럼으로 구성된 PK 나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용할 때는 const 타입의 접근 방식을 사용할 수 없다. 이 경우에는 실제 레코드가 1건만 저장되어 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문이다. \n\nPK 의 일부만 조건으로 사용할 때는 ref 로 표시된다.  \n하지만 PK 나 유니크 인덱스의 모든 컬럼을 동등 조건으로 WHERE 절에 명시하면 const 접근 방식을 사용한다.\n\n- [5] 실행 계획의 type 컬럼이 const인 실행 계획은 MySQL 의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화한다. \n\n#### eq_ref\n\n여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 조인에서 처음 읽은 테이블의 컬럼값을 그다음 읽어야 할 테이블의 PK 나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리킨다. \n\n두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때, 그 유니크 인덱스는 NOT NULL 이어야 하고, 다중 컬럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용되어야만 eq_ref 접근 방법이 사용될 수 있다.\n\n즉, 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다. \n\n#### ref\n\neq_ref 와는 달리 조인의 순서와 관계 없이 사용되며, PK 나 유니크 키 등의 제약 조건도 없다. 인덱스 종류와 관계 없이 **동등 조건으로 검색할 때**는 ref 접근 방식이 사용된다. 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const 나 eq_ref 보다는 느리다. 그러나 동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법 중 하나다. \n\nconst, ref, eq_ref 는 모두 매우 좋은 접근 방식으로 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 접근 방식이다. \n\n#### fulltext\n\nMySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방식을 의미한다. \n\n전문 검색 조건은 우선순위가 상당히 높다. 쿼리에서 전문 인덱스를 사용하는 조건과 그 이외의 일반 인덱스를 사용하는 조건을 함께 사용하면 일반 인덱스의 접근 방식이 const 나 eq_ref, ref 가 아니면 일반적으로 MySQL 은 전문 인덱스를 사용하는 조건을 선택해서 처리한다. \n\n#### ref_or_null\n\nref 접근 방법과 같은데, null 비교가 추가된 형태다. 실제 업무에서 많이 활용되지는 않는다.\n\n#### unique_subquery\n\nWHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다. 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 사용한다.\n\n#### index_subquery\n\n서브쿼리 결과의 중복된 값을 인덱스를 이용해서 제거할 수 있을 때 사용한다.\n\n- unique_subquery: IN (subquery) 형태의 조건에서 subquery 의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음.\n- index_subquery: IN(subquery) 형태의 조건에서 subquery 의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음.\n\n#### range\n\n인덱스 레인지 스캔 형태의 접근 방법이다. 주로 \"<, >, IS NULL, BETWEEN, IN, LIKE\" 등의 연산자를 이용해 인덱스를 검색할 때 사용된다. 일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방법이다. \n\nrange 접근 방식도 상당히 빠르다. \n\n#### index_merge\n\n2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다. \n\n다음과 같은 특징이 있다.\n\n- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어진다.\n- 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge 가 적용되지 않는다.\n- index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 중복 제거와 같은 부가적인 작업이 더 필요하다.\n\n#### index\n\n인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다. range 접근 방식 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하지는 않는다.\n\n테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다. 그러나 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 훨씬 효율적이다.\n\n다음 조건 가운데 첫 번째 + 두 번째 조건을 충족하거나, 첫 번째 + 세 번째 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.\n\n- range 나 const, ref 같은 접근 방식으로 인덱스를 사용하지 못하는 경우\n- 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우 (데이터 파일을 읽지 않아도 되는 경우)\n- 인덱스를 이용해 정렬이나 grouping 작업이 가능한 경우 (별도의 정렬 작업을 피할 수 있는 경우)\n\n#### ALL\n\n테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환한다. 가장 비효율적인 방법이다.\n\nInnoDB 도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O 를 유발하는 작업을 위해 한 번에 많은 페이지를 읽어들이는 기능을 제공한다. 이를 Read Ahead 라고 하며, 한 번에 여러 페이지를 읽어서 처리할 수 있다.\n\n일반적으로 Index 나 ALL 접근 방식은 작업 범위를 제한하는 조건이 아니므로, 빠른 응답을 사용자에게 보내야 하는 웹 서비스와 같은 온라인 트랜잭션 처리 환경에는 적합하지 않다. "},{"excerpt":"주의 entitymanager 의 flush mode 는  으로 설정되지만, 실제로 insert, update, delete 가 발생하는 경우 예외를 던진다.","fields":{"slug":"/entity-manager-readonly/"},"frontmatter":{"date":"2023년 11월 03일 04:11","title":"EntityManager 의 readonly","tags":null},"rawMarkdownBody":"\n## 주의\n\nentitymanager 의 flush mode 는 `COMMIT` 으로 설정되지만, 실제로 insert, update, delete 가 발생하는 경우 예외를 던진다."},{"excerpt":"TODO LOG DH 이력서를 제출했다. 과연 결과는 어떻게 될까...?!?!?!?!?? 배운 것 느낀 것","fields":{"slug":"/2023-11-03/"},"frontmatter":{"date":"2023년 11월 03일 03:11","title":"2023년 11월 03일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n## LOG\n\n- DH 이력서를 제출했다. 과연 결과는 어떻게 될까...?!?!?!?!??\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO LOG DH 에 제출할 Resume 를 작성했다. Resume 진짜 너무 어렵다. 그래도 열심히 해 보자. 배운 것 느낀 것 인적 자산이 가장 중요하다. 더 많은 네트워크를 얻을 수 있는 곳에 가야 한다. 마치 최소 정점 커버와 유사하게 내가 커버할 수 있는 개수 내에서 가장 많은 인적 자원을 얻을 수 있는 곳을 찾아봐야겠다. 영어를 좀 더 잘하…","fields":{"slug":"/2023-11-02/"},"frontmatter":{"date":"2023년 11월 02일 03:11","title":"2023년 11월 02일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n- DH 에 제출할 Resume 를 작성했다. Resume 진짜 너무 어렵다. 그래도 열심히 해 보자.\n\n## 배운 것\n\n## 느낀 것\n\n- 인적 자산이 가장 중요하다. 더 많은 네트워크를 얻을 수 있는 곳에 가야 한다. 마치 최소 정점 커버와 유사하게 내가 커버할 수 있는 개수 내에서 가장 많은 인적 자원을 얻을 수 있는 곳을 찾아봐야겠다.\n- 영어를 좀 더 잘하게 되었을 때 DH 채용을 할 수 있었다면 어땠을까 싶다. 기회는 준비된 자에게 열려있다. 이번 기회는 최선을 다하고, 다음 기회는 반드시 얻을 거다. 이제 영어를 말하는 것에 대한 두려움은 줄었다."},{"excerpt":"테스트 환경 각 API 를 100번씩 호출한 시간의 평균값을 기준으로 측정 노래 10000개 멤버 1000명 내 파트 10000개 기준 멤버의 내 파트 100개 기존 API 성능 기존 쿼리는 DTO Projection 을 사용하여 Song 객체를 FETCH JOIN 한다. 쿼리로 데이터를 가져온 후, 가장 최근에 생성된 MemberPart 로 정렬을 수행…","fields":{"slug":"/shook-my-page-query-improve/"},"frontmatter":{"date":"2023년 11월 01일 07:11","title":"마이페이지 쿼리 개선","tags":["shook"]},"rawMarkdownBody":"\n## 테스트 환경\n\n- 각 API 를 100번씩 호출한 시간의 평균값을 기준으로 측정\n- 노래 10000개\n- 멤버 1000명\n- 내 파트 10000개\n\t- 기준 멤버의 내 파트 100개\n\n## 기존 API 성능\n\n기존 쿼리는 DTO Projection 을 사용하여 Song 객체를 FETCH JOIN 한다.\n\n```java\n@Query(\"SELECT s as song, mp as memberPart \"  \n    + \"FROM MemberPart mp \"  \n    + \"LEFT JOIN FETCH Song s ON mp.song = s \"  \n    + \"WHERE mp.member.id = :memberId\")  \nList<SongMemberPartCreatedAtDto> findByMemberId(  \n    @Param(\"memberId\") final Long memberId  \n);\n```\n\n```java\npublic interface SongMemberPartCreatedAtDto {  \n  \n    Song getSong();  \n  \n    MemberPart getMemberPart();  \n}\n```\n\n쿼리로 데이터를 가져온 후, 가장 최근에 생성된 MemberPart 로 정렬을 수행한다.\n\n```java\npublic List<MyPartsResponse> findMyPartByMemberId(final Long memberId) {  \n    final List<SongMemberPartCreatedAtDto> memberPartAndSongByMemberId = memberPartRepository.findByMemberId(  \n        memberId);  \n  \n    return memberPartAndSongByMemberId.stream()  \n        .sorted(Comparator.comparing(songMemberPartCreatedAtDto ->  \n                                         songMemberPartCreatedAtDto.getMemberPart().getCreatedAt(),  \n                                     Comparator.reverseOrder()  \n        ))        .map(memberPart -> MyPartsResponse.of(  \n            memberPart.getSong(),  \n            memberPart.getMemberPart()  \n        ))        .toList();  \n}\n```\n\nAPI 는 평균 23ms 의 속도로 응답을 반환한다.\n\n![[my-page-my-part-find.png]]\n\n그러나 Song 의 artist 정보를 가져오는 과정에서 N+1 문제가 발생한다.\n\n![[my-page-my-part-n-plus-one.png]]\n\n### DTO Projection 제거 및 Artist Fetch Join 수행\n\nDTO Projection 을 제거하고, Song 과 Artist 를 Fetch Join 하는 쿼리로 변경하였다. \n\n```java\n@Query(\"SELECT mp \"  \n    + \"FROM MemberPart mp \"  \n    + \"LEFT JOIN FETCH Song s ON mp.song = s \"  \n    + \"LEFT JOIN FETCH Artist a ON s.artist = a \"  \n    + \"WHERE mp.member.id = :memberId\")  \nList<MemberPart> findByMemberId(  \n    @Param(\"memberId\") final Long memberId  \n);\n```\n\n오히려 성능이 악화되었다. FETCH JOIN 을 하는 overhead 가 Lazy 로딩을 하는 overhead 보다 큰 것을 확인할 수 있었다.\n\n![[my-page-my-part-artist-fetch-join.png]]\n\n### 인덱스 적용\n\n실행 계획을 확인해보면 member_part 를 찾을 때 Table All Scan 이 발생하고 있다. \n\n| id | select\\_type | table | partitions | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| 1 | SIMPLE | member\\_part | null | ALL | null | null | null | null | 9679 | 10 | Using where |\n| 1 | SIMPLE | s | null | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.member\\_part.song\\_id | 1 | 100 | null |\n| 1 | SIMPLE | a | null | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.s.artist\\_id | 1 | 100 | null |\n\n```bash\n-> Nested loop left join  (cost=1670 rows=968) (actual time=0.301..7.45 rows=100 loops=1)  \n    -> Nested loop left join  (cost=1331 rows=968) (actual time=0.261..7.37 rows=100 loops=1)  \n        -> Filter: (member_part.member_id = 1)  (cost=992 rows=968) (actual time=0.173..6.29 rows=100 loops=1)  \n            -> Table scan on member_part  (cost=992 rows=9679) (actual time=0.172..5.67 rows=10000 loops=1)  \n        -> Single-row index lookup on s using PRIMARY (id=member_part.song_id)  (cost=0.25 rows=1) (actual time=0.0105..0.0106 rows=1 loops=100)  \n    -> Single-row index lookup on a using PRIMARY (id=s.artist_id)  (cost=0.25 rows=1) (actual time=588e-6..627e-6 rows=1 loops=100)\n```\n\n이를 방지하기 위해 member_part 의 member_id 에 인덱스를 걸어주었다.\n\n쿼리 실행 계획에서 member_id 인덱스를 가지고 쿼리를 실행하는 것을 확인할 수 있다. \n\n| id | select\\_type | table | partitions | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| 1 | SIMPLE | member\\_part | null | ref | member\\_part\\_member\\_id | member\\_part\\_member\\_id | 8 | const | 100 | 100 | null |\n| 1 | SIMPLE | s | null | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.member\\_part.song\\_id | 1 | 100 | null |\n| 1 | SIMPLE | a | null | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.s.artist\\_id | 1 | 100 | null |\n\n분석에서도 Table Scan 항목이 사라졌다.\n\n```bash\n-> Nested loop left join  (cost=105 rows=100) (actual time=0.267..0.532 rows=100 loops=1)  \n    -> Nested loop left join  (cost=70 rows=100) (actual time=0.261..0.49 rows=100 loops=1)  \n        -> Index lookup on member_part using member_part_member_id (member_id=1)  (cost=35 rows=100) (actual time=0.251..0.272 rows=100 loops=1)  \n        -> Single-row index lookup on s using PRIMARY (id=member_part.song_id)  (cost=0.251 rows=1) (actual time=0.00194..0.00197 rows=1 loops=100)  \n    -> Single-row index lookup on a using PRIMARY (id=s.artist_id)  (cost=0.251 rows=1) (actual time=200e-6..237e-6 rows=1 loops=100)\n```\n\n응답 속도도 평균 13ms 로 성능이 약 43% 개선된 것을 확인할 수 있다.\n\n![[member-id-indexing.png]]"},{"excerpt":"기본 질문 자기소개 기술 백엔드 JPA N+1 문제란 무엇이고 언제 발생하는가? 어떻게 해결할 수 있는가? Fetch Join 의 단점은 없는지? 어떤 경우에 효과적으로 작동하는지? REST 란 무엇인가요? Restful 한 API 란? CI 란? CI 가 필요한 이유 CD 란? CD 가 필요한 이유 클라우드 서비스란? 시스템 scalability 란? …","fields":{"slug":"/interview-questions/"},"frontmatter":{"date":"2023년 11월 01일 06:11","title":"인터뷰 질문 준비","tags":null},"rawMarkdownBody":"\n## 기본 질문\n\n- 자기소개\n\n## 기술\n\n### 백엔드\n\n**JPA**\n- N+1 문제란 무엇이고 언제 발생하는가? 어떻게 해결할 수 있는가?\n\t- Fetch Join 의 단점은 없는지? 어떤 경우에 효과적으로 작동하는지?\n- REST 란 무엇인가요?\n- Restful 한 API 란?\n- CI 란?\n\t- CI 가 필요한 이유\n- CD 란?\n\t- CD 가 필요한 이유\n- 클라우드 서비스란?\n- 시스템 scalability 란?\n- 메시지 큐잉이란?\n\n### 서비스\n\n- S-HOOK 이 어떤 서비스인지 간략하게 소개\n- 프로젝트를 진행하면서 어려웠던 점과 해결한 방식\n\t- 삽입 정렬을 사용한 이유는 무엇인가? 다른 효과적인 방법은 없었나?\n\t- 이분 탐색이 더 효과적이었을 것 같은데, 채택하지 않은 이유는?\n\n### 소프트웨어 공학\n\n- 애자일 방법론이란?\n\t- 애자일을 경험해본 적이 있는지?\n- OOP 를 경험해본 적이 있는지?\n\n### 자료구조\n\n- 삽입 정렬이란?\n- 이진 탐색 트리란?\n- \n\n### OS\n\n- 스레드란 무엇인가?\n- \n\n\n\n## 기술 외 경험\n\n### 동아리\n\n### 우아한테크코스\n\n- 기술적으로 어떤 것을 배웠는가\n- 수료한 소감"},{"excerpt":"Ringle 표현 contemplate == think simple to == easy to come with: Phrase that something is included or provided with another item / something else will vs would will 미래의 행동이나 사건을 표현할 때 자주 사용된다. 사실, 약속, …","fields":{"slug":"/english-speaking-oct-4week/"},"frontmatter":{"date":"2023년 10월 31일 11:10","title":"10월 넷째주 영어 회화","tags":["english"]},"rawMarkdownBody":"\n## Ringle\n\n### 표현\n\n- contemplate == think\n- simple to == easy to\n- come with: Phrase that something is included or provided with another item / something else\n\n### will vs would\n\n- will\n\t- 미래의 행동이나 사건을 표현할 때 자주 사용된다.\n\t- 사실, 약속, 추측에 사용\n\t- ex. I will meet you at the cafe at 3 p.m\n- would\n\t- 조건부 미래의 행동\n\t\t- I would go to the party if I had time\n\t- 무언가를 요청하거나 제공할 때 공손하게 표현하기\n\t\t- Would you like to go to the restaurant with me?\n\t- 과거의 습관이나 행동\n\n## 회화 수업\n\n### 표현\n\n- make a resume: 이력서를 쓰다.\n- rough: 요즘 사람들은 hard 보다는 rough 를 사용한다고 한다.\n\t- Ex. I'm having a rough time.\n- fudge: 적당히 꾸며내다.. 라고 영어 사전에 적혀있는데 뭐랄까 좀 더 멋진 말로 표현하다? 거짓말은 아니고 그럴듯하게 표현하다 이런 느낌으로 사용하셨던 거 같다.\n- work smarter\n- a letter of recommendation == a recommendation letter: 추천서\n- There only needs to be 1: 오직 하나만 필요하다.\n- a portfolio of projects\n- There is no format\n- has been working: 일해오다\n- pandemic hit: 펜데믹이 발생하다.\n- versatility: 다재다능, 다용도, 다목적\n\t- You can show versatility in that case.\n\n### 조언\n\n- the 는 object 에 사용한다. \n\t- 다음과 같이는 사용하지 않는다. \n\t\t- the 배달의 민족 (x) => 배달의 민족\n\t\t- the 강남대로 (x) => 강남대로\n- The **noun** is **noun** => noun 은 둘 다 동일한 뜻을 갖는다."},{"excerpt":"TODO LOG 배운 것  로 빌드하지 않으면 가끔 아무런 문제가 없는데도 Response 객체가 파싱이 안 된다. ( 상태에서 파싱 불가능. 속성이 1개가 아니어도 안 됨) 해결하기 위해서는 프로젝트를  로 빌드하면 된다. 느낀 것 단어가 아닌 문장으로 말하려고 노력하자.","fields":{"slug":"/2023-10-31/"},"frontmatter":{"date":"2023년 10월 31일 08:10","title":"2023년 10월 31일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue this week\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n- `gradle` 로 빌드하지 않으면 가끔 아무런 문제가 없는데도 Response 객체가 파싱이 안 된다. (`@AllArgsConstructor(PRIVATE)` 상태에서 파싱 불가능. 속성이 1개가 아니어도 안 됨) 해결하기 위해서는 프로젝트를 `gradle` 로 빌드하면 된다.\n\n## 느낀 것\n\n- 단어가 아닌 문장으로 말하려고 노력하자."},{"excerpt":"발단 S-HOOK 의 서비스는 사용자의 좋아요가 큰 의미를 갖는 서비스이다. 메인에 보여지는 노래들은 노래의 총 좋아요 개수로 내림차순 정렬된 리스트이고, 보여지는 킬링파트들의 순위도 킬링파트마다의 좋아요 개수로 정해진다. 하지만 좋아요 개수로 내림차순 정렬을 계속해서 수행하는 것은 DB 에 큰 오버헤드를 발생시킨다. 이를 해결하기 위해 노래 정보들과 노…","fields":{"slug":"/inmemory-cache-develop-reason/"},"frontmatter":{"date":"2023년 10월 30일 08:10","title":"로컬 캐싱 개선 진행 과정","tags":["shook","개발"]},"rawMarkdownBody":"\n## 발단\n\nS-HOOK 의 서비스는 사용자의 좋아요가 큰 의미를 갖는 서비스이다.  \n메인에 보여지는 노래들은 노래의 총 좋아요 개수로 내림차순 정렬된 리스트이고, 보여지는 킬링파트들의 순위도 킬링파트마다의 좋아요 개수로 정해진다.  \n\n하지만 좋아요 개수로 내림차순 정렬을 계속해서 수행하는 것은 DB 에 큰 오버헤드를 발생시킨다. 이를 해결하기 위해 노래 정보들과 노래의 킬링파트 데이터들을 서버 메모리에 정렬된 상태로 캐싱해서 오버헤드를 크게 줄일 수 있었다.\n\n그렇지만 그 과정에서 좋아요 개수가 캐시에 반영되지 않아 실시간으로 좋아요가 증가되고 감소되지 않는 문제가 발생했다. 이를 해결하기 위해 로컬 캐시를 개선하고자 한다.\n\n## 좋아요 로직\n\n좋아요 실시간을 반영하기 위해서는 S-HOOK 의 좋아요 등록 / 취소 과정을 알아야 한다. 대표로 좋아요 등록에 대해 알아보자.  \n\n좋아요를 누르는 요청인 경우, `KillingPart` 의 `like`  메서드를 호출한다. 그런 다음 `KillingPartLikes` 에 `KillingPartLike` 가 추가되었는지 확인하고, `KillingPart` 의 필드인 `likeCount` 를 1 증가시킨다. 즉, Dirty Checking 을 사용하여 값을 업데이트한다.\n\n```java\npublic void like(final KillingPartLike likeToAdd) {  \n    validateLikeUpdate(likeToAdd);  \n    final boolean isLikeCreated = killingPartLikes.addLike(likeToAdd);  \n    if (isLikeCreated) {  \n        this.likeCount++;  \n    }  \n}\n```\n\n그러나 현재 로컬 캐시에 있는 데이터들은 Dirty Checking 으로 값이 변경되지 않아야 하므로, `EntityManager` 를 사용하여 `detach` 를 수행했다.\n\n```java\npublic void recreate(final List<Song> songs) {  \n    songsSortedInLikeCountById = getSortedSong(songs);  \n    songLikeCountById = songs.stream()  \n        .collect(Collectors.toMap(Song::getId, song -> new AtomicInteger(song.getTotalLikeCount())));  \n  \n    songsSortedInLikeCountById.values().stream()  \n    .peek(entityManager::detach)  \n    .flatMap(song -> song.getKillingParts().stream())  \n    .peek(entityManager::detach)  \n    .flatMap(killingPart -> killingPart.getKillingPartLikes().stream())  \n    .forEach(entityManager::detach); \n}\n```\n\n`addLike` 에서는 `KillingPartLikes` 라는 일급 컬렉션 객체 내부의 리스트에 `KillingPartLike` 를 추가하게 된다. \n\n```java\npublic class KillingPartLikes {  \n  \n    @OneToMany(mappedBy = \"killingPart\")  \n    @Where(clause = \"is_deleted = false\")  \n    private List<KillingPartLike> likes = new ArrayList<>();  \n  \n    public boolean addLike(final KillingPartLike like) {  \n        if (like.isDeleted()) {  \n            like.updateDeletion();  \n            likes.add(like);  \n  \n            return true;  \n        }  \n  \n        return false;  \n    }\n    ...\n}\n```\n\n여기서 문제가 발생한다. 현재 로컬 캐시에 있는 데이터는 다음과 같은 쿼리로 생성된다. \n\n```java\n@Query(\"SELECT s AS song \"  \n    + \"FROM Song s \"  \n    + \"LEFT JOIN FETCH s.killingParts.killingParts kp \"  \n    + \"GROUP BY s.id, kp.id\")  \nList<Song> findAllWithKillingParts();\n```\n\n`KillilngPart` 는 `KillingPartLikes` 데이터를 `LAZY` 하게 로딩한다. 즉, 데이터에 접근할 때만 로딩이 되는데, `recreate` 에서 좋아요 데이터를 조회하는 일이 없기 때문에 로딩이 되지 않는다. \n결론적으로는 `KillingPartLikes` 가 FETCH 되지 않았기 때문에 `Lazy Initialization` 예외가 발생하게 된다. 이를 해결할 수 있는 방법은 여러 가지가 있다. \n\n1. EAGER 로딩으로 변경한다.\n\t- EAGER 로딩으로 변경하면 문제는 해결되지만, 모든 킬링파트 데이터를 로드할 때마다 EAGER 로딩이 발생할 것이다.\n\t- 추후 로직이 추가될 때 성능 문제가 발생할 위험이 있다.\n2. `KillingPartLikes` 를 FETCH 한다.\n\t- 특정 쿼리에서만 `KillingPartLikes` 를 FETCH 해올 수 있다. 2번 방법을 채택하였다. \n\n### MultiBagFetchException 발생\n\n두 가지 컬렉션을 FETCH 해올 때, 처음에는 `KillingPartLikes` 가 `List` 였기 때문에 다음과 같은 에러가 발생했다. \n\n```java\n@Query(\"SELECT s AS song \"  \n    + \"FROM Song s \"  \n    + \"LEFT JOIN FETCH s.killingParts.killingParts kp \"  \n    + \"LEFT JOIN FETCH kp.killingPartLikes.likes kpl \"  \n    + \"GROUP BY s.id, kp.id, kpl.id\")  \nList<Song> findAllWithKillingPartsAndLikes();\n```\n\n```bash\nCaused by: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags: [shook.shook.song.domain.killingpart.KillingPart.killingPartLikes.likes, shook.shook.song.domain.Song.killingParts.killingParts]\n\tat org.hibernate.query.sqm.sql.BaseSqmToSqlAstConverter.createFetch(BaseSqmToSqlAstConverter.java:7971)\n\tat org.hibernate.query.sqm.sql.BaseSqmToSqlAstConverter.visitFetches(BaseSqmToSqlAstConverter.java:8065)\n\tat org.hibernate.sql.results.graph.AbstractFetchParent.afterInitialize(AbstractFetchParent.java:32)\n\tat org.hibernate.sql.results.graph.embeddable.internal.EmbeddableFetchImpl.<init>(EmbeddableFetchImpl.java:75)\n\tat org.hibernate.metamodel.mapping.internal.EmbeddedAttributeMapping.generateFetch(EmbeddedAttributeMapping.java:269)\n\tat org.hibernate.sql.results.graph.FetchParent.generateFetchableFetch(FetchParent.java:108)\n\tat org.hibernate.query.sqm.sql.BaseSqmToSqlAstConverter.buildFetch(BaseSqmToSqlAstConverter.java:8108)\n```\n\n`KillingPartLikes` 를 `Set` 으로 변경하면 MultiBagFetchException 을 해결할 수 있다.\n\n```java\n@OneToMany(mappedBy = \"killingPart\")  \n@Where(clause = \"is_deleted = false\")  \nprivate Set<KillingPartLike> likes = new HashSet<>();\n```\n\n### 노래 데이터 재정렬\n\n좋아요 개수가 늘었기 때문에, 기존에 저장하고 있던 노래 데이터를 다시 정렬해야 한다.  \n그렇지만 일일이 좋아요 개수를 매번 다시 계산하는 것은 불필요한 반복 로직이므로, 각 노래의 총 좋아요 개수를 저장하는 `songLikeCountById` `Map` 을 생성한다.\n\n```java\nprivate Map<Long, AtomicInteger> songLikeCountById = new LinkedHashMap<>();\n```\n\n좋아요가 눌릴 때마다 총 좋아요 개수와 킬링파트의 좋아요 개수를 증가시킨다. 증가가 완료된 뒤에는 좋아요된 노래의 정렬을 다시 수행한다.\n\n```java\npublic void pressLike(final KillingPart killingPart, final KillingPartLike likeOnKillingPart) {  \n    final Song song = songsSortedInLikeCountById.get(killingPart.getSong().getId());  \n    final KillingPart killingPartById = findKillingPart(killingPart, song);  \n    killingPartById.like(likeOnKillingPart);  \n    songLikeCountById.get(song.getId()).incrementAndGet();  \n  \n    // 좋아요가 증가되었으므로 노래 정렬 다시 수행  \n    sortSongsByLikeCount();  \n}\n\nprivate void sortSongsByLikeCount() {  \n    // 좋아요 데이터로 노래 아이디를 정렬 => 아이디로 노래를 가져온다.  \n    songsSortedInLikeCountById = songLikeCountById.entrySet().stream().sorted((o1, o2) -> {  \n        if (o1.getValue().get() == o2.getValue().get()) {  // 좋아요 개수가 같은 경우\n            return o2.getKey().compareTo(o1.getKey());  // id 내림차순으로 정렬한다.\n        }  \n        return o2.getValue().get() - o1.getValue().get();  // 좋아요 내림차순으로 정렬\n    }).collect(Collectors.toMap(Map.Entry::getKey, entry -> songsSortedInLikeCountById.get(entry.getKey()),  \n                                (prev, update) -> update, LinkedHashMap::new));  \n}\n```\n\n### `Map` 을 생성하는 오버헤드 줄이기\n\n노래 데이터가 바뀔 때마다 정렬이 수행되어야 한다. 전체 노래에 대한 정보가 있어야 하므로 `Song` 엔티티를 `Map` 으로 갖고 있어야 한다.  \n\n이때 `Map` 을 정렬하기 위해서는 새로운 `Map` 을 만들 수 밖에 없다. 이 부분을 효율적으로 변경할 수 없을까?\n\n결론적으로 노래는 id 로 찾을 수 있는 `Map` 을 따로 두고, 노래의 좋아요와 id 내림차순으로 정렬된 상태인 노래 id `List` 를 두어 새롭게 정렬된 `Map` 을 생성하지 않도록 했다.\n\n이렇게 하면 노래 id 만 정렬된 상태로 유지하면 되고, `List` 로 저장하기 때문에 `List.sort` 메서드를 사용할 수 있게 된다. 즉, 새롭게 `List` 를 생성하는 오버헤드를 줄일 수 있다. \n\n변경된 구조는 다음과 같이 구성된다.\n\n```java\nprivate static final Comparator<Song> COMPARATOR = Comparator.comparing(Song::getTotalLikeCount,  \n                                                                        Comparator.reverseOrder())  \n    .thenComparing(Song::getId, Comparator.reverseOrder());  \nprivate Map<Long, Song> songsSortedInLikeCountById;  \nprivate List<Long> sortedIds;\n```\n\n### 삽입 정렬로 좋아요 정렬 로직 개선\n\n좋아요를 누르거나 취소했을 때 리스트에서 변경되는 값은 노래 하나이다. 즉, 다른 값들은 모두 정렬이 되어 있는데, 노래 하나의 데이터의 위치가 변경되어야 한다는 뜻이다. 대부분이 정렬되어 있는 리스트에서는 삽입 정렬을 사용했을 때 성능이 좋다.\n\n좋아요 개수가 변경되었을 때 노래 아이디를 갖는 리스트를 정렬한다. \n\n```java\npublic void pressLike(final KillingPart killingPart, final KillingPartLike likeOnKillingPart) {  \n    final Song song = songsSortedInLikeCountById.get(killingPart.getSong().getId());  \n    final KillingPart killingPartById = findKillingPart(killingPart, song);  \n    final boolean updated = killingPartById.like(likeOnKillingPart);  \n    if (updated) {  \n        adjustSongPosition(song);  \n    }  \n}\n```\n\n```java\npublic void adjustSongPosition(Song changedSong) {  \n    int currentIndex = sortedIds.indexOf(changedSong.getId());  \n  \n    if (currentIndex == -1) {  \n        return; // 노래를 찾지 못했을 경우  \n    }  \n  \n    // 좋아요가 증가한 경우 (높은 좋아요 순으로 앞으로 이동)  \n    if (shouldMoveForward(changedSong, currentIndex)) {  \n        while (currentIndex > 0 &&  \n            shouldSwapWithPrevious(changedSong, songsSortedInLikeCountById.get(sortedIds.get(currentIndex - 1)))) {  \n            // 이전 노래와 위치 교환  \n            swap(sortedIds, currentIndex, currentIndex - 1);  \n            currentIndex--;  \n        }  \n    }    // 좋아요가 감소한 경우 (낮은 좋아요 순으로 뒤로 이동)  \n    else {  \n        while (currentIndex < sortedIds.size() - 1  \n            && shouldSwapWithNext(changedSong, songsSortedInLikeCountById.get(sortedIds.get(currentIndex - 1)))) {  \n            // 다음 노래와 위치 교환  \n            swap(sortedIds, currentIndex, currentIndex + 1);  \n            currentIndex++;  \n        }  \n    }}  \n  \nprivate boolean shouldMoveForward(Song song, int index) {  \n    return index > 0 && shouldSwapWithPrevious(song, songsSortedInLikeCountById.get(sortedIds.get(index - 1)));  \n}  \n  \nprivate boolean shouldSwapWithPrevious(Song song, Song previousSong) {  \n    return song.getTotalLikeCount() > previousSong.getTotalLikeCount() ||  \n        (song.getTotalLikeCount() == previousSong.getTotalLikeCount() && song.getId() > previousSong.getId());  \n}  \n  \nprivate boolean shouldSwapWithNext(Song song, Song nextSong) {  \n    return song.getTotalLikeCount() < nextSong.getTotalLikeCount() ||  \n        (song.getTotalLikeCount() == nextSong.getTotalLikeCount() && song.getId() < nextSong.getId());  \n}  \n  \nprivate void swap(List<Long> list, int i, int j) {  \n    Long temp = list.get(i);  \n    list.set(i, list.get(j));  \n    list.set(j, temp);  \n}\n```\n\n## 참고\n\n실제 성능 개선이 된 부분은 [[inmemory-cache-develop]] 에서 확인할 수 있다."},{"excerpt":"TODO 글쓰기 미션 요청 [startTime:: 14:30]  [endTime:: 15:00] 20:00 - 20:30 우테코 회고 작성하기  [due:: 2023-11-05] LOG 배운 것 느낀 것","fields":{"slug":"/2023-10-30/"},"frontmatter":{"date":"2023년 10월 30일 05:10","title":"2023년 10월 30일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션 요청 [startTime:: 14:30]  [endTime:: 15:00]\n- [x] 20:00 - 20:30 우테코 회고 작성하기  [due:: 2023-11-05]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO 리뷰어 피드백 완료  [priority:: highest]  [due:: 2023-10-28]  [completion:: 2023-10-29] LOG 블루 자이언트를 봤다. 되게 감명깊게 봐서 느낀 점도 많았다. 배운 것 느낀 것 예전부터 나는 '뛰어난 것이 좋은 것' 이라고 생각해왔다. 정확히는 처음부터/원래부터 잘한다, 천재라는 말을 동경했다…","fields":{"slug":"/2023-10-29/"},"frontmatter":{"date":"2023년 10월 29일 07:10","title":"2023년 10월 29일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 리뷰어 피드백 완료  [priority:: highest]  [due:: 2023-10-28]  [completion:: 2023-10-29]\n\n## LOG\n\n- 블루 자이언트를 봤다. 되게 감명깊게 봐서 느낀 점도 많았다. \n\n## 배운 것\n\n## 느낀 것\n\n- 예전부터 나는 '뛰어난 것이 좋은 것' 이라고 생각해왔다. 정확히는 처음부터/원래부터 잘한다, 천재라는 말을 동경했다. 그런데 블루 자이언트에서 본 주인공들은 달랐다. 처음부터 혹평을 받던 타마다가 대단하다고 생각되는 이유는 그 사람이 성장하는 과정이 존재하기 때문이다. 처음부터 잘했다면, 그 사람이 성장하고 잘하게 되는 건 '당연한 것' 으로 치부되었을 가능성이 높다. 그걸 대변하는 사람이 다이라고 생각한다. 재능도 있고, 열정도 있는 사람. 그렇지만 꼭 그것만이 전부는 아니다. 내가 노력하는 과정은 미래의 내가 빛나는 순간을 위해 존재한다는 거다. 그게 지금이 아니라도 괜찮다. 언젠가 나는 높은 곳에서 빛날 테니까. 그래서 기나긴 노력의 과정을 견딜 수 있는 거였다. 끝이 없는 게 아니라서. 결국 처음에 못하는 건 부끄러운 게 아니라 내가 그만큼 가야 할 길이 멀다는 거고, 그 길을 착실하게 가다보면 언젠가는 도착한다는 걸 알아야 노력할 수 있는 거구나. 아니면 그에 상응하는 열정이 있거나.\n\t- 사실 유키노리에게서 내 모습을 본 것 같았다. 언젠지는 기억이 안 나지만, 나는 예전부터 내가 틀에 박힌 사고만 한다고 생각했다. 그 바운더리 밖으로는 나가지 못하고, 남들이 하는 생각만 겨우 따라하는 사람이라고 생각했었다. 배운 대로, 규칙대로 하던 유키노리가 '형편없다' 라는 평을 받을 때, 왠지 그 때의 기억이 났다. 다이처럼, 멋진 재능은 존재한다. 아쉽게도 그런 재능을 배워서 익힐 수는 없다. 즉흥도 재능이고, 표현도, 노력도 재능이니까. 그렇지만 그게 뭐 어떤가. 그건 나랑은 별개인데. 나는 내 재능을 사랑하고 갈고 닦으면 된다. 그들만의 길이 깨끗하고 포장되어 있다고 해서 나도 따라가기만 하는 건 재미없잖아. 나는 울퉁불퉁한 비포장 도로를 발에 물집이 잡히도록 즐겁게 걸으면 되는 거다."},{"excerpt":"길고 긴 10개월이 지나고, 벌써 레벨4가 마무리되는 지금 우아한테크코스를 회고해보려 합니다. 베로 위키 애독자들도 모를 수도 있는 올해 2월 6일 회고를 가져와 보겠습니다. 2월 6일이면 첫 등교 전 날이죠. 사실 저는 이때 마음의 병이 있어 상담을 받고 있었는데요, 지칠대로 지쳐 제가 뭘 할 수 있을지에 대해 의심만 가득한 상태였습니다. 안일한 마음가…","fields":{"slug":"/woowacourse-retrospect/"},"frontmatter":{"date":"2023년 10월 29일 06:10","title":"우아한테크코스 회고","tags":["우테코","회고"]},"rawMarkdownBody":"\n길고 긴 10개월이 지나고, 벌써 레벨4가 마무리되는 지금 우아한테크코스를 회고해보려 합니다.  \n\n베로 위키 애독자들도 모를 수도 있는 올해 2월 6일 회고를 가져와 보겠습니다. 2월 6일이면 첫 등교 전 날이죠. \n\n```md\n사실 조금 걱정이 된다. 지금 마음가짐이 어떤지 모르겠다.  \n의욕도, 목적도, 목표도 모호한 상태라 그냥 잘 모르겠다. 우테코에서 찾을 수 있지 않을까라는 안일한 마음가짐으로 내일 등교(?)할 예정이다.  \n내 마음대로 안 되는 상황에 스트레스를 받는 편인데, 과연 우아한테크코스가 나에게 어떤 영향을 끼칠지 궁금하다. 기왕이면 좋은 영향이었으면 좋겠다.\n```\n\n사실 저는 이때 마음의 병이 있어 상담을 받고 있었는데요, 지칠대로 지쳐 제가 뭘 할 수 있을지에 대해 의심만 가득한 상태였습니다. 안일한 마음가짐이었고, 고쳐 말하자면 무책임했습니다. 뭘 하고 싶은지도 모르고, 의욕도 없다니 뭘 기대할 수 있었겠습니까?\n\n자, 그렇다면 베로의 될 대로 되라는 식의 우테코 도전, 어떻게 되었을까요? 과거의 베로에게 소개해보겠습니다.\n\n## 주변 사람들을 사랑하기\n\n예전의 저는 어쩌면 주위의 사람들을 두려워했던 것 같습니다. \n정확하게는 그들이 저보다 더 잘하게 되는 상황을 두려워했어요. 그래서 주변 사람들과 항상 경쟁하고 있다는 생각을 가지고 있었습니다. 친구들도 예외는 아니었죠.\n\n그렇지만 우테코에 와보니, 저와 경쟁하고 싶어하는 사람들은 없었어요. 뭐든 알려주려 하고, 배워서 남주는 걸 가장 큰 미덕으로 생각하는 사람들밖에 없더라고요.  \n\n친절하고 열려있는 사람들 옆에서 저만 울타리 안에서 두려움에 떨고 있는 듯 했어요. 그래서 저도 한 번 용기 내서 다가가 봤습니다. 다들 멋진 사람들이었어요. 제가 열린 마음으로 다가가니 그들도 저에게 열린 마음으로 대해줘서 참 기뻤습니다.\n\n주변에 멋진 사람들만 있으니, 사람들을 사랑할 수 있게 되었어요. 진심으로 잘 되었으면 좋겠고, 멋진 꿈을 이뤘으면 좋겠고, 그냥 뭐든 알려주고 싶었어요. 그 과정에서 저도 함께 많이 배웠고, 이젠 사람들과 함께 있는 시간 자체를 사랑하게 됐습니다. 제가 E라니, 과거의 베로는 믿겨지시나요?\n\n우아한테크코스에 오지 않았다면 아마도 제가 만든 울타리에 들어가서 울타리 밖에 늑대만 있을 거라 생각하고 살았겠죠. 사실은 아무도 없는 허허벌판인데 말이에요.  \n\n우테코에서 주변 사람들을 사랑할 수 있게 되었다는 사실에 감사합니다. 주위 사람들이 베푸는 선함을 감사함으로 받아들일 수 있게 되었다는 사실이 가장 기쁩니다.\n\n## 나를 사랑하기\n\n다시 2월 6일 회고로 돌아와서, 또 이런 말을 적었었습니다.\n\n```md\n또 다른 목적은 나를 사랑해보기 위해서이다. \n계속되는 실패(진짜 실패일지, 내 머릿속으로만 그렇게 생각하는 건지도 모르겠다) 때문에 나를 온전히 보기 쉽지 않다. \n차라리 진짜 객관적인 문서로 남겨서 내가 지금 어떻게 살고 있는지 내가 봤으면 좋겠다는 생각이다. 최대한 꾸준히 쓰고 싶다.\n```\n\n맞아요. 요즘 조금 해이해지기는 했지만, 저는 TIL 을 정말 꾸준히 썼습니다.  \nTIL도 좋고, 뭐든 기록해보자는 생각으로 적었던 글들이 벌써 약 380개 정도가 되었네요. 과거의 저도 이 정도로 열심히 했을 줄은 몰랐겠죠. \n\n과거의 베로에게 딱 하나만은 말해줄 수 있습니다.  \n올해 저 정말 열심히 살았어요. 개인 공부를 하루에 3시간 이하로 한 날을 손에 꼽을 수 있을 정도니까요. 글의 개수와 늘어난 자신감이 이 주장을 뒷받침 한다고 생각합니다.  \n\n조금 다른 점은 있습니다. 지금의 저는 열심히 하지 않는 나도 사랑할 수 있어요.  \n매일 열심히 살기는 어려운 일이에요. 그럴 때마다 저를 미워하는 일은 더 이상 하지 않기로 했습니다. \n\n그래서 그런지 요즘 들어 자책하는 일이 줄었습니다.  \n오늘 못하면 내일 하면 돼요.  \n지금은 못해도 내일 잘하면 돼요.  \n오늘은 안 좋은 일이 있었지만 앞으로는 좋은 일이 있을거에요.  \n\n이런 마음가짐들이 또 다시 제게 힘이 됩니다. \n\n## 베로, 우아한테크코스는 어떠셨나요?\n\n저는 감히 '제 인생의 **터닝포인트**였다', 라고 단언하겠습니다.  \n사실 제겐 기술적으로 얼마나 성장했는지가 중요한 게 아니에요. 기술은 밖에서도 얼마든지 배울 수 있었을거에요. 비효율적이지만 말이죠.\n\n가장 크게 변한 건 공부를 대하는 태도입니다. [[level4-writing|레벨 4 글쓰기]] 에도 적었지만, 동료들과 함께 하는 공부가 가장 효율이 좋다는 걸 알게 됐거든요. \n나와 같은 길을 가는 사람은 도전자나 경쟁자가 아니라 동행인이에요. 배척하고 견제해봤자 소용없죠. 같이 가는 길에 혼자 남겨져서 좋을 일은 없을테니까요. 저도 아는 지식을 최대한 공유하고 싶고, 제 지식이 남에게 도움이 될 때가 훨씬 기분 좋습니다.  \n\n제게 맞는 공부를 하는 방법도 알게 됐어요. 전 원래 책이나 인강을 보며 공부했었습니다. 제 집중력은 간장 종지만 해서 금방 흐트러졌지만요.   \n우테코에 와서 열정있는 사람들과 스터디를 해보니, 왜 사람들이 스터디를 하는지 알 것 같았어요. 내가 모르는 건 스터디원이 알려줄 거고, 스터디원이 모르는 건 내가 알려주면 돼요. 먼저 경험해본 사람에게 물어보는 게 가장 효과적이라는 걸 수많은 미션과 페어프로그래밍을 하면서 알게 됐어요. 내가 막히는 부분을 미션을 먼저 구현하면서 막혀본 사람에게 물어보는 게 가장 빠르고, 정확했으니까요.  \n그래서 어떤 게 가장 효과적이냐! 새로운 걸 공부할 땐, 주위 사람들에게 마구 물어보고 함께 공부하는 게 제게 가장 효과적이라는 걸 알게 됐습니다. 학교로 돌아가더라도 모르는 지식에 대한 스터디를 하나 만들어서 진행하려고 해요.\n\n가장 신기했던 점은 세상에 궁금한 게 많아졌다는 점입니다.  \n예전부터 저는 궁금한 게 없었어요. 남에 대해서도 궁금하지 않고, 그냥 모르면 모르는 거지.. 라고 생각하며 살았어요. 그래서 그런지 먼저 다가가는 것도 힘들었고, 새로운 기술이 나와도 피하려고만 했어요. 굳이 알아야 할 필요가 없다고 생각했거든요.  \n\n그렇지만 지금은 뭐든지 궁금해요. 이건 왜 좋고, 왜 써야 하고, 당신은 왜 이렇게 생각했으며, 어떤 부분에서 장점 / 단점이 있고, 어떨 때 사용하면 좋은지 등등... 무수한 질문들이 떠오릅니다. 질문이 많아진 이유는 제가 세상을 사랑할 수 있게 되어서라고 생각해요. 사랑하지 않으면 궁금하지도 않으니까요. 이런 Question Driven Study가 제겐 매우 도움이 됐습니다. 여러분도 한 번 시도해보세요.\n\n## 내일, 그리고 또 내일\n\n최근에 어떤 웹툰을 보다가 매우 인상 깊은 글을 보게 되었습니다. 저는 이 문장들에 굉장한 감명을 받았어요. 마치 제 인생을 설명하는 것 같았죠.\n\n> 사람의 생은 참 허무하고, 가볍고, 보잘 것 없습니다.  \n> 그런 허무에도 불구하고 우리의 생을 이 땅에 붙어있게 만드는 중력은 무엇일까...\n> 전 사랑이라고 생각합니다.   \n> ...\n> 그렇게 세상에 사랑하는 것들이 많아지면 생은 점점 무거워지고, 그 무게에 짓눌릴 때 허무 같은 건 자연스럽게 잊게 됩니다. \n> 인내심을 갖고 당신에게 작용하는 중력을 계속 찾아보십시오. 그리고 그것에 마음껏 집착하고 욕망해 보십시오.\n\n지금까지의 제 삶은 깃털보다도 가벼웠습니다. 하고 싶은 건 없었고, 목표는 당연하게도 없었어요.  \n그나마 좋아하던 개발에 매달려 우테코까지 떠밀려 왔습니다.  \n\n저는 우테코에서 세상을 사랑하는 법을 배웠고, 어떻게 하면 세상을 더 올바른 관점으로 바라볼 수 있는지 알게 됐어요. 결론적으로 말하자면 저도 '누군가를 사랑할 수 있는 사람' 이 되었다고 생각합니다. 그 사실이 제 생을 끌어당기는 가장 큰 중력이라는 생각이 드네요.\n\n우테코에서 저만 많은 걸 얻어가는 것 같아 양심의 가책이 들기도 합니다. 제가 사랑하는 만큼 더 나누지 못한 것이 조금은 아쉬워요. 그래도 여러분 모두 행복하기를 바랍니다. 이제 저는 충분히 행복해요. "},{"excerpt":"TODO 미션 4단계 제출  [priority:: highest]  [created:: 2023-10-28]  [due:: 2023-10-28]  [completion:: 2023-10-28] 팀 피드백 완료  [priority:: highest]  [due:: 2023-10-28]  [completion:: 2023-10-28] 베베 리뷰 완료  [pr…","fields":{"slug":"/2023-10-28/"},"frontmatter":{"date":"2023년 10월 28일 03:10","title":"2023년 10월 28일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 미션 4단계 제출  [priority:: highest]  [created:: 2023-10-28]  [due:: 2023-10-28]  [completion:: 2023-10-28]\n- [x] 팀 피드백 완료  [priority:: highest]  [due:: 2023-10-28]  [completion:: 2023-10-28]\n- [x] 베베 리뷰 완료  [priority:: highest]  [due:: 2023-10-28]  [completion:: 2023-10-28]\n- [x] 리뷰이 피드백 완료  [priority:: highest]  [due:: 2023-10-28]  [completion:: 2023-10-28]\n\n## LOG\n\n- T1 이 녹아웃 스테이지에 진출했다. 갑자기 각성해서 BLG 를 씹어먹어버렸는데 왤까...\n- 여전히 캐싱 처리 테스트를 하고 있다. 결론적으로 어떤 테스트를 해야 할 지부터 생각하는 게 좋을 거 같다. 대강 정리는 했는데 글 대제목으로 적으면서 더 정리해봐야겠다. \n\n## 배운 것\n\n- 백준 13713 번을 풀었다. 실패 함수를 응용해서 가장 긴 접두사를 항상 지정해두고 O(N) 안에 전체 문자열을 탐색하는 어마어마한 알고리즘을 배웠다. 고마워요.\n\n## 느낀 것"},{"excerpt":",  은 어떤 차이점이 있을까?  메서드 (또는 클래스의 모든 메서드) 를 호출한 결과를 캐시할 수 있음을 나타내는 어노테이션이다. 메서드가 호출될 때마다 캐싱 동작이 적용되어 주어진 인자에 대해 메서드가 이미 호출되었는지 여부를 확인한다. 단순히 메서드 매개변수를 사용하여 키를 계산하는 것이지만,  속성을 사용하여 SpEL 표현식을 제공하거나, 사용자 …","fields":{"slug":"/cache-and-cacheable/"},"frontmatter":{"date":"2023년 10월 27일 09:10","title":"Cache vs Cacheable","tags":["spring","jpa"]},"rawMarkdownBody":"\n`@Cache`, `@Cachable` 은 어떤 차이점이 있을까?\n\n## `@Cacheable`\n\n메서드 (또는 클래스의 모든 메서드) 를 호출한 결과를 캐시할 수 있음을 나타내는 어노테이션이다.  \n메서드가 호출될 때마다 캐싱 동작이 적용되어 주어진 인자에 대해 메서드가 이미 호출되었는지 여부를 확인한다. 단순히 메서드 매개변수를 사용하여 키를 계산하는 것이지만, `key()` 속성을 사용하여 SpEL 표현식을 제공하거나, 사용자 정의 `KeyGenerator` 구현으로 기본값을 대체할 수 있다. \n\n계산된 값이 캐시에서 발견되지 않으면, 대상 메서드가 호출되고, 반환된 값이 연결된 캐시에 저장된다. `Optional` 값이 없는 경우에는 null 이 캐시에 저장된다.\n\n## `@Cache`\n\n```java\n@Target({TYPE, METHOD, FIELD})\n@Retention(RUNTIME)\npublic @interface Cache\n```\n\n2차 캐싱을 위한 Root 엔티티나 컬렉션을 표시하고 저장한다.  \n엔티티 또는 컬렉션의 인스턴스 상태를 저장할 `region`, 엔티티 또는 컬렉션에 영향을 미칠 것으로 예상되는 데이터 액세스 패턴을 고려한 적절한 캐시 동시성 정책 (`usage`) 을 지정한다. \n\nJPA 정의된 어노테이션인 `Cacheable` 보다 우선적으로 사용해야 한다. JPA 는 cache 의 semantics 를 정의할 수 있는 수단을 제공하지 않기 때문이다. `Cacheable` 어노테이션과 함께 사용될 수 있지만, 중복된다.\n\n2차 캐시가 있는 루트 엔티티의 엔티티 서브 클래스는 루트 엔티티에 속한 캐시를 상속한다 . \n\n다음과 같이 캐싱을 사용할 수 있다.\n\n```java\n @Entity\n @Cache(usage = NONSTRICT_READ_WRITE)\n public static class Person { ... }\n```\n\n다음과 같이 컬렉션을 캐싱할 수도 있다.\n\n```java\n @OneToMany(mappedBy = \"person\")\n @Cache(usage = NONSTRICT_READ_WRITE)\n private List<Phone> phones = new ArrayList<>();\n```\n\n2차 캐시는 `hibernate.cache.region.factory_class` 를 명시적으로 지정하지 않는 한 비활성화되므로, 기본적으로 해당 어노테이션은 아무런 영향을 미치지 않는다.\n\n### `CacheConcurrencyStrategy`\n\n공유된 2차 캐시에 대한 동시 접근을 관리하기 위한 정책이다.  \n\n2차 캐시는 지정된 세션 팩토리에서 생성된 모든 동시 활성 세션 간에 공유된다. 캐시는 트랜잭션 간에 상태를 공유하면서 데이터베이스 락 또는 다중 버전 동시성 제어를 우회한다. 이는 데이터의 모든 공유가 데이터베이스에 의해 중개될 때만 보장이 되기 때문에, 트랜잭션 처리의 ACID 속성을 약화시키는 경향이 있다. \n\n물론 일반적으로 2차 캐시에 실제로 속하는 데이터는 두 가지 모두에 해당하는 데이터뿐이다. \n\n1. 매우 자주 읽히거나\n2. 쓰기 빈도가 낮은 데이터\n\n엔티티 또는 컬렉션이 캐시 가능으로 표시되는 경우, 예상되는 데이터 접근 패턴에 적합한 `CacheConcurrencyStrategy` 를 선택하여 2차 캐시에 대한 동시 접근을 관리하는 정책을 표시해야 한다. 업데이트 빈도를 가장 중요하게 고려하는 것이 좋다.\n\n- `NONE`: 동시성 전략을 명시하지 않고, 기본 전략을 사용해야 함을 나타낸다.\n- `NONSTRICT_READ_WRITE`: 공유된 2차 캐시에서 락 없이 읽기 / 쓰기 접근이 가능하다.\n- `READ_ONLY`: 공유된 2차 캐시에서 읽기 전용으로 접근 가능하다.\n- `READ_WRITE`: 공유된 2차 캐시에서 소프트 락을 사용해서 읽기 / 쓰기 접근이 가능하다. \n\t- 두 개의 동시 트랜잭션이 동일한 데이터 항목을 동시에 업데이트하려고 시도할 가능성이 사라지지 않음을 나타낸다. 해당 전략은 소프트 락을 사용하여 동시 트랜잭션이 트랜잭션 완료 과정 중에 캐시에서 오래된 항목을 검색하거나 저장하지 못하도록 방지한다. 소프트 잠금은 업데이트 트랜잭션이 완료되는 동안 캐시에 marker 항목을 배치하는 것이다.\n\t- 2번째 트랜잭션은 소프트 락이 있는 동안 캐시에서 항목을 읽지 않고 일반 캐시 누락이 발생한 것처럼 데이터베이스에서 직접 항목을 읽으려고 할 수 있다. \n\t- 마찬가지로 소프트 락은 2번째 트랜잭션이 최신 버전이 아닐 수 있는 항목을 가지고 데이터베이스를 왕복하고 돌아올 때 오래된 항목을 캐시에 저장하는 것을 방지한다. \n\t- **해당 동시성 전략은 `SERIALIZABLE` 트랜잭션 isolation 과 호환되지 않는다.**\n- `TRANSACTIONAL`: 공유된 2차 캐시에서 트랜잭션으로 접근해야 한다.\n\t- 2차 캐시와 데이터베이스 간의 동기화를 유지하는 유일한 방법은 완전 트랜잭션 cache provider 를 사용하는 것임을 나타낸다. 캐시와 데이터베이스는 JTA 또는 XA 프로토콜을 통해 협력해야 하고, hibernate 자체는 캐시 무결성 유지에 대한 책임을 거의 지지 않는다.\n\n### `RegionFactory`\n\n저장 전용 region 을 포함한 2차 캐시 region 을 구축하기 위해 필요하다. \n- 엔티티, 컬렉션 인스턴스\n- 쿼리 result set\n- 캐시된 쿼리된 result set 이 얼마나 오래 되었는지 판단하는데 사용되는 timestamp\n\n`hibernate.cache.region.factory_class` 속성을 사용하여 선택할 수 있다.\n\n## 쿼리 캐싱\n\n동일한 매개 변수를 사용하여 반복적으로 실행되는 쿼리가 있는 경우, 쿼리 캐싱을 통해 성능 향상을 얻을 수 있다.  \n\n캐싱은 트랜잭션 처리 영역에 오버헤드를 발생시킨다. 예를 들어 엔티티에 대한 쿼리 결과를 캐싱하는 경우 hibernate 에서는 엔티티에 대한 변경 사항이 커밋되었는지 여부를 추적하고, 그에 따라 캐시를 무효화해야 한다.  \n또한 쿼리 결과 캐싱의 이점은 제한적이고, 애플리케이션의 사용 패턴에 따라 크게 달라진다. \n\n### Query Cache enable\n\n1. `hibernate.cache.use_query_cache` 를 true 로 설정한다.\n\t- `org.hibernate.cache.internal.StandardQueryCache` 는 캐싱된 쿼리 결과를 보유한다.\n\t- `org.hibernate.cache.spi.UpdateTimestampsCache` 는 쿼리 가능한 테이블에 대한 가장 최근 업데이트의 타임 스탬프를 보유한다. 해당 타임스탬프는 쿼리 캐시에서 제공되는 결과의 유효성을 검사한다. \n2. 기존 캐시 영역의 캐시 타임아웃 조정하기\n\t- 만료 또는 시간 초과를 사용하도록 기본 캐시 구현을 구성하는 경우, `UpdateTimestampsCache` 에 대한 기본 캐시 영역의 캐시 시간 초과를 쿼리 캐시의 시간 초과보다 높은 값으로 설정한다. `UpdateTimestampsCache` 영역이 만료되지 않도록 설정할 수 있으며, 이를 권장한다. 구체적으로 말하자면 LRU 캐시 만료 정책은 절대 적절하지 않다.\n3. 특정 쿼리에 대한 결과 캐싱 사용 설정\n\t- 대부분의 쿼리는 결과 캐싱의 이점을 누리지 못하므로, 전체적으로 쿼리 캐싱을 사용하도록 설정한 후에도 개별 쿼리에 대해 캐싱을 사용하도록 설정해야 한다. 특정 쿼리에 대해 결과 캐싱을 사용하도록 설정하려면 `org.hibernate.Query.setCacheable(true)` 를 호출한다. \n\n\n## 참고\n\n- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html\n- https://docs.jboss.org/hibernate/orm/6.2/javadocs/org/hibernate/annotations/Cache.html"},{"excerpt":"Vertex Cover 정점 집합 S가 있을 때, 모든 간선은 양 끝점 중 하나가 S 에 포함되어야 한다. 최소 정점 커버란? 정점 집합 S가 있을 때, 모든 간선은 양 끝점 중 적어도 하나가 S 에 포함되어야 한다.\n여러 Vertex Cover 중에 크기가 가장 작은 Vertex Cover 를 의미한다. 근사 degree 가 높은 점을 우선 선택 근사 …","fields":{"slug":"/minimum-vertex-cover/"},"frontmatter":{"date":"2023년 10월 27일 02:10","title":"최소 정점 커버 (Minimum Vertex Cover)","tags":["algorithms"]},"rawMarkdownBody":"\n##  Vertex Cover\n\n정점 집합 S가 있을 때, 모든 간선은 양 끝점 중 하나가 S 에 포함되어야 한다.\n\n## 최소 정점 커버란?\n\n정점 집합 S가 있을 때, 모든 간선은 양 끝점 중 적어도 하나가 S 에 포함되어야 한다.\n여러 Vertex Cover 중에 크기가 가장 작은 Vertex Cover 를 의미한다.\n\n## 근사\n\n### degree 가 높은 점을 우선 선택\n\n근사 비율은 $log n$ 이다.\n\n### 선분을 선택\n\n선택된 선분의 양 끝점에 인접한 선분이 모두 커버된다. 정점 커버는 선택된 각 선분의 "},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-25] 미션 2단계  [priority:: high]  [due:: 2023-10-15]  [completion:: 2023-10-25] LOG 배운 것 ehcache-apply 느낀 것","fields":{"slug":"/2023-10-25/"},"frontmatter":{"date":"2023년 10월 25일 06:10","title":"2023년 10월 25일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-25]\n- [x] 미션 2단계  [priority:: high]  [due:: 2023-10-15]  [completion:: 2023-10-25]\n\n## LOG\n\n## 배운 것\n\n- [[ehcache-apply]]\n\n## 느낀 것"},{"excerpt":"구글에 Spring Boot 3.x.x 버전의 JPA 2차 캐시 설정 방법이 없어서 하루를 삽질해서, 다른 분들은 쉽게 설정하셨으면 하는 마음에 정리하는 글입니다. 의존성 설정하기 gradle 파일에 아래의 의존성을 추가해주어야 합니다.  설정 이전 버전에서는  를  라고 적으라는 글이 많은데, Spring Boot 3.x.x 버전에서는 다음과 같이 작성…","fields":{"slug":"/ehcache-apply/"},"frontmatter":{"date":"2023년 10월 25일 03:10","title":"JPA 2차 캐시 적용하기","tags":["shook","jpa","spring"]},"rawMarkdownBody":"\n구글에 Spring Boot 3.x.x 버전의 JPA 2차 캐시 설정 방법이 없어서 하루를 삽질해서, 다른 분들은 쉽게 설정하셨으면 하는 마음에 정리하는 글입니다.\n\n## 의존성 설정하기\n\ngradle 파일에 아래의 의존성을 추가해주어야 합니다.\n\n```groovy\n// cache  \nimplementation 'org.hibernate.orm:hibernate-ehcache:6.0.0.Alpha7'  \nimplementation 'org.hibernate.orm:hibernate-jcache:6.3.1.Final'  \nimplementation 'org.ehcache:ehcache:3.10.8'\n```\n\n## `application.yml` 설정\n\n이전 버전에서는 `region.factory_class` 를 `org.hibernate.cache.ehcache.EhCacheRegionFactory` 라고 적으라는 글이 많은데, Spring Boot 3.x.x 버전에서는 다음과 같이 작성해야 합니다.\n\n```yml\nspring:\n\tjpa:  \n\t  properties:  \n\t    javax:  \n\t      cache:  \n\t        provider: org.ehcache.jsr107.EhcacheCachingProvider  \n\t        uri: classpath:ehcache.xml\n\t      persistence:  \n\t        sharedCache:  \n\t          mode: ENABLE_SELECTIVE  \n\t    hibernate:  \n\t      format_sql: true  \n\t      show-sql: true  \n\t      cache:  \n\t        use_second_level_cache: true  \n\t        region:  \n\t          factory_class: jcache  \n```\n\n`factory_class` 와 `provider` 가 추가되었습니다.\n`uri` 에는 ehcache 설정이 있는 xml 경로를 지정합니다.\n\n### `ehcache.xml` 작성하기\n\n```xml\n<config  \n  xmlns='http://www.ehcache.org/v3'  \n  xmlns:jsr107='http://www.ehcache.org/v3/jsr107'>  \n  \n  <service>    \n\t  <jsr107:defaults enable-statistics=\"true\"/>  \n  </service>  \n  <cache alias=\"songCache\">  \n\t  <key-type>java.lang.Long</key-type>  \n\t  <value-type>shook.shook.song.domain.Song</value-type>  \n\t  <expiry>      \n\t\t  <ttl unit=\"seconds\">10000</ttl>  \n\t  </expiry>    \n\t  <resources>      \n\t\t  <offheap unit=\"MB\">100</offheap>  \n\t  </resources>  \n    </cache>\n</config>\n```\n\nEhCache 3.x 버전을 위한 캐시 설정 파일입니다.  \n\n- `enable-statistics`: 캐시 통계 수집을 활성화 / 비활성화할 수 있습니다. true 면 캐시 동작에 대한 통계를 수집합니다.\n- `alias`: 캐시의 이름(별칭)을 지정합니다. \n- `value-type`: 캐싱하려는 클래스의 상대 경로를 적어줍니다. \n- `key-type`: 캐시 키의 자료형을 지정합니다.\n- `expiry`: 캐시 항목의 만료 시간을 설정합니다. (초 단위)\n- `resources`: 캐시가 사용하는 리소스를 지정합니다.\n\t- `<offheap>`: 캐시 데이터를 JVM 힙 외부에 저장하도록 설정합니다. JVM 가비지 컬렉션에 영향을 받지 않아, 성능 향상을 기대할 수 있습니다. 현재는 100MB 의 오프힙 메모리를 사용하도록 설정되어 있습니다.\n\n캐싱 적용을 위해서는 `Application.java` 에 다음과 같은 코드를 추가하면 됩니다.\n\n```java\n@EnableCaching    // 이 부분!\n@SpringBootApplication  \npublic class ShookApplication {  \n  \n    public static void main(String[] args) {  \n        SpringApplication.run(ShookApplication.class, args);  \n    }  \n}\n```\n\n## `@Cache` 어노테이션\n\n캐싱을 원하는 엔티티 위에 `@Cache` 어노테이션을 달아줍니다. \n\n```java\n@Cache(usage = CacheConcurrencyStrategy.READ_ONLY)  \n@Entity  \npublic class Song {\n```\n\n`usage` 에는 동시성 전략을 명시해줄 수 있습니다.\n\n자세한 설정은 [[cache-and-cacheable]] 에서 확인하실 수 있습니다.\n"},{"excerpt":"면접 전에 이력서 숙지 코테: 기본기\n이력서 + 코테: 구현 능력\n이력서: 성장 가능성\n1, 2차 면접: 커뮤니케이션, 태도, 협업 꿀팁 반드시 회사의 채용 자격 (Job Description) 확인 조직 소개 주요 업무 자격 요건\n우대 사항 (가산점) 1분 자기소개 & 지원 동기 나는 어떤 사람 / 어떤 개발자이고 싶은가 그동안 어떤 경험을 했고, 개발…","fields":{"slug":"/interview-special-lecture/"},"frontmatter":{"date":"2023년 10월 25일 01:10","title":"면접 특강","tags":["우테코","레벨4"]},"rawMarkdownBody":"\n## 면접 전에 이력서 숙지\n\n코테: 기본기\n이력서 + 코테: 구현 능력\n이력서: 성장 가능성\n1, 2차 면접: 커뮤니케이션, 태도, 협업\n\n## 꿀팁\n\n### 반드시 회사의 채용 자격 (Job Description) 확인\n\n1. 조직 소개\n2. 주요 업무\n\n자격 요건\n우대 사항 (가산점)\n\n### 1분 자기소개 & 지원 동기\n\n- 나는 어떤 사람 / 어떤 개발자이고 싶은가\n- 그동안 어떤 경험을 했고, 개발자가 되기 위해 어떤 노력을 해왔는가\n- 어떤 개발자로 성공하고 싶은가\n\n자기소개서와 채용 자격을 기반으로 지원 동기를 엮어보자. 개발자로서 해온 그동안의 경험과 노력이 지원 동기가 되면 좋다. \n회사는 성장할 사람을 뽑지 않고, 회사에 도움이 되는 사람을 뽑는다.\n\n## 레벨인터뷰 총평\n\n### 면접 태도\n\n#### 좋았던 점\n\n- 대체적으로 침착하게 균일한 톤으로 답변\n- 자신이 아는 범위 내에서 최대한 답변하려는 노력이 보인다는 점\n- 질문이 이해가 안 됐을 때, 혹은 확인차 다시 질문의 의도를 물어보는 태도\n- 뒤죽박죽으로 답변하기 보다는 정리한 후 답하려고 노력했다는 점\n\n#### 더 성장하려면\n\n- 긴장 풀자! 경직된 태도보다는 유연한 자세, 긍정적인 태도가 필요하다.\n- 죄송합니다 금지\n- 방어기제 세우지 말자\n\t- ex. 잘 모르겠습니다. 그렇지만 ~~ \n- 답변에 끝맺음이 없고, 말꼬리를 흐리면서 대답한다.\n- 문장의 호흡을 짧게 가져가자. (영어 면접도 똑같을까?)\n\n### 답변은 어떻게 해야 할까?\n\n- 면접은 대화의 과정. 갑과 을이 아니다.\n- 단답으로만 이루어지는 답변은 면접관과 대화를 이어나갈 수 없다.\n- 어떤 것을 학습했는지, 학습한 것을 실행에 옮겼는지, 무엇을 배웠는지 정확히 알고 있어야 한다. 본인의 경험을 확실하게 인지하는 것이 중요하다.\n- 두괄식으로 대답하기: '결론 - 예시 (경험) - 결론'\n\n"},{"excerpt":"JPA 2차 캐시  범위로 지정되어, 동일한  로 생성된 모든 세션에서 공유된다. 엔티티 인스턴스가 ID 로 조회되고, 해당 엔티티에 대해 2차 캐싱이 활성화되면 다음과 같이 작동한다. 인스턴스가 이미 1차 캐시에 있는 경우, 1차 캐시에서 인스턴스가 반환된다. 인스턴스가 1차 캐시에서 발견되지 않고 해당 인스턴스 상태가 2차 캐시에 캐싱되어 있는 경우에…","fields":{"slug":"/jpa-second-cache/"},"frontmatter":{"date":"2023년 10월 24일 04:10","title":"JPA 2차 캐시","tags":["jpa","hibernate","spring"]},"rawMarkdownBody":"\n## JPA 2차 캐시\n\n`SessionFactory` 범위로 지정되어, 동일한 `SessionFactory` 로 생성된 모든 세션에서 공유된다. 엔티티 인스턴스가 ID 로 조회되고, 해당 엔티티에 대해 2차 캐싱이 활성화되면 다음과 같이 작동한다. \n\n1. 인스턴스가 이미 1차 캐시에 있는 경우, 1차 캐시에서 인스턴스가 반환된다.\n2. 인스턴스가 1차 캐시에서 발견되지 않고 해당 인스턴스 상태가 2차 캐시에 캐싱되어 있는 경우에는 해당 캐시에서 데이터를 가져와 인스턴스를 반환한다.\n3. 필요한 데이터가 데이터베이스에서 로드된 뒤, 인스턴스가 반환된다.\n\n인스턴스가 1차 캐시에 저장되면 세션이 닫히거나, 인스턴스가 수동으로 영속성 컨텍스트에서 제거될 때까지 동일한 세션 내의 모든 호출에서 해당 인스턴스가 반환된다. 로드된 인스턴스는 L2 캐시에도 저장된다.\n\n## 2차 캐시 설정\n\n```yml\nspring:\n\tjpa:  \n\t  properties:  \n\t    hibernate:  \n\t      format_sql: true  \n\t      show-sql: true  \n\t    cache:  \n\t\t    use_second_level_cache: true  \n\t\t\tquery_cache_factory: org.hibernate.cache.ehcache.EhCacheRegionFactory  \n\t\tjavax:  \n\t\t\tpersistence:  \n\t\t\tsharedCache:  \n\t\t\t    mode: ENABLE_SELECTIVE\n```\n\n## Hibernate 캐시 동시성 전략\n\n`@Cache` 의 속성인 usage 값으로 `CacheConcurrentStrategy` 를 설정해서 캐시의 동시성 전략을 설정할 수 있다. \n\n- `READ_ONLY` : 읽기 전용. 변하지 않는 데이터를 대상으로 사용하는 것이 좋다.\n- `NONSTRICT_READ_WRITE`: 객체 동시 수정 등에 대한 고려를 전혀 하지 않고 캐싱한다. 하나의 객체가 동시에 수정될 가능성이 거의 없는 경우 사용한다.\n- `READ_WRITE`: 엄격한 읽기 / 쓰기로 두 개 이상의 스레드에서 동시 수정할 가능성에 대해 고려하고 만들어야 한다.\n\n## `@Cacheable`\n\n\n\n## 참고\n\n- https://www.baeldung.com/hibernate-second-level-cache"},{"excerpt":"개요 S-HOOK 은 메인 화면에서 전체 노래를 '좋아요 순으로' 정렬해서 10개의 노래만 보여주고 있다. 장르별 노래도 마찬가지로 좋아요 순으로 정렬 후, 10개의 노래만 클라이언트로 전달한다.  전체 노래를 좋아요 순으로 정렬할 때 DB에서 정렬을 수행하게 되면 쿼리 속도가 굉장히 느려지게 된다. 그렇다고 애플리케이션 단에서 정렬을 수행하면, 전체 데…","fields":{"slug":"/inmemory-cache-develop/"},"frontmatter":{"date":"2023년 10월 24일 04:10","title":"로컬 캐시 개선기","tags":["shook"]},"rawMarkdownBody":"\n## 개요\n\nS-HOOK 은 메인 화면에서 전체 노래를 '좋아요 순으로' 정렬해서 10개의 노래만 보여주고 있다. 장르별 노래도 마찬가지로 좋아요 순으로 정렬 후, 10개의 노래만 클라이언트로 전달한다.\n\n![[shook-main-page.png]]\n\n전체 노래를 좋아요 순으로 정렬할 때 DB에서 정렬을 수행하게 되면 쿼리 속도가 굉장히 느려지게 된다. 그렇다고 애플리케이션 단에서 정렬을 수행하면, 전체 데이터를 조회한 뒤에 정렬을 수행해야 하기 때문에 마찬가지로 좋은 방법은 아니다. \n\n따라서 S-HOOK 은 메인 화면이니만큼 가장 많이 조회되는 API 이고, 자주 동일한 데이터를 전달하고 있어 로컬 캐싱을 적용했는데, 그 과정에서 사용자가 누른 좋아요가 반영되지 않는다는 큰 문제점이 존재한다.\n\n## 왜 지금의 로컬 캐싱을 개선해야 할까?\n\n현재 로컬 캐싱은 `Map` 으로 구현되어 있다. Map 에 저장하는 정보는 songId 를 키로 해서, Song 을 value 로 갖는 구조이다.\n\n```java\n@RequiredArgsConstructor  \n@Transactional(readOnly = true)  \n@Slf4j  \n@Component  \npublic class InMemorySongsScheduler {  \n  \n    private final SongRepository songRepository;  \n    private final InMemorySongs inMemorySongs;  \n  \n    @PostConstruct  \n    public void initialize() {  \n        recreateCachedSong();  \n    }  \n  \n    @Scheduled(cron = \"${schedules.in-memory-song.cron}\")  \n    public void recreateCachedSong() {  \n        log.info(\"InMemorySongsScheduler worked\");  \n        inMemorySongs.recreate(songRepository.findAllWithKillingParts());  \n    }  \n}\n```\n\n특정 시간마다 `SongRepository` 에서 한 번에 노래와 노래의 킬링파트를 조회해서 로컬 캐시를 생성한다. 해당 노래를 Map 으로 저장한 뒤 데이터베이스가 아닌 로컬 캐시에서 노래를 조회하는 방식이다. 로컬 캐시는 하루에 한 번 데이터베이스에서 데이터를 조회하고, 기존 로컬 캐시 데이터를 모두 삭제하는 방식으로 갱신된다.\n\n이때 문제점은 저장한 캐시 데이터의 좋아요 데이터가 갱신되지 않는다는 점이다. S-HOOK은 사용자의 좋아요 데이터가 차트에 사용되기 때문에 실시간성이 중요한데, 기존 캐싱 방법에서는 좋아요 데이터에 따라 데이터가 변화하지 않기 때문에 서비스가 추구하는 방향성과 맞지 않다.\n\n따라서 실시간으로 좋아요 데이터를 반영하기 위해 로컬 캐싱을 개선하기로 했다.\n\n## 개선 방법\n\n1. 로컬 캐싱에 좋아요를 실시간으로 반영하고, 좋아요로 인해 순위 변동이 생긴 경우 변경된 순위를 반영하는 코드를 작성한다.\n2. 구현체를 LinkedHashMap 으로 구현했을 때 성능 테스트\n3. 구현체를 TreeMap 으로 변경했을 때 성능 테스트\n4. DTO 프로젝션을 사용했을 때 성능 테스트\n\n### 좋아요 데이터를 실시간으로 순위에 반영하기\n\n자세한 내용은 [[inmemory-cache-develop-reason|로컬 캐시의 좋아요 데이터 갱신하기]]를 확인하자.\n\n## 테스트\n\n### 환경\n\n- 로컬에서 실행\n\t- Apple M1 Pro 기준 메모리 16GB, CPU 8코어\n- 노래 데이터 10000개\n- 킬링파트 데이터 30000개\n- 조회 시 사용하는 멤버는 모든 킬링파트에 좋아요를 누른 상태 (좋아요 데이터 30000개)\n\nS-HOOK 에서 가장 시간이 오래걸리는 쿼리인 \"노래를 스와이프할 때 현재 노래, 현재 노래보다 좋아요가 많거나 같은 노래 10개 (좋아요 내림차순 정렬, 좋아요가 같을 경우 id 내림차순 정렬), 현재 노래보다 좋아요가 적거나 같은 노래 10개 (좋아요 내림차순 정렬, 좋아요가 같을 경우 id 내림차순 정렬) 를 조회하는 API\" 를 기준으로 테스트하였다. 지금부터는 스와이프 API 라고 짧게 부르도록 하겠다.\n\n테스트 시 호출된 API 순서이다.\n\n1. 10번 노래에서 스와이프 API 호출\n2. 18번 노래의 좋아요 증가\n3. 10번 노래에서 스와이프 API 호출\n4. 18번 노래 좋아요 취소\n\n즉, 18번의 순위가 계속해서 변경될 때를 테스트한다.\n\n사용되는 쿼리는 다음과 같다.\n\n```java\n@Query(\"SELECT s FROM Song s \"  \n    + \"LEFT JOIN s.killingParts.killingParts kp \"  \n    + \"GROUP BY s.id \"  \n    + \"HAVING SUM(COALESCE(kp.likeCount, 0)) < (SELECT SUM(COALESCE(kp2.likeCount, 0)) FROM KillingPart kp2 WHERE kp2.song.id = :id) \"  \n    + \"OR (SUM(COALESCE(kp.likeCount, 0)) = (SELECT SUM(COALESCE(kp3.likeCount, 0)) FROM KillingPart kp3 WHERE kp3.song.id = :id) AND s.id < :id) \"  \n    + \"ORDER BY SUM(COALESCE(kp.likeCount, 0)) DESC, s.id DESC\")  \nList<Song> findSongsWithLessLikeCountThanSongWithId(  \n    @Param(\"id\") final Long songId,  \n    final Pageable pageable  \n);  \n  \n@Query(\"SELECT s FROM Song s \"  \n    + \"LEFT JOIN s.killingParts.killingParts kp \"  \n    + \"GROUP BY s.id \"  \n    + \"HAVING (SUM(COALESCE(kp.likeCount, 0)) > (SELECT SUM(COALESCE(kp2.likeCount, 0)) FROM KillingPart kp2 WHERE kp2.song.id = :id) \"  \n    + \"OR (SUM(COALESCE(kp.likeCount, 0)) = (SELECT SUM(COALESCE(kp3.likeCount, 0)) FROM KillingPart kp3 WHERE kp3.song.id = :id) AND s.id > :id)) \"  \n    + \"ORDER BY SUM(COALESCE(kp.likeCount, 0)), s.id\")  \nList<Song> findSongsWithMoreLikeCountThanSongWithId(  \n    @Param(\"id\") final Long songId,  \n    final Pageable pageable  \n);\n```\n\n### DB 에서 직접 조회하는 경우\n\n18번의 순위가 계속해서 변경될 때, 조회 시 평균적으로 310ms 정도의 성능이 나오는 것을 확인할 수 있었다.\n\n![[query-direct-find.png]]\n\n### `LinkedHashMap` 을 사용하여 좋아요 실시간 반영\n\n노래 Id 를 정렬된 상태로 유지하고, 노래를 저장한다.  \n좋아요가 변경되면 전체 `LinkedHashMap` 을 정렬한다.  \n\n```java\npublic void recreate(final List<Song> songs) {  \n    sortedIds = new ArrayList<>(songsSortedInLikeCountById.keySet().stream()  \n.sorted(Comparator.comparing(songsSortedInLikeCountById::get, COMPARATOR))  \n                                    .toList());  \n    ...\n}\n\nprivate void sortSongIds() {  \n    sortedIds.sort(Comparator.comparing(songsSortedInLikeCountById::get, COMPARATOR));  \n}\n```\n\nDB 에서 조회했을 때보다 10배의 성능 개선이 된 것을 볼 수 있다.\n\n![[linked-hash-map-all-sort.png]]\n\n### `TreeMap` 으로 좋아요 실시간 반영\n\n삽입, 삭제에 $log(N)$ 의 시간복잡도를 갖는 `TreeMap` 을 사용하면 성능이 개선될 것이라고 생각했다. \n\n그러나 `TreeMap` 의 특성 상 `LinkedHashMap` 보다 조회 속도가 느렸다. 또한 `TreeMap` 은 삽입, 삭제에서 정렬이 발생하기 때문에 기존에 있는 Map 의 키를 삭제해야만 했는데, 삭제 후 삽입하는 속도가 `LinkedHashMap` 에 비해 크게 개선되지 않았다. \n\n따라서 `LinkedHashMap` 을 사용하는 것이 더 좋은 성능을 보여준다는 결론을 내렸다.\n\n아래 테스트 결과에서도 `LinkedHashMap` 에 비해 성능이 20% 정도 악화된 것을 볼 수 있다.  \n\n![[tree-map-develop.png]]\n\n### 삽입 정렬로 거의 정렬된 데이터 순서 바꾸기\n\n데이터가 거의 정렬된 데이터이고, 단 하나의 노래 데이터의 순서만 바뀌기 때문에 삽입 정렬이 더 효율적이라고 생각했다.\n\n`List.sort` 대신 좋아요가 증가한 경우 앞 쪽으로 swap 하고, 좋아요가 감소한 경우 뒷 쪽으로 swap 을 진행했다.\n\n```java\npublic void pressLike(final KillingPart killingPart, final KillingPartLike likeOnKillingPart) {  \n    final Song song = songsSortedInLikeCountById.get(killingPart.getSong().getId());  \n    final KillingPart killingPartById = findKillingPart(killingPart, song);  \n    final boolean updated = killingPartById.like(likeOnKillingPart);  \n    if (updated) {  \n        adjustSongPosition(song);  \n    }  \n}  \n  \npublic void adjustSongPosition(Song changedSong) {  \n    int currentIndex = sortedIds.indexOf(changedSong.getId());  \n  \n    if (currentIndex == -1) {  \n        return; // 노래를 찾지 못했을 경우  \n    }  \n  \n    // 좋아요가 증가한 경우 (높은 좋아요 순으로 앞으로 이동)  \n    if (shouldMoveForward(changedSong, currentIndex)) {  \n        while (currentIndex > 0 &&  \n            shouldSwapWithPrevious(changedSong, songsSortedInLikeCountById.get(sortedIds.get(currentIndex - 1)))) {  \n            // 이전 노래와 위치 교환  \n            swap(sortedIds, currentIndex, currentIndex - 1);  \n            currentIndex--;  \n        }  \n    }    // 좋아요가 감소한 경우 (낮은 좋아요 순으로 뒤로 이동)  \n    else {  \n        while (currentIndex < sortedIds.size() - 1  \n            && shouldSwapWithNext(changedSong, songsSortedInLikeCountById.get(sortedIds.get(currentIndex - 1)))) {  \n            // 다음 노래와 위치 교환  \n            swap(sortedIds, currentIndex, currentIndex + 1);  \n            currentIndex++;  \n        }  \n    }}  \n  \nprivate boolean shouldMoveForward(Song song, int index) {  \n    return index > 0 && shouldSwapWithPrevious(song, songsSortedInLikeCountById.get(sortedIds.get(index - 1)));  \n}  \n  \nprivate boolean shouldSwapWithPrevious(Song song, Song previousSong) {  \n    return song.getTotalLikeCount() > previousSong.getTotalLikeCount() ||  \n        (song.getTotalLikeCount() == previousSong.getTotalLikeCount() && song.getId() > previousSong.getId());  \n}  \n  \nprivate boolean shouldSwapWithNext(Song song, Song nextSong) {  \n    return song.getTotalLikeCount() < nextSong.getTotalLikeCount() ||  \n        (song.getTotalLikeCount() == nextSong.getTotalLikeCount() && song.getId() < nextSong.getId());  \n}  \n  \nprivate void swap(List<Long> list, int i, int j) {  \n    Long temp = list.get(i);  \n    list.set(i, list.get(j));  \n    list.set(j, temp);  \n}\n```\n\n그 결과 좋아요를 수행하는 연산의 성능이 약 17% 개선되었다.  \n비교해야 하는 데이터가 많을수록 시간 복잡도가 증가하기 때문에, 비교해야 하는 데이터가 많은 좋아요 true 의 연산 속도보다 좋아요 false 의 연산 속도가 더 빠른 것을 볼 수 있다. \n\n![[insertions-sort-like-sort.png]]\n\n### 이진 탐색으로 시간 복잡도 최적화\n\n그러나 삽입 정렬은 최악의 경우 O(N) 의 복잡도를 가질 수 있다. 현재는 계속해서 swap 으로 이동을 해주고 있기 때문에 O(N) 의 복잡도가 추가로 들어 최악의 최악 상황에서는 O(N^2) 이 걸릴 수도 있다.\n\n따라서 최악의 경우에도 O(logN) 의 시간 복잡도를 갖는 이진 탐색을 사용하여 데이터가 삽입되어야 하는 위치를 찾아서 해당 위치에 데이터를 삽입하는 방식으로 구현해보았다. \n\n"},{"excerpt":"참고 https://medium.com/watcha/%EC%BF%BC%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%B2%AB%EA%B1%B8%EC%9D%8C-%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-7%EA%B0%80…","fields":{"slug":"/query-speed-improve/"},"frontmatter":{"date":"2023년 10월 24일 04:10","title":"쿼리 속도 향상을 위한 방법","tags":["shook"]},"rawMarkdownBody":"\n\n\n## 참고\n\n- https://medium.com/watcha/%EC%BF%BC%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%B2%AB%EA%B1%B8%EC%9D%8C-%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-7%EA%B0%80%EC%A7%80-%EC%B2%B4%ED%81%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-bafec9d2c073"},{"excerpt":"태양 가까이 날면 위험해, 이카로스. 넌 앞으로 뭘 하고 싶어? 지금은 부끄럽지만, 나에게는 그런 자부심이 있었다. 내가 좋아하는 것만큼은 잘할 수 있다. 하지만 좋아하는 걸 찾는 것 자체가 어려운 일이었다. 어렸을 때부터 항상 주위의 누군가 물어보던 \"넌 앞으로 뭘 하고 싶어?\" 라는 질문에 대답하는 게 가장 힘들었으니 말이다. 그래서 그런 갈증이 있었…","fields":{"slug":"/level4-writing/"},"frontmatter":{"date":"2023년 10월 23일 11:10","title":"나는 어떤 개발자가 되고 싶은가","tags":["우테코","레벨4"]},"rawMarkdownBody":"\n*태양 가까이 날면 위험해, 이카로스.*  \n  \n## 넌 앞으로 뭘 하고 싶어?  \n  \n지금은 부끄럽지만, 나에게는 그런 자부심이 있었다.  \n  \n> 내가 좋아하는 것만큼은 잘할 수 있다.  \n  \n하지만 좋아하는 걸 찾는 것 자체가 어려운 일이었다.    \n어렸을 때부터 항상 주위의 누군가 물어보던 \"넌 앞으로 뭘 하고 싶어?\" 라는 질문에 대답하는 게 가장 힘들었으니 말이다.  \n  \n그래서 그런 갈증이 있었다.  \n  \n> 좋아하는 걸 뭐라도 찾고 싶다. 진짜로 열심히 할 텐데.  \n  \n그렇지만 아무것도 찾아내지 못한 채로, 그렇게 몇 년이 흘렀다.  \n  \n사람들이 물어보던 질문이 정말로 궁금해서 물어보는 게 아니었다는 걸 알게 될 때쯤, 난 \"계속 공부를 하고 싶다\" 라는 두루뭉술한 대외적 답변을 하나 준비했다. 질문에 대답할  \n때마다 '이게 정말 하고 싶은 게 맞을까?'라는 생각이 들어도 애써 무시했다. 남들 다 있는 목표 하나 없는 사람이 되는 건 싫다는 소심한 자존감 때문이었다.  \n  \n그저 그런 생각만으로 왜 살아가야 하는지 고민하게 되었던 고등학교 1학년, 나는 동아리의 구석 자리 선배들의 컴퓨터 속 고양이 게임에 매료되었다.  \n  \n## 움직이는 고양이  \n  \n별것도 아니었다. 고양이가 하늘을 날고, 사과를 먹으니 점수가 올랐다.    \n선배들은 그 조그만 화면을 보면서 웃기다며 깔깔댔다.  \n  \n그냥 그런 생각을 했다. 해보고 싶다.  \n  \n동아리에 들어가서 선배들이랑 간단한 게임도 만들고, 대학교 MOOC 강의도 들어봤다. 수능 공부할 시간을 쪼개 C언어를 공부했고, 주말에도 앱을 만들러 전남대학교에 갔다. 잠이  \n많은 내가 컴퓨터와 함께할 때면 자야 한다는 걸 잊을 만큼 재밌었다.  \n  \n그때 정했다. 나는 프로그래머가 되어야겠다고.  \n  \n순전히 재미 때문에 컴퓨터 공학과에 진학했고, 대학교에 가면 관련 공부만 할 생각에 즐거웠다.     \n하지만 그때도 몰랐다. 프로그래머도 여전히 막연한 목표였다는 걸.  \n  \n## 나는 밀랍 날개를 달고, 내가 새인 줄 착각했다.  \n  \n으레 다른 사람들이 꿈꾸듯, 나도 '서비스로 세상에 기여하는 개발자'가 되고 싶었다.    \n'서비스로 세상에 기여하는 개발자'라는 태양은 태양이란 게 무엇인지 정확히 몰랐던 내게도 아름다워 보였다.    \n그 꿈은 어찌나 드높은지, 모두가 우러러보는 길이었다.  \n  \n갈 길이 멀었다.      \n난 호기롭게 날아올랐다. 태양을 향해.  \n  \n그저 전공 공부만 하면 개발 실력이 늘 거로 생각했다.    \n그저 뭔가를 만들 수만 있다면 그 꿈에 다가갈 수 있을 거로 생각했다.    \n그런데도 가까워지지 않았다. 왜인지 계속 제자리에 멈춘 듯한 느낌이었다.  \n  \n\"내가 하고 있는 게 뭐지?\"    \n\"왜 이런 공부를 하고 있을까?\"    \n\"이렇게 하면 정말로 세상에 기여할 수 있는 서비스를 만들 수 있을까?\"    \n\"잘 공부하고 있는 걸까?\"    \n  \n이런 답도 없는 막막한 고민을 하게 될 때쯤, 내 앞에 먼저 날아간 사람들이 너무 많다는 걸 알게 됐다.    \n그들은 멀리 있었고, 난 조급해졌다. 그렇지만 먼저 출발한 그들을 따라잡으려면 시간이 필요했고, 원하던 목표는 단기간에 도달할 수 없는 경지였다.  \n  \n난 당장 태양을 향해 가고 싶었다.  \n태양은 드높은데, 내 날개는 밀랍이 녹아 듬성듬성했다.    \n날아가는 고된 과정에서 아등바등하는 상황이 참 싫었다.    \n열정도 체력도 고갈된 나는 그렇게 추락했다. 바다로.  \n  \n## 바다. 그리고 파도  \n  \n바닥난 자존감과 함께 추락한 바다는 추웠다. 그땐 처음으로 내가 \"못하는 사람\"이라고 느낀 순간이었다.    \n한동안 떠다니기만 했다. 좋아하는 것도 못 하면 어떡하지, 라는 생각이 들었다. 더 이상 아무것도 못 할 것만 같아서 무서웠다.  \n  \n그 당시 공부하던 알고리즘만 봐도 불안했다. 문제를 풀다 막막해서 울던 날도 많았고, 하고 있던 일만 억지로 마칠 수 있었다.    \n그러다 우테코 공고를 보게 됐다. 여기서라면 원하던 공부를 할 수 있을 것만 같았다.    \n힘들었지만, 겨우겨우 일어나서 프리코스를 했다. 정말 운이 좋게도, 다시 파도에 떠밀려 우테코에 올 수 있었다.  \n  \n## 함께 날자  \n  \n우테코는 신기했다. 주변의 크루들과는 경쟁하지 않아도 됐다. 서로가 서로의 동료이자 선생님, 길잡이였다.  \n앞에 날아가고 있던 새들도 나처럼 날갯짓하는 똑같은 사람이었다.        \n그래서 그런지, 더 이상 무언가를 증명하지 않아도 된다는 생각이 들었다.      \n나는 모두를 이기고 싶었던 게 아니었다. 그저 좋아하는 것을 하고 싶었을 뿐이었다.  \n  \n난 여전히 검은 화면에 올라오는 흰색 글자들을 사랑한다.    \n크루들과 토론하는 시간, 끝없는 에러를 고치는 과정도 언제나 즐겁다.  \n  \n이젠 자신있게 말할 수 있다. 나는 즐겁게 개발하는 개발자가 되고 싶다!    \n막연한 목표로 향하기만 하는 사람이 아니라, 과정 자체를 즐길 줄 아는 사람이 되고 싶다.  \n  \n어쩔 수 없는 숙명인지, 태양을 좇고 싶다. 하지만 목표까지 가는 길이 힘들어도 이제는 괜찮다. 옆에서 같이 날아줄 사람들이 많으니까. 내가 추락하기 전에 잡아줄 거다.      \n앞서가는 사람들의 존재도 지금은 그렇게 위협적이지 않다. 오히려 그들과 **함께** 날고 싶다.       \n앞지르는 건 중요하지 않다. 내 페이스에 맞춰 가기만 하면 된다.  \n  \n오늘도 날개를 고쳐 맨다. 태양열에 내 열정이 녹아내리지 않게.    \n태양은 드높아도, 가는 길이 재밌으니까. 그거면 됐다."},{"excerpt":"🔐β aHoJVsnkSKKz+XRqDtEXgN3uMtHpo56eXx4QC3on9i1dxPC6bGcEM/6fTRuWBGNH4M9gyzdj2ZcTDzGACLiqfr9oq1Sbg2hwxSJ1CejDpHe6RtssoZtjd5zVLOeE+okyy6/7UxEns865oKdhHx9rrjEC38s/UwAxVNCYnLqerSh/qLw1isHcOMGNP6iSMMFPG/jb…","fields":{"slug":"/delivery-hero-employment/"},"frontmatter":{"date":"2023년 10월 23일 10:10","title":"DH 채용 설명회","tags":null},"rawMarkdownBody":"\n🔐β aHoJVsnkSKKz+XRqDtEXgN3uMtHpo56eXx4QC3on9i1dxPC6bGcEM/6fTRuWBGNH4M9gyzdj2ZcTDzGACLiqfr9oq1Sbg2hwxSJ1CejDpHe6RtssoZtjd5zVLOeE+okyy6/7UxEns865oKdhHx9rrjEC38s/UwAxVNCYnLqerSh/qLw1isHcOMGNP6iSMMFPG/jb0TwZ48v26aa7iRTCsug+0KUegXayFu6BKTspjhiY60hw/gfV6/JZyLFdYi+RTDIxWq9DC2C21fILyBYKbNYHMQ83I4my+47hitx1fZx4GbabSZu+MvoOPpkAviX31KfPAio21i+wvGRdBEriuNdiqakC8alScfpUOpt/XiyL/ADdrEBIipviwg6oI9N35Df5rFjKvgbsFqpsKcSF9jpJmQFulme/J9i1MrGktiCtP3X2hFAcv8gXORdmHC73T1BREeJ7CHxVdmBJSuUSQnLd5AlaxYB9VvrGrECfNK+etqtAnz//uUVZ9G9Si6lD0FDkGvWCRr3wLVu5QsAbo6yxsEwhs+59JnIAK+Me4fZIdrsc/FL8dFT2bkDGzR0s1u8dGOdImtzVqtZIS1kl0NIvNFaHxJw51Okdas51minU7IKD8wkFpphjg+aQZjCwxRRTNQVqsRT0jHdWu15CriPupVyjjWN+qkwmjXCXnamiC3Zclq+yXkkGb87RX8VF2NDR3Ude7KbZtn5gkgGsr9H6Vpw9y701TwreDGxkMwrsdHaxaIZLe7pve1+yUslgaNwTA3QyJX3dzEgvYtC9v1WDoUKmwukm1cQIadGa3gML+9RAA3J4qltNH24av1A5n/SuIBBprLF4RvMBrWo+BgjAXzwSVgtGazWNXxTTu5UfTBmwRxPnKeX0b3SxEpcwSnBzOYKPAZBi5thqOz9VUKelQYwh08JfGSxEZllEAOfpelFsKA2EbUR4yDm1Sr3pDhObmLrgUJdGW8vzmRosRmDTZr6B/KRjlziwGBwPp8ESNAcnIGWgDH6X7h45G+sDABmjxsvuQKGeXHnpdnZeka7CLQ0CjI5Bu5RQzhOR7VsYl5BIAFi4CyHNm5S+nE1McBlpTda4sTQceMpzpNDSTFrJmdjFoQMppctxELbVsKDyEhUNdOAagiHzPoM3C6LEhBTosSZrzeaxdiAMwCzARr2m6ySRlI6B3q0kf7VlzpOFQDzWoeVRSfMFztjv1UsMVu0vVrcMfUWXcnQu7D1wydUQk0/weywjEhSxnQa3hngLJdueKTUPrswwnmN7C4hGuNycyoIvVcWzQsOM8iooIBMd52j3zAdD4Iq/PM/F5/jfaFUiKDDzQwepcRNC9cmGjttESMNtx65cGIeTLBJVlIlB95AP+04VDTq/d9a0N1AkS+Q/FnvNyzqKK3mLkfHoG6lL8EGUSUILyMMvWM4bbytoCqtww/NyfEDXXWZIkjW+67VeDrC/C9JlqdI2ZATKvyaPyl8nm7nn6wtY4ng+aIO/wRm/d7H9sMZI8R37BFsUbimIdlrJNI8EjL4Br+VgP/pEKhMF0XfT07JP3GqIdoUBoyiXaPe6XdGeuiYoqVpIkOd2+YPjeZByzngEB7MLZ9Tb2fIFWX1663yzAZrLZXcmxiI7VYXkZOAWN74QnxZQICLXh7nx1DLg0BXzGu0KK+61h43o4LkQlUCd9k7XpaLuvW/yiMGnTr+Rbzd71MQz8b7scBJ2LDm9BCQAVotAe9MUDqUtXeAZB/jlNzMBJ6kLMeFXdjzaEZJc0tHeZc2hRPzOckhOUIg4QraammUE81wEG12jRMy80UQMKDGMuJdeRr3T4yb0D4Dxzh+c+xlcn8ewoMey5dbLWsHv1hhfOWotSQ42kgxzbm+wPLbsa5O5E4/54D8Wc6ef0svwufU/Z0nHf2Tp3OZCHFw/U8QObipsckbm+bewc6BsY5VyNDjUOly5kGYM+oO811iLYDA+7e7WhAMoEdQsPrDz0EwkRAlCjnAXuDwtekAGuox2HKKZLg/w1rc627GccC83o82IX7v4P3Anzrz3EZl35DEQnBkQx40rUHI7V9kNtVy1IDycXEgmWd5EWhwdOy42cEu7B4+4WkPaNiXFN2DUqcSdqiz9/WLsXvJapXRC0Tkl0ThDvrr2W/CJi8h/B4W/mTiEAGLHfzG4UmjcLvA/ZmYs4XmhA7lIwYBQD1nbGS9qlcYg4leTFEgoaTNWB02qH1rTdkpPFucNkcwmYv0sHyyINoeoA55RxdTGvQVRkiCh+CzvzaZfr03WkmH2kCnUywWZMURbyBYIC/AMjveHJtf+Ye5fCJU3gcAaNYNZG6PvDBjRWiq/9je6DQbKu30IKmKGiMETkTbvMs9C8QqVWNWB3ljApaDEFeRDJCb58Fqr0Q+QIQo3ReU1u4MU3rLDRgcOneDRP5TLKu9sMRAbrctPo8baWJja95/m7+tm/tH0fSlZy2LkYWmdSpyAGdgjShADHr716zIImwAE90cP8iiWF/rWVuhIi0gqn9VMjUpD2IlW/8ARg6+VkzGEitnAcH5LJ6CzyT/B3H5xUHS0DC30pyP/0MtL14by05pXYSDzf7azNKs6RPTEOsmnkKyY0bpffb+ASnO2FKMXzm14sBMf9JdjhPurcWEjBFpdEmfTDBJFGZE2aTjR/Y7+VZTXYxTEcDjX2nGdmHEFBRmYV3GVkiCAY/k80u+ljX0L1DSjdiiKAbreycZxzy61NMeULVkHy8Bh3gKsTM06LowXhcnS9tC5ZlvyL3l23NQ5hs9EM1/Zqrki4FRaYNI6zyVkxFPJnIW7MOsXLlwYO1DfC4bKE7vyLPw9Pk2C6kvmoYOyQqTlbzO0Ibz3Va3HlYR3qF7nwDROF3V6SaaDBahminrzY7iQYDoJmI7go+B4tL9FumjYMSa7MLKYH8FsgGWxDTiQwozfE0NSnKvc81lC1Cm83WRVPr+aGXRvseNcyA61upe0fUk2N38DUPsr4CvGlPeQDDeuUEkXaX4TjHmJpMpmVXPsfXHFbJJQWQUXKGwwTc0l2ZvsqQIzTTvUG3Tq3PC3xjrhLc7Sw5PP2Tiz4JeKVoJ/rLXoG5/vuOjAyjWGzA0NCMercc3O1OmSm5HEsAHsSa8StuUrrgH0NIbxj1ML6KjLBDKYq700LQA8ulGYLlP+zMSJWDN6phQjcJ/2t8s1cpY9v0nr3xLoZoOflCJZbWKVpPpMaR0BiFYhrlW4env0of9soEXe0ZgEmtqxApVCR/A1biIngl9IEx3ZruEXZV7xnXnnpTJ1Nl1xQhyvJaQrAEvFxZi4vVdYFPZvUeIZDMc2vkC+vSGazDv5u81vc9sygfiEmgSJ7Pr9pccIOKu9rGz1MQEuvuzM6M/DBRbCqjP21S9V1HwgQZB+Dpv4zrvIvbh0UsSlK8tVCOcB1Z2CJCu3HU6GPNsLVFaiuF1ELzu2mXNT0qTtkhQo34xMZHFPSFvxLLkvLmXvTF3QUXT8RHupCmFO1c5rhq48v374ehDwxWYktvNCyWxKcDjz7EQRnWSOjr2v4f0SyblpTfgOypQJfZhJ6Qe0Oo+IQ9Al0w0nsVL9oLPoL3W2KxhCHJ5otrnsZzGm2S+R0xgHqb7rQkyPkLQzU6gzASc3De2j7zTcAxFl+0ILkCXgZNDSeC6Z8voQukr/0t1Itg7lhhVXKfghJGqxAYobbwmIvNfJHAabsXJWqvujg8qFFylGXZdJLmMkDzPEBanGQVOFVG1qK0y6Y7+rWueDZnHy6KNWKbq5LTGXyPBWfQBS8lr9oylwJvstDkii6N7CfjkoWIwGKGo0GXafjD38qpo7TuYA8oCJwq96T+PRb19opWfnVC7UISAS+dwskJykv1+eIakcvOoxIxadBRNbu9UGpZQlEKH6kcLVtLPTDfzmN69kVvqrxaZlXKjGQ9914gOnAK5Ux8roisa10QZY2r3aBKEZXryb+DWA5+r9a85vXWVg/aYasOXOIfHQk7fTKRtBNJ/Op4OO6ub5xNsW9lT+A57EYiVbWeIjJeyilcvFt/TNEJLTSoui2+ufGCttKD9cUYr18ck2zAKZLLkpOybOxzun7z0vuMfauTEwxdfuOmSDy7YlaAbxur8+Grl3lxQEMeYArQnsc6uHZxCdQIAtxWjopdmGK1a50hI7kSTdn4sJAj+4s/5SqvwEIjdlLT8ypT0SbIgevAeFPW4WUb7t31AclW/OaD6C6igLkpEX3Ixnd6uYwBCi7tvx6R7iV6D/OZGQtghR4wJ8tP3tJeYTpX61N+/yW/TsLi2OWaMWKAkKdZT52aGsQ6Mg03M+n95upRXN/s/Vx/dDuteoRVXWqSfyegridsTzNIQl7QdASvGfRKoAyyU6p7+THwYkOOSsN0culctmUeUdicoLX2vvNptF2RPcD6JzriXrz9nhXbwtF81uph3RwKhogjH7ofOtyV3XP1JofmvI7s9wsBPFAEJmzfqnJfDNBFo/fyyYFJQxDdqPnIndd5ehQTu+0B9Fz+5P3WDKQvnW2kL+/RBMb62gGhYNs0QpC/Dq/uRmgJ0S0D0nnBYz27Q8ayso92HJC0gpTRdzFNycP/nJ7KzV938Nfhp9k4x9QEWnV2ACglOmKSV/pa1p5GM0jrXRwnW+GuqxK3B2eugZ1fHKg+b2w1C5sZoWcAsQZMRvQzq5zLBDBeFpOAOm8tWnr/HrgQS7QXy793pg1jIMySYar8kKLmZlXfiertJjnhln29kPkyXv3+iH+Lm/Gy1Ia7zxd0zdkYpFnp0mVstNCsEewnr5gb5CLo1HJns9WRnNoZ1cc8fDDXhs9pBXwlWAwb5CBGfSeJrUWiQ/R5354DSQahdg/txh5cEE/t3tPBaO6Yxy+yln6hspYEahemA/6gQqZNX8Pq/F5RQPSsQlXYCsoHEvkrh6Tc2oFZRmnWJKXiSpQecBkondjyo0afEinoKac11O+qS26LBnPGVMFeK+phJTCiqBgHsX8S0ypxyj20sAFd6hyprAh/GdjC1LXZEQcDpfX3hrTESIEik7Sstm16LUD0ZsdJ+8+2frfsQzGtpXqhpvoRc= 🔐"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] LOG T1 vs C9 T1 승리 ㅎ 직관 갔는데 너무 간단하게 이겨서 기쁘긴 했다 ㅋㅋㅋ 오히려 KT vs BLG 가 더 긴장됐던 거 같음 배운 것 느낀 것 미션 어렵다... 너무 힘들다... JDBC 로 하지 …","fields":{"slug":"/2023-10-23/"},"frontmatter":{"date":"2023년 10월 22일 15:10","title":"2023년 10월 23일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n\n## LOG\n\n- T1 vs C9 T1 승리 ㅎ 직관 갔는데 너무 간단하게 이겨서 기쁘긴 했다 ㅋㅋㅋ 오히려 KT vs BLG 가 더 긴장됐던 거 같음\n\n## 배운 것\n\n## 느낀 것\n\n- 미션 어렵다... 너무 힘들다... JDBC 로 하지 말고 3단계 때 마이그레이션 할 걸...ㅋㅋㅋㅋ 다시 JPA 로 짜는 중.."},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] LOG 배운 것  은 final class 이기 때문에 모킹할 수 없다. 따라서  을 받아서  을  으로 띄우는 방식으로 모킹을 간접적으로 구현할 수 있다. 느낀 것","fields":{"slug":"/2023-10-21/"},"frontmatter":{"date":"2023년 10월 21일 10:10","title":"2023년 10월 21일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n\n## LOG\n\n## 배운 것\n\n- `LocalDateTime` 은 final class 이기 때문에 모킹할 수 없다. 따라서 `Clock` 을 받아서 `Clock` 을 `MockBean` 으로 띄우는 방식으로 모킹을 간접적으로 구현할 수 있다.\n\n## 느낀 것"},{"excerpt":"돌아볼까. 9시 40분 쯤에 캠퍼스에 도착해서 팀원들과 인사를 한다.\n10시부터 데일리 미팅을 하면서 기분 점수를 공유한다. 난 언제나 9점 이상이었던 것 같다. 데일리 미팅이 끝나면 강의를 듣거나, 미션을 하거나, 피쳐를 개발하거나, 회의를 하거나. 항상 바빴던 기억 밖에 없다. 우테코 정규 교육 시간이 끝나고 나면 항상 오빠랑 같이 공부를 했다. 대략…","fields":{"slug":"/level4-retrospect/"},"frontmatter":{"date":"2023년 10월 21일 09:10","title":"레벨4 회고","tags":["shook","우테코","레벨4"]},"rawMarkdownBody":"\n## 돌아볼까.\n\n9시 40분 쯤에 캠퍼스에 도착해서 팀원들과 인사를 한다.\n10시부터 데일리 미팅을 하면서 기분 점수를 공유한다. 난 언제나 9점 이상이었던 것 같다.\n\n데일리 미팅이 끝나면 강의를 듣거나, 미션을 하거나, 피쳐를 개발하거나, 회의를 하거나. 항상 바빴던 기억 밖에 없다.\n\n우테코 정규 교육 시간이 끝나고 나면 항상 오빠랑 같이 공부를 했다. 대략 생각해봤을 때 하루에 적어도 3시간씩은 꼭 남은 공부를 했던 것 같다.\n\n바론과 함께 게임도 열심히 했다. 아직도 열심히 하고 있다.  \n테코톡도 했다. 준비하는 시간 동안은 준비 안 했던 게 조금은 후회되었지만, 난 발표 날에 너무 재밌었다. 질문이 더 많았었다면 더 좋았을 것 같다는 생각이 든다.  \n처음 사용자 유치 기준이 나왔을 때, 100명이 많아 보였다. 언제 다 채우지... 너무 높게 적었나 하면서 팀원들과 걱정했던 기억이 난다.  \n그런데도 막상 홍보하려고 하니까 저작권이 걱정돼서 한 2주 간 마음고생했었다. 변호사와 대화할 생각까지 했으니 ㅋㅋㅋ 한저협에서 저작권에 위배되지 않는다는 답변을 해줘서 다행이었다. 그때 다들 안도했던 모습이 떠오른다.  \n홍보할 때도 의견이 많이 갈렸다. 지금 생각해보면 역시 도밥 말대로 아무데나 홍보하는 게 맞았을 수도 있다 ㅋㅋㅋ 그렇지만 브라운이 말씀하셨던 것처럼 뭐든 실패를 하고 나서 배우는 게 더 많다고 생각한다. 오히려 홍보를 많이 실패해서 우리의 타깃을 다시 어디로 맞추어야 하는지 결정할 수 있는 계기가 됐다.  \n결국은 트위터 홍보를 대차게 망하고 나서, 밑져야 본전이라 생각해서 에타에 올렸는데 너무 홍보가 잘 돼서 놀랐다. 처음으로 트래픽이 끊기지 않아서 다들 감동받았던 기억이 난다.\n5차 데모데이 때는 발표를 했다. 너무너무 할 일이 많아 당일 발표 2시간 전에 도밥과 겨우 대본을 맞춰봤었다. 다행히 문제는 없이 잘 끝냈다.  \n갑자기 우형 면접 때 코테를 보게 되어서, 팀원들이 서비스에 들이는 시간을 줄인다고 해놓고도 너무 열심히 해줬다. 티는 안 냈지만 감동이었다. 역시 우리 팀이 최고다.  \n브라운과 커피챗을 했다. 분야를 어떻게 정해야 할 지, 목표를 어떻게 정하는 게 좋을 지 추상적인 질문만 했는데 브라운이 멋진 대답을 해주셔서 큰 영감을 받았다. 감사했습니다 브라운 🥹. \n6차 데모데이 전 주에는 이사를 했다. 이사하고 나니 캠퍼스가 더 가까워졌지만 오히려 지각을 하게 됐다.. 역시 거리가 가까워질수록 늦는 건 어쩔 수 없나보다.  \n6차 데모데이 때 팀원들과 함께 전 날 랜딩 페이지도 만들고, 스티커도 만들었다. 한 2일 간 처음으로 11시까지 남아본 것 같다. 이 기회에 사실을 말하자면 예쁜 스티커는 우리끼리 만들어서 가질 생각이었다..ㅋㅋㅋ  \n6차 데모데이 당일에는 로고 칭찬, 캐릭터 칭찬을 많이 받아서 행복했다. 디자인이 멋지다, 너무 잘 만들었다, 칭찬을 많이 받아서 우리 프로젝트 최고의 날이라고 생각했다. 끝나고는 다 같이 스플릿 집에서 술을 마셨다. 술 마시는 도중에 도밥이 테오 방에 우리 서비스 홍보해서 서비스 사용자가 250명 는 것 보고 일희일희 했다... ㅎ  \n\n## 우테코\n\n그런 생각을 했다.\n\n> 나만 너무 많은 걸 얻어가는 것 같다. \n> 다른 사람들도 많은 걸 얻어 갔으면 좋겠다.\n\n올해 얻은 것을 생각해보자.\n\n나는 아무것도 할 수 없을 거라 생각했던 나를 버렸다. 어떻게 공부해야 할 지 몰라 방황하던 나도 제자리로 돌려놨다.  \n사람들과 이야기하는 것을 즐기게 되었다. 문제에 대해 이야기할 수 있는 많은 사람들을 얻었다. 편하게 의견을 나눌 수 있는 사람들과 인맥을 쌓았다. 이제는 함께하는 공부가 훨씬 재밌다는 것을 안다.  \n어떻게 하면 새로운 것을 배워갈 수 있는지, 내게 효과적인 공부법은 무엇인지 알게 됐다.\n막연하기만 했던 인생의 목표를 어떻게 정할 수 있는지는 알게 됐다. 나만의 소소한 목표도 세워 봤다.  \n우테코 기간 동안 꾸준히 블로그 글을 썼다. 나도 꾸준히 뭔가를 할 수 있는 사람이라는 걸 알게 됐다.  \n지금까지 내 탓이라 생각해왔던 일이 너무나도 손쉽게 해결됐다. 노력이라는 걸 할 수 있게 됐다.  \n함께 목표를 세우고, 목표를 향해 함께 달려갈 수 있는 사람과 행동력을 얻었다.  \n이젠 건강하지 않은 인간 관계를 판별할 수 있다.  \n좋은 팀원들을 만나 기억에 남을 멋진 팀플을 했고, 앞으로도 할 예정이다.  \n서비스는 절대 기술이 아닌, 서비스를 사용하는 사용자를 향하는 방향으로 반드시 움직여야 한다는 것을 알게 되었다.  \n혼자하는 공부도 좋지만, 함께하는 동료가 더 중요하다는 걸 알게 되었다.  \n(몇 년 간 살 수 있는 집도 생겼다 ㅋㅋ). \n\n그저 지금은 당연하다고 생각할 수 있게 할 만큼의 많은 습관을 얻게 되었다.  \n물론 우테코 때문이 아닌 것들도 있지만, 8개월 간 많은 것들을 얻은 것은 확실하다.   \n이만큼 많은 것들을 얻을 수 있었던 이유는 단지 내가 너무 좋은 환경에 있었기 때문이다.  \n이런 많은 기회를, 멋진 경험들을 할 수 있게 도와줬던 우테코에게 감사하다. 지금도 과분하다고 생각한다.  \n\n## S-HOOK\n\n우테코 공식적으로는 서비스 운영 기간은 종료되었다. 그렇지만 3달 간 만들어왔던 서비스에 큰 애정이 생겼다.  \n처음으로 어떤 결과물이나, 성적에 목매달지 않고 진행했던 서비스라 그런지 앞으로도 더 열심히 운영하고 싶다.  \n\n프로젝트를 진행하면서 내 서비스의 사용자를 모으는 게 얼마나 힘든지 (ㅋㅋ), 사용자를 위한 기능을 고민하는 것이 얼마나 중요한지, 팀 속에서 내가 어떤 역할을 해야 하는 지 알 수 있었다.  \n\n우리 팀원들도 다들 취업해야 하고 하니, 그만할 줄 알고 프론트엔드 어떻게 구하지라는 고민을 하고 있었는데 ㅋㅋㅋㅋ 다들 계속해서 서비스를 개발하고 싶다고 해서 감동이었다 🥹  \n\n팀원들이 그렇게 말했어도 함께 하지 않아도 괜찮다. 그만두는 게 슬프지 않은 건 아니지만 😂   \n올해 3달 동안 팀원들과 개발한 과정은 아마 평생 잊지 못할 것 같다.  \n\n## 안녕\n\n나 자신 수고 많았다! 진짜 Level 4까지 열심히 살았다고 생각한다.  \n\n앞으로도 파이팅하자.  "},{"excerpt":"Spring Data JDBC 란? 도메인 중심 설계 원칙에 따라 JDBC 데이터베이스를 사용하는 솔루션 개발에 핵심 Spring 개념을 적용한 것이다. JDBC Aggregate 의 핵심 기능은 Spring 컨테이너의 IoC 서비스를 호출할 필요 없이 직접 사용할 수 있다. 이는 Spring 컨테이너의 다른 서비스 없이 \"독립적으로 사용할 수 있는\"  …","fields":{"slug":"/spring-data-jdbc/"},"frontmatter":{"date":"2023년 10월 21일 07:10","title":"Spring Data JDBC","tags":["spring"]},"rawMarkdownBody":"\n## Spring Data JDBC 란?\n\n도메인 중심 설계 원칙에 따라 JDBC 데이터베이스를 사용하는 솔루션 개발에 핵심 Spring 개념을 적용한 것이다.\n\nJDBC Aggregate 의 핵심 기능은 Spring 컨테이너의 IoC 서비스를 호출할 필요 없이 직접 사용할 수 있다. 이는 Spring 컨테이너의 다른 서비스 없이 \"독립적으로 사용할 수 있는\" `JdbcTemplate` 과 매우 유사하다.\n\n## Requirements\n\nJDK 8.0 이상, Spring Framework 6.0.13 이상이 필요하다.\n\nDB2, H2, HSQLDB, MariaDB, MySQL, Oracle, Postgres, Microsoft SQL Server 를 직접 지원한다.\n\n다음과 같은 기본 기능들을 제공한다.\n\n```java\npublic interface CrudRepository<T, ID> extends Repository<T, ID> {\n\n  <S extends T> S save(S entity);      (1)\n\n  Optional<T> findById(ID primaryKey); (2)\n\n  Iterable<T> findAll();               (3)\n\n  long count();                        (4)\n\n  void delete(T entity);               (5)\n\n  boolean existsById(ID primaryKey);   (6)\n\n  // … more functionality omitted.\n}\n```\n\n`ListCrudRepository` 는 이와 동등한 메서드를 제공하지만, `CrudRepository` 메서드가 `Iterable` 을 반환하는 것과 달리 `List` 를 반환한다.\n\n- [i] `JpaRepository` 나 `MongoRepository` 와 같이 persistence 기술 별 추상화도 제공한다. 이런 인터페이스는 `CrudRepository` 와 같은 다소 일반적인 persistence 기술에 구애받지 않는 인터페이스에 더해, `CrudRepository` 를 확장하고 기본 persistence 기술의 기능을 노출한다.\n\n`CrudRepository` 에 더해서, 엔티티에 대한 페이징 접근을 용이하게 하는 메서드를 추가하는 `PagingAndSortingRepository` 도 제공한다.\n\n```java\npublic interface PagingAndSortingRepository<T, ID>  {\n\n  Iterable<T> findAll(Sort sort);\n\n  Page<T> findAll(Pageable pageable);\n}\n```\n\n다음과 같이 사용할 수 있다. \n\n```java\nPagingAndSortingRepository<User, Long> repository = // … get access to a bean\nPage<User> users = repository.findAll(PageRequest.of(1, 20));\n```\n\n이 외에도 count 쿼리, delete 쿼리에 대한 쿼리 파생이 가능하다.\n\n```java\ninterface UserRepository extends CrudRepository<User, Long> {\n\n  long countByLastname(String lastname);\n}\n```\n\n```java\ninterface UserRepository extends CrudRepository<User, Long> {\n\n  long deleteByLastname(String lastname);\n\n  List<User> removeByLastname(String lastname);\n}\n```\n\n### 쿼리 메서드\n\n다음과 같은 레포지터리가 있다고 가정한다.\n\n```java\ninterface PersonRepository extends Repository<Person, Long> { … }\n```\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n  List<Person> findByLastname(String lastname);\n}\n```\n\n`JavaConfig` 나 `XML Configuration` 으로 해당 인터페이스에 대한 프록시 인스턴스를 스프링에 설정한다.\n\n```java\nimport org.springframework.data.….repository.config.EnableJpaRepositories;\n\n@EnableJpaRepositories\nclass Config { … }\n```\n\n그 뒤, 레포지터리를 주입 받아 사용한다.\n\n```java\nclass SomeClient {\n\n  private final PersonRepository repository;\n\n  SomeClient(PersonRepository repository) {\n    this.repository = repository;\n  }\n\n  void doSomething() {\n    List<Person> persons = repository.findByLastname(\"Matthews\");\n  }\n}\n```\n\n### 쿼리 생성하기\n\n```java\ninterface PersonRepository extends Repository<Person, Long> {\n\n  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);\n\n  // Enables the distinct flag for the query\n  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);\n  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);\n\n  // Enabling ignoring case for an individual property\n  List<Person> findByLastnameIgnoreCase(String lastname);\n  // Enabling ignoring case for all suitable properties\n  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);\n\n  // Enabling static ORDER BY for a query\n  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);\n  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);\n}\n```\n\nJPA 와 유사하다.\n\n`distinct`, `ignoreCase`, `order by` 를 설정할 수 있다.\n\n#### 주의할 점\n\n- 표현식은 일반적으로 연결될 수 있는 (concatenated) operator 로 결합된 property 순회 (traversal) 이다.\n\t- property expression 에 대해 `Between`, `LessThan`, `GreaterThan`, `Like` 와 같은 연산자도 지원된다. datastore 마다 다를 수 있다.\n- 메서드 구문 분석기는 개별 속성 또는 대/소문자 ignore 를 지원하는 모든 속성에 대한 `ignoreCase` 플래그 설정이 지원된다. 대/소문자 ignore 지원 여부는 store 마다 다를 수 있다.\n- 속성을 참조하는 쿼리 메서드에 `OrderBy` 절을 추가하고 정렬 방향 (`Asc`, `Desc`)를 지정하여 순서를 적용할 수 있다. 자세한 내용은 [Paging, Iterating Large Results, Sorting](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.special-parameters) 을 참고하자.\n\n### 속성 표현식\n\n관리되는 엔티티의 직접 속성만 참조할 수 있다. 쿼리 생성 시 구문 분석된 property 가 관리되는 도메인 클래스의 property 인지 확인하게 된다. 그러나 중첩된 속성을 traverse 하여 제약 조건을 정의할 수도 있다. \n\n다음과 같은 예시를 보자.\n\n```java\nList<Person> findByAddressZipCode(ZipCode zipCode);\n```\n\n`Person` 클래스에 `ZipCode` 를 갖는 `Address` 가 있다고 가정한다. 이 경우, 메서드는 `x.address.zipCode` 속성 traverse 를 생성한다. resolution algorithm 이 `AddressZipCode` 를 property 로 해석하는 것부터 시작해서, 도메인 클래스에서 해당 이름의 property 가 존재하는지 부터 확인한다. 알고리즘이 성공하면 (해당 property 이름이 도메인 클래스에 존재하면) 해당 property 를 사용한다.\n\n그렇지 않은 경우에는 알고리즘이 오른쪽에서 camel-case 부분의 소스를 head, tail 로 분할하여 해당 속성을 찾으려고 시도한다. (`addressZip`, `Code` 로 분리) head 부분의 property 를 찾으면 동일 알고리즘을 다시 실행한다. 해당 분할이 일치하지 않는 경우, 분할 지점을 `address`, `ZipCode` 로 이동하여 계속 진행한다.\n\n대부분의 경우 해당 방법이 작동하지만, 알고리즘이 잘못된 속성을 선택할 수 있다. `Person` 클래스에 `addressZip` 속성도 있다고 가정하면, 아마도 알고리즘은 첫 번째 분할 라운드에서 잘못된 속성을 선택한 뒤 실패할 것이다.\n\n이런 모호함을 해결하려면, 다음과 같이 메서드 이름 안에 `_` 를 사용하여 traverse point 를 수동으로 정의할 수 있다. \n\n```java\nList<Person> findByAddress_ZipCode(ZipCode zipCode);\n```\n\n### Paging, Iterating Large Results, Sorting\n\n쿼리에서 매개변수를 처리하려면, 앞의 예제에서 이미 본 것처럼 메서드 매개변수를 정의하면 된다. 그 외에도 `Pageable`, `Sort` 와 같은 특정 유형을 인식하여 쿼리에 페이지네이션, 정렬을 동적으로 적용할 수 있다.\n\n```java\nPage<User> findByLastname(String lastname, Pageable pageable);\n\nSlice<User> findByLastname(String lastname, Pageable pageable);\n\nList<User> findByLastname(String lastname, Sort sort);\n\nList<User> findByLastname(String lastname, Pageable pageable);\n```\n\n```ad-important\nSort, Pageable 을 사용하는 API 는 메서드에 null 이 아닌 값을 전달할 것으로 예상한다. 만약 Sort, Pageable 을 사용하지 않으려면, Sort.unsorted() 나 Pageable.unpaged() 를 사용해야 한다.\n```\n\n자세한 설명은 [어떤 메서드가 적합할까?](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.scrolling.guidance) 를 확인하는 것이 좋다.\n\n### Aggregate Roots 에서 이벤트 발행하기\n\n[Publishing Events from Aggregate Roots](https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#core.domain-events) 참고\n\n레포지터리에서 관리하는 엔티티는 Aggregate Root 이다. 도메인 중심 디자인 애플리케이션에서 이런 Aggregate Root 는 일반적으로 도메인 이벤트를 발행한다. Spring Data 는 `@DomainEvents` 라는 어노테이션을 제공한다. \n\n```java\nclass AnAggregateRoot {\n\n    @DomainEvents (1)\n    Collection<Object> domainEvents() {\n        // … return events you want to get published here\n    }\n\n    @AfterDomainEventPublication (2)\n    void callbackMethod() {\n       // … potentially clean up domain events list\n    }\n}\n```\n\n`@DomainsEvents` 를 사용하는 메서드는 단일 이벤트 인스턴스 또는 이벤트 컬렉션을 반환할 수 있다. 인수를 받지 않아야 한다.\n\n모든 이벤트가 발행된 후에는 `@AfterDomainEventPublication` 으로 어노테이션이 달린 메서드를 사용할 수 있다. 이 메서드로 발행할 이벤트 목록들을 잠재적으로(potentially) 정리(clean)할 수 있다.\n\n---\n이 메서드들은 다음 중 하나의 Spring Data Repository 메서드가 호출될 때마다 호출된다. \n\n- save, saveAll\n- delete, deleteAll, deleteAllInBatch, deleteInBatch\n\n해당 메서드들은 Aggregate Root 인스턴스들을 인자로 받는다. \ndeleteById 는 인스턴스를 삭제하는 쿼리를 실행하도록 선택할 수 있기 때문에 애초에 Aggregate 인스턴스에 접근할 수 없어 제외되었다.\n\n## 특성\n\n### Core concepts\n\nSpring Data Repository abstraction 의 중심 인터페이스는 `Repository` 이다.\n\n`CrudRepository` 나 `ListCrudRepository` 인터페이스는 관리 중인 엔티티 클래스에 대한 정교한 CRUD 기능을 제공한다. \n\n## 시작하기\n\n### 의존성 추가\n\n```groovy\nimplementation 'org.springframework.boot:spring-boot-starter-data-jdbc' \nimplementation 'org.springframework.boot:spring-boot-starter-jdbc'\n```\n\n`build.gradle` 파일에 필요한 의존성을 추가한다. \n\n### 스키마 설정\n\nSpring Data JDBC 는 자동으로 데이터베이스 스키마를 생성하지 않는다. 따라서 스키마를 수동으로 생성해야 한다. 여기서는 `schema.sql` 을 사용한 방법으로 진행해보겠다.\n\n```sql\n\n```\n\n### Repository 생성\n\n```java\npublic interface MenuRepository extends CrudRepository<Menu, Long> {\n\n}\n```\n\n## 참고\n\n- https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#requirements"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] 코드 리뷰 반영  [priority:: highest]  [due:: 2023-10-15]  [completion:: 2023-10-18] LOG 배운 것 느낀 것","fields":{"slug":"/2023-10-18/"},"frontmatter":{"date":"2023년 10월 18일 04:10","title":"2023년 10월 18일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n- [x] 코드 리뷰 반영  [priority:: highest]  [due:: 2023-10-15]  [completion:: 2023-10-18]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"배운 것 I'm weak 보다는 I get sick easily 가 더 자연스럽다. furniture, stuff 는 복수로 쓰지 않는다. 어딘가로 이사를 갈 때는  라고 말하는 것이 좋다. ~를 하기 위해 갔다는 drive up / come up to v-ing 로 표현한다. cloth hanger 는 옷걸이. 행거는 rack 이라고 한다. get ri…","fields":{"slug":"/english-speaking-10-17/"},"frontmatter":{"date":"2023년 10월 17일 13:10","title":"10/17 회화 수업","tags":["english"]},"rawMarkdownBody":"\n## 배운 것\n\n- I'm weak 보다는 I get sick easily 가 더 자연스럽다.\n- furniture, stuff 는 복수로 쓰지 않는다.\n- 어딘가로 이사를 갈 때는 `move from (이전 위치) to (새로운 위치)` 라고 말하는 것이 좋다.\n- ~를 하기 위해 갔다는 drive up / come up to v-ing 로 표현한다.\n- cloth hanger 는 옷걸이. 행거는 rack 이라고 한다.\n- get rid of 는 쓰레기로 버린다는 느낌 보다는 기부 같이 어딘가에 줘서 없애버린다는 느낌이라고 한다. 쓰레기로 버렸다는 throw away 가 더 알맞다.\n- find 는 찾다가 뭔가를 발견한 (aha!) 느낌. search / look for 는 계속해서 찾는 느낌으로 사용한다.\n- 자연스럽게 had been v-ing 를 사용하려면 had been v-ing이 포함된 한 문장, 그 뒤에 then / but / however / when 등으로 이어지는 다음 문장이 필요하다. 즉, 두 문장으로 구성되어야 한다.\n\t- 그에 비해 was / were v-ing 는 한 문장으로 끝나도 어색하지 않다고 한다.\n- I didn't hear you.\n\t- I can't listen your word 라고는 말하지 않는다.\n- busy v-ing: ~하느라 바빴다.\n- for a month 가 아닌 a month 라고 한다.\n\t- ex. the rent was 300,000 won a month.\n- when 과 then 은 비슷한 의미로 사용될 수 있다.\n\n### 단어\n\n- rack: 행거\n- studio: 원룸\n- dorms: 대학이나 회사가 관리하는 기숙사\n- public housing: 정부에서 관리하는 집?\n- stipend: 회사에서 해주는 주거 지원\n- stipulations == requirements\n- ish: 대략 (around, about, approximately)\n\t- time, amount, year, date, money 등에 사용할 수 있다.\n\t- ex. how much clothes you have? I guess 30ish clothes.\n\t- it is 3ish \n- the government program: 정부에서 지원하는 정책? 같은 느낌인 듯\n\n## 발음\n\n- exhausting: egg-zausting\n- cloth: cloz\n"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] LOG 영어 회화 수업이 있었다. 저번 주보다는 좀 더 잘 말한 것 같아서 좋았다. 배운 것 english-speaking-10-17 forwarded-header-filter 느낀 것 할 게 굉장히 많다. 열심히…","fields":{"slug":"/2023-10-17/"},"frontmatter":{"date":"2023년 10월 17일 13:10","title":"2023년 10월 17일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n## LOG\n\n- 영어 회화 수업이 있었다. 저번 주보다는 좀 더 잘 말한 것 같아서 좋았다.\n\n## 배운 것\n\n- [[english-speaking-10-17]]\n- [[forwarded-header-filter]]\n\n## 느낀 것\n\n- 할 게 굉장히 많다. 열심히 해보자!"},{"excerpt":"리버스 프록시나 API 게이트웨이 같은 중간자 서버가 원래 요청의 컨텍스트나 경로 접두사 정보를 애플리케이션에 전달할 때 사용하는 HTTP 헤더이다. 해당 설정이 되어 있지 않으면 swagger 를 사용할 때 다음과 같이 swagger 문서 위치를 찾지 못할 수도 있다.  필요한 경우는 다음과 같다. Base Path Routing: 중간자 서버가 특정 …","fields":{"slug":"/nginx/"},"frontmatter":{"date":"2023년 10월 17일 01:10","title":"NGINX","tags":["infra"]},"rawMarkdownBody":"\n## `X-Forwarded-Prefix`\n\n리버스 프록시나 API 게이트웨이 같은 중간자 서버가 원래 요청의 컨텍스트나 경로 접두사 정보를 애플리케이션에 전달할 때 사용하는 HTTP 헤더이다.\n\n해당 설정이 되어 있지 않으면 swagger 를 사용할 때 다음과 같이 swagger 문서 위치를 찾지 못할 수도 있다. \n\n![[swagger-fail-load.png]]\n\n필요한 경우는 다음과 같다.\n\n1. Base Path Routing: 중간자 서버가 특정 경로 접두사를 기반으로 요청을 다른 다운스트림 서비스로 라우팅하는 경우\n2. Application Context Awareness: 중간 서버에서 리버스 프록시된 요청의 원래 경로 접두사를 알아야 하는 애플리케이션 (올바른 상대 URL 생성을 위해)\n\t- swagger UI 가 API 문서에서 각 엔드포인트에 대한 상대적인 URL 을 생성한다. 만약 애플리케이션이 리버스 프록시 뒤의 특정 base path 에서 동작한다면, 상대 URL 은 올바른 base path 를 포함해야 하므로 `X-Forwarded-Prefix` 로 base-path 를 알아내야 한다.\n3. Security and Logging: 로깅이나 보안 감사를 위해 원래 요청의 접두사를 알고 싶을 때\n\t- Swagger 는 `ForwardedHeaderFilter` 를 사용하여 `X-Forwarded-*` 헤더를 처리하고, 해당 정보를 사용해서 요청 URL 을 재구성한다. Swagger 는 이렇게 재구성된 URL 을 사용해서, 올바른 API 엔드포인트 URL 을 생성한다.\n\n```nginx\nlocation /app {\n    proxy_set_header X-Forwarded-Prefix /app;\n    proxy_pass http://backend_server;\n}\n```\n\n이렇게 설정하면 백엔드 서비스가 `X-Forwarded-Prefix` 헤더를 사용해서 원래 요청의 접두사를 알 수 있다.\n\n[[forwarded-header-filter]] 참고\n\n## health-checking\n\n```\nhttp {\n    upstream backend_servers {\n        server backend1.example.com; # 특정 포트1\n        server backend2.example.com; # 특정 포트2\n\n        # 헬스 체킹 설정\n        health_check interval=30s fails=3 passes=2 uri=/healthcheck;  # 특정 url 로 요청\n    }\n\n    server {\n        listen 80;\n\n        location / {\n            proxy_pass http://backend_servers;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n        }\n    }\n}\n```"},{"excerpt":"사용자 경험을 생각했을 때 5000ms (5초) 보통 사용자들은 안 나오면 새로고침을 한다.  기본값 => 그렇지만  과  가 같아서 아무런 영향을 주지 않는다. : 비활성화 0 : 기본값 + 변경될 값 차이 => 부하테스트 캐싱을 적용한 상태에서 DB 접근 시간이 있는 쿼리를 부하테스트 : \bmaximumPoolSize 와 동일 : 기본값 30분 (근거…","fields":{"slug":"/shook-hikaricp/"},"frontmatter":{"date":"2023년 10월 16일 06:10","title":"shook hikari","tags":null},"rawMarkdownBody":"\n- `connectionTimeout`\n\t- 사용자 경험을 생각했을 때 5000ms (5초)\n\t- 보통 사용자들은 안 나오면 새로고침을 한다.\n- `idleTimeout`\n\t- 기본값 => 그렇지만 `minimumIdle` 과 `maximumPoolSize` 가 같아서 아무런 영향을 주지 않는다.\n- `keepaliveTime`: 비활성화 0\n- `maximumPoolSize`: 기본값 + 변경될 값 차이 => 부하테스트\n\t- 캐싱을 적용한 상태에서 DB 접근 시간이 있는 쿼리를 부하테스트\n- `minimumIdle`: \bmaximumPoolSize 와 동일\n- `maxLifetime`: 기본값 30분 (근거 없어서)\n\n==mysql 권장 설정==\n\n```properties\ndataSource.cachePrepStmts=true\ndataSource.prepStmtCacheSize=250\ndataSource.prepStmtCacheSqlLimit=2048\ndataSource.useServerPrepStmts=true\ndataSource.useLocalSessionState=true\ndataSource.rewriteBatchedStatements=true\ndataSource.cacheResultSetMetadata=true\ndataSource.cacheServerConfiguration=true\ndataSource.elideSetAutoCommits=true\ndataSource.maintainTimeStats=false\n```\n\n## DB 에 쿼리가 가는 요청\n\n- `/members/{member_id}` : 0\n- `/login/{oauthType}`: 607\n- `/my-page`: 753\n- `/songs/{song_id}/parts/{killing_part_id}/likes`: 175\n- `/songs/{song_id}/parts/{killing_part_id}/comments`: 56 + alpha\n- `/voting-songs/{voting_song_id}/parts` : 100\n\n=> 1800\n"},{"excerpt":"세그먼트 트리란? 배열 간격에 대한 정보를 이진 트리에 저장하는 자료 구조. 세그먼트 트리를 사용하면 범위의 최소, 최대 및 합계 Query, 범위 Query 를 O(logN) 시간에 해결할 수 있다. 구현 세그먼트 트리의 크기 세그먼트 트리의 크기는 배열 arr 의 개수가 N개일 때, N보다 큰 가장 가까운 N의 제곱수를 구한 뒤에 그것의 2배를 하여 …","fields":{"slug":"/segment-tree/"},"frontmatter":{"date":"2023년 10월 15일 23:10","title":"세그먼트 트리","tags":["algorithms"]},"rawMarkdownBody":"\n## 세그먼트 트리란?\n\n배열 간격에 대한 정보를 이진 트리에 저장하는 자료 구조.\n\n세그먼트 트리를 사용하면 범위의 최소, 최대 및 합계 Query, 범위 Query 를 O(logN) 시간에 해결할 수 있다.\n\n## 구현\n\n### 세그먼트 트리의 크기\n\n세그먼트 트리의 크기는 배열 arr 의 개수가 N개일 때, N보다 큰 가장 가까운 N의 제곱수를 구한 뒤에 그것의 2배를 하여 미리 세그먼트 트리의 크기를 만들어 두어야 한다.\n실제로는 데이터 개수 N에 4를 곱한 만큼 미리 세그먼트 트리의 크기를 할당한다.\n\n### 세그먼트 트리 초기화\n\nindex 는 자식 노드를 계산하기 쉽게 (좌측 노드: 부모 노드 index * 2, 우측 노드: 부모 노드 index * 2 + 1) 1 부터 시작한다.\n\n- python version - recursion\n\n```python\ndef init(start, end, index):\n\tif start == end: # leaf node \n\t\ttree[index] = arr[start]\n\t\treturn tree[index]\n\tmid = (start + end) // 2\n\ttree[index] = init(start, mid, index * 2) + init(mid + 1, end, index * 2 + 1)   # 좌측 노드, 우측 노드를 채운다.\n\treturn tree[index]\n```\n\n- java version\n\n```java\npublic void init(int[] tree, int[] input) { // tree 는 이미 0으로 초기화된 상태 (덧셈 세그먼트 트리에서)\n\tint treeSize = 2;\n\twhile (treeSize <= input.length * 2) {\n\t\ttreeSize *= 2;\n\t}\n\n\tfor(int i = 0; i<input.length; i++) {\n\t\ttree[(treeSize / 2 + i)] = input[i];\n\t}\n\n\tfor(int i = treeSize / 2 - 1; i >= 1; i--) {\n\t\ttree[i] = tree[i *2] + tree[i *2 + 1];\n\t}\n}\n```\n\n세그먼트 트리의 인덱스와 구간 합은 별개의 값이다.\n\n## 세그먼트 트리로 구간 합 구하기\n\n구간의 합은 범위 안에 있는 경우만 더해주면 된다.\n\n- python version - recursion\n\n```python\ndef interval_sum(start, end, index, left, right):\n\tif left > end or right < start:\n\t\treturn 0\n\tif left <= start and end <= right:  # 범위 안에 있는 경우\n\t\treturn tree[index]\n\tmid = (start + end) // 2\n\treturn interval_sum(start, mid, index * 2, left, right) + interval_sum(mid + 1, end, index*2 + 1, left, right)\n```\n\n- java version\n\n```java\npublic static int sum(int[] tree, int l, int r) {\n\tint leaf = tree.size / 2;\n\tl += leaf;\n\tr += leaf;\n\n\tint sum = 0;\n\n\twhile(l <= r) {\n\t\tif(l % 2 != 0) { // 왼쪽 포인터가 오른쪽 노드일 때 (범위에 포함되지 않을 때 더한다.)\n\t\t\tsum += tree[l];\n\t\t}\n\t\tif(r % 2 == 0) { // 오른쪽 포인터가 왼쪽 노드일 때 (범위에 포함되지 않을 때 더한다.)\n\t\t\tsum += tree[r];\n\t\t}\n\t\tl = (l + 1) % 2;  // 오른쪽으로 이동\n\t\tr = (r - 1) % 2;  // 왼쪽으로 이동\n\t}\n\treturn sum;\n}\n```\n\n## 특정 원소의 값을 수정하기\n\n- python\n\n```python\ndef update(start, end, index, what, value):  # what: 구간 합을 수정할 노드 인덱스  \n    if what < start or what > end:  \n        return  \n    tree[index] += value  \n    if start == end:  \n        return  \n    mid = (start + end) // 2  \n    update(start, mid, index * 2, what, value)  \n    update(mid + 1, end, index * 2 + 1, what, value)\n```\n\n- java\n\n```java\npublic void update(int[] tree, int index, int value) {\n\tint leaf = tree.length / 2;\n\tindex += leaf;\n\tint gap = value - tree[index];\n\twhile(index > 0) {\n\t\ttree[index] += gap;\n\t\tindex /= 2;\n\t}\n}\n```\n\n## 복잡도\n\n- 초기값 설정: java 반복문 기준 $O(N)$\n- 값 업데이트, 값 조회: $O(logN)$\n\n## 참고\n\n- https://pseong.tistory.com/18\n"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] 링글 예습  [priority:: highest]  [due:: 2023-10-16]  [completion:: 2023-10-17] LOG 배운 것 느낀 것","fields":{"slug":"/2023-10-16/"},"frontmatter":{"date":"2023년 10월 15일 23:10","title":"2023년 10월 16일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n- [x] 링글 예습  [priority:: highest]  [due:: 2023-10-16]  [completion:: 2023-10-17]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"Hall's Theorem special condition, 즉 degree-constrained 에서만 동작한다. 어떻게 no bottleneck 인지 알까? degree-constrained => no-bottlenecks\nif every girl likes >= d boys and every boy likes <= d girls then no-bot…","fields":{"slug":"/bipartite-matching/"},"frontmatter":{"date":"2023년 10월 15일 12:10","title":"이분 매칭","tags":["algorithms"]},"rawMarkdownBody":"\n## Hall's Theorem\n\nspecial condition, 즉 degree-constrained 에서만 동작한다.\n\n### 어떻게 no bottleneck 인지 알까?\n\ndegree-constrained => no-bottlenecks\nif every girl likes >= d boys and every boy likes <= d girls then no-bottleneck\n\nsay set S of girls has e incident edges. (e is cardinality)\n\n$$d * |s| <= e <= d * |E(S)|$$\n\nd: 어떤 상수 (여기서는 어떤 정의역이 치역과 연결된 최대 개수)\nS: 정의역 전체 집합\nE(S): 치역 전체 집합\ne: 정의역과 치역을 연결하는 전체 간선의 개수\n\n$$정의역의 크기 * (정의역과 치역이 연결된 최대 개수) <= 전체 간선 개수 <= 치역의 크기 * (정의역과 치역이 연결된 최대 개수)$$\n\n즉, 정의역의 최대 cardinality 가 치역의 최대 cardinality 보다 크거나 같다면 언제나 bottleneck 이 생기지 않는다. \n\n## 이분 매칭 알고리즘\n\n### 이분 그래프\n\n두 개의 정점 그룹이 존재할 때 모든 간선(경로)의 용량이 1이면서 양쪽 정점이 서로 다른 그룹에 속하는 그래프를 이분 그래프라고 한다.\n\n이러한 이분 그래프에서 한 쪽 그룹은 X 그룹, 다른 한 쪽 그룹은 Y 그룹이라고 할 때 모든 경로의 방향은 X -> Y 인 그래프의 최대 유량을 구하는 것을 이분 매칭이라고 한다.\n\n**규칙**\n\n- 매칭: 어떤 정점이 그것을 가리키는 위치의 다른 정점을 점유한 상태\n- 각 정점은 한 개씩만 점유 가능하다.\n- 간선의 용량은 1이다.\n"},{"excerpt":"speaking-theme-computer-science","fields":{"slug":"/english-speaking-theme/"},"frontmatter":{"date":"2023년 10월 15일 09:10","title":"영어 회화 주제 준비","tags":null},"rawMarkdownBody":"\n- [[speaking-theme-computer-science]]"},{"excerpt":"My major is the Computer Science. I have been studying my major for five years from the high school. Currently, I'm making a service that introduces 'killing-part' in famous songs. 'Killing-part' mea…","fields":{"slug":"/speaking-theme-computer-science/"},"frontmatter":{"date":"2023년 10월 15일 09:10","title":"Computer Science","tags":["english"]},"rawMarkdownBody":"\nMy major is the Computer Science. I have been studying my major for five years from the high school. \n\nCurrently, I'm making a service that introduces 'killing-part' in famous songs. 'Killing-part' means that verse of songs loved by many people. I'm a server developer that maintains my service server.\n\nWhen I was a high school student, I had seen my senior who made some computer programs. It looked like so interesting, I wanted to learn about that. Therefore, I came into club of engineering. I studied about computer language (like language of C). It was so funny to learn about activating computer programs. I fell love in my major :)\n\nMy major makes me keep studying. Because it changes very quickly, I will keep studying about upcoming techniques. But ironically, it makes me very exciting! And My favorite hobby is to study about the computer science. \n\nNowadays, I'm taking a year off from my university. At earlier of this year, I got accepted '우아한테크코스' that instructs some techniques about the server development. I have studied in study program that is operated in '배달의민족' company from that time. If I do good jobs, it can employ me. So I have to study hard. \n\nI spend most of time with my teammates that develops my service together. When I didn't understand for some knowledge, they explained them very sincerely. Although studying sometimes made me feel bad, I can overcome if I'm with my friends together. I have deeply appreciated them."},{"excerpt":"시급한 것 README.md 서비스 구조도 최신화 ERD 최신화 기능 설명 구체화 기술 좋아요 동시성 문제 해결  [completion:: 2023-10-28] 기획 외부 노래 검색할 수 있도록 기능 추가 백엔드 기술 graceful shutdown 적용  [completion:: 2023-10-20] 인메모리 캐싱 걷어내기 쿼리 성능 개선 멀티 모듈 적…","fields":{"slug":"/shook-function-develop/"},"frontmatter":{"date":"2023년 10월 15일 09:10","title":"S-HOOK 개선하면 좋을 점들","tags":["shook","유지보수"]},"rawMarkdownBody":"\n## 시급한 것\n\n### README.md\n\n- [x] 서비스 구조도 최신화\n- [x] ERD 최신화\n- [x] 기능 설명 구체화\n\n### 기술\n\n- [x] 좋아요 동시성 문제 해결  [completion:: 2023-10-28]\n\n## 기획\n\n- [ ] 외부 노래 검색할 수 있도록 기능 추가\n\n## 백엔드 기술\n\n- [x] graceful shutdown 적용  [completion:: 2023-10-20]\n- [ ] 인메모리 캐싱 걷어내기\n\t- [ ] 쿼리 성능 개선\n- [ ] 멀티 모듈 적용하기\n\t- [ ] 패키지 정리하기\n\t- [ ] 이벤트로 의존성 분리\n- [ ] 요청 / 응답 로깅\n- [ ] S3 & cloudfront 도입하기\n- [ ] 외부 노래 검색 가능하도록 기능 추가\n- [ ] 검색 기능 고도화\n\n### 인프라\n\n- [ ] jenkins 로 migration\n\t- [ ] cd 제대로 적용하기\n- [ ] cors 설정 nginx 로 migration\n- [ ] 블루-그린 배포 도커 컴포즈 사용해서 고도화\n- [ ] DATADOG 도입"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] 바론 코드리뷰  [priority:: highest]  [created:: 2023-10-15]  [scheduled:: 2023-10-15]  [completion:: 2023-10-15] 스터디룸 예약  [pr…","fields":{"slug":"/2023-10-15/"},"frontmatter":{"date":"2023년 10월 15일 07:10","title":"2023년 10월 15일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n- [x] 바론 코드리뷰  [priority:: highest]  [created:: 2023-10-15]  [scheduled:: 2023-10-15]  [completion:: 2023-10-15]\n- [x] 스터디룸 예약  [priority:: highest]  [due:: 2023-10-15]  [completion:: 2023-10-15]\n- [x] Essay 보내기  [priority:: highest]  [due:: 2023-10-15]  [completion:: 2023-10-15]\n\n## LOG\n\n- 🔐β zhvAVVlSCs3Eqd6x4tpiT4TENXP3nYBRAFL2tsynD4+U4dupN0WQxicD0moiu3PFqWJSKmC1UDN+5NO0cXPHDegKuJyuLBwWR+Fs8plT1sfrY9v1iAbeKHc= 🔐\n- \n\n## 배운 것\n\n- `Stream.concat` 을 사용해서 두 stream 을 결합할 수 있다.\n\n## 느낀 것\n\n- `nginx` 파일을 최신화 안 해두니까 캠퍼스가 아닌 곳에서는 볼 수가 없다.. 당장 최신화 해서 어디에 저장해둬야겠다."},{"excerpt":"🔐β I1H8/LExG7VYJVmP27/+SnIvJaDEkn4270LdK4YeJfAypYTphAIp/G4B8KVZEXOTpRiO2UcwdtV0etnTv6ONkYlJg6RHERLvd/Ke+jvtaanjp3xKasQw3EIf/B9zofCvCkg/plM5TNcO8sKC6L1V1DuDBk9b23JTZhIHP+BoI0qNqzPVHfCxFAHVUTz8RnMYsZfR…","fields":{"slug":"/objective/"},"frontmatter":{"date":"2023년 10월 14일 23:10","title":"나의 목표","tags":null},"rawMarkdownBody":"\n🔐β I1H8/LExG7VYJVmP27/+SnIvJaDEkn4270LdK4YeJfAypYTphAIp/G4B8KVZEXOTpRiO2UcwdtV0etnTv6ONkYlJg6RHERLvd/Ke+jvtaanjp3xKasQw3EIf/B9zofCvCkg/plM5TNcO8sKC6L1V1DuDBk9b23JTZhIHP+BoI0qNqzPVHfCxFAHVUTz8RnMYsZfREtUSSOHzcYjGXFouYxySWh5ZnfdKtdFDTpIp5VIwGgwmPf6JjLF6BTF0ufpVztr1fZKYnwBNidBB+1hdGX1bYNVJFBeaZdyXfovF4sPCIvIjx5lViRJueQnT6CJvkDtaxX861MHWF77hJitMlovj1HQMdsTtsCH6IqlnE4+Qe1M7YnmYEbqNkaQmJUnxKmtV0a59QzLf1jvfmbDpeaIzsmgqLbYoyfYpvfy9R1n9soicAhkm6TbLh0NK0AahP/TWOMp+wivSjx3bk2rmhWEmsebAZU1Uklfk4YoILiH6U7Kb+mosP+xeSiOGChCwrU8C5UpF7N6dHVny5tRvQrhErP+z5x+OQJtN4YgxwSC0tyieIh2qFq2cpikp1P1P+NzgntmkYq1bNFOeLfEppGZWSIm+2c8AxBfHP0l83gYx1p7T5+q5VDVlfHjQ0tRCOSioxqMVslnYR7+yV3w6ZI0Fgzqw5BLnCqV3EPyNLn4lnWRxGiyRlIGC53rFXZA7vVcf2U3eFvP3ENAACijTs2HDlpkUYl9kArD9B84uzjt8ltlD2ElJd34H9Ra298RLmT3qrtTh+pLndFNtuhs3ASNrhfOqMwbrdJipc4jyeBlKBOqFv9uYiUBqsggMIJjSjN4+Poqmgn41axci4/wpKBR9GnRaBUm6mLpWayDb5CMurn54ukwtHFdr5IXijBycLPByGAdepGPNOaPDTA8EauDAcfpotYvGTHJ+AFxqNZI66P3R+kFua4N1yDcqY5sXD7MOPA08EE0jrxWKPF8KlAlahe5menyQfo6ZxFob6XyfqsDjfpxw1aeQ0biQ4k7ae7/Me8ymDa7ssC0MmhGLFxhjzLUcqpRAjjedoFSkK2CIEY6XuTtZK86qdZS7MczslwO+LTE7J1hsEzqel3hL7N/RsTStjCivC0gpMK0b2V3DmvENc1IVKFTq7W1Jgav3O9lW99DHgDS6QWRf2XXJGy6yUYeNru4Ac/5yL52I3tYOxxeHOH03SzIYVnTqca0hfWPWm8Lb9tCltXz8NXMkP4m63DuJ1szxB50RVQQiWtJ+/++AFvVd0y6BLeyg4UoSUV8KXDhJcDhilCJBGzpxSvJg52r8Yh1q4p2/+pZq1WQTkMdounYroGzGssiIUskyI+PLxZwWGg6HSwd1AeYXizNu7oEVVK8VCLYYz5cG+EKTTDxiutSKSmMDfi13ZWiAksATA9BJUI+kOVTrXXj6fDJAMR2VEXo9uhxNvYBlCRPeCtAO2Luml5D1vN+/rjYizt8k99Rpp6ucILO4vRMuRl/22/Srb1f2qkX1M/rVsYTxO1ssITbgoMrBof3TvwoWvkN9Cp5TQXKg7s96FXhk5p2OBmNgRcbVPyJ+U+2pyRj2xA3+jz28kDr+aiFD1V9qu+f31iERYz4EGqjpp4jgVVhPEg1S0QnJBH7uhT9bAVTaIKfOa34VHxM48dTuzgdZ/CDgjl+cDSdkIpIFKalVo87omnUgoA0PoQrn2GH9NJlgsQX/CeS4vDLnfW6xIgDw/yV22fS2BtKj3BaMvzCr0G8EcmoAkiZcIDyBtJlDTLCXYf5ZQgsZt9qiy6HOBM+2F+hgC6Ywgnw5qShmR3ZXipdtH9dLysnt4zO44Gk68dJBiVmOCKGJkv5tlDbk/5c86w0Inqdyd6hj2JZ+NSwupJgupbDVJQFtZTxzZvsnncNcAZ/gSnuCUWOKMK9X1lOLpMQ9x7wWQlE9z6tl+79gvG39eBn2SyN8HSw39W7HFJEZ8fcwih+bs6TpHOCzB9h78YVCow+Q6omrLhJAKV/7tSTQSbtwENtBx0Y06fWfs4gi5BapXx6GR/CfuI31T7GHbAcZOjIx2VHvDudRlTngVR4ZJihP2s2enga/+2KY3ttR7r0fTicu0LlPeD0E++2KO/EyjUGwd0YxJ3k/Aa+J69l90uqeZBz3aIrdxFljAlSnYA4JLUfUWHK1bnpSgt/ckSGMud5QJnwpSPlYoSdoYzMPp/WCC/kjuIg6UfNCZKmmg22mn+TOhKkkAluN7gQLWRWsu08CEJ6U74kl0kJBtsiwcyHG50mzz2Q46XQm2hww5YqTFdQMyiK/zOELOZOkhSCw93nw3gBZENW/fYWbdjA7eXicVI0MAJGuPlIldHkLdQx9akKVsckrEqDdqzZHT0zJBG3H7Ghe8HI79NWKU6jlTbNj/ZBOYX/fABnPSWq7qMdrleTzT1tdLMEaqNA2b9QWWXfZSpAYuq89QyXMoPdmv3loUV4xZsAbxOu+gq6TNTFbCKNdnxGFzPLlCCxqD1AZulJLNH1/fhf4sw09detQxqMW8UFoUAth1uFDXigqWCt7yVk0wBkTF4zNlqaluQ+nRYYB51tIWExpPVJdQHQthby10KM5nrr7BUydn2OTHPww7EvT4aPP0fDBJalFrP1yrCgwfYaB8raTO/TYnNKPTsgqUfpcSiT/9TNxCJhcFY8To1k6gd/GnUXTF8GFKOPYW+Jof5EuYrHlscu/jSTNkxv38Qg76ExUpZ55ShmNkoMWGGbluMOhK5SEWbQOTq4X0uAPFhhpOBzgniKerfsrc2gQgvD/krj07AUDcAEtTBzhfAg3b5ufvknTzjvjbaHxdxVU2yazBeb4L/uCSIiuYrVIuV6suV/iwapPYvURE0PiA9JinDfUuND8azK8pc5q2ByXLuNVdJ/MJcfuvK0b7a0SVHovCsM9wieXbwi/QoQU5NpTv9okWFYtLzxjCSS1n5Tj6fq4yNGXoo7pAkXjGL9Cb2pwGp50h1al30I7rJSVNMWicMmkGnoBradWj4V6M/0rSX0C/7keIxcmxxHSPoLmyWXfxR31+LIqVnQadYg8Oklf+DnEUxqjJ8kxW1e9ACys/y9mLuUkbVsmZLW2UOgBC2QOnYCX8vPqD6dGlL+YW1Y1B2WlVM4C9eUqr/4/i1OWtC15q2P7MuWX/qlIEaOInpnTyCvFR81e7v/kUda73BPF6jbFBwdbe6Kg4i1auxCCu1l9NpHxIvGYLj7+vZdSUdl2Alc3E6scmvpIfst66qzvXQzwV6pFZvv32WNe39KTgsZAmo70731aW4+2QAkUDsz1Gfb2vWhdovePnLDVaICewBsbqsx3xY3E6FRxFFQnhaNtjKDX7h2s4iOzjOojLQ8Hg6oLG82gqSyqq/LK/myZUW/CA1Ckbq0z+ke2bBfQ3X5ha5FQbEYyP565GsuLVhdNtud4dWcZEqR5dBqNB6kXuIp0LbI4BhJpmh+Vr53fBWGDlP+X5XFbo0fXql1QY4mTg06pD3Vcd32bzwmIDXDF95czRtv+7VvOQhHLC7IgLcKCAjVs/3tGPJZhG/+OyEgIEgB8sGYK2suynfKmxdqinq5OVNvASml/09tw+b6cVxN+uVas1bd8c4siS3x2SNk9CkV5YpszFb/42yh9F7R0M6Bo6w7xdAlsdyENbNIe4MRLwwzcSNbpPN9INnabRQuq/0ktILQ0jT1UvNW9dOSq1i3fL3ABs7Nlna0NrBVonsNGLUBa3TLQWeDITl4430agUpjJ8AnvxeHl8IF90weOtMsy9bk07gC1/3EU2uttHVFTEbomeGTY0XQ5RA6vF8iMN0pC7RSarlNbxhs0XpBoCKsEPN+IKO6R9J4Myp3pMM0= 🔐"},{"excerpt":"Spurious wakeups 란? 스레드가 알 수 없는 이유로  혹은 유사한 블로킹 연산에서 예기치 않게 깨어나는 현상이다. 즉,  ,  또는 스레드 인터럽트 등의 알려진 시그널을 받지 않았음에도 스레드가 깨어나는 것이다. 운영체제와 하드웨어 구현의 복잡성에서 기인하는 문제 중에 하나이다. 성능 최적화나 race condition 의 해결과 관련해서 발…","fields":{"slug":"/spurious-wakeups/"},"frontmatter":{"date":"2023년 10월 12일 02:10","title":"Spurious wakeups","tags":["os","cs"]},"rawMarkdownBody":"\n## Spurious wakeups 란?\n\n스레드가 알 수 없는 이유로 `wait()` 혹은 유사한 블로킹 연산에서 예기치 않게 깨어나는 현상이다.  \n\n즉, `notify()` , `notifyAll()` 또는 스레드 인터럽트 등의 알려진 시그널을 받지 않았음에도 스레드가 깨어나는 것이다.\n\n운영체제와 하드웨어 구현의 복잡성에서 기인하는 문제 중에 하나이다. 성능 최적화나 race condition 의 해결과 관련해서 발생할 수 있다. \n\n### 발생하는 상황\n\n1. 성능 최적화\n일부 운영체제가 커널 레벨에서 스레드, 프로세스의 상태 변경과 관련된 연산을 최적화하기 위해 배치 처리나 그룹화를 수행할 수 있다. 이런 최적화 과정 중에 스레드가 `wait()` 상태에서 깨어날 수 있는 내부적인 signal 이 다른 이벤트로 인해 의도치 않게 전달되어 발생할 수 있다.\n\n**예시**\n여러 스레드가 거의 동시에 `wait()` 상태로 전환될 수 있다. 이 경우, 커널은 전환이 일어나는 시기를 일정 간격으로 모아서 한꺼번에 처리하는 배치 처리를 수행할 수 있다. 이런 과정에서 예기치 않은 시점에 스레드 상태가 변경되며 발생할 수 있다.\n\n2. 경쟁 상황의 해결\n운영체제에서 다양한 리소스에 대한 접근을 조정하려할 때, 여러 스레드가 프로세스 간의 경쟁 상황을 해결하는 메커니즘을 사용할 수 있다. 이때의 부작용으로 스레드가 예기치 않게 깨어날 수 있다.\n\n**예시**\n스레드 A, B 가 동일한 파일을 동시에 수정하려고 시도할 때, 운영체제는 한 스레드에만 접근 권한을 주고 다른 스레드는 잠시 대기 상태로 만들 수 있다.\n그런데 이때 특정 스레드가 리소스에 대한 접근 권한을 받았지만, 다양한 이유로 실제로 접근하기 전에 다시 BLOCK 상태로 들어갈 수 있다. 이 경우 다른 스레드가 해당 리소스에 접근할 기회를 얻게 되면 race condition 해결을 위해 BLOCKED / WAITING 상태의 스레드를 깨울 수 있다.\n\n> 데드락을 다항 시간에 해결하는 방법이 없다. 스레드가 사용하는 자원이 천차만별이라 컴퓨터가 때로는 휴리스틱한 방법을 사용한다. 바로 랜덤한 스레드를 깨우거나 죽이는 것이다...\n\n3. 하드웨어 인터럽트\n하드웨어 인터럽트란 CPU, 메모리, I/O 장치 등의 하드웨어에서 발생하는 예외 상황이나 요청이다. \n\n**예시**\n- 인터럽트 처리: 디스크에서 데이터를 읽는 도중 오류가 발생하면 운영체제가 인터럽트를 받게 된다. 해당 인터럽트를 처리하기 위해 관련 스레드를 깨울 수 있다.\n- 리소스 할당: CPU 나 메모리 같은 자원을 다른 스레드에 할당하기 위해 현재 실행 중인 스레드를 중단시킬 수 있다. 반대로 스레드가 요청한 자원이 사용 가능해질 경우 해당 스레드를 깨워 작업을 계속하도록 할 수 있다.\n- 시그널 또는 예외 처리: 특정 스레드가 시그널, 예외를 받았을 때, 운영체제가 해당 스레드를 깨워 해당 시그널이나 예외를 처리하게 할 수 있다.\n"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] 링글 예습  [priority:: highest]  [due:: 2023-10-08]  [completion:: 2023-10-09] 테코톡 준비  [scheduled:: 2023-10-08]  [due:: 202…","fields":{"slug":"/2023-10-09/"},"frontmatter":{"date":"2023년 10월 09일 05:10","title":"2023년 10월 09일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n- [x] 링글 예습  [priority:: highest]  [due:: 2023-10-08]  [completion:: 2023-10-09]\n- [x] 테코톡 준비  [scheduled:: 2023-10-08]  [due:: 2023-10-08]  [completion:: 2023-10-09]\n- [x] 링글 수업  [priority:: highest]  [due:: 2023-10-09]\n\n## LOG\n\n- 3회차 링글 수업을 했다. 링글 좀 재밌을지도? 하다보니까 점점 더 긴장감이 풀려서 그런지 하고 싶은 말을 제대로 못해도 그냥 막 말하게 된다. 좋은 거겠지?\n- 내일은 영어 회화 수업 듣는 날.. 두근두근 어떨까 과연\n- intel 인턴, aws 인턴 지원했다. 과연 어떻게 될 것인지. 어차피 나는 내년에 졸업할 거니까 기왕이면 aws 됐으면 좋겠네요 ㅎ\n- 인턴 지원하면서 포트폴리오 정리했다. 근데 막상 쓰려고 하니까 어떤 걸 써야 할 지 모르겠더라. 앞으로 더 열심히 해야 한다는 뜻이겠지?\n- 링글 자리 잡다가 원루프랩이라는 곳에 왔는데 조용하고 집중도 잘 된다. 문제는 너무 많이 하니까 허리가 아프다...ㅋㅋㅋ 오늘 ppt 많이 만들었으니 만족합니다. \n\n## 배운 것\n\n- `@Inherited` : 다른 어노테이션 위에 사용될 때 해당 어노테이션이 상속될 수 있도록 지정한다.\n\t- 클래스 수준에서만 상속된다. 인터페이스의 상속에는 영향을 주지 않는다. \n\t- 메서드 수준의 어노테이션 상속에는 영향을 주지 않는다.\n- `withInitial` 로 `ThreadLocal` 을 초기화할 수 있다.\n\n## 느낀 것\n\n- 테코톡 준비 미리미리 하자."},{"excerpt":"객체가 값 기반 클래스인지 확인한다. Lock 종류 LightWeight Lock (LWLock) 최적화된 락이다. 여러 스레드가 동시에 동기화 블록이나 메서드에 접근하지 않을 것으로 예상될 때 사용된다. 스레드가 실제로 대기 상태로 전환되지 않고 CAS(Compare-And-Swap) 과 같은 원자적 연산을 사용하여 락 상태를 변경한다. 오버헤드가 낮지…","fields":{"slug":"/jdk-synchronizer/"},"frontmatter":{"date":"2023년 10월 08일 13:10","title":"JDK 의 Synchronizer 파헤치기","tags":["jdk","jvm"]},"rawMarkdownBody":"\n## `synchronizer.cpp`\n\n```cpp\nvoid ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n  if (obj->klass()->is_value_based()) {\n    handle_sync_on_value_based_class(obj, current);\n  }\n\n  current->inc_held_monitor_count();\n\n  if (!useHeavyMonitors()) {\n    if (LockingMode == LM_LIGHTWEIGHT) {\n      // Fast-locking does not use the 'lock' argument.\n      LockStack& lock_stack = current->lock_stack();\n      if (lock_stack.can_push()) {\n        markWord mark = obj()->mark_acquire();\n        if (mark.is_neutral()) {\n          assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n          // Try to swing into 'fast-locked' state.\n          markWord locked_mark = mark.set_fast_locked();\n          markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n          if (old_mark == mark) {\n            // Successfully fast-locked, push object to lock-stack and return.\n            lock_stack.push(obj());\n            return;\n          }\n        }\n      }\n      // All other paths fall-through to inflate-enter.\n    } else if (LockingMode == LM_LEGACY) {\n      markWord mark = obj->mark();\n      if (mark.is_neutral()) {\n        // Anticipate successful CAS -- the ST of the displaced mark must\n        // be visible <= the ST performed by the CAS.\n        lock->set_displaced_header(mark);\n        if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n          return;\n        }\n        // Fall through to inflate() ...\n      } else if (mark.has_locker() &&\n                 current->is_lock_owned((address) mark.locker())) {\n        assert(lock != mark.locker(), \"must not re-lock the same lock\");\n        assert(lock != (BasicLock*) obj->mark().value(), \"don't relock with same BasicLock\");\n        lock->set_displaced_header(markWord::from_pointer(nullptr));\n        return;\n      }\n\n      // The object header will never be displaced to this lock,\n      // so it does not matter what the value is, except that it\n      // must be non-zero to avoid looking like a re-entrant lock,\n      // and must not look locked either.\n      lock->set_displaced_header(markWord::unused_mark());\n    }\n  } else if (VerifyHeavyMonitors) {\n    guarantee((obj->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight/stack-locked\");\n  }\n\n  // An async deflation can race after the inflate() call and before\n  // enter() can make the ObjectMonitor busy. enter() returns false if\n  // we have lost the race to async deflation and we simply try again.\n  while (true) {\n    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n    if (monitor->enter(current)) {\n      return;\n    }\n  }\n}\n\nvoid ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n  current->dec_held_monitor_count();\n\n  if (!useHeavyMonitors()) {\n    markWord mark = object->mark();\n    if (LockingMode == LM_LIGHTWEIGHT) {\n      // Fast-locking does not use the 'lock' argument.\n      if (mark.is_fast_locked()) {\n        markWord unlocked_mark = mark.set_unlocked();\n        markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n        if (old_mark != mark) {\n          // Another thread won the CAS, it must have inflated the monitor.\n          // It can only have installed an anonymously locked monitor at this point.\n          // Fetch that monitor, set owner correctly to this thread, and\n          // exit it (allowing waiting threads to enter).\n          assert(old_mark.has_monitor(), \"must have monitor\");\n          ObjectMonitor* monitor = old_mark.monitor();\n          assert(monitor->is_owner_anonymous(), \"must be anonymous owner\");\n          monitor->set_owner_from_anonymous(current);\n          monitor->exit(current);\n        }\n        LockStack& lock_stack = current->lock_stack();\n        lock_stack.remove(object);\n        return;\n      }\n    } else if (LockingMode == LM_LEGACY) {\n      markWord dhw = lock->displaced_header();\n      if (dhw.value() == 0) {\n        // If the displaced header is null, then this exit matches up with\n        // a recursive enter. No real work to do here except for diagnostics.\n#ifndef PRODUCT\n        if (mark != markWord::INFLATING()) {\n          // Only do diagnostics if we are not racing an inflation. Simply\n          // exiting a recursive enter of a Java Monitor that is being\n          // inflated is safe; see the has_monitor() comment below.\n          assert(!mark.is_neutral(), \"invariant\");\n          assert(!mark.has_locker() ||\n                 current->is_lock_owned((address)mark.locker()), \"invariant\");\n          if (mark.has_monitor()) {\n            // The BasicLock's displaced_header is marked as a recursive\n            // enter and we have an inflated Java Monitor (ObjectMonitor).\n            // This is a special case where the Java Monitor was inflated\n            // after this thread entered the stack-lock recursively. When a\n            // Java Monitor is inflated, we cannot safely walk the Java\n            // Monitor owner's stack and update the BasicLocks because a\n            // Java Monitor can be asynchronously inflated by a thread that\n            // does not own the Java Monitor.\n            ObjectMonitor* m = mark.monitor();\n            assert(m->object()->mark() == mark, \"invariant\");\n            assert(m->is_entered(current), \"invariant\");\n          }\n        }\n#endif\n        return;\n      }\n\n      if (mark == markWord::from_pointer(lock)) {\n        // If the object is stack-locked by the current thread, try to\n        // swing the displaced header from the BasicLock back to the mark.\n        assert(dhw.is_neutral(), \"invariant\");\n        if (object->cas_set_mark(dhw, mark) == mark) {\n          return;\n        }\n      }\n    }\n  } else if (VerifyHeavyMonitors) {\n    guarantee((object->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight/stack-locked\");\n  }\n\n  // We have to take the slow-path of possible inflation and then exit.\n  // The ObjectMonitor* can't be async deflated until ownership is\n  // dropped inside exit() and the ObjectMonitor* must be !is_busy().\n  ObjectMonitor* monitor = inflate(current, object, inflate_cause_vm_internal);\n  if (LockingMode == LM_LIGHTWEIGHT && monitor->is_owner_anonymous()) {\n    // It must be owned by us. Pop lock object from lock stack.\n    LockStack& lock_stack = current->lock_stack();\n    oop popped = lock_stack.pop();\n    assert(popped == object, \"must be owned by this thread\");\n    monitor->set_owner_from_anonymous(current);\n  }\n  monitor->exit(current);\n}\n```\n\n- `ObjectSynchronizer::enter`\n객체가 값 기반 클래스인지 확인한다. \n\n## Lock 종류\n\n### LightWeight Lock (LWLock)\n\n최적화된 락이다. 여러 스레드가 동시에 동기화 블록이나 메서드에 접근하지 않을 것으로 예상될 때 사용된다.  \n스레드가 실제로 대기 상태로 전환되지 않고 CAS(Compare-And-Swap) 과 같은 원자적 연산을 사용하여 락 상태를 변경한다.  \n\n오버헤드가 낮지만, 두 개 이상의 스레드가 동시에 동기화에 접근하려고 할 때 contention 이 발생하면 더 heavy 한 락 방식으로 업그레이드 된다.  \n\n### Legacy Lock\n\n이전 버전의 HotSpot JVM 에서 사용되던 방식을 기반으로 한다.  \n이 방식에서도 먼저 락 상태를 원자적 연산을 사용하여 변경하려고 시도한다. 해당 시도가 실패하면 `ObjectMonitor` 로의 업그레이드가 발생한다.  \n\n### `ObjectMonitor`\n\n락과 관련된 모든 정보와 기능을 제공하는 별도의 데이터 구조이다.  \nLWLcok 이나 Legacy Lock 방식에서 여러 스레드가 동시에 동기화에 접근하려 해서 발생하는 Contention 이 생기면 `ObjectMonitor` 구조로 락이 '부풀려진다' (inflate)\n\n`ObjectMonitor` 는 동기화에 대한 상세 정보를 저장한다. (락의 소유자, 대기 중인 스레드, 등록된 조건 변수) 스레드가 락을 기다리게 하거나, notify 를 받게 할 수 있다. \n\n오버헤드가 높지만 높은 수준의 contention 에서도 잘 동작하며 스레드 간의 통신, 조정을 효과적으로 지원한다.  \n\n`jdk/src/hotspot/share/runtime/objectMonitor.cpp` 에서 구현을 확인할 수 있다.\n\n#### enter\n\n```cpp\nbool ObjectMonitor::enter(JavaThread* current) {\n  // The following code is ordered to check the most common cases first\n  // and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n\n  void* cur = try_set_owner_from(nullptr, current);\n  if (cur == nullptr) {\n    assert(_recursions == 0, \"invariant\");\n    return true;\n  }\n\n  if (cur == current) {\n    // TODO-FIXME: check for integer overflow!  BUGID 6557169.\n    _recursions++;\n    return true;\n  }\n\n  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n    assert(_recursions == 0, \"internal state error\");\n    _recursions = 1;\n    set_owner_from_BasicLock(cur, current);  // Convert from BasicLock* to Thread*.\n    return true;\n  }\n\n  // We've encountered genuine contention.\n  assert(current->_Stalled == 0, \"invariant\");\n  current->_Stalled = intptr_t(this);\n\n  // Try one round of spinning *before* enqueueing current\n  // and before going through the awkward and expensive state\n  // transitions.  The following spin is strictly optional ...\n  // Note that if we acquire the monitor from an initial spin\n  // we forgo posting JVMTI events and firing DTRACE probes.\n  if (TrySpin(current) > 0) {\n    assert(owner_raw() == current, \"must be current: owner=\" INTPTR_FORMAT, p2i(owner_raw()));\n    assert(_recursions == 0, \"must be 0: recursions=\" INTX_FORMAT, _recursions);\n    assert(object()->mark() == markWord::encode(this),\n           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n           markWord::encode(this).value());\n    current->_Stalled = 0;\n    return true;\n  }\n\n  assert(owner_raw() != current, \"invariant\");\n  assert(_succ != current, \"invariant\");\n  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n  assert(current->thread_state() != _thread_blocked, \"invariant\");\n\n  // Keep track of contention for JVM/TI and M&M queries.\n  add_to_contentions(1);\n  if (is_being_async_deflated()) {\n    // Async deflation is in progress and our contentions increment\n    // above lost the race to async deflation. Undo the work and\n    // force the caller to retry.\n    const oop l_object = object();\n    if (l_object != nullptr) {\n      // Attempt to restore the header/dmw to the object's header so that\n      // we only retry once if the deflater thread happens to be slow.\n      install_displaced_markword_in_object(l_object);\n    }\n    current->_Stalled = 0;\n    add_to_contentions(-1);\n    return false;\n  }\n\n  JFR_ONLY(JfrConditionalFlush<EventJavaMonitorEnter> flush(current);)\n  EventJavaMonitorEnter event;\n  if (event.is_started()) {\n    event.set_monitorClass(object()->klass());\n    // Set an address that is 'unique enough', such that events close in\n    // time and with the same address are likely (but not guaranteed) to\n    // belong to the same object.\n    event.set_address((uintptr_t)this);\n  }\n\n  { // Change java thread status to indicate blocked on monitor enter.\n    JavaThreadBlockedOnMonitorEnterState jtbmes(current, this);\n\n    assert(current->current_pending_monitor() == nullptr, \"invariant\");\n    current->set_current_pending_monitor(this);\n\n    DTRACE_MONITOR_PROBE(contended__enter, this, object(), current);\n    if (JvmtiExport::should_post_monitor_contended_enter()) {\n      JvmtiExport::post_monitor_contended_enter(current, this);\n\n      // The current thread does not yet own the monitor and does not\n      // yet appear on any queues that would get it made the successor.\n      // This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event\n      // handler cannot accidentally consume an unpark() meant for the\n      // ParkEvent associated with this ObjectMonitor.\n    }\n\n    OSThreadContendState osts(current->osthread());\n\n    assert(current->thread_state() == _thread_in_vm, \"invariant\");\n\n    for (;;) {\n      ExitOnSuspend eos(this);\n      {\n        ThreadBlockInVMPreprocess<ExitOnSuspend> tbivs(current, eos, true /* allow_suspend */);\n        EnterI(current);\n        current->set_current_pending_monitor(nullptr);\n        // We can go to a safepoint at the end of this block. If we\n        // do a thread dump during that safepoint, then this thread will show\n        // as having \"-locked\" the monitor, but the OS and java.lang.Thread\n        // states will still report that the thread is blocked trying to\n        // acquire it.\n        // If there is a suspend request, ExitOnSuspend will exit the OM\n        // and set the OM as pending.\n      }\n      if (!eos.exited()) {\n        // ExitOnSuspend did not exit the OM\n        assert(owner_raw() == current, \"invariant\");\n        break;\n      }\n    }\n\n    // We've just gotten past the enter-check-for-suspend dance and we now own\n    // the monitor free and clear.\n  }\n\n  add_to_contentions(-1);\n  assert(contentions() >= 0, \"must not be negative: contentions=%d\", contentions());\n  current->_Stalled = 0;\n\n  // Must either set _recursions = 0 or ASSERT _recursions == 0.\n  assert(_recursions == 0, \"invariant\");\n  assert(owner_raw() == current, \"invariant\");\n  assert(_succ != current, \"invariant\");\n  assert(object()->mark() == markWord::encode(this), \"invariant\");\n\n  // The thread -- now the owner -- is back in vm mode.\n  // Report the glorious news via TI,DTrace and jvmstat.\n  // The probe effect is non-trivial.  All the reportage occurs\n  // while we hold the monitor, increasing the length of the critical\n  // section.  Amdahl's parallel speedup law comes vividly into play.\n  //\n  // Another option might be to aggregate the events (thread local or\n  // per-monitor aggregation) and defer reporting until a more opportune\n  // time -- such as next time some thread encounters contention but has\n  // yet to acquire the lock.  While spinning that thread could\n  // spinning we could increment JVMStat counters, etc.\n\n  DTRACE_MONITOR_PROBE(contended__entered, this, object(), current);\n  if (JvmtiExport::should_post_monitor_contended_entered()) {\n    JvmtiExport::post_monitor_contended_entered(current, this);\n\n    // The current thread already owns the monitor and is not going to\n    // call park() for the remainder of the monitor enter protocol. So\n    // it doesn't matter if the JVMTI_EVENT_MONITOR_CONTENDED_ENTERED\n    // event handler consumed an unpark() issued by the thread that\n    // just exited the monitor.\n  }\n  if (event.should_commit()) {\n    event.set_previousOwner(_previous_owner_tid);\n    event.commit();\n  }\n  OM_PERFDATA_OP(ContendedLockAttempts, inc());\n  return true;\n}\n```\n\n1. 락이 null 인지 확인 후, 락이 없으면 현재 스레드가 락을 즉시 획득하고, 함수가 반환된다. \n2. 이미 락을 보유하고 있는 스레드가 다시 락을 획득하려고 하는 경우, 락의 재진입 수를 증가시키고 반환한다.\n3. `LockingMode` 가 Legacy Lock 이고, 현재 스레드가 락을 이미 소유하고 있으면 락의 재진입 수를 1로 설정하고 함수가 반환된다.\n4. 만약 contention (경쟁 상황) 이 발생하면 스레드는 락을 즉시 획득하기 위해 spin 을 시도할 수 있다. 짧은 시간 동안 락 획득을 계속 시도한다.\n5. spin 이 실패하거나, spin 을 건너뛰는 경우, 스레드는 락을 획득할 때까지 대기한다.\n6. 락을 성공적으로 획득한 후에는 특정 진단 및 모니터링 도구에 대한 추가 정보가 전달된다.\n7. true 를 반환하여 락 획득에 성공했음을 나타낸다.\n\n#### `ObjectWaiter`\n\n대기 집합 개념은 `ObjectWaiter` 로 구현된다.\n\n```cpp\nObjectWaiter::ObjectWaiter(JavaThread* current) {\n  _next     = nullptr;\n  _prev     = nullptr;\n  _notified = 0;\n  _notifier_tid = 0;\n  TState    = TS_RUN;\n  _thread   = current;\n  _event    = _thread->_ParkEvent;\n  _active   = false;\n  assert(_event != nullptr, \"invariant\");\n}\n```"},{"excerpt":"2023-10-01 2023-10-02 2023-10-04 2023-10-07 2023-10-08 2023-10-09 2023-10-15 2023-10-16 2023-10-17 2023-10-18 2023-10-21 2023-10-23 2023-10-25 2023-10-28 2023-10-29 2023-10-30 2023-10-31","fields":{"slug":"/2023-10/"},"frontmatter":{"date":"2023년 10월 08일 12:10","title":"2023년 10월","tags":["TIL"]},"rawMarkdownBody":"\n- [[2023-10-01]]\n- [[2023-10-02]]\n- [[2023-10-04]]\n- [[2023-10-07]]\n- [[2023-10-08]]\n- [[2023-10-09]]\n- [[2023-10-15]]\n- [[2023-10-16]]\n- [[2023-10-17]]\n- [[2023-10-18]]\n- [[2023-10-21]]\n- [[2023-10-23]]\n- [[2023-10-25]]\n- [[2023-10-28]]\n- [[2023-10-29]]\n- [[2023-10-30]]\n- [[2023-10-31]]"},{"excerpt":"TODO 미션 3단계 제출  [priority:: highest]  [created:: 2023-10-05]  [completion:: 2023-10-08] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] 아코와 페어프로그래밍  [priority:: highest]  […","fields":{"slug":"/2023-10-08/"},"frontmatter":{"date":"2023년 10월 08일 05:10","title":"2023년 10월 08일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 미션 3단계 제출  [priority:: highest]  [created:: 2023-10-05]  [completion:: 2023-10-08]\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n- [x] 아코와 페어프로그래밍  [priority:: highest]  [due:: 2023-10-08]  [completion:: 2023-10-08]\n\n## LOG\n\n- 종각에 가서 잠깐 보쌈을 먹으러 갔다. 오.. 굉장히 맛있었다. 인정합니다.\n- 갑자기 비가 와서 중구로 내려와서 스타벅스에서 공부했다. 아코랑 페어 프로그래밍했다. code with me 썼는데 그 뒤로 아코가 내 커밋에서 안 없어진다. 이거 어떻게 해 ㅋㅋ\n\n## 배운 것\n\n- 맨날 까먹는 포트 죽이기 `lsof -i :포트번호` 로 확인 후 `kill -9 포트번호`\n\n## 느낀 것"},{"excerpt":"TODO 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30] LOG 배운 것 느낀 것","fields":{"slug":"/2023-10-07/"},"frontmatter":{"date":"2023년 10월 07일 07:10","title":"2023년 10월 07일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 글쓰기 미션  [priority:: medium]  [due:: 2023-10-30]  [completion:: 2023-10-30]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"JDK Proxy 사용 시 문제점 ProxyFactoryBean 도입하기 Proxy로 생성한 객체를 스프링 빈에 등록할 수 있다. 매번 인터페이스를 만들지 않아도 되고, 메서드 외에 클래스도 지정할 수 있다. 프록시 생성 방법을 정할 수 있다. -> jdk proxy 또는 CGLib BeanPostProcessor 인터페이스를 활용하면 자동 생성 가능하다…","fields":{"slug":"/wooteco-aop/"},"frontmatter":{"date":"2023년 10월 06일 01:10","title":"AOP 강의","tags":["우테코","spring","레벨4"]},"rawMarkdownBody":"\n## JDK Proxy 사용 시 문제점\n\n## ProxyFactoryBean 도입하기\n\n- Proxy로 생성한 객체를 스프링 빈에 등록할 수 있다.\n- 매번 인터페이스를 만들지 않아도 되고, 메서드 외에 클래스도 지정할 수 있다.\n- 프록시 생성 방법을 정할 수 있다. -> jdk proxy 또는 CGLib\n- BeanPostProcessor 인터페이스를 활용하면 자동 생성 가능하다.\n\n## AOP 핵심 개념\n\n| 용어      | 개념                               | 인터페이스  |\n| --------- | ---------------------------------- | ----------- |\n| Aspect    | Point + Advice                     | Advisor    |\n| Pointcut  | Advice 를 적용할 JoinPoint 를 선별 | Pointcut    |\n| Advice    | 특정 JoinPoint 에 실행되는 코드    | Interceptor |\n| JoinPoint | Advice 를 적용할 위치              | Invocation  |\n| Target    | 부가기능 (advice) 를 적용할 대상   |             |\n\n## AOP 란?\n\n- 부가 기능을 모듈화 하는 것\n\t- OOP 개념으로 코드 중복을 제거할 수 없을 때 사용\n\t\t- 트랜잭션처럼 메서드 전후로 실행되어야 하는 코드\n\t- 미들웨어, 인프라와 관련된 코드를 모듈화\n\t\t- 트랜잭션, 보안, 로깅, 캐시 등\n- OOP 와 대척되는 개념이 아니다.\n\t- AOP 는 OOP 를 보완하는 개념이다.\n\t- AOP 만으로 애플리케이션을 개발할 수 없다.\n- 스프링은 프록시 기술로 AOP 개념을 구현했다.\n- Servlet Filter 도 AOP 개념이 적용되어 있다.\n- Servlet Filter 는 부가기능 적용이 HTTP 요청, 응답으로 제한된다.\n- 스프링 AOP 는 클래스, 메서드 등등 원하는 위치에 Advice 설정 가능\n\n## AOP 의 종류\n\n- 위빙 (Weaving) 이란 코드의 적절한 위치에 aspect 를 추가하는 과정\n- 실습 미션처럼 자바 코드가 실행되는 런타임에 aspect 를 추가한다면?\n\t- 동적 AOP\n\t- 스프링 AOP\n\t\t- JDK Dynamic Proxy (Interface based)\n\t\t- CGLiB Proxy (subclass based)\n- 컴파일 시점 바이트코드에 aspect 를 추가한다면?\n\t- 정적 AOP\n\t- AspectJ\n"},{"excerpt":"TODO 링글 복습하기  [priority:: medium]  [due:: 2023-10-02]  [completion:: 2023-10-05] 닉네임 변경 PR 보내기  [priority:: highest]  [due:: 2023-10-03]  [completion:: 2023-10-04] 트위터 인용글 올리기  [priority:: highest]  …","fields":{"slug":"/2023-10-04/"},"frontmatter":{"date":"2023년 10월 04일 05:10","title":"2023년 10월 04일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 링글 복습하기  [priority:: medium]  [due:: 2023-10-02]  [completion:: 2023-10-05]\n- [x] 닉네임 변경 PR 보내기  [priority:: highest]  [due:: 2023-10-03]  [completion:: 2023-10-04]\n- [x] 트위터 인용글 올리기  [priority:: highest]  [due:: 2023-10-04]  [completion:: 2023-10-05]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"세이브포인트 트랜잭션 내에서 특정 지점을 표시하는 방법이다. 세이브포인트를 설정한 후에는 해당 지점까지의 작업을 롤백하는 것이 가능하다. 전체 트랜잭션을 롤백하는 것이 아닌, 세이브포인트 이후의 변경사항만 롤백하게 된다. 대부분의 현대 RDBMS 에서는 지원하고 있다. 오래된 버전의 데이터베이스, 몇몇 NoSQL 데이터베이스는 세이브포인트 기능을 제공하지…","fields":{"slug":"/database-technique/"},"frontmatter":{"date":"2023년 10월 04일 02:10","title":"데이터베이스 기술","tags":["database"]},"rawMarkdownBody":"\n## 세이브포인트\n\n트랜잭션 내에서 특정 지점을 표시하는 방법이다. 세이브포인트를 설정한 후에는 해당 지점까지의 작업을 롤백하는 것이 가능하다. 전체 트랜잭션을 롤백하는 것이 아닌, 세이브포인트 이후의 변경사항만 롤백하게 된다. \n\n대부분의 현대 RDBMS 에서는 지원하고 있다. 오래된 버전의 데이터베이스, 몇몇 NoSQL 데이터베이스는 세이브포인트 기능을 제공하지 않을 수 있다.\n\n### MySQL\n\n세이브포인트를 지원한다. \n\n- **SAVEPOINT savepoint_name**: 트랜잭션 내에서 세이브포인트를 생성.\n- **ROLLBACK TO savepoint_name**: 해당 세이브포인트까지의 변경사항 롤백\n- **RELEASE SAVEPOINT savepoint_name**: 세이브포인트 제거\n"},{"excerpt":"트랜잭션이란 DBMS에서 수행되는 논리적인 작업의 단위를 말한다.\n하나 이상의 데이터베이스 조작 (INSERT, UPDATE, DELETE 등)을 묶어 하나의 작업으로 처리한다. 트랜잭션의 특성 (ACID) 원자성: 트랜잭션의 모든 연산은 하나의 원자적 작업 단위로 간주된다. 모든 연산이 성공적으로 수행되면 트랜잭션은 커밋되어 영구적으로 적용되고, 하나라…","fields":{"slug":"/transaction/"},"frontmatter":{"date":"2023년 10월 04일 01:10","title":"Transaction","tags":["database"]},"rawMarkdownBody":"\n## 트랜잭션이란\n\nDBMS에서 수행되는 논리적인 작업의 단위를 말한다. \n하나 이상의 데이터베이스 조작 (INSERT, UPDATE, DELETE 등)을 묶어 하나의 작업으로 처리한다.\n\n### 트랜잭션의 특성 (ACID)\n\n1. 원자성: 트랜잭션의 모든 연산은 하나의 원자적 작업 단위로 간주된다. 모든 연산이 성공적으로 수행되면 트랜잭션은 커밋되어 영구적으로 적용되고, 하나라도 실패하면 트랜잭션은 롤백되어 이전 상태로 복원된다. -> 트랜잭션의 연산은 전부 수행되거나 전혀 수행되지 않아야 한다.\n2. 일관성: 트랜잭션이 수행되기 전, 후의 데이터베이스 상태는 일관된 상태를 유지해야 한다. 즉, 데이터베이스에 저장된 데이터의 제약 조건, 규칙, 관계 등이 모두 만족되어야 한다. 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 된다.\n3. 격리성: 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다. 각 트랜잭션은 시스템 내에서 독립적으로 실행되는 것처럼 보여야 한다.\n4. 지속성: 트랜잭션이 커밋된 후에는 해당 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장되어야 한다. 시스템 장애나 복구 작업 같은 예외 상황이 발생하더라도 트랜잭션이 커밋되었으면 결과는 영구적으로 보존되어야 한다.\n\n### 트랜잭션의 과정\n\n1. 트랜잭션 시작: 트랜잭션을 시작할 수 있는 레벨을 설정하고, 해당 레벨에서 동작하는 새로운 트랜잭션을 시작한다.\n2. 데이터베이스 조작: 새로 생성된 트랜잭션 내에서 데이터 조회, 입력, 수정, 삭제 등의 조작을 수행한다.\n3. 데이터 검증: 데이터 조작이 모두 성공적으로 처리되었다면, COMMIT을 수행한다. 그러나 데이터 조작 오류가 발생하면 ROLLBACK 명령을 실행하여 이전 상태로 되돌린다.\n4. 트랜잭션 종료: 트랜잭션을 완료하고, 해당 레벨의 트랜잭션을 종료한다. \n\n### 트랜잭션 레벨\n\n동시에 실행중인 여러 트랜잭션 간의 데이터 일관성과 격리 수준을 조절하는데 사용된다.\n\n### 트랜잭션 격리 수준\n\n#### Read Uncommitted (레벨 0)\n- 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.\n- SELECT 문장이 수행되는 동안 해당 데이터에 shared lock이 걸리지 않는다.\n- 데이터 부정합 문제가 발생할 확률이 높으나, 성능은 가장 빠르다.\n- DirtyRead, Non-Repeatable Read, Phantom Read 현상이 발생한다.\n- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많다. MySQL을 사용한다면 Read Committed 이상의 격리 수준을 사용하자.\n\n#### Read Committed (레벨 1)\n- 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용한다. \n- SELECT 문장이 수행되는 동안 해당 데이터에 shared lock이 걸린다. 따라서 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없고, 대기한다. 즉, data 10을 50으로 변경하는 동안 다른 사용자는 바뀐 데이터에 접근할 수 없다. (data 50에 접근할 수 없다.)\n- 실제 테이블 값을 가져오는 것이 아닌, Undo 영역에 백업된 레코드에서 값을 가져온다. Undo 영역은 트랜잭션의 롤백 대비를 위해, 트랜잭션의 격리 수준을 유지하며 높은 동시성을 제공하기 위해 사용된다.\n![[transacion-read-committed.png]]\n- Non-Repeatable Read, Phantom Read 문제가 발생한다.\n- 일반적인 웹 애플리케이션에서는 크게 문제가 되지 않지만, 입출금 같은 금전과 관련이 된다면 문제가 될 수 있다. \n\n#### Repeatable Read (레벨 2)\n- 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 같음을 보장한다. Undo 영역에 백업된 이전 데이터를 사용한다.\n- 실행되는 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 undo 영역의 데이터는 삭제할 수 없다.\n- 즉, 10번 트랜잭션에서 실행되는 모든 SELECT 쿼리는 10번보다 작은 트랜잭션 번호에서 변경한 내용만 보게 된다. 10번 트랜잭션이 실행되는 도중에 12번 트랜잭션이 UPDATE 쿼리를 수행해도 12번 트랜잭션의 변경 사항은 10번 트랜잭션 SELECT 쿼리에 영향을 줄 수 없다.\n- 하나의 레코드에 대해 백업이 하나 이상 존재할 수 있다. 따라서 한 사용자가 트랜잭션을 시작한 후 장기간 트랜잭션을 종료하지 않는 경우에는 Undo 영역이 계속해서 확장되고, 백업 레코드가 많아질수록 MySQL 서버의 처리 성능이 떨어질 수 있다.\n- Phantom Read 문제가 발생한다. (그러나 MySQL InnoDB는 MVCC 다중 버전 제어를 통해 Phantom Read 문제를 해결한다. 즉, MySQL 에서는 Phantom Read 문제가 발생하지 않는다.)\n\n#### Serializable (레벨 3)\n- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 접근할 수 없다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.\n- 동시 처리 성능이 다른 트랜잭션 격리 수준에 비해 현저히 떨어진다.\n- `SERIALIZABLE` 격리 수준에서 \n\n#### MySQL InnoDB가 Phantom Read를 해결하는 방법 - MVCC 다중 버전 제어\n\nMVCC(Multi Version Concurrency Control) -> 잠금을 사용하지 않는 일관된 읽기를 제공한다.\n동시성 제어를 위한 기술로, 여러 개의 버전을 생성하여 트랜잭션간 충돌을 방지한다.\n\n각각의 트랜잭션은 일련번호를 할당받고, 트랜잭션의 시작 지점이 빠른 트랜잭션은 숫자가 작다.\n데이터베이스의 각 레코드는 변경 이력을 추적하기 위해 여러 버전으로 관리되는데, 이때 해당 레코드를 변경한 트랜잭션의 일련번호가 함께 저장된다.\n\n트랜잭션의 시작 시점에 따라서 해당 시점 이전에 커밋된 트랜잭션들의 변경 내역만을 볼 수 있도록 설정된다. \n즉, 10번 트랜잭션의 경우 10보다 작은 일련 번호를 갖는 트랜잭션이 변경한 내역들만 볼 수 있다. \n다른 트랜잭션이 트랜잭션 실행 중에 데이터를 변경하더라도 실행 중인 트랜잭션은 변경 내용을 알 수 없다.\n\n#### DB_TRX_ID\n\nMVCC 를 구현하기 위해 데이터의 각 행에 관련 정보를 추가로 저장한다. 주로 다음과 같은 숨겨진 컬럼들을 사용한다.\n\n- DB_TRX_ID: 데이터를 마지막으로 수정한 트랜잭션의 ID\n- DB_ROLL_PTR: 롤백 세그먼트에 대한 포인터. 이전 버전의 데이터 (undo 로그) 에 대한 링크이다.\n- DB_ROW_ID: 데이터베이스 내부에서 사용하는, 명시적인 기본 키가 없는 테이블에 대한 auto_increment id 이다.\n\n#### Undo 로그\n\n변경 전 데이터의 상태를 기록하고, 트랜잭션이 롤백되거나 다른 트랜잭션이 이전 버전의 데이터를 읽어야 할 때 사용된다. Undo 로그 자체는 버퍼 풀에 캐시될 수 있지만, 영구적인 저장을 위해 디스크 상의 undo 로그 세그먼트에 저장된다.\n\n버퍼 풀은 데이터베이스 서버의 메모리 내에서 데이터와 인덱스 페이지를 캐시하는 역할을 하므로, 자주 접근되는 데이터의 최신 버전을 메모리 내에 빠르게 접근할 수 있도록 해준다. 그러나 MVCC 에 필요한 데이터 버전 정보는 원본 레코드에 직접 저장되어 데이터베이스의 일관성과 내구성을 유지한다.\n\n#### 스냅샷\n\nInnoDB 스토리지 엔진을 사용하는 MySQL 에서는 MVCC 모델에 따라 트랜잭션을 시작할 때 특정 시점의 데이터베이스 스냅샷을 가진다. 스냅샷은 데이터의 실제 복사본을 만드는 것이 아닌, 데이터를 조회하거나 변경할 때 해당 트랜잭션의 시점에서 보아야 할 데이터의 버전을 결정하는 논리적인 개념이다.\n\nREPEATABLE READ 격리 수준에서는 트랜잭션이 시작될 때의 스냅샷을 통해 조회를 수행한다. 트랜잭션 도중에 다른 트랜잭션에 의해 데이터가 변경되더라도 변경 되기 전의 \n\n##### 트랜잭션 ID 할당 시점\n\nMySQL 의 InnoDB 스토리지 엔진에서 DB_TRX_ID 는 특정 레코드를 마지막으로 수정한 트랜잭션 ID를 나타낸다.      \n\n**트랜잭션이 시작되는 즉시 트랜잭션 ID 를 부여받는 것은 아니다.** InnoDB 가 경합을 줄이고 동시성을 향상시키기 위해서 lazy 한 방식으로 동작하기 때문이다.     \n\n트랜잭션이 데이터를 수정하려고 시도할 때만 트랜잭션 ID 가 할당된다.       \n트랜잭션에 의해 행이 수정되면 해당 행의 DB_TRX_ID 필드에 트랜잭션 ID 가 저장된다. 해당 ID는 InnoDB가 마지막으로 수정한 트랜잭션을 추적하는 데 도움이 된다. \n\n트랜잭션이 종료되고 트랜잭션이 커밋되면 변경 사항이 디스크에 기록되고 이후 모든 트랜잭션에서 변경 사항을 볼 수 있다. 트랜잭션이 롤백되면 해당 트랜잭션에 의해 변경된 내용은 undo log의 정보를 사용하여 실행 취소된다.     \n\n트랜잭션 ID가 lazy 할당 되기 때문에 읽기 전용 트랜잭션이나 데이터베이스를 수정하지 않는 트랜잭션이 불필요하게 트랜잭션 ID를 사용하지 않도록 한다.     \n\n#### 예시\n\n1. 격리수준 serializable 트랜잭션 A가 먼저 시작된다. 이후 트랜잭션 B가 시작된다. 그 다음 트랜잭션 B가 table1 에 12를 insert 하고 commit 해서 트랜잭션 A보다 먼저 종료되었다. 이 경우, 트랜잭션 B가 트랜잭션 A보다 먼저 처리된 것으로 간주하여 A는 B의 반영사항을 그대로 읽을 수 있다.\n2. 격리수준 repeatable read 트랜잭션 A가 먼저 시작된다. 이후 트랜잭션 B가 시작된다. 그 다음 트랜잭션 B가 table1 에 12를 insert 하고 commit 해서 트랜잭션 A보다 먼저 종료되었다. 이 경우, 트랜잭션 A는 B가 반영한 정보(12)를 볼 수 없다. 이유는 undo 영역의 snapshot 을 사용하여 트랜잭션 A가 유지되는 기간 동안 동일한 데이터를 읽어오기 때문이다.\n\n### 트랜잭션 격리 수준에서 발생할 수 있는 문제점\n\n#### Dirty Read\n특정 트랜잭션에 의해 데이터가 변경되었으나, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 트랜잭션 내부에서 발생한 변경 사항을 조회할 수 있는 문제이다. \n\nA 트랜잭션에서 데이터를 변경하고 커밋하지 않은 시점에 B 트랜잭션이 변경된 데이터를 읽은 상황에서 A 트랜잭션이 롤백하게 되면 치명적일 수 있다. B 트랜잭션은 롤백으로 무효가 된 데이터를 가지고 처리를 진행하기 때문에 문제가 발생한다.\n\n#### Non-Repetable Read\n같은 트랜잭션 내에서 같은 데이터를 여러 번 조회했을 때 읽어온 데이터가 다른 경우를 의미한다.\n\n#### Phantom Read\nNon-Repeatable Read의 한 종류로, 조회해온 결과의 행이 새로 생기거나 없어지는 현상이다.\n\n**참고**\n- https://hudi.blog/transaction-isolation-level/\n- https://mysqldba.tistory.com/334\n- https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation\n\n### Lock\n\n## Redo Log vs Undo Log\n\n### Redo Log\n\n- 목적\n데이터베이스 시스템의 장애나 중단 후 복구를 지원한다. 시스템 장애 발생 시 마지막 커밋된 상태로 데이터베이스를 복원할 수 있다.  \n- 작동 방식\n데이터베이스의 모든 변경 사항(insert, update, delete) 은 먼저 redo log 에 기록된다. 이 변경 사항은 실제 데이터베이스에 비동기적으로 적용될 수 있다. 시스템이 장애로 중단된 경우, redo log 의 내용은 복구 과정에서 사용되어 데이터베이스를 최근 커밋된 상태로 복원한다.\n\n### Undo Log\n\n- 목적\n데이터베이스 트랜잭션의 원자성과 일관성을 보장하는 것이다. 트랜잭션이 중간에 실패하거나 롤백되어야 하는 경우, 데이터베이스를 변경 전 상태로 되돌릴 수 있다.\n- 작동 방식\n트랜잭션이 레코드를 변경할 때, 원래 레코드 값을 undo log 에 기록한다. 트랜잭션이 실패하거나 롤백되는 경우 undo log 의 내용을 사용하여 해당 레코드를 원래 상태로 되돌린다.\n\n"},{"excerpt":"transactional 트랜잭션이란? 여러 SQL 문을 한 번에 커밋 혹은 롤백 할 수 있는 작업 단위 언제 트랜잭션을 사용하는가? 3단계 미션 회원 정보의 변경 이력 남기기 저는 비밀번호 바꾼적이 없어요.... 누가 바꿨는지 확인해주세요... 비밀번호 변경 && 변경 이력 둘 중 하나라도 실패하면 되돌려야 한다. SQL 문이 단건이면 트랜잭션을 안 써…","fields":{"slug":"/transaction-and-spring-transaction/"},"frontmatter":{"date":"2023년 10월 04일 01:10","title":"Transaction과 Spring Transaction 강의","tags":["우테코","레벨4","강의"]},"rawMarkdownBody":"\n[[transactional]]\n\n## 트랜잭션이란?\n\n여러 SQL 문을 한 번에 커밋 혹은 롤백 할 수 있는 작업 단위\n\n## 언제 트랜잭션을 사용하는가?\n\n- 3단계 미션\n\t- 회원 정보의 변경 이력 남기기\n\t\t- 저는 비밀번호 바꾼적이 없어요....\n\t\t- 누가 바꿨는지 확인해주세요...\n\t- 비밀번호 변경 && 변경 이력\n\t\t- 둘 중 하나라도 실패하면 되돌려야 한다.\n\n## SQL 문이 단건이면 트랜잭션을 안 써도 될까?\n\n- DB 내부에서는 여러 작업이 수행될 수도 있다.\n\t- 수천 개 레코드 조회\n\t- 컬럼에 따라 인덱스도 갱신\n- 단건 조회라도 트랜잭션을 붙이고 readonly 옵션을 사용하자.\n\n## Java 의 트랜잭션\n\n```java\ntry (final Connection connection = dataSource.getConnection();) {\n\tconnection.setAutoCommit(false);\n\t\n\t...\n\t\n\tconnection.commit();\n} catch (SQLException e) {\n\tconnection.rollback();\n\tthrow new DataAccessException(e);\n}\n```\n\n트랜잭션을 커밋 + 롤백하는 단위를 `트랜잭션 경계` 라고 한다.\n\n## `Connection` 이 제공하는 기능\n\n- 트랜잭션 경계 설정\n- 트랜잭션의 격리 레벨 설정\n\t- 격리 레벨은 ACID 모델 중 I 에 해당한다.\n- readonly 옵션\n- 그 외 데이터베이스 연결 관련 기능\n\n## 데이터베이스 설계 원칙 - ACID 모델\n\n- 어떤 상황에서도 데이터 손실이 없을 거라 신뢰할 수 있다. \n\n| 개념 (ACID) | DBMS      | 기술 (MySQL InnoDB)               |\n| ----------- | --------- | --------------------------------- |\n| Atomic      | 회복      | Transaction                       |\n| Consistency | 병행 제어 | DoublewriteBuffer, Crash Recovery |\n| Isolation   | 병행 제어 | Transaction Isolation Level       |\n| Durability  | 회복      | DoublewriteBuffer, Backup, etc.   |\n\n- [2] Doublewrite Buffer 란?\n\nMySQL 의 InnoDB 스토리지 엔진에서 사용된다. 시스템 장애나 갑작스러운 종료가 발생했을 때 데이터베이스 페이지의 부분적인 쓰기나 깨진 페이지들을 회복시켜준다.\n데이터베이스 페이지가 디스크에 기록되기 전에, 먼저 doublewrite buffer 에 두 번 쓰여지고 실제 데이터 파일 위치에 안전하게 쓰여진다. 즉, 원래 위치에 쓰기 중 문제가 발생하면 doublewrite buffer 에 있는 복사본을 사용하여 데이터를 복구할 수 있다.\n하드웨어 장애나 기타 예기치 않은 문제로 인한 데이터의 손상 또는 손실을 방지할 수 있다.\n\n- [1] Doublewrite buffer 와 crash recovery 의 차이점은 뭘까?\n\n둘 다 데이터베이스의 내구성, 무결성을 보장하기 위한 메커니즘이다.  \n\n- Doublewrite buffer\n\t- 목적: 디스크에 데이터를 쓸 때 부분적인 쓰기나 전원 중단 같은 예기치 않은 장애로 인한 데이터 페이지의 손상을 방지하거나 복구하는 것이다.\n\t- 즉, 디스크 쓰기 중의 데이터 손상을 방지하거나 복구하는 데 초점을 두고 있다.\n- Crash Recovery\n\t- 목적: 데이터베이스가 예기치 않은 중단 후 재시작될 때 트랜잭션의 일관성을 복원하고, 완료되지 않은 트랜잭션을 되돌리거나 완료하는 것이다.\n\t- 작동 방식: 데이터베이스는 변경 사항을 쓰기 전에 로그 (Redo Log) 에 기록한다. 데이터베이스가 갑작스럽게 중단된 후 재시작될 때, 해당 로그는 `crash recovery` 과정에서 사용되어 데이터베이스의 일관성을 복원한다. 완료되지 않은 트랜잭션은 이 로그를 사용하여 되돌리거나 완료된다.\n\t- 즉, 예기치 않은 데이터베이스 중단 후 트랜잭션의 일관성을 복원하는 데 초점을 두고 있다.\n\n## 스프링으로 트랜잭션 사용하기\n\n- JDBC API 로 트랜잭션을 적용하기 복잡하다.\n- 예기치 못한 상황이 발생할 수 있으니 timeout 설정은 해주는 것이 좋다.\n- isolation level, readonly을 설정할 수 있다.\n- 애플리케이션의 수준에서 propagation 을 설정할 수 있다.\n\n> 데이터베이스에서도 propagation 을 적용할 수 있을까?\n> \n> RDBMS 자체에서는 고수준의 트랜잭션 전파 설정을 직접 지원하지 않는다. 보통 고수준 프레임워크에서 제공되는 기능이다. \n"},{"excerpt":"Pool Size에 대해 를 번역하였습니다. 다른 변경 사항이 없는 상태에서 커넥션 풀 크기만 줄였을 때 애플리케이션 응답 시간이 최대 100ms 에서 2ms 로 50배 이상 개선되었다는 Oracle 의 성능 측정 결과가 있었다. 실제로는 단일 코어는 한 번의 하나의 스레드만 실행할 수 있고, 운영체제가 컨텍스트를 전환할 때 해당 코어가 다른 스레드의 코…","fields":{"slug":"/about-pool-sizing/"},"frontmatter":{"date":"2023년 10월 03일 08:10","title":"Pool Size 에 대해","tags":["spring","database"]},"rawMarkdownBody":"\n> [Pool Size에 대해](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing) 를 번역하였습니다.\n\n다른 변경 사항이 없는 상태에서 커넥션 풀 크기만 줄였을 때 애플리케이션 응답 시간이 최대 100ms 에서 2ms 로 50배 이상 개선되었다는 Oracle 의 성능 측정 결과가 있었다.  \n\n실제로는 단일 코어는 한 번의 하나의 스레드만 실행할 수 있고, 운영체제가 컨텍스트를 전환할 때 해당 코어가 다른 스레드의 코드를 실행하는 방식으로 실행된다.  \n물론 하나의 CPU 리소스가 A, B 를 순차적으로 실행하는 것이 타임 슬라이싱으로 A, B 를 동시에 실행하는 것보다 항상 더 빠르다. 스레드 수가 CPU 코어 수를 초과하면 더 많은 스레드를 추가하여 속도가 빨라지는 것이 아니라 **느려진다**.\n\n## 데이터베이스의 주요 병목 현상\n\n**CPU, 디스크, 네트워크**\n\n간단하게 생각하면 컴퓨팅 코어가 8개인 서버에서 연결 수를 8개로 설정하면 최적의 성능을 제공할 수 있고, 그 이상이면 컨텍스트 전환의 오버헤드로 인해 속도가 느려지기 시작할 것이다.  \n\n그렇지만 디스크와 네트워크도 무시할 수는 없다.  \n\n데이터베이스는 일반적으로 읽기 / 쓰기 헤드가 있는 디스크에 데이터를 저장한다. 읽기 / 쓰기 헤드는 한 번에 한 곳에만 있을 수 있기 떄문에 다른 쿼리에 대한 데이터를 읽기 / 쓰기 하려면 새로운 위치로 탐색해야 한다. 즉, 탐색 시간 비용이 발생하고, 디스크가 플래터에서 데이터가 읽기 / 쓰기를 위해 다시 돌아올 때까지 기다려야 하는 회전 비용도 발생한다. (캐싱이 좀 더 효율적으로 도와주겠지만, 기본적으로는 이런 과정을 거쳐야 한다.)  \n\nI/O 대기시간 동안 커넥션 / 쿼리 / 스레드는 디스크를 기다리면서 단순하게 'block' 된다.  \n이 시간 동안 OS 는 다른 스레드에 대한 코드를 더 실행하여 해당 CPU 리소스를 더 잘 사용할 수 있다. 즉, 스레드가 I/O 에서 차단되는 시간이 존재하기 때문에, 실제로는 물리적인 컴퓨팅 코어 수보다 많은 수의 커넥션 / 스레드를 보유하여 더 많은 작업을 수행할 수 있는 것이다.  \n\n얼마나 더 많은지는 디스크 서브시스템에 따라 다르다. 최신 SSD 드라이브에는 탐색 시간 비용, 회전 요인이 없다.  \n'SSD가 더 빠르니 더 많은 스레드를 사용할 수 있다' 는 말이 아니다. 더 빠르고, 탐색이 없고, 회전 지연이 없다는 것은 block 이 적다는 것을 의미하기 때문에 더 적은 수의 스레드가 더 많은 스레드보다 더 나은 성능을 발휘할 수 있다. 더 많은 스레드는 blocking 으로 인해 실행 기회가 생길 때만 더 나은 성능을 발휘하는 것이다.  \n\n네트워크도 디스크와 유사하다. 이더넷 인터페이스를 통해 유선으로 데이터를 사용하는 경우에도 송수신 버퍼가 가득 차서 멈출 때 blocking 이 발생할 수 있다. 그러나 네트워크는 리소스 block 측면에서는 계산에서 생략해도 괜찮다.  \n\n![[postgresql-benchmark.png]]\n\n위의 PostgreSQL 벤치마크에서 약 50개의 커넥션에서 TPS 속도가 평탄해진다. 16코어, 32코어를 사용하지 않는다면 커넥션 96개도 너무 많다. \n\n## 공식\n\n애플리케이션을 테스트하고, 이 공식을 중심으로 다양한 풀 설정을 시도해보아야 한다.  \n\n$$connections = (corecount* 2 + effectiveSpindleCount)$$\n\n(코어수는 하이퍼 스레딩이 활성화 되어 있더라도 HT 스레드를 포함해서는 안 된다.)\n\n> effectiveSpindleCount 란?\n>\n> 스토리지의 회전하는 디스크(HDD) 수를 의미한다.  \n> 기본적으로 스토리지가 데이터를 빠르게 액세스 하려면 여러 HDD 를 동시에 사용하여 다중 I/O 작업을 수행할 수 있어야 한다. 하지만 데이터가 메모리에 완전히 캐시되어 있으면 디스크 액세스가 필요하지 않으므로 effectiveSpindleCount 는 0이 된다. 캐시 히트율이 떨어질수록, 스토리지 액세스의 필요성이 높아지므로 effectiveSpindleCount 는 실제 스핀들의 숫자에 접근하게 된다.  \n\nEx. 4코어 I7 서버에 HDD 하나가 있다면 커넥션 풀의 크기는 다음과 같아야 한다.  \n\n$$9 = (4 * 2 + 1)$$\n\n값이 작아보이지만, 해당 설정에서 3000명의 프론트엔드 사용자가 6000TPS 로 간단한 쿼리를 실행하는 것을 쉽게 처리할 수 있다.  \n\n프론트엔드 사용자가 10000명일 때 10000개의 커넥션 풀을 갖는 것은 미친 짓이다. 1000개도 끔찍하다. 100개도 과하다. 최대 수십 개의 연결로 구성된 소규모 풀이 필요하며, 나머지 애플리케이션 스레드는 풀에서 커넥션을 기다리는 상태로 block 되어야 한다.  \n`CPU 코어 * 2` 를 초과하는 경우는 거의 없다.  \n\n> 조금 더 알아봤는데...\n> CPU 바운드가 높은 작업에서만 해당되는 공식일 수도\n\n## Pool Locking\n\n단일 액터가 많은 커넥션을 얻는 것과 관련해서 Pool Locking 의 가능성이 제기되었다. 그러나 대부분 응용 프로그램 수준의 문제이다. 물론 풀 크기를 늘리면 이런 시나리오에서 lock 을 완화할 수 있지만, 풀을 확장하기 전에 응용 프로그램 수준에서 무엇을 할 수 있는지 먼저 살펴봐야 한다.  \n\n데드락을 피하기 위해 풀 크기를 계산하는 것은 다음과 같은 공식으로 가능하다.  \n\n$$poolsize = T_{n} * (C_{m}- 1) + 1$$\n\n어떤 작업을 수행하기 위해 4개의 커넥션이 필요한 세 개의 스레드 $T_{n}= 3$ 이 있다고 가정하자. 데드락이 절대 발생하지 않도록 보장하기 위해 필요한 풀 크기는 $3 * (4 - 1) + 1 = 10$ 이다.  \n\n이는 반드시 최적의 풀 크기는 아닐 수 있지만, 데드락을 피하기 위한 최소한의 크기이다.  \n어떤 환경에서는 `JTA (JavaTransaction Manager)` 를 사용하여 현재 트랜잭션에서 이미 커넥션을 보유하고 있는 스레드에 `getConnection()` 에서 동일한 `Connection` 을 반환함으로써 필요한 커넥션을 크게 줄일 수 있다.\n\n> 액터란?\n> \n> 동시성 프로그래밍에서 독립적으로 실행되는 엔티티를 의미한다. 액터들은 서로 메시지를 주고받으며 통신하고 동작한다. 각 액터는 자신만의 상태를 가지고, 외부에서 직접 접근할 수 없다. 대신, 액터는 받은 메시지에 따라 내부 상태를 변경하거나 다른 액터에 메시지를 보내는 등의 작업을 수행한다.  \n> \n> 그러나 위의 맥락에서는 일반적인 액터 모델의 의미가 아닌 동시성을 다루는 작업 단위나 엔티티를 의미한다. \n\n\n- [?] 액터가 여러 커넥션을 얻는 경우 예시\n- 액터가 동시에 여러 테이블이나 데이터 셋에서 정보를 가져와야 할 때, 각 쿼리에 대해 별도 커넥션을 확보할 수 있다. \n- 여러 외부 서비스와 통신해야 하는 작업을 수행할 때, 각 서비스마다 별도의 커넥션을 열 수 있다.\n- 액터가 여러 리소스에 대한 동시 트랜잭션을 관리해야 할 때, 각 리소스에 대한 커넥션을 유지하게 된다.  \n"},{"excerpt":"데이터 커넥션 풀이란? In software engineering, a connection pool is a cache of database connections maintained so that the connections can be reused when future requests to the database are required. 데이터베이스에 …","fields":{"slug":"/hikaricp/"},"frontmatter":{"date":"2023년 10월 03일 05:10","title":"HikariCP","tags":["spring","레벨4","우테코"]},"rawMarkdownBody":"\n## 데이터 커넥션 풀이란?\n\n> In [software engineering](https://en.wikipedia.org/wiki/Software_engineering \"Software engineering\"), a **connection pool** is a [cache](https://en.wikipedia.org/wiki/Database_cache \"Database cache\") of [database connections](https://en.wikipedia.org/wiki/Database_connection \"Database connection\") maintained so that the connections can be reused when future requests to the database are required.\n\n데이터베이스에 대한 요청이 필요할 때 커넥션을 재사용할 수 있도록 유지 / 관리되는 데이터베이스 커넥션 캐시이다. 데이터베이스에서 명령을 실행하는 성능을 향상시키기 위해 사용된다.  \n\n각 유저마다 데이터베이스 커넥션을 열고 유지하는 것은 리소스가 많이 든다.  \n커넥션 풀에서는 커넥션이 생성된 후 풀에 재배치되어 다시 사용되므로, 새롭게 연결을 설정할 필요가 없다.  \n\n## hikariCP 란?\n\nJava 에서 사용하는 130KB 의 매우 가벼운 고성능 JDBC 커넥션 풀 라이브러리이다.  \n\n### hikariCP 를 사용할 때의 이점\n\n#### 다른 커넥션 풀과 비교\n\nhikariCP 의 깃허브에는 다음과 같은 사진이 있다.  \n\nhikariCP 가 빠른 이유는 다음과 같다.  \n\n1. 바이트코드 수준의 엔지니어링: 어셈블리 수준의 네이티브 코딩을 포함한 극한의 바이트코드 수준 엔지니어링이 수행되었다.\n2. 마이크로 최적화: 측정하기는 어렵지만, 최적화가 결합되어 전반적인 성능을 향상시켰다.\n3. `Collections` 프레임워크의 똑똑한 사용: range chacking 을 제거하고, head to tail 제거 스캔을 수행하는 사용자 정의 클래스인 `FastList` 로 `ArrayList<Statement>` 를 대체했다.  \n\n## `HikariConfig`\n\n데이터 소스를 초기화하는 데 사용되는 configuration 클래스이다.  \n해당 클래스는 username, password, jdbcUrl, dataSourceClassName 같은 반드시 필요한 4가지 매개 변수가 포함되어 있다.  \n\n`jdbcUrl` 및 `dataSourceClassName` 중 일반적으로 한 번에 하나씩 사용한다.\n\n다른 풀링 프레임워크에서는 제공하지 않는 다음과 같은 기능들을 제\n공한다.  \n\n- _autoCommit_\n- _connectionTimeout_\n- _idleTimeout_\n- _maxLifetime_\n- _connectionTestQuery_\n- _connectionInitSql_\n- _validationTimeout_\n- _maximumPoolSize_\n- _poolName_\n- _allowPoolSuspension_\n- _readOnly_\n- _transactionIsolation_\n- _leakDetectionThreshold_\n\n## 사용하기\n\n```java\nprivate static HikariConfig config = new HikariConfig(\n    \"datasource.properties\" );\n```\n\n`resources` 디렉터리에 있는 properties 파일로 초기화할 수 있다.  \n\n다음과 같은 특성들이 필요하다.  \n\n```properties\ndataSourceClassName=org.postgresql.ds.PGSimpleDataSource\ndataSource.user=test\ndataSource.password=test\ndataSource.databaseName=mydb\ndataSource.portNumber=5432\ndataSource.serverName=localhost\n```\n\n## 자주 사용되는 property\n\n- `autoCommit`\n풀에서 반환된 커넥션의 auto-commit 을 제어한다.  \n**기본값은 true 이다.**  \n\n- `connectionTimeout`\n클라이언트 (사용자) 가 풀에서 커넥션을 기다리는 최대 시간을 제어한다.  \n연결을 사용할 수 없는 상태에서 해당 시간을 초과하면 `SQLException` 이 발생한다.  \n최소 연결 시간 제한은 250ms 이다.  \n**기본값은 30000(30초)**\n\n- `idleTimeout`\n풀에서 커넥션이 유휴 상태로 유지될 수 있는 최대 시간을 제어한다.  \n`minimumIdle` 이 `maximumPoolSize` 보다 작도록 정의된 경우에만 적용된다.  \n풀이 `minimumIdle` 커넥션 개수에 도달하면 유휴 커넥션은 삭제되지 않는다. 커넥션이 유휴 상태로 종료되었는지는 평균 15초, 최대 30초의 차이가 있을 수 있다.  \n값이 0이면 유휴 연결이 풀에서 제거되지 않는다. 허용되는 최솟값은 10000ms이다.  \n**기본값은 600000ms(10분)**\n\n- `keepaliveTime`\n데이터베이스 또는 네트워크 인프라에 의해 커넥션이 time out 되는 것을 방지하기 위해 HikariCP 가 커넥션을 유지하려고 시도하는 빈도를 제어한다. `maxLifeTime` 값보다 작아야 한다!\n커넥션 유지는 '유휴 연결' 에서만 발생한다. 특정 커넥션에 대해 `keepaliveTime` 이 되면 해당 연결이 풀에서 제거되고, `ping` 이 수행된 후 다시 풀에 반환된다.  \n일반적으로 풀에서의 지속 시간은 단일 자릿수 밀리초 혹은 그보다 더 짧아야 한다. 즉, 성능에 거의 / 전혀 영향을 미치지 않아야 한다. 허용되는 최솟값은 30000ms (30초) 이지만, 몇 분 정도의 값이 가장 바람직하다.  \n**기본값은 0 (비활성화)**\n\n> 🤔 여기서 말하는 `ping` 이란?\n> \n> 데이터베이스 연결이 여전히 활성화되어 있고, 정상적으로 작동하는지 확인하기 위한 간단한 테스트나 확인 작업.  \n> \n> `JDBC4` 의 `isValid()` 메서드로 데이터베이스 연결이 여전히 유효한지 확인하거나, `connectionTestQuery` 같은 사용자가 제공하는 간단한 SQL 쿼리를 데이터베이스에 실행하여 연결의 유효성을 검사하는 방식으로 ping 을 수행할 수 있다.  \n\n- `maxLifetime`\n풀에 있는 커넥션의 최대 수명을 제어한다.  \n사용 중인 커넥션은 절대로 종료되지 않고, 커넥션이 종료될 때만 제거된다. 풀에서의 대량 소멸을 방지하기 위해 커넥션별로 약간의 음의 감쇠가 적용된다.  \n**해당 값을 설정하는 것이 좋고**, 데이터베이스나 인프라에 설정된 connection time limit 보다 몇 초 더 짧게 설정하는 것이 좋다.  \n\n0 값은 최대 수명이 없음을 나타내고, (물론 `idleTimeout` 에 따라 달라질 수 있다.) 허용되는 최소값은 30000ms (30초) 이다.  \n**기본값은 1800000ms (30분)**\n\n- `connectionTestQuery`\n드라이버가 `JDBC4` 를 지원하는 경우에는 이 속성을 설정하지 않는 것이 좋다.  \n`JDBC4 Connection.isValid()` API 를 지원하지 않는 레거시 드라이버를 위한 속성이다.  \n\n- `minimumIdle`\nHikariCP 가 풀에서 유지하려고 시도하는 최소 유휴 커넥션 수를 제어한다.  \n유휴 커넥션이 이 값 아래로 떨어지고, 풀의 총 커넥션 수가 최대 풀 크기보다 작아지면 커넥션을 추가한다.  \n성능과 급증하는 요청에 대한 응답성을 극대화하기 위해서는 해당 값을 설정하지 않고, HikariCP가 고정 크기 연결 풀로 작동하도록 하는 것이 좋다.  \n**기본값은 `maximumPoolSize` 와 동일**\n\n- `maximumPoolSize`\n유휴 커넥션과 사용 중인 커넥션을 모두 포함해서 풀이 가질 수 있는 최대 크기를 제어한다.  \n기본적으로 해당 값에 따라 데이터베이스 백엔드의 실제 최대 커넥션 수가 결정된다.  \n풀이 이 크기에 도달하고, 사용 가능한 유휴 커넥션이 없는 경우, `getConnection()` 호출은 time out 전까지 최대 `connectionTimeout` 밀리초 동안 block 된다.  \n**기본값은 10**\n\n### 주의할 것\n\n지나치게 많은 값을 `maximumPoolSize` 로 잡지 않도록 주의해야 한다.  \n자세한 내용은 [[about-pool-sizing]] 에서 확인하자. \n\n## 튜닝이 필요한 이유\n\n- 불필요하게 많은 커넥션을 유지하게 되면 메모리, 시스템 리소스가 낭비된다.  \n- 데이터베이스 커넥션을 생성 / 종료하는 것은 리소스를 많이 소모한다. 적절한 수의 커넥션을 유지하여 애플리케이션이 데이터베이스에 더 빠르게 액세스할 수 있다.  \n- 특정 상황에서 너무 많은 커넥션 요청이 있을 때 데드락이 발생할 수 있는데, 커넥션 풀 튜닝으로 이런 문제들을 예방할 수 있다.\n\n## MySQL 권장 설정\n\n- `prepStmtCacheSize`\nMySQL 드라이버가 커넥션 당 캐시할 `PreparedStatement` 수를 설정한다. 250-500 사이로 설정하는 것이 좋다.  \n**기본값은 25**\n\n- `prepStmtCacheSqlLimit`\n드라이버가 캐시할 `PreparedStatement` SQL 문의 최대 길이이다. MySQL 기본값은 256이다. Hibernate 와 같은 ORM 프레임워크의 경우 기본값은 생성되는 statement 의 길이보다 작은 편이다. **권장 설정 값은 2048이다.**\n\n- `cachePrepStmts`\n캐시가 기본적으로 비활성화되어 있는 경우, 위의 매개변수 중 어느 것도 영향을 미치지 않으므로 해당 매개변수를 true 로 설정해야 한다.  \n\n- `useServerPrepStmts`\n최신 버전의 MySQL 은 server-side `PreparedStatement` 를 지원하므로, 성능이 크게 향상될 수 있다. 해당 속서을 true 로 설정한다.  \n\nHikariCP 의 일반적인 MySQL 설정은 다음과 같다.  \n\n```properties\njdbcUrl=jdbc:mysql://localhost:3306/simpsons\nusername=test\npassword=test\ndataSource.cachePrepStmts=true\ndataSource.prepStmtCacheSize=250\ndataSource.prepStmtCacheSqlLimit=2048\ndataSource.useServerPrepStmts=true\ndataSource.useLocalSessionState=true\ndataSource.rewriteBatchedStatements=true\ndataSource.cacheResultSetMetadata=true\ndataSource.cacheServerConfiguration=true\ndataSource.elideSetAutoCommits=true\ndataSource.maintainTimeStats=false\n```\n\n## 참고\n\n- https://en.wikipedia.org/wiki/Connection_pool\n- https://www.baeldung.com/hikaricp\n- [hikariCP 공식 Github](https://github.com/brettwooldridge/HikariCP)\n- https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration"},{"excerpt":"TODO 미션 리뷰하기  [priority:: highest]  [created:: 2023-10-02]  [due:: 2023-10-02]  [completion:: 2023-10-02] 기숙사 퇴사 신청  [priority:: highest]  [created:: 2023-10-02]  [due:: 2023-10-02]  [completion:: 20…","fields":{"slug":"/2023-10-02/"},"frontmatter":{"date":"2023년 10월 02일 12:10","title":"2023년 10월 02일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 미션 리뷰하기  [priority:: highest]  [created:: 2023-10-02]  [due:: 2023-10-02]  [completion:: 2023-10-02]\n- [x] 기숙사 퇴사 신청  [priority:: highest]  [created:: 2023-10-02]  [due:: 2023-10-02]  [completion:: 2023-10-02]\n\n## LOG\n\n- 링글 수업을 들었다. 저번 링글 수업보다는 덜 떨었고, 좀 더 자신있게 말했다. 다행히 선생님도 말하기 편해서 더 잘 말할 수 있었다. \n\n## 배운 것\n\n## 느낀 것\n\n- 뭔가를 생각할 때마다 머리가 뒤죽박죽이다. 무슨 말을 할 때 단어들이 정돈되지 않고 한 번에 마구잡이로 나오는 편이다. 그래서 그런지 영어를 할 때도 정돈되지 않은 문장으로 황급하게 말하는 습관이 있는 것 같다. 이제 말할 때 기회가 한 번 밖에 없다고 생각하고 머릿속에서 정리된 문장을 말하고 쓸 수 있도록 노력해야겠다."},{"excerpt":"TODO LOG 배운 것 느낀 것","fields":{"slug":"/2023-10-01/"},"frontmatter":{"date":"2023년 10월 01일 09:10","title":"2023년 10월 01일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"JDBC 란? 자바에서 데이터베이스에서 접근하기 위한 API 이다. JDBC 는 관계형 데이터베이스로의 저수준 연결과 SQL 쿼리 실행을 지원하고, Java 애플리케이션과 데이터베이스 사이의 중간다리 역할을 한다.  의 인스턴스는 한 번 설정되면 Thread-safe 하다.  참조로 직접 인스턴스화해서 서비스 구현에서 사용하거나,  안에서 준비되고 bea…","fields":{"slug":"/jdbctemplate/"},"frontmatter":{"date":"2023년 09월 27일 08:09","title":"JdbcTemplate","tags":["java","spring","database"]},"rawMarkdownBody":"\n## JDBC 란?\n\n자바에서 데이터베이스에서 접근하기 위한 API 이다.  \nJDBC 는 관계형 데이터베이스로의 저수준 연결과 SQL 쿼리 실행을 지원하고, Java 애플리케이션과 데이터베이스 사이의 중간다리 역할을 한다.  \n\n`JdbcTemplate` 의 인스턴스는 한 번 설정되면 Thread-safe 하다. `Datasource` 참조로 직접 인스턴스화해서 서비스 구현에서 사용하거나, `ApplicationContext` 안에서 준비되고 bean 참조를 통해 사용할 수도 있다.\n\n`ApplicationContext` 에서 `DataSource` 는 언제나 빈으로 설정되어야 하고, 첫 번째 경우 (`DataSource` 참조) 에는 서비스에 직접 제공되고, 두 번째 경우에는 준비된 템플릿으로 제공되어야 한다.\n\n### 특징\n\n- `JdbcTemplate` 은 thread-safe 하다.\n`JdbcTemplate` 의 주요 설정인 `DataSource`, `SQLExceptionTranslator` 등은 생성 시점 또는 초기 설정 후에 변경되지 않는다.  \n또한 `JdbcTemplate` 은 SQL 과 관련된 로직을 처리하기 위해 콜백 패턴을 사용한다. 사용자는 특정 작업을 위한 콜백 인터페이스를 제공하는데, 콜백들은 각 스레드별로 독립적으로 동작한다.  \n- \n\n### 구성 요소\n\n#### `Connection`\n\n데이터베이스 연결을 대표하는 객체이다.  \n해당 객체를 통해 SQL 명령을 실행하거나, 다른 데이터베이스 작업을 수행한다.  \n\n#### `Statement`, `PreparedStatement`\n\nSQL 문을 데이터베이스에 보내기 위한 객체. `PreparedStatement` 는 파라미터를 동적으로 바인딩해야 하는 SQL 문을 실행하는 데 사용된다.  \n\n#### `ResultSet`\n\nSQL 쿼리의 결과를 나타내는 객체. 데이터베이스로부터 반환된 데이터를 순차적으로 접근할 수 있다.  \n\n#### `SQLException`\n\n데이터베이스 작업 중 발생하는 예욀르 처리하는 데 사용되는 예외 클래스이다.  \n\n## JdbcTemplate 이란?\n\nSpring Framework 에서 제공하는 클래스로, Java 의 JDBC API 를 더 쉽게 효율적으로 사용할 수 있도록 도와준다.  \n\nJDBC 의 코드 중복, 오류 처리, 연결 관리 등의 공통 작업들을 단순화 시키며, 개발자는 SQL 쿼리 실행과 관련된 핵심 비즈니스 로직에만 집중할 수 있게 된다.  \n\n## `JdbcAccessor`\n\n`DataSource` 나 exception translator 같은 공통 속성을 정의하는 `JdbcTemplate` 및 기타 JDBC-accessing DAO helper 들을 위한 base class 이다.  \n\n코드는 다음과 같다.  \n\n```java\npackage org.springframework.jdbc.support;  \n  \nimport javax.sql.DataSource;  \n  \nimport org.apache.commons.logging.Log;  \nimport org.apache.commons.logging.LogFactory;  \n  \nimport org.springframework.beans.factory.InitializingBean;  \nimport org.springframework.lang.Nullable;  \nimport org.springframework.util.Assert;  \n  \npublic abstract class JdbcAccessor implements InitializingBean {  \n  \n    /** Logger available to subclasses. */  \n    protected final Log logger = LogFactory.getLog(getClass());  \n  \n    @Nullable  \n    private DataSource dataSource;  \n  \n    @Nullable  \n    private volatile SQLExceptionTranslator exceptionTranslator;  \n  \n    private boolean lazyInit = true;  \n  \n  \n\tpublic void setDataSource(@Nullable DataSource dataSource) {  \n       this.dataSource = dataSource;  \n    }  \n  \n    @Nullable  \n    public DataSource getDataSource() {  \n       return this.dataSource;  \n    }  \n  \n    protected DataSource obtainDataSource() {  \n       DataSource dataSource = getDataSource();  \n       Assert.state(dataSource != null, \"No DataSource set\");  \n       return dataSource;  \n    }  \n  \n    public void setDatabaseProductName(String dbName) {  \n       if (SQLErrorCodeSQLExceptionTranslator.hasUserProvidedErrorCodesFile()) {  \n          this.exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dbName);  \n       }  \n       else {  \n          this.exceptionTranslator = new SQLExceptionSubclassTranslator();  \n       }  \n    }  \n    \n    public void setExceptionTranslator(SQLExceptionTranslator exceptionTranslator) {  \n       this.exceptionTranslator = exceptionTranslator;  \n    }  \n  \n    public SQLExceptionTranslator getExceptionTranslator() {  \n       SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator;  \n       if (exceptionTranslator != null) {  \n          return exceptionTranslator;  \n       }  \n       synchronized (this) {  \n          exceptionTranslator = this.exceptionTranslator;  \n          if (exceptionTranslator == null) {  \n             if (SQLErrorCodeSQLExceptionTranslator.hasUserProvidedErrorCodesFile()) {  \n                exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(obtainDataSource());  \n             }  \n             else {  \n                exceptionTranslator = new SQLExceptionSubclassTranslator();  \n             }  \n             this.exceptionTranslator = exceptionTranslator;  \n          }  \n          return exceptionTranslator;  \n       }  \n    }  \n    \n\tpublic void setLazyInit(boolean lazyInit) {  \n       this.lazyInit = lazyInit;  \n    }  \n  \n    public boolean isLazyInit() {  \n       return this.lazyInit;  \n    }  \n  \n    @Override  \n    public void afterPropertiesSet() {  \n       if (getDataSource() == null) {  \n          throw new IllegalArgumentException(\"Property 'dataSource' is required\");  \n       }  \n       if (!isLazyInit()) {  \n          getExceptionTranslator();  \n       }  \n    }  \n}\n```\n\n- `setLazyInit` : `SQLException` 를 처음 접했을 때, `SQLExceptionTranslator` 를 lazy 초기화할지 정한다.  \n\n#### 왜 `SQLExceptionTranslator` 를 지연 초기화 가능하게 했을까?\n\n`SQLExceptionTranslator` 는 JDBC의 `SQLException` 을 Spring 의 데이터 접근 계층 예외로 변환하는 역할을 한다.  \n\n1. 모든 사용자가 `SQLExceptionTranslator` 의 기능을 필요로 하지 않는다. 모든 상황에서 불필요하게 초기화하는 것은 리소스 낭비가 될 수도 있다.\n2. 사용자가 필요에 따라 다른 `SQLExceptionTranslator` 구현체를 제공할 수 있는 유연성을 제공한다.  \n\n## `JdbcOperations`\n\nJDBC 작업을 위한 주요 메서드들을 정의한다.  \n`JdbcTemplate` 은 `JdbcOperations` 의 구현체로, 실제 데이터베이스 작업을 수행한다.  \n\n직접적으로 자주 사용되지는 않으나, 쉽게 mocking 하거나 stubbing 할 수 있어 테스트 가용성을 높일 수 있다.  \n\n```java\npublic interface JdbcOperations {\n\t@Nullable  \n\t<T> T execute(ConnectionCallback<T> action) throws DataAccessException;\n\n\t<T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException;\n\n\t@Nullable  \n\t<T> T queryForObject(String sql, RowMapper<T> rowMapper) throws DataAccessException;\n\n\tMap<String, Object> queryForMap(String sql) throws DataAccessException;\n\n\t<T> List<T> queryForList(String sql, Class<T> elementType) throws DataAccessException;\n\n\tint update(String sql) throws DataAccessException;\n\n...\n}\n```\n\n`queryForObject` 나 `query` 같은 메서드들은 Spring 의 `JdbcTemplate` 과 관련된 편의 메서드들이다.  \n\n## 참고\n\n- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html\n- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcOperations.html"},{"excerpt":"TODO 코드 리뷰 반영  [priority:: highest]  [due:: 2023-09-27]  [completion:: 2023-09-27] LOG 배운 것 느낀 것","fields":{"slug":"/2023-09-27/"},"frontmatter":{"date":"2023년 09월 27일 08:09","title":"2023년 09월 27일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 코드 리뷰 반영  [priority:: highest]  [due:: 2023-09-27]  [completion:: 2023-09-27]\n\n## LOG\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO 견적 보내기  [priority:: high]  [created:: 2023-09-26]  [due:: 2023-09-26]  [completion:: 2023-09-26] 새 안경 맞추기  [scheduled:: 2023-09-27]  [due:: 2023-09-27]  [completion:: 2023-09-27] 닉네임 변경 API 추가  …","fields":{"slug":"/2023-09-26/"},"frontmatter":{"date":"2023년 09월 26일 11:09","title":"2023년 09월 26일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 견적 보내기  [priority:: high]  [created:: 2023-09-26]  [due:: 2023-09-26]  [completion:: 2023-09-26]\n- [x] 새 안경 맞추기  [scheduled:: 2023-09-27]  [due:: 2023-09-27]  [completion:: 2023-09-27]\n- [x] 닉네임 변경 API 추가  [priority:: highest]  [due:: 2023-09-26]  [completion:: 2023-09-26]\n- [x] 미션 리뷰 반영  [priority:: medium]  [due:: 2023-09-26]  [completion:: 2023-09-26]\n\n## LOG\n\n- YBM 레벨 테스트를 봤다. 처음에는 걱정했었는데 어제보다는 좀 덜 떨었던 것 같다. 내 실력은 내가 잘 알기 때문에...ㅋㅋㅋ 오히려 편하게 봤던 것 같다. 그리고 테스트해주신 선생님이 굉장히 친절하시고 이야기를 잘 들어주셔서 부담이 많이 덜어졌다. 아마 10월 초부터 주 1회 다닐 것 같다. 링글도 같이 병행해야지. 사실 오늘 링글 샀음 ㅎ\n- 안경이 박살 났다... 안경이 너무 자주 부서져서 그냥 새로 사려고 한다.\n- 베로 위키 이전을 위한 블로그 디자인이 오늘 대략적으로 끝났다. 이제 RSS 만 성공적으로 붙이면 잘 될 것 같다 👍\n\n## 배운 것\n\n## 느낀 것\n"},{"excerpt":"애플리케이션에서 데이터베이스로 연결하기 많은 웹 애플리케이션에서 DB 를 활용한다. 하지만 애플리케이션에서 DB 연결하는 것은 상당히 비용이 많이 드는 작업이다. 연결에 필요한 객체의 JVM GC 처리 TCP 연결 생성 / 종료의 I/O 처리 DB 연결 비용을 줄일 방법이 없을까? Connection Pooling 이란? 미리 DB 에 연결한 객체를 재사…","fields":{"slug":"/level4-db-connection-pool/"},"frontmatter":{"date":"2023년 09월 26일 02:09","title":"DB connection Pool 강의","tags":["레벨4","우테코"]},"rawMarkdownBody":"\n## 애플리케이션에서 데이터베이스로 연결하기\n\n- 많은 웹 애플리케이션에서 DB 를 활용한다.\n- 하지만 애플리케이션에서 DB 연결하는 것은 상당히 비용이 많이 드는 작업이다.  \n\t- 연결에 필요한 객체의 JVM GC 처리\n\t- TCP 연결 생성 / 종료의 I/O 처리\n- DB 연결 비용을 줄일 방법이 없을까?\n\n## Connection Pooling 이란?\n\n- 미리 DB 에 연결한 객체를 재사용하면 비용을 줄일 수 있다. \n- 사용 가능한 연결 객체가 없고 최대 크기에 도달하지 않았다면 새 연결을 만든다.\n\n## Pooling vs No Pooling\n\n- 정말로 Connectino pooling 이 더 빠른지 실험해보자."},{"excerpt":"노래 등록 기능 현재는 노래를 팀 내부에서 개인적으로 추가하고 있다. 그러나 이런 사이클은 오래가기 힘들고, 전적으로 우리가 좋아하는 노래 위주로 노래가 추가될 가능성이 높다. 그게 나쁘다는 건 아니지만 사용자의 니즈와는 조금 동떨어진 노래들이 있을 수 있다는 것이다. 다음과 같은 플로우를 제공한다. 노래 이름, 가수 이름, 유튜브 공식 뮤비 링크를 업로…","fields":{"slug":"/shook-sixth-demoday-function/"},"frontmatter":{"date":"2023년 09월 26일 00:09","title":"S-HOOK 에 더 추가하고 싶은 기능","tags":["shook","기획"]},"rawMarkdownBody":"\n## 노래 등록 기능\n\n현재는 노래를 팀 내부에서 개인적으로 추가하고 있다.  \n그러나 이런 사이클은 오래가기 힘들고, 전적으로 우리가 좋아하는 노래 위주로 노래가 추가될 가능성이 높다. 그게 나쁘다는 건 아니지만 사용자의 니즈와는 조금 동떨어진 노래들이 있을 수 있다는 것이다.  \n\n다음과 같은 플로우를 제공한다.  \n\n1. 노래 이름, 가수 이름, 유튜브 공식 뮤비 링크를 업로드한다.\n2. 자신이 생각하는 킬링파트를 넣는다. (굳이 3개가 아니어도 되지만 하나는 꼭 올려야 한다.)\n3. 노래가 등록된다.\n\n**발생할 수 있는 문제점들**\n\n- 노래 이름, 가수 이름이 공식적인 이름이 아닐 수 있다.\n\t- 해결책\n\t\t1. 현재 ==등록 대기중인 노래==라는 탭을 추가한다. 등록 대기중인 노래는 중간에 노래 이름, 가수 이름이 변경될 수 있고, 부적절한 경우 삭제가 가능함을 명시한다. \n\t\t\t- 킬링파트가 N 개 이상 등록되면 노래가 등록된다.\n\t\t2. 노래를 추가할 수 있게 하고, 신고 시스템을 촘촘하게 만든다. (악의적인 유저 존재 가능)\n\t\t3. maniaDB API 를 사용하여 해당 DB 에 존재하는 노래 이름과 가수 이름만 넣을 수 있도록 한다.\n- 노래 이름, 가수 이름이 이상할 수 있다. (악의적인 유저 가정)\n\t- 해결책\n\t\t- 노래 신고 기능 추가\n\t\t- 주기적으로 모니터링한다.\n- 이상한 킬링파트가 들어갈 수 있다.\n\t- 해결책\n\t\t- 킬링파트 신고 기능 추가\n\t\t- 주기적으로 모니터링한다.\n- 앨범 커버는 우리가 넣어줘야 한다.\n\t- 해결책\n\t\t1. 앨범 커버는 없어도 등록할 수 있도록 한다.\n\t\t2. 앨범 커버가 있어야 등록할 수 있도록 한다.\n\t\t\t1. 마지막에 노래가 등록되기 전, 우리가 주기적으로 확인해서 앨범 커버만 추가한다.\n\n## 킬링파트 등록 개선\n\n- 킬링파트 길이는 토글됨을 가정한다.\n\n1. 킬링파트 길이를 5~20초로 한정한다.\n\t1. 킬링파트 길이를 + - 버튼으로 조정할 수 있도록 하고, 시작점을 지정한다. 끝점은 지정하지 않는다.\n2. 다른 킬링파트에 포함되는 킬링파트는\b등록 수를 포함해서 계산한다.\n"},{"excerpt":"TODO 링글 체험 수업  [priority:: high]  [created:: 2023-09-25]  [due:: 2023-09-25]  [completion:: 2023-09-26] 루쿠 코드 리뷰  [priority:: highest]  [due:: 2023-09-25] 기능 고민해오기  [priority:: high]  [due:: 2023-09-…","fields":{"slug":"/2023-09-25/"},"frontmatter":{"date":"2023년 09월 24일 15:09","title":"2023년 09월 25일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n\n- [x] 링글 체험 수업  [priority:: high]  [created:: 2023-09-25]  [due:: 2023-09-25]  [completion:: 2023-09-26]\n- [x] 루쿠 코드 리뷰  [priority:: highest]  [due:: 2023-09-25]\n- [x] 기능 고민해오기  [priority:: high]  [due:: 2023-09-25]  [completion:: 2023-09-26]\n\n## LOG\n\n- 영어 레벨테스트 신청을 하러 강남에 다녀왔다. 영어 잘할 수 있을까... 다른 사람들이 지켜보는 가운데에서 잘 말하는 걸 못하는데 (사실 말하다가 무슨 말하려고 했는지 까먹어서가 크다...) 잘 극복할 수 있었으면 좋겠다.\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"TODO 미션 3단계 제출하기  [priority:: highest]  [created:: 2023-09-24]  [due:: 2023-09-24] LOG 오늘  가 body 에 왜 한 번에 써지는 지 알아보려고 spring framework 3.1.x 버전 이슈를 싹 다 뒤졌다. 사실 완벽하게는 알아내지 못했지만, 대략  자체가 커스텀 Converter…","fields":{"slug":"/2023-09-24/"},"frontmatter":{"date":"2023년 09월 24일 14:09","title":"2023년 09월 24일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n- [x] 미션 3단계 제출하기  [priority:: highest]  [created:: 2023-09-24]  [due:: 2023-09-24]\n\n## LOG\n\n- 오늘 `ResponseBody` 가 body 에 왜 한 번에 써지는 지 알아보려고 spring framework 3.1.x 버전 이슈를 싹 다 뒤졌다. 사실 완벽하게는 알아내지 못했지만, 대략 `ResponseBody` 자체가 커스텀 Converter 를 고려해서 만들어진 거라 초기에는 커스텀 할 수 있었던 걸로 보인다.  \n- 코코닥의 연습 SET 3을 풀었다. 2번은 구현하기 좀 어려워서 힌트를 받았었는데 조금만 더 고민했으면 스스로 풀 수 있었을 것 같아서 아쉬웠다. 그래도 이번엔 올솔했다!\n- 🔐β qzrqILtsQo6aCCtdqkWouwr4UZyCOoKedfqhhKEUqwA/0PAga4C/F4kOALF7WEW517chaM/wrYIeMLghOgvoA57JIt311mBqkJWmCD1tz4O3MTBQgFyegWcbP/Ijkx66l91oM+lY55a0qemWshtCXI7bN4YYxZXOgLv6zXBnjQvfYMeQdHi439Pahz15yZ+wUQikx0hhcJaud15+8Nv1DpR4dJj7/xEPYT3iMtNgHBRFw2qN61HODAf9fAbBIUzB4pswW89L 🔐\n\n## 배운 것\n\n- `@RestController` 는 json을 리턴하는 것으로 자동으로 간주하는데, json 은 view 로 변환되지 않고 바로 body 에 쓴다.\n\n## 느낀 것\n\n- 좋아하는 시가 오랜만에 생각이 났다. 마음 절절한 시를 좋아한다.  \n\n```text\n그대 죽어 별이 되지 않아도 좋다.\n푸른 강이 없어도 물은 흐르고\n밤하늘은 없어도 별은 뜨나니\n그대 죽어 별빛으로 빛나지 않아도 좋다.\n언 땅에 그대 묻고 돌아오던 날\n산도 강도 뒤따라와 피울음 울었으나\n그대 별의 넋이 되지 않아도 좋다.\n잎새에 이는 바람이 길을 멈추고\n새벽이슬에 새벽하늘이 다 저었다.\n\n우리들 인생도 찬비에 젖고\n떠오르던 붉은 해도 다시 지나니\n밤마다 인생을 미워하고 잠이 들었던\n그대 굳이 인생을 사랑하지 않아도 좋다.\n```\n\n"},{"excerpt":"TODO 장르 조회 API 구현  [priority:: highest]  [created:: 2023-09-20]  [scheduled:: 2023-09-20]  [due:: 2023-09-20]  [completion:: 2023-09-21] 바론 코드리뷰  [priority:: high]  [due:: 2023-09-20]  [completion:: …","fields":{"slug":"/2023-09-20/"},"frontmatter":{"date":"2023년 09월 20일 03:09","title":"2023년 09월 20일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today or scheduled today\nshort mode\n```\n\n## TODO\n\n- [x] 장르 조회 API 구현  [priority:: highest]  [created:: 2023-09-20]  [scheduled:: 2023-09-20]  [due:: 2023-09-20]  [completion:: 2023-09-21]\n- [x] 바론 코드리뷰  [priority:: high]  [due:: 2023-09-20]  [completion:: 2023-09-21]\n- [x] 아코 코드리뷰  [priority:: high]  [due:: 2023-09-20]  [completion:: 2023-09-21]\n\n## LOG\n\n- 코난이 코로나로 우리 곁을 떠났다... 코난 요양 파이팅. 나는 금요일까지 컨디션 파이팅.\n\n## 배운 것\n\n- `@GetMapping(params = \"genre\")` 로 특정 parameter 를 명시적으로 지정해줄 수 있다. `@RequestParam(name =\"genre)` 를 해도 필수로 인식이 안 되었는데 이렇게 해주니 해결됐다.\n\n## 느낀 것\n\n- 테코톡 준비 하나도 못하고 있다.\n- 알고리즘 스트릭 깨졌다 ㅠㅠ\n- 이제 조금만 더 버티면 주말...!"},{"excerpt":"옵시디언 플러그인 팔러 왔습니다. 혹시 옵시디언을 사용하시는 분들은 유용하게 사용하실 수 있는 플러그인들을 엄선해서 글을 작성했으니, 유용한 플러그인 얻어가시길 바랍니다. 옵시디언을 아직 안 써보신 분들은 이렇게 다양한 플러그인들이 있으니... 옵시디언에 관심 주시면 감사하겠습니다 ㅋㅅㅋ 간단하게 커뮤니티 플러그인 사용하는 법 설정 - 커뮤니티 플러그인으…","fields":{"slug":"/obsidian-plugin/"},"frontmatter":{"date":"2023년 09월 19일 03:09","title":"Obsidian Plugin 추천","tags":["obsidian"]},"rawMarkdownBody":"\n옵시디언 플러그인 팔러 왔습니다.  \n혹시 옵시디언을 사용하시는 분들은 유용하게 사용하실 수 있는 플러그인들을 엄선해서 글을 작성했으니, 유용한 플러그인 얻어가시길 바랍니다.  \n옵시디언을 아직 안 써보신 분들은 이렇게 다양한 플러그인들이 있으니... 옵시디언에 관심 주시면 감사하겠습니다 ㅋㅅㅋ\n\n## 간단하게 커뮤니티 플러그인 사용하는 법\n\n설정 - 커뮤니티 플러그인으로 들어가서 커뮤니티 플러그인 사용을 누른다.  \n\n\n![[obsidian-how-to-plugin.png]]\n\n그럼 다음과 같이 커뮤니티 플러그인을 탐색할 수 있는 버튼이 생긴다.  \n이 글에서 소개하는 커뮤니티 플러그인들은 모두 탐색에서 이름으로 검색할 수 있다.  \n\n\n![[obsidian-community-plugin.png]]\n\n## 사실상 필수 플러그인\n\n## Omnisearch\n\n노션과 옵시디언 같은 플러그인의 고질적인 문제점인 **내용 검색** 을 해결해주는 플러그인이다.  \n\n단축키를 등록해서 검색하면 내용과 제목을 포함해서 빠르게 검색 가능하다!! 삶의 질을 올려주는 정말 훌륭한 플러그인이다.\n\n![[omnisearch.png]]\n\n## Style Settings\n\n테마를 사용하다보면 테마를 커스텀하는 기능을 제공하는 테마들이 존재한다.  \n테마 커스텀을 위해서는 반드시 설치해야 하는 플러그인이다.  \n\n사용하는 테마를 선택해서 내부 상세 설정들을 변경해줄 수 있다. 이 부분은 테마마다 굉장히 상이한 부분이므로 넘어가도록 하겠다.  \n\n![[obsidian-style-settings.png]]\n\n## Templater\n\n매일 비슷한 포맷으로 글을 쓰거나, TIL 을 쓰는데 매번 템플릿 복사하는 게 너무 귀찮은 분들을 위한 플러그인.\n\n![[obsidian-templater-location.png]]\n\n`Automatic jump to cursor` 를 사용하면 템플릿 삽입 후 파일의 마지막 커서 위치로 이동할 수 있게 해준다. 필수로 체크해주면 좋다.  \n\n특히 단축키 cmd + N 을 templater create new note 에 연결해두면 정말 편하게 사용할 수 있다.  \n\n![[obsidian-templater-shortcut.png]]\n\n![[obsidian-templater-template-choose.png]]\n\ncreate new note from template 을 실행하면 템플릿을 선택할 수 있다.  \n선택하면 해당 템플릿으로 자동으로 파일을 만들어 준다.\n\n![[obsidian-templater-new-file.png]]\n\n개인적으로 TIL 의 frontmatter, template 의 frontmatter 를 자동으로 설정해주기 위해 사용한다.  \n\n## 추천하는 플러그인\n\n## Obsidian Git\n\n깃허브 블로그를 운영하고 있는 분이시라면 매번 바뀐 파일들을 커밋하기 너무 귀찮으셨을 것이다.  \nObsidian Git 은 시간 주기마다 주기적으로 커밋해주는 플러그인이다. \n\n개인적으로 커밋은 3시간 단위로 커밋하고, 푸시는 혹시 모르니 수동으로 할 수 있도록 변경해두었다.  \n\n![[obsidian-git-commit-message.png]]\n커밋 메시지를 지정해서 변경된 파일과 날짜, 파일 개수 등을 표시해줄 수도 있다.\n\n## Icon Folder\n\n밋밋한 파일들이 보기 싫으셨다면? Icon Folder 로 폴더 / 파일 아이콘을 추가할 수 있다.  \n상위 폴더에 icon inherit 을 설정해서 하위 폴더 / 파일에 icon 이 상속되도록 설정해줄 수도 있다.  \n\n![[obsidian-icon-folder.png]]\n\n## Update time on edit\n\nfrontmatter 의 문서 생성 시각, 문서 업데이트 시각을 매번 업데이트 해주는 것은 너무너무너무너무너무 귀찮은 작업이다.  \n이것도 자동화 할 수 있다. \n\n![[obsidian-date-format.png]]\n\ndate format 은 업데이트되는 시간의 형식을 정해줄 수 있다. 사진의 `date-fns documentation` 링크를 확인하면 어떻게 설정할 수 있는지 자세하게 확인할 수 있다.  \n\nupdated at 에는 frontmatter 에 저장되는 업데이트 시간 속성 이름을 입력해주면 된다. 나는 속성 이름이 updated 이기 때문에 위와 같이 작성했다.\ncreated at 에는 frontmatter 에 저장되는 생성 시간 속성 이름을 입력한다.  \n\n이렇게 설정하고 나서는 문서가 업데이트 될 때마다 분 단위로 updated 속성이 변경되며, 문서가 생성될 때 date 속성의 값이 초기화될 것이다.  \n\n## Calender\n\nTIL 을 작성했지만 노션처럼 캘린더 뷰가 없어서 아쉬우셨던 분들을 위한 플러그인.\n오른쪽 탭에 달력이 나오고, 날짜를 누르면 해당 TIL 로 이동할 수 있게 해주는 플러그인이다.  \n\n![[obsidian-calendar.png]]\n\n세부 설정은 위처럼 할 수 있다. 플러그인 **Natural Language Dates** 와 사용하면 좋다.  \n\n아래처럼 Date format 을 사용하면, TIL 파일의 이름을 가지고 캘린더가 인식하게 바꿀 수 있다.  \n\n![[obsidian-natural-language-dates.png]]\n\n이런 식으로 TIL 을 작성한 날짜들을 볼 수 있다. (군데군데 비어있는 건 넘어가주세요)\n\n![[obsidian-calendar-view.png]]\n\n## Outliner\n\nIntelliJ 단축키 opt + 화살표 로 코드를 이동하는 데 익숙하셨던 분들에게 추천하는 플러그인이다.  \n이 플러그인을 사용하면 리스트나 체크박스에 커서를 두고 shift + cmd + 위/아래 화살표 로 리스트와 체크박스를 위 아래로 이동할 수 있다!! 의외로 편한 기능이다.\n\nStick 설정은 한 번에 줄을 지울 때 체크박스나 리스트를 지울 것인지 선택하는 것이다. 개인적으로 한 번에 줄 지우는 것을 좋아해서 Never 로 설정해두었다.  \n\n![[obsidian-outliner-setting.png]]\n## Admonition\n\n옵시디언의 밋밋한 콜아웃, 인용이 아쉬우셨다면 Admonition 을 추천한다.  \n\n코드 블럭에 `ad-` prefix 를 붙이면 어떤 것들을 지원하는지 알려주는 자동완성이 나타난다. \n\n![[obsidian-admonition-prefix.png]]\n\n예시로 몇 가지를 사용해보았다. 이전보다 훨씬 깔끔하다!\n\n![[obsidian-callout.png]]\n\n추가적인 세팅은 플러그인 세팅에서 세부적으로 정할 수 있다.\n\n## 마무리\n\n옵시디언 플러그인 문의가 너무 많아... 글을 작성해보았습니다.  \n이 글이 옵시디언 플러그인을 찾아 헤메는 사람들에게 도움이 되기를 바랍니다 :)\n주기적으로 추가될 수도 있습니다 ㅋㅋ"},{"excerpt":"TODO 바론 코드 리뷰  [priority:: highest]  [due:: 2023-09-19]  [completion:: 2023-09-19] LOG 블로그가 고장났다... 이참에 그냥 다른 테마로 갈아타려고 한다. 너무 슬프다 근데 ㅠ 다시 고쳤다. 하 너무 디버깅이 힘들다. 후디 테마 블로그로 갈아타서 거기서 커스터마이징 하는 게 더 좋을 것 같…","fields":{"slug":"/2023-09-19/"},"frontmatter":{"date":"2023년 09월 19일 02:09","title":"2023년 09월 19일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\n```\n\n## TODO\n\n- [x] 바론 코드 리뷰  [priority:: highest]  [due:: 2023-09-19]  [completion:: 2023-09-19]\n\n## LOG\n\n- 블로그가 고장났다... 이참에 그냥 다른 테마로 갈아타려고 한다. 너무 슬프다 근데 ㅠ\n- 다시 고쳤다. 하 너무 디버깅이 힘들다. 후디 테마 블로그로 갈아타서 거기서 커스터마이징 하는 게 더 좋을 것 같아서 지속적으로 사이드로 개발해둬야 겠다. 어제 한 7시간 동안 개츠비만 봤더니 개츠비 마스터 된 듯...\n\n## 배운 것\n\n## 느낀 것"},{"excerpt":"ApplicationContextAware 란? 정말 간단한 구조를 가지고 있는 인터페이스이다. Interface to be implemented by any object that wishes to be notified of the ApplicationContext that it runs in. 실행중인  에 대한 알림(?) 을 받고자 하는 객체가 구현할…","fields":{"slug":"/application-context-aware/"},"frontmatter":{"date":"2023년 09월 19일 02:09","title":"ApplicationContextAware","tags":["spring"]},"rawMarkdownBody":"\n## ApplicationContextAware 란?\n\n정말 간단한 구조를 가지고 있는 인터페이스이다.  \n\n```java\npackage org.springframework.context;  \n  \nimport org.springframework.beans.BeansException;  \nimport org.springframework.beans.factory.Aware;  \n  \npublic interface ApplicationContextAware extends Aware {  \n  \n    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;  \n  \n}\n```\n\n> Interface to be implemented by any object that wishes to be notified of the ApplicationContext that it runs in.\n\n실행중인 `ApplicationContext` 에 대한 알림(?) 을 받고자 하는 객체가 구현할 인터페이스라고 한다.  \n\n번역이 이상하지만 아무튼 런타임에 `ApplicationContext` 가 필요한 객체가 구현하면 된다.  \n`HandlerMapping`, `ViewResolver`, `DispatcherServlet` 과 같이 런타임에 동적으로 빈들의 의존관계가 필요한 클래스가 구현한다.  \n\n> Implementing this interface makes sense for example when an object requires access to a set of collaborating beans. Note that configuration via bean references is preferable to implementing this interface just for bean lookup purposes.\n\n공식 docs 에서도 빈 조회 목적으로만 구현하는 것보다, 빈 참조를 통해 구성하기 위한 용도로 사용하는 것이 더 바람직하다고 적혀있다.  \n\n## 어떻게 주입되나?\n\n예시로 `AbstractHandlerMapping` 이라는 클래스를 보자.  \n`initApplicationContext` 에서 `initInterceptor` 로 초기화를 하는 것을 확인할 수 있다.  \n\n여기서 `obtainApplicationContext()` 를 수행하게 되는데, \n\n```java\npublic abstract class AbstractHandlerMapping extends WebApplicationObjectSupport  \n       implements HandlerMapping, Ordered, BeanNameAware {  \n  \n    /** Dedicated \"hidden\" logger for request mappings. */  \n    protected final Log mappingsLogger =  \n          LogDelegateFactory.getHiddenLog(HandlerMapping.class.getName() + \".Mappings\");  \n  \n  \n    @Nullable  \n    private Object defaultHandler;\n    ...\n\n\t@Override  \nprotected void initApplicationContext() throws BeansException {  \n    extendInterceptors(this.interceptors);  \n    detectMappedInterceptors(this.adaptedInterceptors);  \n    initInterceptors();  \n}  \n  \nprotected void extendInterceptors(List<Object> interceptors) {  \n}  \n  \nprotected void detectMappedInterceptors(List<HandlerInterceptor> mappedInterceptors) {  \n    mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(  \n          obtainApplicationContext(), MappedInterceptor.class, true, false).values());  // ApplicationContext 를 받아온다.  \n}  \n   \nprotected void initInterceptors() {  \n    if (!this.interceptors.isEmpty()) {  \n       for (int i = 0; i < this.interceptors.size(); i++) {  \n          Object interceptor = this.interceptors.get(i);  \n          if (interceptor == null) {  \n             throw new IllegalArgumentException(\"Entry number \" + i + \" in interceptors array is null\");  \n          }  \n          this.adaptedInterceptors.add(adaptInterceptor(interceptor));  \n       }  \n    }}\n}\n```\n\n`WebApplicationObjectSupport` 는 다시 `ApplicationObjectSupport` 를 상속한다.  \n위에서 언급되었던 `obtainApplicationContext()` 를 수행하는 것을 볼 수 있다.  \n\n```java\npublic abstract class WebApplicationObjectSupport extends ApplicationObjectSupport implements ServletContextAware {  \n  \n    @Nullable  \n    private ServletContext servletContext;  \n  \n  \n    @Override  \n    public final void setServletContext(ServletContext servletContext) {  \n       if (servletContext != this.servletContext) {  \n          this.servletContext = servletContext;  \n          initServletContext(servletContext);  \n       }  \n    }\n\n\t...\n\n\tprotected final ApplicationContext obtainApplicationContext() {  \n\t    ApplicationContext applicationContext = getApplicationContext();  \n\t    Assert.state(applicationContext != null, \"No ApplicationContext\");  \n\t    return applicationContext;  \n\t}\n}\n```\n\n`getApplicationContext()` 메서드는 `ApplicationObjectSupport` 에 구체적으로 구현되어있다. \n\n```java\npublic abstract class ApplicationObjectSupport implements ApplicationContextAware {  \n  \n    /** Logger that is available to subclasses. */  \n    protected final Log logger = LogFactory.getLog(getClass());  \n  \n    /** ApplicationContext this object runs in. */  \n    @Nullable  \n    private ApplicationContext applicationContext;  \n  \n    /** MessageSourceAccessor for easy message access. */  \n    @Nullable  \n    private MessageSourceAccessor messageSourceAccessor;\n\n\t...\n    \n\t@Override  \n\tpublic final void setApplicationContext(@Nullable ApplicationContext context) throws BeansException {  \n\t    if (context == null && !isContextRequired()) {  \n\t       // Reset internal context state.  \n\t       this.applicationContext = null;  \n\t       this.messageSourceAccessor = null;  \n\t    }  \n\t    else if (this.applicationContext == null) {  \n\t       // Initialize with passed-in context.  \n\t       if (!requiredContextClass().isInstance(context)) {  \n\t          throw new ApplicationContextException(  \n\t                \"Invalid application context: needs to be of type [\" + requiredContextClass().getName() + \"]\");  \n\t       }  \n\t       this.applicationContext = context;  \n\t       this.messageSourceAccessor = new MessageSourceAccessor(context);  \n\t       initApplicationContext(context);  \n\t    }  \n\t    else {  \n\t       // Ignore reinitialization if same context passed in.  \n\t       if (this.applicationContext != context) {  \n\t          throw new ApplicationContextException(  \n\t                \"Cannot reinitialize with different application context: current one is [\" +  \n\t                this.applicationContext + \"], passed-in one is [\" + context + \"]\");  \n\t       }  \n\t    }}\n}\n```\n\n## `BeanFactoryUtils` 란?\n\n위 코드를 자세하게 보면 이런 코드가 있다.  \n\n```java\n    mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(  \n          obtainApplicationContext(), MappedInterceptor.class, true, false).values());  \n```\n\n이러면 `BeanFactoryUtils` 가 빈을 가지고 있는 것 아닐까? 좀 더 알아보자.  \n\n`BeanFactoryUtils` 는 `ApplicationContext` 를 파라미터로 받고 있다.  \n`ApplicationContext` 는 굉장히 여러 가지를 상속 받고 있는데, 그 중에 하나가 `ListableBeanFactory` 이다.  \n\n`ListableBeanFactory` 는 다음과 같은 클래스이다.  \n딱 봐도 복잡한 빈 관련 기능들을 수행하는 것을 볼 수 있다.  \n\n```java\npackage org.springframework.beans.factory;  \n  \nimport java.lang.annotation.Annotation;  \nimport java.util.Map;  \nimport java.util.Set;  \n  \nimport org.springframework.beans.BeansException;  \nimport org.springframework.core.ResolvableType;  \nimport org.springframework.lang.Nullable;  \n  \npublic interface ListableBeanFactory extends BeanFactory {  \n  \n    boolean containsBeanDefinition(String beanName);  \n  \n    int getBeanDefinitionCount();  \n  \n    String[] getBeanDefinitionNames();  \n  \n    <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType, boolean allowEagerInit);  \n  \n    <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType, boolean allowEagerInit);  \n  \n    String[] getBeanNamesForType(ResolvableType type);  \n  \n    String[] getBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit);  \n  \n    String[] getBeanNamesForType(@Nullable Class<?> type);  \n  \n    String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);  \n  \n    <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException;  \n  \n    <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)  \n          throws BeansException;  \n  \n    String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType);  \n  \n    Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) throws BeansException;  \n  \n    <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)  \n          throws NoSuchBeanDefinitionException;  \n  \n    <A extends Annotation> A findAnnotationOnBean(  \n          String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)  \n          throws NoSuchBeanDefinitionException;  \n  \n    <A extends Annotation> Set<A> findAllAnnotationsOnBean(  \n          String beanName, Class<A> annotationType, boolean allowFactoryBeanInit)  \n          throws NoSuchBeanDefinitionException;  \n  \n}\n```\n\n`BeanFactoryUtils.beansOfTypeIncludingAncestors` 를 좀 더 자세히 알아보자. 해당 메서드를 호출하면 다음과 같은 코드가 실행된다.  \n\n아래는 `BeanFactoryUtils.beansOfTypeIncludingAncestors` 코드이다.  \n\n```java\npublic static <T> Map<String, T> beansOfTypeIncludingAncestors(  \n       ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)  \n       throws BeansException {  \n  \n    Assert.notNull(lbf, \"ListableBeanFactory must not be null\");  \n    Map<String, T> result = new LinkedHashMap<>(4);  \n    result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit));  \n    if (lbf instanceof HierarchicalBeanFactory hbf) {  \n       if (hbf.getParentBeanFactory() instanceof ListableBeanFactory pbf) {  \n          Map<String, T> parentResult = beansOfTypeIncludingAncestors(pbf, type, includeNonSingletons, allowEagerInit);  \n          parentResult.forEach((beanName, beanInstance) -> {  \n             if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {  \n                result.put(beanName, beanInstance);  \n             }  \n          });  \n       }  \n    }    return result;  \n}\n```\n\n주어진 타입의 모든 빈 인스턴스를 `ListableBeanFactory` 와 해당 팩토리의 부모 계층에서 찾는 데 사용되는 메서드이다. 특히 계층적인 `BeanFactory` 에서 유용하다.  \n\n즉, `ApplicationContext` 는 `ListableBeanFactory` 를 상속하고, `refresh` 에서 빈을 초기화하는 과정이 일어난다. `BeanFactoryUtils` 는 이런 빈들을 찾아오는 과정들을 용이하게 해주는 클래스라고 생각하면 된다.    \n\n`refresh` 함수에 대한 자세한 부분은 `AbstractApplicationContext` 의 `refresh` 메서드를 참고하면 된다.  \n약간의 설명은 [[application-context]] 에 적어두었다.  \n"},{"excerpt":"TODO LOG 할 일은 아무것도 못했지만... 그래도 발표 자료는 다 만들었다. 내일 데모데이 파이팅!!!!!!!!!!!!!!!! 처음으로 11시까지 남아봤다. 오늘은 컨디션이 좋아서 피곤하지 않았던 것 같다. 머리 쓸 일도 없었고 ㅋㅋ 역시 머리를 안 쓰면 덜 피곤하다. 딜리버리 히어로 CTO 들과의 만남이 있었다. 가장 와닿았던 건 일단 영어를 해야…","fields":{"slug":"/2023-09-21/"},"frontmatter":{"date":"2023년 09월 19일 02:09","title":"2023년 09일 21일","tags":null},"rawMarkdownBody":"\n```tasks\nnot done \ndue today\nshort mode\n```\n\n## TODO\n## LOG\n\n- 할 일은 아무것도 못했지만... 그래도 발표 자료는 다 만들었다. 내일 데모데이 파이팅!!!!!!!!!!!!!!!!\n- 처음으로 11시까지 남아봤다. 오늘은 컨디션이 좋아서 피곤하지 않았던 것 같다. 머리 쓸 일도 없었고 ㅋㅋ 역시 머리를 안 쓰면 덜 피곤하다.\n- 딜리버리 히어로 CTO 들과의 만남이 있었다. 가장 와닿았던 건 일단 영어를 해야 한다는 것. 지금 못한다는 건 재미없다는 주장의 이유가 될 수 없다는 것.\n\n## 배운 것\n\n## 느낀 것\n\n- 잠깐의 환경 변화로 꾸준한 루틴을 포기하지 말자. 정말 어쩔 수 없이 루틴대로 살지 못하는 날도 있다.\n- Challenge and Frustration, always.\n"},{"excerpt":"개요 이번 데모데이까지 회의 시간이 많이 줄어들었습니다. 또한 팀원들의 바쁜 스케줄로 인해 + 개인 사정으로 인해 회의 시간 뿐만 아니라 회의 개수도 줄어들게 되었습니다. 회의 개수가 줄어들게 되니, 이번 스프린트 때 이전 회의에서 이야기했던 기획의 고도화된 부분, 상세한 구현사항에 대해 이야기 할 시간이 부족했습니다. 이번 스프린트를 기준으로 이야기해보…","fields":{"slug":"/meeting-process-refactoring-request/"},"frontmatter":{"date":"2023년 09월 19일 02:09","title":"회의 진행 방식 개선을 위한 회의 요청","tags":["shook","협업"]},"rawMarkdownBody":"\n## 개요\n\n이번 데모데이까지 회의 시간이 많이 줄어들었습니다. 또한 팀원들의 바쁜 스케줄로 인해 + 개인 사정으로 인해 회의 시간 뿐만 아니라 회의 개수도 줄어들게 되었습니다.  \n회의 개수가 줄어들게 되니, 이번 스프린트 때 이전 회의에서 이야기했던 기획의 고도화된 부분, 상세한 구현사항에 대해 이야기 할 시간이 부족했습니다. \n\n이번 스프린트를 기준으로 이야기해보자면, 장르 카테고리를 만든다! 까지는 전체 회의에서 정해진 내용입니다.  \n그렇지만 장르 카테고리의 디자인, 장르 카테고리 API 구성, 어떤 장르를 내려줄 것인지, 몇 개의 데이터가 필요할 것인지, 이런 세부사항에 대한 논의를 하는 회의는 없었습니다.  \n\n이렇게 세부사항에 대한 회의를 못한 이유가 무엇인지 생각해보았습니다.\n\n## 세부 사항에 대한 회의를 할 수 없을 정도로 일정 추정을 잘하지 못했다.\n\n장르 카테고리 기능이 일정 추정이 잘 안 된 이유도 있습니다.  \n굉장히 급하게 정해진 기능이고, 이것저것 할 일이 많아 생각보다 조급하게 구현했습니다.  \n\n그러다보니 장르 카테고리를 구현하는 팀원들끼리 임의로 정한 부분들이 많습니다.  \n급하게 정하다 보니 문서화도 되지 않았고, 고민했던 부분에 대한 정리도 미흡했습니다. \n서로 생각날 때마다 고민거리 이야기, 구현 사항 이야기를 하다보니 시간이 낭비되는 부분도 있었습니다. \n아마 세부 구현 사항들은 팀원들도 제대로 모를 수도 있습니다. \b서로의 싱크에 매우 치명적인 사항이라고 생각합니다.    \n\n### 해결책\n\n문제점은 결정되지 않은 사항들에 대한 회의가 효율적으로, 체계적으로 이루어지지 않았다는 것입니다.  \n제가 제안하는 해결책은 다음과 같습니다. \n\n1. 회의에서 결정되지 않은 사항들을 우선순위를 매겨 정리합니다.  \n회의에서 결정되지 못한, 시간이 모자라 하지 못한 사항들을 개인적으로 정리하지 말고 팀 노션에 정리합니다.  \n팀 노션에 정리된 사항들은 데일리마다 확인하며, 우선순위별로 하나씩 회의를 진행합니다.  \n\n2. 결정되지 않은 내용을 픽스하기 위해 필요한 회의들의 데드라인을 정의합니다.  \n각 회의들은 무한정 그대로 둘 수는 없습니다. 회의들이 반드시 이루어져야 하는 기간을 정하고, 그 안에 논의하는 것을 원칙으로 합니다.  \n\n이렇게 하면 놓치는 사항 없이 회의를 효율적으로 진행할 수 있을 거라 생각합니다. \n\n## 모두가 모여야 회의를 시작할 수 있다.\n\n우리 프로젝트의 병목 지점은 '다 모이면 이야기하자' 라고 생각합니다.  \n회의가 늦춰지는 이유이기도 하고, 다 모일 수 있는 시간을 정하기가 굉장히 어렵습니다. 시간이 적기도 하고 말이죠.  \n\n모든 프로세스를 모든 팀원과 함께, 동기적으로 작업하는 것이 레벨3 때는 싱크도 가장 잘 맞고 적합한 방식이었습니다.  \n그렇지만 레벨4 처럼 바쁜 상황에서 모든 팀원의 상황을 고려하여 회의 시간을 맞추는 것은 현실적으로 너무나도 어렵다고 생각합니다. 반드시 필요한 세부 회의를 안 할 수도 없는 노릇이구요.  \n\n### 해결책\n\n모두가 모이지 않더라도, 세부 구현에 대해 이야기 할 수 있는 **비동기적 기능 개발 프로세스**를 제안합니다. \n\n지금처럼 큰 기능을 정하는 회의를 짧게 가져가는 흐름은 그대로 두고, **정해진 기능들을 BE&FE 스쿼드로 각각 나눠서 각 기능의 세분화는 스쿼드의 결정대로** 하는 방식을 제안합니다.  \n이때 정해지는 스쿼드와 기능들은 각 주의 팀원들이 공유한 이번 주에 할 수 있는 일정 추정대로 정합니다.  \n\n==Q. 스쿼드로 나뉘었을 때 스쿼드에 속하지 않는 팀원들과 싱크가 맞지 않는 부분은 어떻게 할 수 있나요?  ==\n\nA. 각 기능의 세부사항이 픽스되었을 때는 문서로 작성하여 반드시 팀원에게 공유하는 프로세스가 작동해야 합니다. 세부사항이 픽스되었을 때 피드백을 받는 시간은 **너무 길어지지 않도록** 세부사항 구현이 올라왔을 때 1시간 동안 피드백을 받도록 합니다. 생각해본 상세 프로세스는 다음과 같습니다.  \n1. 스쿼드끼리의 상세 구현이 정해진 날, 최대한 빨리 슬랙 채널에 상세 구현 사항을 정리하여 올린다. 상세 구현은 두루뭉술하지 않고 정해진 자세한 사항들을 모두 적어서 공유한다. \n2. 다른 스쿼드에 속한 팀원들은 반드시 1시간 내에 상세 구현을 읽고 피드백을 남긴다. (1시간 뒤에 제공된 팀원 피드백은 해당 스쿼드에서 의견 기여도를 낮게 책정하는 것으로 간주한다.)\n3. 팀원들의 피드백을 반영하고, 반영되지 않은 피드백의 경우 근거를 정리한다. 피드백 반영은 빠르게 이루어져야 한다.\n4. 피드백을 반영하여 최종 상세 구현 예정 사항을 슬랙 채널에 업로드한다. 들어가야 하는 내용은 대략 다음과 같다.\n\t1. 상세 구현 사항\n\t2. 반영된 피드백과 근거\n\t3. 반영되지 않은 피드백과 근거\n5. 완전하게 정해진 최종 상세 구현에 대해서는 피드백을 더 이상 남기지 않는다.\n\n==Q. BE, FE 의 구현 속도가 다른 경우는 어떻게 하나요?==\n\nA. 보통 구현 속도가 빠른 팀원이 문제가 될 수 있을 것 같습니다. 따라서 시간이 남은 경우에 진행할 수 있는 간단한 Task들을 정리하는 것이 필요하다고 생각합니다.  \n금방 진행할 수 있지만, 우선순위가 낮은 Task 들을 정리한 뒤, 해당 팀원에게 할당해주면 좋을 것 같습니다. \n\n==Q. 완전히 정해진 최종 상세 구현에 대해 피드백을 남기지 않는 이유는 뭔가요?==\n\nA. 최종 상세 구현에 피드백을 남기게 되면, 계속 피드백이 이어지게 됩니다. 이런 경우 세부 회의를 모두 모여서 하는 것이 더 효율적일 것입니다.  \n그렇지만 항상 논란이 되는 부분은 정해져 있고, 그 부분에는 정답이 없는 경우가 많습니다.  \n만약 최종 상세 구현에 대해 추가적인 피드백 혹은 불만 사항이 있는 경우, 다음 스프린트 때 '결정되지 않은 사항' 으로 등록하여 회의하는 것이 좋다고 생각합니다.  \n\n==Q. 회의에서 결정되지 않은 사항들은 모두 세부 회의로 취급되어 스쿼드끼리만 이야기하게 되나요?==\n\nA. 아닙니다. 모두의 논의가 필요하다고 생각되는 회의들은 모두의 시간이 맞는 때에 회의해야 한다고 생각합니다.  \n그러나 이 기준이 매우 모호할 수 있기에, 큼직한 결정이 필요한 경우에만 모두 모이는 것으로 하고, 그 외에는 세부 구현으로 간주하는 방식을 제안합니다. \n\n## 세부 사항 구현이 늦어진 이유 중 하나 - 각 파트별로 세부 진행 상황 전달이 늦다.\n\nBE, FE 모두 각자 세부적으로 진행된 상황이 전달이 늦습니다.  \nAPI 에서 변경 된 사항이 있어도 잘 전달되지 않는 경우도 있고, BE 측에서는 FE 에서 얼마나 기능이 진행되었는지도 알기 힘든 것 같아요.  \n\n### 해결책\n\n각 파트별로 필수적으로 공유해야 하는 사항들을 정하고, 각각의 변경 사항이 빠르게 공유될 수 있도록 즉시 공유합니다.  \n공유하기 위한 슬랙 채널 `shook-개발-패치노트` , `shook-prod-패치노트` 를 만들어 보았습니다.  \n\n- BE\n\t- `shook-개발-패치노트` 에 API 를 공유한다. 기존 API 에 변경 사항이 있다면 함께 기록한다.\n\t- API 공유는 API 가 픽스된 즉시 공유한다. 공유된 API 에 변경 사항이 있다면 수정될 때마다 전달한다.\n\t- 완전히 배포가 완료된 경우, \n- FE\n\t- 디자인 완료 시 `shook-개발-패치노트` 에 공유한다. 디자인이 수정될 때에도 함께 기록한다.\n- 공통\n\t- 기능 구현 완료 시, `shook-개발-패치노트` 에 기능 구현 사항을 공유한다.\n\t- 기능 배포가 완료된 경우, `shook-prod-패치노트` 에 변경 사항과 함께 공유한다.\n\t- PR 템플릿에 '변경 사항 슬랙 공유 여부' 체크리스트를 추가한다.\n\n## 추가 - 팀원 간 공유 강화\n\n- 기능을 구현할 때 어려운 점이 있을 때는 아무리 늦어도 스크럼 때 공유합시다. (가장 좋은 것은 주변에 즉시 알리는 것이지만 힘들 수도 있으니까) 어려운 점을 혼자 해결하는 것보다 함께 해결하는 것이 더 빠르다고 생각해요.  \n- 팀과 기능 구현 사항에 대해 불만이 있을 때도 스크럼 때 반드시 말하는 것으로 합시다. 불만사항이 감정회고 까지 지체되는 건 좋지 않은 것 같아요. 물론 스크럼 시간이 빨리 끝나는 것도 중요하지만, 각 파트 간의 싱크가 맞는 게 더 중요하다고 생각해요.  \n- 의문 사항, 불만 사항은 스크럼 때는 간단하게 제시만 하고, 자세한 논의는 다음 날 회의로 잡아서 최대 30분 동안 논의해 보는 것으로 하는 건 어떨까요? 불필요한 시간 낭비를 줄이고, 좀 더 효율적으로 회의할 수 있을 것 같습니다.  \n- 불만사항 예시\n\t- 너무 할 일이 많다.\n\t- 디자인 너무 어렵다.\n\t- 내가 맡은 일이 다른 스쿼드에 비해 너무 많은 것 같다.\n\t- 내가 할 게 없다.\n\t- 내가 맡은 부분이 그렇게 중요하지 않은 것 같다. 다른 일 없나요\n\n---\n\n제가 항상 이런 민감한 사항에 대해서 회의 안건을 내게 되어 팀원들에게 어느 정도 미안한 마음이 있습니다. 우리 팀 중에 특정 팀원을 탓하는 게 절대절대 아니라는 점, 언제나 회의 안건은 S-HOOK 을 위해 제안하는 것이라는 점 알아주시면 감사하겠습니다 🥺  \n\n저는 이런 문제들은 분명 정책적으로, 팀 문화적으로 해결할 수 있다고 생각해요.  \n이 회의도 우리 팀의 행복한 개발 생활에 도움이 되기를 (간절히) 바랍니다.  \n\n## 비고\n\n해당 회의 / 안건 / 제안에 대한 비판, 불만, 칭찬, 개선점, 뭐든 좋습니다.  \n추가적인 의견이 무엇이든 있으시다면 남겨주세요 :)\n"},{"excerpt":"ViewResolver 란? 클라이언트의 HTTP 요청을 어떤 View 에 매핑할 것인지 결정하는 컴포넌트이다. 주로 MVC 아키텍처에서 사용되며, 컨트롤러에서 리턴된 뷰 이름을 실제로 렌더링할 수 있는 뷰로 매핑하는 작업을 담당한다. 필요성 어떤 뷰 기술을 사용할 것인지 추상화할 수 있다. JSP 를 사용하다가, Json 을 쓸 수도 있는 것이다. 다른…","fields":{"slug":"/view-resolver/"},"frontmatter":{"date":"2023년 09월 19일 02:09","title":"ViewResolver","tags":["spring"]},"rawMarkdownBody":"\n## ViewResolver 란?\n\n클라이언트의 HTTP 요청을 어떤 View 에 매핑할 것인지 결정하는 컴포넌트이다.  \n주로 MVC 아키텍처에서 사용되며, 컨트롤러에서 리턴된 뷰 이름을 실제로 렌더링할 수 있는 뷰로 매핑하는 작업을 담당한다.  \n\n## 필요성\n\n1. 어떤 뷰 기술을 사용할 것인지 추상화할 수 있다. JSP 를 사용하다가, Json 을 쓸 수도 있는 것이다. 다른 뷰 기술로 전환이 용이하다.\n2. 컨트롤러가 뷰를 처리하는 부분을 추상화하여 더 간결하고 가독성 있는 코드를 작성할 수 있다. \n3. 단순히 뷰의 이름만 리턴해도 뷰를 찾을 수 있기 때문에 개발이 편리하다. \n\n## 구현\n\n```java\npackage org.springframework.web.servlet;  \n  \nimport java.util.Locale;  \n  \nimport org.springframework.lang.Nullable;  \n  \npublic interface ViewResolver {  \n\n\t@Nullable  \n    View resolveViewName(String viewName, Locale locale) throws Exception;  \n  \n}\n```\n\n구현은 굉장히 간단하다.  \n\n컨트롤러에서 리턴된 뷰 이름인 `viewName` 을 입력받아 실제 뷰 객체를 찾아 반환한다.  \n다국어 지원이 필요한 경우, `Locale` 정보를 사용하여 적절한 지역에 맞는 뷰를 선택할 수 있다.  \n\n`resolveViewName` 는 뷰 이름을 해석할 때 문제가 발생하며 `Exception` 을 던질 수 있다.  \n\n## `InternalResourceViewResolver`\n\nJSP 를 렌더링하는 `ViewResolver` 구현체이다.  \n`UrlBasedViewResolver` 를 상속 받은 클래스이다.  \n\n```java\npackage org.springframework.web.servlet.view;  \n  \nimport org.springframework.lang.Nullable;  \nimport org.springframework.util.ClassUtils;  \n  \npublic class InternalResourceViewResolver extends UrlBasedViewResolver {  \n  \n    private static final boolean jstlPresent = ClassUtils.isPresent(  \n          \"jakarta.servlet.jsp.jstl.core.Config\", InternalResourceViewResolver.class.getClassLoader());  \n  \n    @Nullable  \n    private Boolean alwaysInclude;  \n  \n  \n\tpublic InternalResourceViewResolver() {  \n       Class<?> viewClass = requiredViewClass();  \n       if (InternalResourceView.class == viewClass && jstlPresent) {  \n          viewClass = JstlView.class;  \n       }  \n       setViewClass(viewClass);  \n    }  \n  \n    public InternalResourceViewResolver(String prefix, String suffix) {  \n       this();  \n       setPrefix(prefix);  \n       setSuffix(suffix);  \n    }  \n  \n    public void setAlwaysInclude(boolean alwaysInclude) {  \n       this.alwaysInclude = alwaysInclude;  \n    }  \n  \n  \n    @Override  \n    protected Class<?> requiredViewClass() {  \n       return InternalResourceView.class;  \n    }  \n  \n    @Override  \n    protected AbstractUrlBasedView instantiateView() {  \n       return (getViewClass() == InternalResourceView.class ? new InternalResourceView() :  \n             (getViewClass() == JstlView.class ? new JstlView() : super.instantiateView()));  \n    }  \n  \n    @Override  \n    protected AbstractUrlBasedView buildView(String viewName) throws Exception {  \n       InternalResourceView view = (InternalResourceView) super.buildView(viewName);  \n       if (this.alwaysInclude != null) {  \n          view.setAlwaysInclude(this.alwaysInclude);  \n       }  \n       view.setPreventDispatchLoop(true);  \n       return view;  \n    }  \n  \n}\n```\n\n`InternalResourceViewResolver(String prefix, String suffix)` 로 접두사, 접미사를 인자로 받아 생성할 수 있다. 다음과 같은 `ViewResolver` 가 있고, \"home\" 이라는 뷰 이름을 반환하면 `InternalResourceViewResolver` 가 `/WEB-INF/views/home.jsp` 같은 실제 경로로 자동으로 변환해준다. 이를 통해 뷰 경로에 대한 하드 코딩을 줄이고, 뷰 이름만으로도 뷰를 유연하게 지정할 수 있다.  \n\n```java\nInternalResourceViewResolver resolver = new InternalResourceViewResolver(\"/WEB-INF/views/\", \".jsp\");\n```\n\n`requiredViewClass()` : `ViewResolver` 가 요구하는 뷰 클래스의 타입을 반환한다. `InternalResourceView.class` 를 반환한다.  \n\n`buildView(String viewName)` : 주어진 뷰 이름으로 뷰 객체를 생성하고, 설정을 적용한 뒤 반환한다.  \n\n다음과 같은 코드로 \n\n```java\npublic UrlBasedViewResolverRegistration jsp(String prefix, String suffix) {  \n    InternalResourceViewResolver resolver = new InternalResourceViewResolver();  \n    resolver.setPrefix(prefix);  \n    resolver.setSuffix(suffix);  \n    this.viewResolvers.add(resolver);  \n    return new UrlBasedViewResolverRegistration(resolver);  \n}\n```\n\n## `ContentNegotiatingViewResolver`\n\n`content-type` 이 주어진 경우 사용하는 `ViewResolver` 이다.  \n\n```java\npackage org.springframework.web.servlet.view;  \n  \nimport java.util.ArrayList;  \nimport java.util.Collection;  \nimport java.util.Collections;  \nimport java.util.LinkedHashSet;  \nimport java.util.List;  \nimport java.util.Locale;  \nimport java.util.Map;  \nimport java.util.Set;  \n  \nimport jakarta.servlet.ServletContext;  \nimport jakarta.servlet.http.HttpServletRequest;  \nimport jakarta.servlet.http.HttpServletResponse;  \n  \nimport org.springframework.beans.factory.BeanFactoryUtils;  \nimport org.springframework.beans.factory.InitializingBean;  \nimport org.springframework.core.Ordered;  \nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;  \nimport org.springframework.http.MediaType;  \nimport org.springframework.lang.Nullable;  \nimport org.springframework.util.Assert;  \nimport org.springframework.util.CollectionUtils;  \nimport org.springframework.util.MimeTypeUtils;  \nimport org.springframework.util.StringUtils;  \nimport org.springframework.web.HttpMediaTypeNotAcceptableException;  \nimport org.springframework.web.accept.ContentNegotiationManager;  \nimport org.springframework.web.accept.ContentNegotiationManagerFactoryBean;  \nimport org.springframework.web.context.request.RequestAttributes;  \nimport org.springframework.web.context.request.RequestContextHolder;  \nimport org.springframework.web.context.request.ServletRequestAttributes;  \nimport org.springframework.web.context.request.ServletWebRequest;  \nimport org.springframework.web.context.support.WebApplicationObjectSupport;  \nimport org.springframework.web.servlet.HandlerMapping;  \nimport org.springframework.web.servlet.SmartView;  \nimport org.springframework.web.servlet.View;  \nimport org.springframework.web.servlet.ViewResolver;  \n  \npublic class ContentNegotiatingViewResolver extends WebApplicationObjectSupport  \n       implements ViewResolver, Ordered, InitializingBean {  \n  \n    @Nullable  \n    private ContentNegotiationManager contentNegotiationManager;  \n  \n    private final ContentNegotiationManagerFactoryBean cnmFactoryBean = new ContentNegotiationManagerFactoryBean();  \n  \n    private boolean useNotAcceptableStatusCode = false;  \n  \n    @Nullable  \n    private List<View> defaultViews;  \n  \n    @Nullable  \n    private List<ViewResolver> viewResolvers;  \n  \n    private int order = Ordered.HIGHEST_PRECEDENCE;  \n  \n  \n    public void setContentNegotiationManager(@Nullable ContentNegotiationManager contentNegotiationManager) {  \n       this.contentNegotiationManager = contentNegotiationManager;  \n    }  \n  \n    @Nullable  \n    public ContentNegotiationManager getContentNegotiationManager() {  \n       return this.contentNegotiationManager;  \n    }  \n  \n    public void setUseNotAcceptableStatusCode(boolean useNotAcceptableStatusCode) {  \n       this.useNotAcceptableStatusCode = useNotAcceptableStatusCode;  \n    }  \n  \n    public boolean isUseNotAcceptableStatusCode() {  \n       return this.useNotAcceptableStatusCode;  \n    }  \n  \n    public void setDefaultViews(List<View> defaultViews) {  \n       this.defaultViews = defaultViews;  \n    }  \n  \n    public List<View> getDefaultViews() {  \n       return (this.defaultViews != null ? Collections.unmodifiableList(this.defaultViews) :  \n             Collections.emptyList());  \n    }  \n  \n    public void setViewResolvers(List<ViewResolver> viewResolvers) {  \n       this.viewResolvers = viewResolvers;  \n    }  \n  \n    public List<ViewResolver> getViewResolvers() {  \n       return (this.viewResolvers != null ? Collections.unmodifiableList(this.viewResolvers) :  \n             Collections.emptyList());  \n    }  \n  \n    public void setOrder(int order) {  \n       this.order = order;  \n    }  \n  \n    @Override  \n    public int getOrder() {  \n       return this.order;  \n    }  \n  \n  \n    @Override  \n    protected void initServletContext(ServletContext servletContext) {  \n       Collection<ViewResolver> matchingBeans =  \n             BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();  \n       if (this.viewResolvers == null) {  \n          this.viewResolvers = new ArrayList<>(matchingBeans.size());  \n          for (ViewResolver viewResolver : matchingBeans) {  \n             if (this != viewResolver) {  \n                this.viewResolvers.add(viewResolver);  \n             }  \n          }       }       else {  \n          for (int i = 0; i < this.viewResolvers.size(); i++) {  \n             ViewResolver vr = this.viewResolvers.get(i);  \n             if (matchingBeans.contains(vr)) {  \n                continue;  \n             }  \n             String name = vr.getClass().getName() + i;  \n             obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name);  \n          }  \n  \n       }       AnnotationAwareOrderComparator.sort(this.viewResolvers);  \n       this.cnmFactoryBean.setServletContext(servletContext);  \n    }  \n  \n    @Override  \n    public void afterPropertiesSet() {  \n       if (this.contentNegotiationManager == null) {  \n          this.contentNegotiationManager = this.cnmFactoryBean.build();  \n       }  \n       if (this.viewResolvers == null || this.viewResolvers.isEmpty()) {  \n          logger.warn(\"No ViewResolvers configured\");  \n       }  \n    }  \n  \n    @Override  \n    @Nullable    \n    public View resolveViewName(String viewName, Locale locale) throws Exception {  \n       RequestAttributes attrs = RequestContextHolder.getRequestAttributes();  \n       Assert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\");  \n       List<MediaType> requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());  \n       if (requestedMediaTypes != null) {  \n          List<View> candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);  \n          View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);  \n          if (bestView != null) {  \n             return bestView;  \n          }  \n       }  \n       String mediaTypeInfo = logger.isDebugEnabled() && requestedMediaTypes != null ?  \n             \" given \" + requestedMediaTypes.toString() : \"\";  \n  \n       if (this.useNotAcceptableStatusCode) {  \n          if (logger.isDebugEnabled()) {  \n             logger.debug(\"Using 406 NOT_ACCEPTABLE\" + mediaTypeInfo);  \n          }  \n          return NOT_ACCEPTABLE_VIEW;  \n       }  \n       else {  \n          logger.debug(\"View remains unresolved\" + mediaTypeInfo);  \n          return null;  \n       }  \n    }  \n    \n\t@Nullable  \n    protected List<MediaType> getMediaTypes(HttpServletRequest request) {  \n       Assert.state(this.contentNegotiationManager != null, \"No ContentNegotiationManager set\");  \n       try {  \n          ServletWebRequest webRequest = new ServletWebRequest(request);  \n          List<MediaType> acceptableMediaTypes = this.contentNegotiationManager.resolveMediaTypes(webRequest);  \n          List<MediaType> producibleMediaTypes = getProducibleMediaTypes(request);  \n          Set<MediaType> compatibleMediaTypes = new LinkedHashSet<>();  \n          for (MediaType acceptable : acceptableMediaTypes) {  \n             for (MediaType producible : producibleMediaTypes) {  \n                if (acceptable.isCompatibleWith(producible)) {  \n                   compatibleMediaTypes.add(getMostSpecificMediaType(acceptable, producible));  \n                }  \n             }          }          List<MediaType> selectedMediaTypes = new ArrayList<>(compatibleMediaTypes);  \n          MimeTypeUtils.sortBySpecificity(selectedMediaTypes);  \n          return selectedMediaTypes;  \n       }  \n       catch (HttpMediaTypeNotAcceptableException ex) {  \n          if (logger.isDebugEnabled()) {  \n             logger.debug(ex.getMessage());  \n          }  \n          return null;  \n       }  \n    }  \n    \n    @SuppressWarnings(\"unchecked\")  \n    private List<MediaType> getProducibleMediaTypes(HttpServletRequest request) {  \n       Set<MediaType> mediaTypes = (Set<MediaType>)  \n             request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);  \n       if (!CollectionUtils.isEmpty(mediaTypes)) {  \n          return new ArrayList<>(mediaTypes);  \n       }  \n       else {  \n          return Collections.singletonList(MediaType.ALL);  \n       }  \n    }  \n    \n\tprivate MediaType getMostSpecificMediaType(MediaType acceptType, MediaType produceType) {  \n       produceType = produceType.copyQualityValue(acceptType);  \n       if (acceptType.isLessSpecific(produceType)) {  \n          return produceType;  \n       }  \n       else {  \n          return acceptType;  \n       }  \n    }  \n    \n    private List<View> getCandidateViews(String viewName, Locale locale, List<MediaType> requestedMediaTypes)  \n          throws Exception {  \n  \n       List<View> candidateViews = new ArrayList<>();  \n       if (this.viewResolvers != null) {  \n          Assert.state(this.contentNegotiationManager != null, \"No ContentNegotiationManager set\");  \n          for (ViewResolver viewResolver : this.viewResolvers) {  \n             View view = viewResolver.resolveViewName(viewName, locale);  \n             if (view != null) {  \n                candidateViews.add(view);  \n             }  \n             for (MediaType requestedMediaType : requestedMediaTypes) {  \n                List<String> extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType);  \n                for (String extension : extensions) {  \n                   String viewNameWithExtension = viewName + '.' + extension;  \n                   view = viewResolver.resolveViewName(viewNameWithExtension, locale);  \n                   if (view != null) {  \n                      candidateViews.add(view);  \n                   }  \n                }             }          }       }       if (!CollectionUtils.isEmpty(this.defaultViews)) {  \n          candidateViews.addAll(this.defaultViews);  \n       }  \n       return candidateViews;  \n    }  \n  \n    @Nullable  \n    private View getBestView(List<View> candidateViews, List<MediaType> requestedMediaTypes, RequestAttributes attrs) {  \n       for (View candidateView : candidateViews) {  \n          if (candidateView instanceof SmartView smartView) {  \n             if (smartView.isRedirectView()) {  \n                return candidateView;  \n             }  \n          }       }       for (MediaType mediaType : requestedMediaTypes) {  \n          for (View candidateView : candidateViews) {  \n             if (StringUtils.hasText(candidateView.getContentType())) {  \n                MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());  \n                if (mediaType.isCompatibleWith(candidateContentType)) {  \n                   mediaType = mediaType.removeQualityValue();  \n                   if (logger.isDebugEnabled()) {  \n                      logger.debug(\"Selected '\" + mediaType + \"' given \" + requestedMediaTypes);  \n                   }  \n                   attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, RequestAttributes.SCOPE_REQUEST);  \n                   return candidateView;  \n                }  \n             }          }       }       return null;  \n    }  \n  \n  \n    private static final View NOT_ACCEPTABLE_VIEW = new View() {  \n  \n       @Override  \n       @Nullable       \n       public String getContentType() {  \n          return null;  \n       }  \n  \n       @Override  \n       public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {  \n          response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);  \n       }  \n    };  \n}\n```\n\n## `@ResponseBody`\n\n`@ResponseBody` 어노테이션을 사용하면 메서드 반환값이 뷰를 통해 렌더링 되는 것이 아니라, HTTP Response Body 에 직접 작성된다.  \n\n- `HttpMessageConverter` 메커니즘: `HttpMessageConverter` 구현체들을 사용하여 Java 객체를 HTTP 요청과 응답 메시지로 변환한다.  \n- JSON 변환: `MappingJackson2HttpMessageConverter` 가 Jackson 라이브러리를 사용하여 `HttpMessageConverter` 를 구현한다.  \n\n다음과 같은 과정으로 변환된다.  \n\n1. Controller 메서드가 호출되고 `@ResponseBody` 어노테이션이 있는 메서드의 반환값을 변환해야 할 때, 적절한 `HttpMessageConverter` 를 찾기 위해 등록된 리스트를 순회한다. (JSON 뿐만 아니라 XML, RSS 등 여러 가지 형태가 있을 수 있기 때문이다.)\n2. JSON 변환을 위해 `MappingJackson2HttpMessageConverter` 를 찾아 사용한다.  \n3. `MappingJackson2HttpMessageConverter` 가 Java 객체를 JSON 문자열로 변환한다.  \n4. HTTP Response Body 에 쓰여진다.  \n\n구체적인 코드는 아래에 있다. \n\n```java\npackage org.springframework.http.converter.json;  \n  \nimport java.io.IOException;  \nimport java.util.Collections;  \nimport java.util.List;  \n  \nimport com.fasterxml.jackson.core.JsonGenerator;  \nimport com.fasterxml.jackson.databind.ObjectMapper;  \n  \nimport org.springframework.http.MediaType;  \nimport org.springframework.lang.Nullable;  \n  \npublic class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter {  \n  \n    private static final List<MediaType> problemDetailMediaTypes =  \n          Collections.singletonList(MediaType.APPLICATION_PROBLEM_JSON);  \n  \n  \n    @Nullable  \n    private String jsonPrefix;  \n  \n  \n    public MappingJackson2HttpMessageConverter() {  \n       this(Jackson2ObjectMapperBuilder.json().build());  \n    }  \n  \n    public MappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {  \n       super(objectMapper, MediaType.APPLICATION_JSON, new MediaType(\"application\", \"*+json\"));  \n    }  \n  \n  \n    public void setJsonPrefix(String jsonPrefix) {  \n       this.jsonPrefix = jsonPrefix;  \n    }  \n  \n    public void setPrefixJson(boolean prefixJson) {  \n       this.jsonPrefix = (prefixJson ? \")]}', \" : null);  \n    }  \n  \n  \n    @Override  \n    protected List<MediaType> getMediaTypesForProblemDetail() {  \n       return problemDetailMediaTypes;  \n    }  \n  \n    @Override  \n    protected void writePrefix(JsonGenerator generator, Object object) throws IOException {  \n       if (this.jsonPrefix != null) {  \n          generator.writeRaw(this.jsonPrefix);  \n       }  \n    }  \n}\n```\n\n`generator.writeRaw()` 는 진짜로 쓰는 코드다.  \n\n```java\n@Override  \npublic void writeRaw(String text) throws IOException  \n{  \n    // Nothing to check, can just output as is  \n    int len = text.length();  \n    int room = _outputEnd - _outputTail;  \n  \n    if (room == 0) {  \n        _flushBuffer();  \n        room = _outputEnd - _outputTail;  \n    }  \n    // But would it nicely fit in? If yes, it's easy  \n    if (room >= len) {  \n        text.getChars(0, len, _outputBuffer, _outputTail);  \n        _outputTail += len;  \n    } else {  \n        writeRawLong(text);  \n    }  \n}\n```\n\n\n"},{"excerpt":"RDT? Reliable Data Transfer 의 약자이다. 신뢰성 있는 데이터 전송을 위한 프로토콜의 일반적인 개념을 의미한다. TCP? 전송 제어 프로토콜 (Transmission Control Protocol) 의 약자로, 인터넷 프로토콜 스택의 전송 계층에 있는 프로토콜이다. RDT 의 구체적인 구현이다. 재전송 패킷이 손실되거나 예상한 시간 …","fields":{"slug":"/tcp/"},"frontmatter":{"date":"2023년 09월 17일 11:09","title":"TCP","tags":["tcp","network"]},"rawMarkdownBody":"\n## RDT?\n\nReliable Data Transfer 의 약자이다. 신뢰성 있는 데이터 전송을 위한 프로토콜의 일반적인 개념을 의미한다.  \n\n## TCP?\n\n전송 제어 프로토콜 (Transmission Control Protocol) 의 약자로, 인터넷 프로토콜 스택의 전송 계층에 있는 프로토콜이다. RDT 의 구체적인 구현이다. \n\n## 재전송\n\n패킷이 손실되거나 예상한 시간 내에 ACK 가 도착하지 않으면 패킷을 재전송한다.  \n\n1. ACK 가 예상 시간 내에 도착하지 않을 때 TCP 는 데이터가 유실되었다고 판단하고 재전송을 시작한다.\n2. 패킷 손실이 감지되면, TCP 는 혼잡이 원인이라고 생각하고 윈도우 크기를 줄인다. 윈도우 크기가 너무 작아져서 모든 패킷에 대한 ACK 를 빠르게 받게 되면 TCP 는 윈도우 크기를 다시 증가시키면서 전송 속도를 높인다.  \n3. ACK 가 너무 오래 도착하지 않으면 연결이 끊어진 것으로 간주하고 해당 세션에 대한 연결을 종료할 수 있다. \n\n- 시퀀스 번호: 각 패킷은 고유한 시퀀스 번호를 갖는다. 이를 통해 수신자는 패킷의 순서를 알 수 있으며, 누락된 패킷이 있는지 알 수 있다.\n- 타이머 설정: 송신자는 데이터 패킷을 보낼 때마다 재전송 타이머를 설정한다. 해당 타이머가 만료되기 전에 수신자로부터 해당 패킷의 ACK 를 받지 못하면, 패킷이 손실되었다고 판단하고 패킷을 재전송한다. \n- ACK 확인: 수신자는 패킷을 받을 때마다 해당 패킷의 ACK 를 송신자에게 전송한다. 송신자는 해당 ACK 를 통해 패킷이 성공적으로 전달되었는지 확인한다.\n- 재전송: 송신자는 ACK 를 받지 못한 패킷을 재전송한다. 네트워크 상의 패킷 손실, 지연 등 다양한 이유로 인해 필요할 수 있다.\n- Exponential Backoff: 만약 패킷이 계속해서 손실되면, 송신자는 재전송 간격을 지수적으로 증가시켜 네트워크 혼잡을 줄이려 시도한다. \n\n### 타임아웃 메커니즘\n\n연결 설정을 시도하는 동안 네트워크 지연이나 다른 문제로 인해 응답이 없는 경우를 처리하기 위해 존재한다.  \n\n1. SYN Retransmission\n\n클라이언트가 처음 SYN 패킷을 보낸 후, 서버로부터 SYN-ACK 응답을 기다리게 된다. 만약 응답이 일정 시간 내에 도착하지 않으면 클라이언트는 SYN 패킷을 다시 전송할 수 있다. 재전송되는 SYN 패킷의 타임아웃은 지수적으로 증가하며, 특정 횟수까지만 시도된다. (Linux 에서는 기본적으로 5회의 SYN 재전송을 시도하고, 이로써 총 연결 대기 시간은 약 180초 정도이다.)\n\n재전송 간격은 두 배로 증가하는 Exponential Backoff 를 사용한다.  \n\n2. Connection Timeout\n\nSYN 패킷의 재전송 횟수가 일정 횟수를 초과하고 클라이언트는 연결 시도를 중단하고 연결 실패로 간주한다. 이 때의 타임아웃을 연결 타임아웃이라 한다. 운영체제나 TCP 스택 설정에 따라 다를 수 있다. 일반적으로는 수 초 ~ 수 분 사이의 시간을 갖는다. \n\n## 플래그\n\n### PSH\n\n수신자의 TCP 스택은 버퍼링하지 않고 해당 패킷의 데이터를 즉시 애플리케이션 레벨로 전달해야 한다는 것을 나타낸다.  \n일반적으로 버퍼링된 데이터를 받는 쪽의 애플리케이션에 즉시 전달하고자 할 때 사용된다.  \n\n### ACK\n\nTCP 패킷이 확인 응답을 포함하고 있음을 나타낸다.  \nTCP 가 신뢰성 있는 데이터 전송 프로토콜이기 때문에, 데이터를 성공적으로 받았다는 것을 수신 측이 송신 측에 알려주는 확인응답 메커니즘이 필요하다.  \n\nACK 플래그와 함께 전송되는 숫자는 다음에 기대하는 시퀀스 번호를 뜻한다.  \n모든 TCP 패킷에는 ACK 플래그가 설정되어야 한다.  \n\n### RST\n\n현재 연결을 즉시 종료하도록 지시한다.  \n연결이 예상치 않게 종료되어야 할 때 사용한다. 예시로, 서버가 클라이언트로부터 받은 데이터를 해당 포트에서 수신 대기하고 있지 않은 서비스로 전달하려고 시도하는 경우 RST 패킷을 반환할 수 있다.  \n\n서버나 클라이언트에서 더 이상 데이터 통신을 원하지 않을 때도 RST 패킷을 보낼 수 있다.  \n\n"},{"excerpt":"Tomcat? Java 를 위한 오픈소스 웹 서버(Web Server) 이자, 서블릿 컨테이너이다. 구조 Context: 톰캣 내부의 단일 웹 애플리케이션 Connector: 클라이언트와의 통신을 담당하며, HTTP 요청을 받아들이고 처리한다. 톰캣의 기본 Connector 는 HTTP/1.1 표준에 따라 클라이언트로부터의 요청을 처리한다. Host: 톰…","fields":{"slug":"/tomcat/"},"frontmatter":{"date":"2023년 09월 17일 10:09","title":"tomcat","tags":["tomcat"]},"rawMarkdownBody":"\n## Tomcat?\n\nJava 를 위한 오픈소스 웹 서버(Web Server) 이자, 서블릿 컨테이너이다. \n\n## 구조\n\n- Context: 톰캣 내부의 단일 웹 애플리케이션\n- Connector: 클라이언트와의 통신을 담당하며, HTTP 요청을 받아들이고 처리한다. 톰캣의 기본 Connector 는 HTTP/1.1 표준에 따라 클라이언트로부터의 요청을 처리한다. \n- Host: 톰캣 서버에 대한 네트워크 이름의 연결. localhost 가 기본 구성에 포함되어 있다.\n- Engine: 톰캣의 핵심 역할. 여러 커넥터로부터의 모든 요청을 수신하고 처리하여 클라이언트에 전송할 적절한 커넥터로 응답을 다시 전달한다. 엔진에는 하나 이상의 호스트가 포함되어 있어야 하며, 그 중 하나가 기본 호스트로 지정되어 있어야 한다.\n- Listener: `LifecycleListener` 인터페이스를 구현하여 특정 이벤트에 응답할 수 있는 Java 객체\n- Realm: 사용자, 비밀번호, 사용자 역할의 데이터베이스. 컨테이너 기반 인증을 지원한다.\n- Valve: 애플리케이션에 도달하기 전에 들어오는 모든 HTTP 요청을 가로채는 인터셉터 같은 요소.\n\n## Connector\n\n- HTTP/1.1 Connector\n\t- 들어오는 각 비동기 요청에는 해당 요청이 지속되는 동안 유지되는 스레드가 필요하다. 현재 사용 가능한 요청 처리 스레드에서 처리할 수 있는 것보다 더 많은 동시 요청이 수신되면 `maxThreads` 까지 추가 스레드가 생성된다. 그래도 더 많은 동시 요청이 수신되면 Tomcat 은 현재 연결 수가 `maxConnections` 에 도달할 때까지 새 연결을 수락한다.\n\t- Connection 은 Connection 을 처리할 스레드를 사용할 수 있게 될 때까지 커넥터가 생성한 서버 소켓 내부에서 대기열에 대기한다.\n\t- 운영 체제에서 제공하는 연결 대기열의 크기는 `acceptCount` 으로 조정할 수 있다. 해당 큐가 가득 차면 추가 Connection 요청이 거부되거나 시간 초과될 수 있다.\n- HTTP/2\n\n### BIO\n\nTomcat 7 의 기본 방식이고, 하나의 스레드가 하나의 Connection 을 담당한다. `maxConnections` 는 200 으로 설정된다. \n\n### NIO\n\nTomcat 8.5 부터의 기본 방식이며, 하나의 스레드가 하나 이상의 Connection 을 담당한다. `maxConnections` 는 기본 값이 10000 이고, `maxThreads` 는 기본 값이 200이다.\n\n## Backlog\n\n연결을 처리할 수 있는 스레드를 사용할 수 있을 때까지 연결을 허용하고, `maxConnection` 수에 도달하면 추가 연결 요청은 `acceptCount` 크기를 갖는 큐에 대기하게 된다. 해당 큐를 Backlog, 백로그라고 한다.  \n\n백로그가 가득 차 있을 때, 새로운 연결 요청은 일반적으로 거절되거나 무시된다.  \n이미 성립된 연결에 대해서는 백로그와는 별개로 연결의 데이터 전송 상태에 따라 (데이터 전송이 완료되었는가, 아닌가 등) 재전송 메커니즘이 동작한다.  \n\n### maxConnection?\n\n> Each incoming, non-asynchronous request requires a thread for the duration of that request. If more simultaneous requests are received than can be handled by the currently available request processing threads, additional threads will be created up to the configured maximum (the value of the `maxThreads` attribute). If still more simultaneous requests are received, Tomcat will accept new connections until the current number of connections reaches `maxConnections`. Connections are queued inside the server socket created by the **Connector** until a thread becomes available to process the connection. Once `maxConnections` has been reached the operating system will queue further connections. The size of the operating system provided connection queue may be controlled by the `acceptCount` attribute. If the operating system queue fills, further connection requests may be refused or may time out.\n\n톰캣은 현재 연결 수가 maxConnection 에 도달할 때까지 새 요청을 수락하며, `maxConnection` 에 도달하면 OS 가 추가로 연결할 수 있는 요청을 큐에 대기시킨다.  \n\n즉, 톰캣이 연결할 수 있는 최대 연결 수를 의미한다.  \n\n### 백로그에 존재하는 요청들의 재전송\n\n#### 백로그에 있는 요청들은 어떤 상태일까?\n\n아직 완전히 연결 성립 과정을 마치지 않은 (TCP 3-way handshake) 가 완료되기를 기다리는 연결 요청들이다.  \n백로그에서 대기 중인 요청들은 TCP handshake 가 완료되면 연결이 성립된 것으로 간주하고, 데이터를 주고받을 준비가 된다. \n\n#### 백로그에 있는 요청의 3-way handshake 과정\n\n백로그에 요청이 쌓이게 되면, 해당 요청이 처리되지 못하고 대기하게 된다. 그러나 TCP 의 재전송은 이미 성립된 연결에서 데이터 전송 중 패킷의 유실을 감지하게 될 때 주로 발생한다.  \n\n초기 연결 설정 중 (TCP Handshake) 에 문제가 발생하면 재시도할 수 있으나, 연결이 한 번 성립된 이후에는 재전송이 이루어진다.  \n\n톰캣의 백로그에 있는 요청의 handshake 과정은 다음과 같다.\n\n1. **백로그 상태의 연결 요청**: 클라이언트가 SYN 패킷을 보냈을 때, 요청이 백로그에 대기한다. 3-way handshake 첫 단계는 시작되었으나, 완료되지 않은 상태이다.\n2. **톰캣의 연결 수락**: 백로그에 대기 중인 요청 중에 톰캣이 처리할 수 있는 요청이 있으면, 서버는 SYN-ACK 패킷을 보내서 응답한다.\n3. **연결 완료**: 클라이언트가 ACK 로 응답하여 연결을 확정한다. 3-way handshake 가 완료되고, 톰캣과 클라이언트는 데이터를 주고 받을 준비가 된 것이다.\n\n#### 백로그에 존재하는 요청들의 타임아웃\n\n3-way handshake 에는 특정한 시간 제한이 없지만, TCP 자체의 재전송 메커니즘이나 운영체제 네트워크 스택에 의해 타임아웃이 발생할 수는 있다. \n\n자세한 재전송 메커니즘은 [[tcp]] 를 확인하자.\n\n## 참고\n\n- [https://tomcat.apache.org/tomcat-8.5-doc/config/http.html](https://tomcat.apache.org/tomcat-8.5-doc/config/http.html)"},{"excerpt":"LOG 미션 2단계를 제출했다. 스프링과 비슷한 구조로 만들게 되어서 너무 뿌듯하다. 역시 내가 고민한 건 스프링에서 다 고민하고 만든 구조구나. 10/13에 이사하게 돼서 오늘이 마지막 과외였다. 이사하기 전 주에 과외를 다시 모집할 예정이다. 과연 할 수 있을 것인지? 배운 것 handler-adapter 에 대해 공부했다. 미션 테스트 코드 짜느라 …","fields":{"slug":"/2023-09-17/"},"frontmatter":{"date":"2023년 09월 17일 10:09","title":"2023년 09월 17일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 미션 2단계를 제출했다. 스프링과 비슷한 구조로 만들게 되어서 너무 뿌듯하다. 역시 내가 고민한 건 스프링에서 다 고민하고 만든 구조구나.\n- 10/13에 이사하게 돼서 오늘이 마지막 과외였다. 이사하기 전 주에 과외를 다시 모집할 예정이다. 과연 할 수 있을 것인지?\n\n## 배운 것\n\n- [[handler-adapter]] 에 대해 공부했다.\n- 미션 테스트 코드 짜느라 [[mockito]] 내용을 좀 더 추가할 수 있었다.\n\n## 느낀 것\n\n- 베포후헤말 스터디에서 배웠던 내용들이 막 나오니까 너무 재밌다. 그때는 잘 이해도 안 되고 왜 이렇게 된 건지 그냥 의문만 있었는데 이제는 잘 이해돼서 진짜 신기하다. 역시 아는만큼 보이는구나 싶다.\n- 과외를 다시 하게 되면 돈을 벌게 되니까 좋고 (이전보다 많이 벌 수도), 앞으로 과외를 못 구하게 되면 공부할 시간이 늘어나니 좋다. 어찌 됐든 좋은 일이다!\n"},{"excerpt":"개요  은  메서드가 있는데 왜  은  메서드가 인터페이스에 없을까? 그 이유에 대해 간단하게 알아보자.  스프링의 빈 생명 주기에서 초기화 작업을 지원하는 콜백 인터페이스 중 하나이다. 해당 인터페이스를 구현한 빈은 모든 프로퍼티가 설정된 '후에'  메서드가 자동으로 호출된다. 이를 통해 추가적인 초기화 작업, 검증 작업을 수행할 수 있다.  메서드 스…","fields":{"slug":"/handler-mapping/"},"frontmatter":{"date":"2023년 09월 17일 07:09","title":"HandlerMapping","tags":null},"rawMarkdownBody":"\n## 개요\n\n`DispatcherServlet` 은 `initialize` 메서드가 있는데 왜 `HandlerMapping` 은 `initialize` 메서드가 인터페이스에 없을까? 그 이유에 대해 간단하게 알아보자.  \n\n## `InitializingBean`\n\n```java\npublic interface InitializingBean {  \n  \n    /**  \n     * Invoked by the containing {@code BeanFactory} after it has set all bean properties  \n     * and satisfied {@link BeanFactoryAware}, {@code ApplicationContextAware} etc.  \n     * <p>This method allows the bean instance to perform validation of its overall  \n     * configuration and final initialization when all bean properties have been set.     * @throws Exception in the event of misconfiguration (such as failure to set an  \n     * essential property) or if initialization fails for any other reason     */    void afterPropertiesSet() throws Exception;  \n  \n}\n```\n\n스프링의 빈 생명 주기에서 초기화 작업을 지원하는 콜백 인터페이스 중 하나이다.  \n해당 인터페이스를 구현한 빈은 모든 프로퍼티가 설정된 '후에' `afterPropertiesSet` 메서드가 자동으로 호출된다. 이를 통해 추가적인 초기화 작업, 검증 작업을 수행할 수 있다.  \n\n### `afterPropertiesSet` 메서드\n\n스프링 컨테이너에 의해 빈의 모든 프로퍼티가 설정된 직후에 호출된다.  \n\n보통 빈의 초기화를 위한 로직을 포함하며, 빈의 상태를 검증하거나 필요한 경우 초기 데이터를 로드하는 등의 작업을 수행할 수 있다. \n\n`InitializingBean` 을 사용하는 경우, `afterPropertiesSet` 메서드가 가장 먼저 호출되고, `init-method` 나 `@PostConstruct` 로 지정된 메서드가 호출된다.  \n\n## 스프링은 왜 굳이 객체 생성 과정과 초기화 과정을 나누었을까?\n\n초기화 과정에서는 다른 빈들과의 의존성을 설정해야 한다. 그런데 객체가 생성되었을 때, 내부의 의존성들이 아직 준비되지 않았을 가능성이 있다. 그러므로 초기화 단계에서 의존성을 주입받거나 연결하게 된다.  \n\n또한 초기화 과정을 별도로 둠으로서 특정 시점에만 초기화 로직을 실행하거나, 다양한 초기화 전략을 사용하는 것이 가능해진다.  \n\n만약 초기화 과정에서 오류가 발생하면, 이를 적절하게 처리하기 위한 로직을 추가해야 한다. 이런 경우 별도의 초기화 단계를 통해서 이런 오류를 구체적으로 파악 / 대응할 수 있다.  \n"},{"excerpt":"개요 레벨4의 mvc 미션에서  과  이 동시에 호환되게 만들어야 한다. 두 가지  이 하는 일은 동일하다. 그러나 내부 구현이 다르기 때문에 단순히 구현을 하려면 다음과 같이 만들 수 밖에 없다. 사실상 controller 를 찾고, 실행하고, view 를 찾아서 넘기는 것까지 동일한 행동인데, 내부 구현이 다르다는 이유만으로 코드가 이만큼이나 길어졌다…","fields":{"slug":"/adapter-pattern/"},"frontmatter":{"date":"2023년 09월 17일 06:09","title":"어댑터 패턴","tags":["design-pattern","디자인패턴"]},"rawMarkdownBody":"\n## 개요\n\n레벨4의 mvc 미션에서 `AnnotationHandlerMapping` 과 `ManualHandlerMapping` 이 동시에 호환되게 만들어야 한다.  \n두 가지 `HandlerMapping` 이 하는 일은 동일하다. 그러나 내부 구현이 다르기 때문에 단순히 구현을 하려면 다음과 같이 만들 수 밖에 없다.  \n\n```java\nprivate void process(final HttpServletRequest request, final HttpServletResponse response)  \n    throws ServletException {  \n    try {  \n        processAnnotationHandlerMapping(request, response);  \n    } catch (NoSuchElementException e) {  \n        processManualHandlerMapping(request, response);  \n    } catch (Throwable e) {  \n        log.error(\"Exception : {}\", e.getMessage(), e);  \n        throw new ServletException(e.getMessage());  \n    }  \n}  \n  \nprivate void processAnnotationHandlerMapping(final HttpServletRequest request, final HttpServletResponse response)  \n    throws Exception {  \n    final var controller = (HandlerExecution) annotationHandlerMapping.getHandler(request);  \n    final var modelAndView = controller.handle(request, response);  \n    move(modelAndView, request, response);  \n}  \n  \nprivate void processManualHandlerMapping(final HttpServletRequest request, final HttpServletResponse response)  \n    throws ServletException {  \n    try {  \n        final String requestURI = request.getRequestURI();  \n        final var controller = manualHandlerMapping.getHandler(requestURI);  \n        final var viewName = controller.execute(request, response);  \n        move(viewName, request, response);  \n    } catch (Throwable e) {  \n        throw new ServletException(e.getMessage());  \n    }  \n}\n```\n\n사실상 controller 를 찾고, 실행하고, view 를 찾아서 넘기는 것까지 동일한 행동인데, 내부 구현이 다르다는 이유만으로 코드가 이만큼이나 길어졌다. \n\n이런 문제를 해결할 수 있는 방법은 없을까? 바로 어댑터 패턴을 이용하면 가능하다.  \n\n## 어떻게 해결할 수 있을까?\n\n위에 있는 코드들을 살펴보면, 각각 다음과 같은 부분들이 다르다. \n\n1. `getHandler` 의 매개변수\n\t1. requestURI, request 두 가지로 나뉘어 있다.\n2. `controller` 를 실행하는 메서드\n\t1. `execute` , `handle` 두 가지로 나뉘어 있다.\n\n그 외에는 모두 동일한 로직을 수행한다. \n\n그러니 해당 메서드들을 '동일하게' 호출해줄 수 있는 어댑터 클래스를 만들 수 있다. \n\n## 어댑터 패턴이란?\n\n특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.  \n\n클라이언트와 구현된 인터페이스를 분리할 수 있으며, 변경 내역이 어댑터로 캡슐화 되기 때문에 나중에 인터페이스가 변경되더라도 클라이언트를 변경할 필요가 없다.  \n\n## 어댑터 동작 과정\n\n1. 클라이언트에서 타깃 인터페이스로 메서드를 호출하고, 어댑터에 요청을 보낸다.\n2. 어댑터는 어댑'티' 인터페이스로 그 요청을 어댑티에 관한 하나 이상의 메서드 호출로 변환한다.\n3. 클라이언트는 호출 결과는 받을 수 있으나, 중간에 어댑터가 있다는 사실을 알지 못한다.  \n\n## 변경된 코드\n\n그렇다면 코드는 어떻게 변경할 수 있을까?\n\n먼저 `HandlerAdapter` 인터페이스를 생성하자. 해당 `HandlerAdapter` 가 요청을 처리할 수 있는지 확인할 수 있는 `support` 추상 메서드와, 실제로 요청을 처리하기 위한 `handle` 추상 메서드를 생성한다.  \n\n```java\npackage webmvc.org.springframework.web.servlet.mvc.tobe;  \n  \nimport jakarta.servlet.http.HttpServletRequest;  \nimport jakarta.servlet.http.HttpServletResponse;  \nimport webmvc.org.springframework.web.servlet.ModelAndView;  \n  \npublic interface HandlerAdapter {  \n  \n    boolean supports(Object handler);  \n  \n    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;  \n}\n```\n\n## 스프링의 `HandlerAdapter` \n\n스프링에서도 마찬가지로 어댑터 패턴을 사용하고 있다. `HandlerAdapter` 에 대해 더 자세하게 알아보려면 [[handler-adapter]] 를 참고하자.\n\n## 참고\n\n- 헤드퍼스트 디자인 패턴"},{"excerpt":"HandlerAdapter MVC framework SPI, allowing parameterization of the core MVC workflow.\nInterface that must be implemented for each handler type to handle a request. This interface is used to allow the…","fields":{"slug":"/handler-adapter/"},"frontmatter":{"date":"2023년 09월 17일 06:09","title":"HandlerAdapter","tags":["spring","레벨4"]},"rawMarkdownBody":"\n## HandlerAdapter\n\n> MVC framework SPI, allowing parameterization of the core MVC workflow. \n> Interface that must be implemented for each handler type to handle a request. This interface is used to allow the DispatcherServlet to be indefinitely extensible. The DispatcherServlet accesses all installed handlers through this interface, meaning that it does not contain code specific to any handler type.\n> Note that a handler can be of type Object. This is to enable handlers from other frameworks to be integrated with this framework without custom coding, as well as to allow for annotation-driven handler objects that do not obey any specific Java interface.\n> This interface is not intended for application developers. It is available to handlers who want to develop their own web workflow.\n> Note: HandlerAdapter implementors may implement the org.springframework.core.Ordered interface to be able to specify a sorting order (and thus a priority) for getting applied by the DispatcherServlet. Non-Ordered instances get treated as the lowest priority.\n\n요청을 처리하기 위해 핸들러 타입별로 구현해야 하는 인터페이스이다.  \n핸들러는 Object 유형이 될 수 있다. 이를 통해 다른 프레임워크의 핸들러를 특정 코드 없이 프레임워크와 통합할 수 있고, 특정 Java 인터페이스를 따르지 않은 어노테이션 기반 핸들러 객체를 허용할 수 있다.  \n\n즉, `HandlerMapping` 을 통해 찾은 `Handler` 를 실행할 수 있는 객체이다.  \n\n### `supports()`\n\n> Given a handler instance, return whether this HandlerAdapter can support it. Typical HandlerAdapters will base the decision on the handler type. HandlerAdapters will usually only support one handler type each.\n\n`HandlerAdapter` 가 지원할 수 있는지 여부를 반환한다. 일반적으로 `HandlerAdapter` 들은 오직 하나의 핸들러 타입만 지원한다.  \n\n### `handle()`\n\n> Use the given handler to handle this request. The workflow that is required may vary widely.\n\n실제로 요청을 처리하는 메서드이다.  \n\n## `AbstractHandlerMethodAdapter` \n\nhandler 가 `HandlerMethod` 의 인스턴스인지 확인한다.  \n\n```java\n@Override  \npublic final boolean supports(Object handler) {  \n    return (handler instanceof HandlerMethod handlerMethod && supportsInternal(handlerMethod));  \n}\n```\n\n`supportsInternal()` 메서드는 언제나 true 를 리턴하므로, `HandlerMethod` 인스턴스이기만 하면 true 를 리턴하게 된다.  \n\n## `DispatcherServlet` 의 `getHandlerAdapter`\n\n```java\nprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {  \n    if (this.handlerAdapters != null) {  \n       for (HandlerAdapter adapter : this.handlerAdapters) {  \n          if (adapter.supports(handler)) {  \n             return adapter;  \n          }  \n       }    }    throw new ServletException(\"No adapter for handler [\" + handler +  \n          \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");  \n}\n```\n\nHandlerAdapter 가 지원할 수 있는 handler 를 찾으면 `adapter` 를 반환한다.  \n\n### `handle()`\n\n```java\n@Override  \n@Nullable  \npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)  \n       throws Exception {  \n  \n    return handleInternal(request, response, (HandlerMethod) handler);  \n}\n```\n\n내부적으로 `handleInternal()` 을 호출한다.\n\n## `RequestMappingHandlerAdapter`\n\n### `handleInternal()`\n\n```java\n@Override  \nprotected ModelAndView handleInternal(HttpServletRequest request,  \n       HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {  \n  \n    ModelAndView mav;  \n    checkRequest(request);  \n  \n    // Execute invokeHandlerMethod in synchronized block if required.  \n    if (this.synchronizeOnSession) {  \n       HttpSession session = request.getSession(false);  \n       if (session != null) {  \n          Object mutex = WebUtils.getSessionMutex(session);  \n          synchronized (mutex) {  \n             mav = invokeHandlerMethod(request, response, handlerMethod);  \n          }  \n       }       else {  \n          // No HttpSession available -> no mutex necessary  \n          mav = invokeHandlerMethod(request, response, handlerMethod);  \n       }  \n    }    else {  \n       // No synchronization on session demanded at all...  \n       mav = invokeHandlerMethod(request, response, handlerMethod);  \n    }  \n  \n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {  \n       if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {  \n          applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);  \n       }  \n       else {  \n          prepareResponse(response);  \n       }  \n    }  \n    return mav;  \n}\n```\n\n1. `checkRequest()` 로 해당 요청이 지원되는 methods 인지, 세션이 필요한지 확인한다.  \n\n```java\n// WebContentGenerator.class\nprotected final void checkRequest(HttpServletRequest request) throws ServletException {  \n    // Check whether we should support the request method.  \n    String method = request.getMethod();  \n    if (this.supportedMethods != null && !this.supportedMethods.contains(method)) {  \n       throw new HttpRequestMethodNotSupportedException(method, this.supportedMethods);  \n    }  \n  \n    // Check whether a session is required.  \n    if (this.requireSession && request.getSession(false) == null) {  \n       throw new HttpSessionRequiredException(\"Pre-existing session required but none found\");  \n    }  \n}\n```\n\n2. 세션을 사용하는 경우 mutex 를 사용한다. 세션 사용 유무에 따라 성능 차이가 생길 수 있을 것이다.  \n3. `invokeHandlerMethod` 를 실행한다.\n\n### `invokeHandlerMethod`\n\n```java\n@Nullable  \nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,  \n       HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {  \n  \n    ServletWebRequest webRequest = new ServletWebRequest(request, response);  \n    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);  \n    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);  \n  \n    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);  \n    if (this.argumentResolvers != null) {  \n       invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);  \n    }  \n    if (this.returnValueHandlers != null) {  \n       invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);  \n    }  \n    invocableMethod.setDataBinderFactory(binderFactory);  \n    invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);  \n  \n    ModelAndViewContainer mavContainer = new ModelAndViewContainer();  \n    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));  \n    modelFactory.initModel(webRequest, mavContainer, invocableMethod);  \n    mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);  \n  \n    AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);  \n    asyncWebRequest.setTimeout(this.asyncRequestTimeout);  \n  \n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);  \n    asyncManager.setTaskExecutor(this.taskExecutor);  \n    asyncManager.setAsyncWebRequest(asyncWebRequest);  \n    asyncManager.registerCallableInterceptors(this.callableInterceptors);  \n    asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);  \n  \n    if (asyncManager.hasConcurrentResult()) {  \n       Object result = asyncManager.getConcurrentResult();  \n       mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];  \n       asyncManager.clearConcurrentResult();  \n       LogFormatUtils.traceDebug(logger, traceOn -> {  \n          String formatted = LogFormatUtils.formatValue(result, !traceOn);  \n          return \"Resume with async result [\" + formatted + \"]\";  \n       });  \n       invocableMethod = invocableMethod.wrapConcurrentResult(result);  \n    }  \n  \n    invocableMethod.invokeAndHandle(webRequest, mavContainer);  \n    if (asyncManager.isConcurrentHandlingStarted()) {  \n       return null;  \n    }  \n  \n    return getModelAndView(mavContainer, modelFactory, webRequest);  \n}\n```\n\n`RequestMapping` 핸들러 메서드를 호출하는 메서드이다.  \n\n1. `HttpServletRequest` 와 `HttpServletResponse` 를 기반으로 `ServletWebRequest` 를 생성한다.\n2. 핸들러 메서드의 입력 파라미터를 처리하기 위해 `DataBinder` 와 Model Factory 를 설정한다.\n3. `ServletInvocableHandlerMethod` 객체를 생성한다. 해당 객체는 실제로 주어진 핸들러 메서드를 호출하는 역할을 한다. `ArgumentResolver`, `ReturnValueHandler`, `DataBinderFactory` 등을 갖는다.\n4. 뷰와 모델 정보를 포함하고, 응답을 구성하는 `ModelAndViewContainer` 를 초기화한다. \n5. 요청이 비동기로 처리되는 경우, 비동기 웹 요청과 `WebAsyncManager` 설정을 한다. \n\t1. 비동기 요청의 타임 아웃, task executor, callable interceptors 나 deferred result interceptor 등이 설정된다.\n6. 현재 요청이 비동기 요청의 일부로 시작되었고, 결과가 사용가능한 경우에 핸들링한다.\n7. `invocableMethod.invokeAndHandle()` 을 통해 실제 핸들러 메서드가 호출된다.  \n8. 요청 처리 후의 뷰 정보를 `ModelAndView` 로 반환한다.\n\n## 참고\n- https://velog.io/@jihoson94/Spring-MVC-HandlerAdapter-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0"},{"excerpt":"S-HOOK 개발 서버에서 인덱스 조회 성능 개선을 위해 성능 테스트를 진행하다 마주한 에러이다. 스와이프를 하기 위해 노래를 클릭했을 때 현재 노래, 현재 노래보다 좋아요가 적은 노래들, 현재 노래보다 좋아요가 많은 노래들을 불러오는 API 의 성능 테스트를 진행했다. 그런데 개발 서버의 페이지를 연속으로 새로고침할 때마다  가 발생했다. 과연 무슨 에…","fields":{"slug":"/broken-pipe-error/"},"frontmatter":{"date":"2023년 09월 16일 13:09","title":"Broken Pipe Error","tags":["spring","shook","trouble-shooting"]},"rawMarkdownBody":"\nS-HOOK 개발 서버에서 인덱스 조회 성능 개선을 위해 성능 테스트를 진행하다 마주한 에러이다. 스와이프를 하기 위해 노래를 클릭했을 때 현재 노래, 현재 노래보다 좋아요가 적은 노래들, 현재 노래보다 좋아요가 많은 노래들을 불러오는 API 의 성능 테스트를 진행했다.  \n\n그런데 개발 서버의 페이지를 연속으로 새로고침할 때마다 `Broken Pipe Error` 가 발생했다.  \n\n과연 무슨 에러일까? 왜 발생한 걸까?\n\n## 발생한 에러\n\n```shell\norg.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe\n```\n\n발생한 에러의 전문이다. 간결하게 `Broken pipe` 라고 적혀 있다.  \n\n### java.io.IOException\n\n먼저 `IOException` 란 무엇인지 docs 를 살펴보자.  \n\n> Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.\n\n일종의 I/O 예외가 발생했으며, 실패하거나 중단된 I/O 작업으로 인해 발생하는 예외라고 한다.  \n테스트할 때 I/O 과정에서 문제가 생겼다는 것을 알 수 있다.\n\n### ClientAbortException\n\n> Extend IOException to identify it as being caused by an abort of a request by a remote client.\n\n`IOException` 을 확장한 예외로, 원격 클라이언트에 의한 요청 중단으로 인해 발생한 것이라고 쓰여 있다.  \n\n## Broken Pipe Error 란?\n\n두 소켓 Receiver, Sender 상의 통신을 가정할 때, 한 소켓 (대체로 Receiver) 가 갑작스러운 이상으로 종료된 상황에서 다른 하나의 소켓 (Sender) 가 이를 알지 못하고 데이터를 계속 전송하려고 할 때 발생한다.  \n\n즉, 서버인 Receiver 가 작업 결과를 전달할 곳이 없어 발생하는 에러이다.  \n\n다음과 같은 상황에서 발생할 수 있다.  \n\n> 1. 클라이언트에서 요청을 한다.\n> 2. 서버에서 작업을 완료한 후, 클라이언트로 결과를 전송하려 한다.\n> 3. 결과가 클라이언트로 넘겨지기 전에 네트워크가 끊기거나, 클라이언트가 정지 버튼을 누르거나, 브라우저를 종료하거나, 다른 화면으로 이동한다.\n> 4. 최초로 요청한 정보가 사라지므로 서버 측에서 작업 결과를 전달할 곳이 없어진다.\n\n페이지를 새로 고침하면 이전 connection 이 반환되지 않고, connection 을 닫았다가 새로운 연결을 다시 열기 때문에 이전 서버 요청에서 해당 오류가 발생하게 되는 것이다.  \n\n## Socket 문제일까?\n\n새 페이지가 로드되거나 현재 페이지가 새로 고침되면 이전 페이지의 모든 리소스가 닫히고, 브라우저에서 `socket.io/webSocket` 연결을 포함해서 해제된다.  \n\n즉, 서버는 새로 로드된 페이지에서 새로운 `socket.io` 연결을 받게 된다. 쿠키나 세션을 이용해서 이전 클라이언트의 연결인지 식별하고, 이전 클라이언트가 현재 새 페이지에서 재연결하는 것임을 인식한 뒤 조치를 취할 수 있다. (세션이 같으면 캐싱된 값을 내려준다든지...)  \n\n## 해결 방법\n\n구글에 여러 가지 방법들이 나와있지만, 사실 그렇게 크게 와닿지 않았다.  \n일반적인 네트워크 문제로 발생할 수 있는 예외이고, 서버의 오류가 아니기 때문에 클라이언트 단에서 막는 게 맞는 것 같다.  \n\n우리 상황에서는 클라이언트의 리프레쉬를 일정 시간 간격으로 제한하면 해결될 문제일 것 같다.  \n또한 서버에서 특정 IP, 세션에 대한 요청 빈도를 제한할 수 있을 것이다. \n\n## 참고\n\n- https://stackoverflow.com/questions/71587838/when-refreshing-the-web-page-if-keep-the-socket-unchanged"},{"excerpt":"LOG 대학원을 고민해보게 됐다. 만약 가게 된다면 네트워크나 OS 연구실에 가보지 않을까요 내내 미션만 했다... 그래도 힘들지만 재밌다. 되게 새로운 것들도 많이 배우고, 예전에는 이해 안 되던 것들이 이제는 너무 잘 돼서 재밌다 !!!! 배운 것 handler-mapping 을 공부했다. broken-pipe-error 에 대해 알아봤다. 별 거 아…","fields":{"slug":"/2023-09-16/"},"frontmatter":{"date":"2023년 09월 16일 13:09","title":"2023년 09월 16일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 대학원을 고민해보게 됐다. 만약 가게 된다면 네트워크나 OS 연구실에 가보지 않을까요\n- 내내 미션만 했다... 그래도 힘들지만 재밌다. 되게 새로운 것들도 많이 배우고, 예전에는 이해 안 되던 것들이 이제는 너무 잘 돼서 재밌다 !!!!\n\n## 배운 것\n\n- [[handler-mapping]] 을 공부했다.\n- [[broken-pipe-error]] 에 대해 알아봤다. 별 거 아니던데\n\n## 느낀 것\n\n- 이제 나도 나를 믿어볼 수 있지 않을까??????? 한 번만 더 믿어볼게 파이팅"},{"excerpt":"LOG 오늘 내내 인덱스 쿼리 성능 개선을 했다. 너무 어렵다... 튜닝하는 것도 쉬운 일이 아니다. 정리를 해야 하는데 정리를 못했다. 이런... 할 게 너무 많아서 정리가 계속 밀리고 있다. 미션 학습 테스트를 했다. 생각보다 오래 걸렸다. 역시나 이런... 얼른 미션 해야 이것저것 할 수 있는데. 배운 것 fifth-demoday-index 를 했다…","fields":{"slug":"/2023-09-15/"},"frontmatter":{"date":"2023년 09월 15일 01:09","title":"2023년 09월 15일","tags":null},"rawMarkdownBody":"## LOG\n\n- 오늘 내내 인덱스 쿼리 성능 개선을 했다. 너무 어렵다... 튜닝하는 것도 쉬운 일이 아니다. 정리를 해야 하는데 정리를 못했다. 이런... 할 게 너무 많아서 정리가 계속 밀리고 있다.\n- 미션 학습 테스트를 했다. 생각보다 오래 걸렸다. 역시나 이런... 얼른 미션 해야 이것저것 할 수 있는데.\n\n## 배운 것\n\n- [[fifth-demoday-index]] 를 했다.\n- [[query-performance-test]] 도 했다.\n- [[mysql-explain]] 에 대해서도 알아봤다.\n- 파이썬의 `round()` 는 오사오입이다... 누가 이렇게 만들었지\n \n## 느낀 것\n\n- 우테코는 나에게 정말 많은 걸 준 것 같다. 경험과 성장, 같이 의논할 수 있는 사람들, 근거 있는 생각 등.. 나는 이제 모르는 게 있어도 두렵지 않다. 어떻게 배워나가는지, 노력하면 잘할 수 있다는 걸 이제는 안다!\n"},{"excerpt":"performance_schema MySQL 서버 실행에 대한 세부적인 통계와 모니터링 정보를 제공하는 스토리지 엔진이다. 특정 쿼리의 성능 알아보기 주로  테이블을 참조한다. 이 테이블은 실행된 SQL 문의 통계를 제공하고, 다양한 정보를 통해 성능 분석을 할 수 있다. DIGEST 쿼리를 구분하는데 사용되는 값이다. DIGEST_TEXT 다이제스트에 …","fields":{"slug":"/query-performance-test/"},"frontmatter":{"date":"2023년 09월 14일 13:09","title":"performance_schema로 Query 성능 체크하기","tags":["mysql","database","레벨4","우테코","shook"]},"rawMarkdownBody":"\n## performance_schema\n\nMySQL 서버 실행에 대한 세부적인 통계와 모니터링 정보를 제공하는 스토리지 엔진이다.  \n\n### 특정 쿼리의 성능 알아보기\n\n주로 `events_statements_summary_by_digest` 테이블을 참조한다. 이 테이블은 실행된 SQL 문의 통계를 제공하고, 다양한 정보를 통해 성능 분석을 할 수 있다. \n\n- DIGEST\n\t- 쿼리를 구분하는데 사용되는 값이다.\n- DIGEST_TEXT\n\t- 다이제스트에 해당하는 실제 SQL 텍스트\n- COUNT_STAR\n\t- 쿼리가 몇 번 실행되었는지\n- SUM_TIMER_WAIT\n\t- 쿼리를 실행하는 데 걸린 전체 시간\n- MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT\n\t- 최소, 평균, 최대 실행 시간\n- SUM_ROWS_SENT, SUM_ROWS_EXAMINED\n\t- 쿼리 실행 시 반환 및 조사된 행 수\n"},{"excerpt":"EXPLAIN Extra 컬럼 Using index Covering Index Scan. 필요한 모든 데이터가 인덱스에서 직접 가져올 수 있으므로 데이터 파일을 읽을 필요가 없다. Using where 쿼리에서 WHERE 절이 사용되었고, MySQL 이 결과를 필터링 하기 위해 where 를 사용했다. Using filesort MySQL 이 결과를 정렬…","fields":{"slug":"/mysql-explain/"},"frontmatter":{"date":"2023년 09월 14일 12:09","title":"EXPLAIN","tags":["mysql","database"]},"rawMarkdownBody":"## EXPLAIN\n\n### Extra 컬럼\n\n- Using index\n\t- Covering Index Scan. 필요한 모든 데이터가 인덱스에서 직접 가져올 수 있으므로 데이터 파일을 읽을 필요가 없다.  \n- Using where\n\t- 쿼리에서 WHERE 절이 사용되었고, MySQL 이 결과를 필터링 하기 위해 where 를 사용했다.  \n- Using filesort\n\t- MySQL 이 결과를 정렬하기 위해 디스크 기반의 정렬 기법을 사용했다. 인덱스를 사용하여 자동으로 정렬할 수 없는 경우에 발생하며, 성능에 부정적인 영향을 줄 수 있다.\n- Range checked for each record (index map: x)\n\t- JOIN 연산을 수행할 때, 가장 좋은 인덱스를 결정하기 위해 각각의 행에 대해 범위를 확인했다는 것을 나타낸다.  \n- Impossible WHERE noticed after reading const tables\n\t- WHERE 절의 조건에 따라 쿼리가 결과를 반환할 수 없음을 MySQL 이 인식했다.  \n- Using join buffer\n\t- 조인 버퍼를 사용하여 조인 연산을 수행했다.\n\t- 특정 조인 유형에서 사용되며, 성능에 영향을 줄 수 있다.\n- Select tables optimized away\n\t- 쿼리 최적화 과정에서 테이블 액세스가 필요하지 않다고 판단되어 제외되었다. \n- Distinct\n\t- 중복된 결과를 제거하기 위해 `DISTINCT` 키워드를 사용했다.\n- Using temporary\n\t- MySQL 이 쿼리의 결과를 만들기 위해 임시 테이블을 생성했다. 대개 이는 `GROUP BY`, `ORDER BY` 또는 둘 다 포함하는 쿼리에서 발생한다. `ORDER BY` 절과 `GROUP BY` 절이 서로 다른 컬럼을 참조할 때, 혹은 조인된 결과를 정렬해야 할 때 이런 상황이 발생한다.\n\t- 임시 테이블을 사용하면 디스크에 기록될 수 있기 때문에 성능 저하를 유발할 수 있다.\n\n#### Using join buffer\n\n조인 연산을 수행하기 위해 특별한 메모리 버퍼인 \"조인 버퍼\" 를 사용했다는 것이다.  \n주로 Block Nested-Loop join 에 해당하는 연산이 발생할 때 나타난다.  \n\n**Block Nested-Loop join**\n\n1. Outer 테이블의 각 레코드에 대해\n2. Inner 테이블 전체를 스캔하면서\n3. 조인 조건에 맞는 레코드를 찾는 방법\n\n**장점**\n\n조인 버퍼를 사용하면 Inner 테이블의 읽기 연산 횟수를 획기적으로 줄일 수 있다. 조인 버퍼에는 Outer 테이블에서 읽은 여러 레코드의 정보가 저장된다. 한 번의 스캔으로 여러 조인 연산을 동시에 수행할 수 있다.\n\n조인 버퍼의 크기는 `join_buffer_size` 시스템 변수로 설정할 수 있다.  \n이 값이 충분히 크면, 더 많은 Outer 테이블 레코드를 한 번에 조인 버퍼에 저장하고, 더 적은 수의 스캔으로 Inner 테이블과의 조인 연산을 완료할 수 있다.   \n\n**단점**\n\n조인 버퍼는 메모리를 사용하기 때문에, 동시에 실행되는 많은 쿼리가 조인 버퍼를 사용해야 하거나, `join_buffer_size` 가 너무 큰 경우에는 메모리 부족 문제가 발생할 수 있다.\n"},{"excerpt":"좋아요 순 노래 전체 조회 쿼리 Explain song 만 개, 킬링파트 3만 개로 테스트했다. type possible_keys key key_len ref rows filtered Extra ALL PRIMARY null null null 9910 100 Using temporary ALL null null null null 29478 100 Usin…","fields":{"slug":"/fifth-demoday-index/"},"frontmatter":{"date":"2023년 09월 14일 08:09","title":"Index로 성능 개선하기","tags":["shook","레벨4","우테코"]},"rawMarkdownBody":"## 좋아요 순 노래 전체 조회 쿼리\n\n```sql\nselect song.id, song.album_cover_url, song.created_at, song.length, song.singer, song.title, song.video_id, sum(coalesce(kp.like_count,0)) \nfrom song  \nleft join killing_part kp on song.id=kp.song_id  \ngroup by song.id  \n```\n\n### Explain\n\nsong 만 개, 킬링파트 3만 개로 테스트했다.\n\n| type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |  \n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  \n| ALL | PRIMARY | null | null | null | 9910 | 100 | Using temporary |  \n| ALL | null | null | null | null | 29478 | 100 | Using where; Using join buffer \\(hash join\\) |\n\ntype 이 ALL 로 나오기 때문에, 전체 테이블 스캔이 발생했다.  \n\n### 개선 사항\n\n- `kp.song_id` 에 인덱스 걸기\n\n| id | select\\_type | table | partitions | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |  \n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |  \n| 1 | SIMPLE | song | null | index | PRIMARY | PRIMARY | 8 | null | 9910 | 100 | null |  \n| 1 | SIMPLE | kp | null | ref | idx\\_kp\\_song\\_id | idx\\_kp\\_song\\_id | 8 | shook.song.id | 3 | 100 | null |\n\n살펴보는 row 의 수가 '크게' 줄었다!\n\n- 페이지네이션 적용\n\n## 특정 킬링파트 전체 댓글 쿼리\n\n```sql\nselect comment.killing_part_id, comment.id, comment.content, comment.created_at, comment.member_id, m.id, m.created_at, m.email, m.nickname  \nfrom killing_part_comment comment  \nleft join member m on m.id=comment.member_id  \nwhere comment.killing_part_id=? \n```\n\n### Explain\n\nmember 가 1명이었음  \ncomment 4만개 기준으로 테스트\n\n\n|table | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| comment | ALL | null | null | null | null | 40051 | 10 | Using where |\n| m | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.comment.member\\_id | 1 | 100 | null |\n\n마찬가지로 ALL 로 나오는 모습이다.  \n\n### 기존 성능 체크\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- | \n| 2 | 41795000000 | 19135000000 | 20897500000 | 22660000000 | 15000000 |\n### 개선사항\n\n- `member_id`, `killing_part_id` 에 인덱스 걸기\n\n| table | type | possible\\_keys | key | key\\_len | ref | rows | filtered | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| comment | ref | idx\\_killing\\_part\\_comment\\_killing\\_part\\_id | idx\\_killing\\_part\\_comment\\_killing\\_part\\_id | 8 | const | 18564 | 100 | null |\n| m | eq\\_ref | PRIMARY | PRIMARY | 8 | shook.comment.member\\_id | 1 | 100 | null |\n\n확인하는 row 수가 2분의 1로 감소했다.  \n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 6 | 50175000000 | 797000000 | 8362500000 | 22660000000 | 30000000 |\n\n성능도 최소 시간 기준 100분의 1로 크게 향상되었다.  \n\n## 스와이프하는 노래를 조회하는 쿼리 (비로그인)\n\n```sql\nselect * from song s where s.id=? // 기준 song 조회 \n\n// 기준 노래보다 좋아요가 많은 노래 10개 조회\nselect * from song s1_0 \nleft join killing_part k1_0 on s1_0.id=k1_0.song_id \ngroup by s1_0.id \nhaving ( \n// 좋아요 개수 값이 클 때 sum(coalesce(k1_0.like_count,0))> ( \n\t\tselect sum(coalesce(k2_0.like_count,0)) \n\t\tfrom killing_part k2_0 where k2_0.song_id=? \n\t) \n\tor \n// 좋아요 개수 같으면 id 가 큰 순으로 정렬 \n\t( \n\t\tsum(coalesce(k1_0.like_count,0))= ( \n\t\t\tselect sum(coalesce(k3_0.like_count,0)) \n\t\t\tfrom killing_part k3_0  \n\t\t\twhere k3_0.song_id=? \n\t\t) and s1_0.id>? \n\t) \n) \norder by sum(coalesce(k1_0.like_count,0)), s1_0.id // 좋아요 순 → id 작은 순 \noffset ? rows fetch first ? rows only \n\n// 아래쪽 조회하는 쿼리  \nselect * \nfrom song s1_0 \nleft join killing_part k1_0 on s1_0.id=k1_0.song_id \ngroup by s1_0.id \nhaving \nsum(coalesce(k1_0.like_count,0))< \n\t( \n\tselect sum(coalesce(k2_0.like_count,0)) \n\tfrom killing_part k2_0 \n\twhere k2_0.song_id=? \n\t) \nor \n( sum(coalesce(k1_0.like_count,0))= \n\t( \n\t\tselect sum(coalesce(k3_0.like_count,0)) \n\t\tfrom killing_part k3_0 \n\t\twhere k3_0.song_id=? \n\t) \n\tand s1_0.id<? \n) \norder by sum(coalesce(k1_0.like_count,0)) desc, s1_0.id desc \noffset ? rows fetch first ? rows only \n\n// 기준 노래의 킬링파트 조회하는 로직 \nselect * from killing_part k1_0 where k1_0.song_id=?\n```\n\n## Explain\n\n- 기준 노래보다 좋아요가 많은 데이터 조회 및 정렬\n\n| select\\_type | table | type | possible\\_keys | key | ref | rows | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| PRIMARY | s1\\_0 | ALL | PRIMARY | null | null | 9910 | Using temporary; Using filesort |\n| PRIMARY | k1\\_0 | ALL | null | null | null | 29478 | Using where; Using join buffer \\(hash join\\) |\n| SUBQUERY | k3\\_0 | ALL | null | null | null | 29478 | Using where |\n| SUBQUERY | k2\\_0 | ALL | null | null | null | 29478 | Using where |\n\n모두 ALL Search 를 수행하고 있으며, filesort 또한 수행되고 있는 것을 볼 수 있다. (성능에 안 좋다는 건 다 들어간 인스턴스 쿼리;;)\n\n- 기준 노래보다 좋아요가 적은 데이터 조회 및 정렬\n\n| select\\_type | table | type | possible\\_keys | key | ref | rows | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| PRIMARY | s1\\_0 | ALL | PRIMARY | null | null | 9910 | Using temporary; Using filesort |\n| PRIMARY | k1\\_0 | ALL | null | null | null | 29478 | Using where; Using join buffer \\(hash join\\) |\n| SUBQUERY | k3\\_0 | ALL | null | null | null | 29478 | Using where |\n| SUBQUERY | k2\\_0 | ALL | null | null | null | 29478 | Using where |\n\n마찬가지로 ALL search 수행 중이다.\n\n- song_id 로 킬링파트 조회\n\n| select\\_type | table | type | key | ref | rows | Extra |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| SIMPLE | k1\\_0 | ALL | null | null | 29478 | Using where |\n\nALL Search 진행 중이다.\n\n### 성능 측정\n\n- 좋아요 많은 거 쿼리 (캐시 안 타도록)\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 4 | 432433000000 | 102933000000 | 108108250000 | 114617000000 | 119000000 |\n\n- 좋아요 적은 거 쿼리 (캐시 안 타도록)\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 5 | 510016000000 | 91359000000 | 102003200000 | 111161000000 | 31000000 |\n\n- 킬링파트 조회 쿼리 (캐시 안 타도록)\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 4 | 99311000000 | 23335000000 | 24827750000 | 26468000000 | 14000000 |\n\n### 개선 방법\n\n- `killing_part` 의 `song_id` 인덱싱\n\n### 이후 성능 측정\n\n- 좋아요 많은 거 조회\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 20 | 1597450000000 | 65837000000 | 79872500000 | 114617000000 | 185000000 |\n\nMIN_TIMER_WAIT 성능 30% 개선\n\n- 좋아요 아래 조회\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 20 | 1406030000000 | 53473000000 | 70301500000 | 111161000000 | 97000000 |\n\nMIN_TIMER_WAIT 성능 250% 악화\n\n- 킬링파트 조회\n\n| COUNT\\_STAR | SUM\\_TIMER\\_WAIT | MIN\\_TIMER\\_WAIT | AVG\\_TIMER\\_WAIT | MAX\\_TIMER\\_WAIT | SUM\\_LOCK\\_TIME |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 10 | 101400000000 | 288000000 | 10140000000 | 26468000000 | 34000000 |\n"},{"excerpt":"Reflection Runtime에 동적으로 특정 Class 의 정보를 추출할 수 있는 프로그래밍 기법이다. 리플렉션으로 형은 알고 있지만 형변환을 할 수 없는 상태에서 객체의 메서드를 호출할 수 있다. 힙 영역에 로드된 Class 타입의 객체를 통해 원하는 클래스의 인스턴스를 생성할 수 있도록 정적 바인딩보다는 성능상 오버헤드가 있지만 동적 바인딩을 통…","fields":{"slug":"/reflection/"},"frontmatter":{"date":"2023년 09월 13일 03:09","title":"Reflection (리플렉션)","tags":["java","레벨4","우테코"]},"rawMarkdownBody":"\n## Reflection\n\nRuntime에 동적으로 특정 Class 의 정보를 추출할 수 있는 프로그래밍 기법이다.  \n리플렉션으로 형은 알고 있지만 형변환을 할 수 없는 상태에서 객체의 메서드를 호출할 수 있다.  \n\n힙 영역에 로드된 Class 타입의 객체를 통해 원하는 클래스의 인스턴스를 생성할 수 있도록 \n\n정적 바인딩보다는 성능상 오버헤드가 있지만 동적 바인딩을 통해 상속과 다형성 등 다양한 기능을 사용할 수 있는 장점이 있다.  \n\n### 동적 바인딩 특징\n\n- Runtime 에 결정\n- Late Binding 이라고도 부른다.\n- Overriding\n- Java 에서의 다형성, 상속을 가능하게 해준다.\n\n## Reflection 활용처\n\n- 동적으로 Class 를 사용해야 하는 경우\n\t- 코드 작성 시점에서는 어떠한 Class 를 사용해야할지 모르지만 Runtime 에 Class 를 가져와서 실행해야 하는 경우\n- Test Code 작성\n\t- private 변수를 변경하고 싶거나 private method 를 테스트할 경우\n- 자동 Mapping 기능 구현\n\t- IDE 사용 시 특정 단어를 입력하면 이와 관련된 Class 나 메서드들을 IDE 가 먼저 확인하고 사용자에게 제공한다.\n- Jackson, GSON 등의 JSON Serialization Library\n\t- Reflection 을 사용하여 객체 필드의 변수명 / 어노테이션명을 json key 와 mapping 해주고 있다.\n- 정적 분석 tool\n\n### 주의점\n\n- 성능 이슈\n- 보안 이슈\n- `setAccessible(true)` 를 사용하여 private 필드나 메서드에 접근할 경우 보안 취약점을 초래할 수 있다.\n\n## 사용법\n\n### 클래스 객체 얻기\n\n- `getSimpleName()`\n\t- 클래스의 단순한 이름 반환. 패키지나 외부 클래스 없이 클래스 이름만을 반환한다.\n\t- `java.util.Map.Entry` 의 경우 `Entry` 만을 반환한다.\n- `getName()`\n\t- 클래스의 완전히 정규화된 이름을 반환한다. 패키지 이름을 포함한다.\n\t- `java.util.Map.Entry` 의 경우 `java.util.Map.Entry` 를 반환한다.\n\t- 내부 클래스의 경우 `OuterClass$InnerClass` 를 반환한다.  \n```java\npublic class OuterClass {\n    public class InnerClass {\n    }\n}\n\nClass<?> innerClass = OuterClass.InnerClass.class;\nSystem.out.println(innerClass.getName()); // 출력: OuterClass$InnerClass\n\n```\n- `getCanonicalName()`\n\t- 클래스의 캐노니컬 이름 (코드에서 사용되는 형식의 이름) 을 반환한다.\n\t- 대부분의 클래스에 대해 `getName()` 과 동일한 이름을 반환하지만, 내부 클래스의 경우 `$` 대신 `.` 을 사용해서 이름을 반환한다.\n\t- `java.util.Map.Entry` 의 경우 `java.util.Map.Entry` 를 반환한다.\n\n### 필드 얻어오기\n\n- `getField(String name)` : 특정 이름의 필드를 가져오고 싶은 경우에 사용한다. `public` 필드에만 접근할 수 있다.  \n```java\nClass<?> clazz = SomeClass.class;\nField field = clazz.getField(\"fieldName\");\n```\n- `getFields()` : 해당 클래스와 상속받은 부모 클래스의 모든 `public` 필드를 가져올 수 있다.  \n```java\nClass<?> clazz = SomeClass.class;\nField[] fields = clazz.getFields();\n```\n- `getDeclaredField(String name)` : 해당 클래스의 모든 접근 제한자를 가진 필드를 이름으로 가져올 수 있다.  \n```java\nClass<?> clazz = SomeClass.class;\nField field = clazz.getDeclaredField(\"privateFieldName\");\n```\n- `getDeclaredFields()` : 해당 클래스의 `private` 필드를 포함한 모든 필드를 가져온다.  \n```java\nClass<?> clazz = SomeClass.class;\nField[] fields = clazz.getDeclaredFields();\n```\n- `Field` 객체로 객체 필드 값에 접근할 수 있다. `setAccessible(true)` 를 사용해서 `private` 필드에도 접근 가능하다.\n```java\nSomeClass instance = new SomeClass();\nField field = SomeClass.class.getDeclaredField(\"someField\");\nfield.setAccessible(true);\nObject value = field.get(instance);\n```\n\n### 생성자 가져오기\n\n- `getConstructors()` : 해당 클래스의 모든 `public` 생성자를 가져온다.\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?>[] constructors = clazz.getConstructors();\n```\n- `getConstructor(Class<?>... parameterTypes)` : 특정 파라미터 타입들을 가진 public 생성자를 가져온다.\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?> constructor = clazz.getConstructor(String.class, int.class);\n```\n- `getDeclaredConstructors()` : private 포함한 모든 생성자 가져오기\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?>[] constructors = clazz.getDeclaredConstructors();\n```\n- `getDeclaredConstructor(Class<?>... parameterTypes)` : 특정 파라미터 타입들을 가진 모든 접근 제한자에 대한 생성자를 가져올 수 있다. \n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?> constructor = clazz.getDeclaredConstructor(String.class);\n```\n- `getEnclosingConstructor()` : 특정클래스나 인터페이스가 다른 생성자 내부에서 정의된 경우 해당 생성자를 나타내는 `Constructor` 객체를 반환한다.\n```java\npublic class OuterClass {\n\n    public OuterClass() {\n        class InnerClass {\n        }\n    }\n\n    public static void main(String[] args) {\n        Class<?> innerClazz = null;\n\n        // 이렇게 하면 OuterClass의 모든 선언된 클래스들을 가져옵니다.\n        for (Class<?> declaredClass : OuterClass.class.getDeclaredClasses()) {\n            if (declaredClass.getSimpleName().equals(\"InnerClass\")) {\n                innerClazz = declaredClass;\n                break;\n            }\n        }\n\n        if (innerClazz != null) {\n            Constructor<?> enclosingConstructor = innerClazz.getEnclosingConstructor();\n            System.out.println(enclosingConstructor);\n        }\n    }\n}\n```\n- 객체 생성하기\n```java\nClass<?> clazz = SomeClass.class;\nConstructor<?> constructor = clazz.getDeclaredConstructor(String.class);\nconstructor.setAccessible(true);\nSomeClass instance = (SomeClass) constructor.newInstance(\"parameterValue\");\n```\n\n## 어노테이션 유무\n\n### 어노테이션이 있는가?\n\n- `isAnnotationPresent`  \n클래스에 어노테이션이 존재하는지 확인해주는 메서드이다.  \n\n```java\npublic class AnnotationChecker {\n    public static void main(String[] args) {\n        Class<MyClass> clazz = MyClass.class;\n\n        if (clazz.isAnnotationPresent(MyAnnotation.class)) {\n            System.out.println(\"MyAnnotation is present on MyClass.\");\n        } else {\n            System.out.println(\"MyAnnotation is not present on MyClass.\");\n        }\n    }\n}\n```\n\n만약 객체의 클래스에 어노테이션이 붙어있는지 확인하려면 `getClass().isAnnotationPresent()` 를 해주면 된다.  \n\n## 참고\n\n- GPT 와 대화하기"},{"excerpt":"SPOF nginx 언제 문제가 발생할 수 있을까? 하드웨어 장애가 발생하는 경우 WAS, WS 가 모두 다운된다. 어떻게 해결할 수 있을까? 서버 분리 => nginx와 WAS 를 별개의 서버로 분리한다. 해당 해결책으로 어떤 문제가 생길 수 있을까? 서버를 분리하더라도 SPOF 가 될 가능성이 존재한다 => nginx 서버도 이중화를 진행한다. WAS…","fields":{"slug":"/level4-architecture-shook/"},"frontmatter":{"date":"2023년 09월 12일 12:09","title":"인프라 개선하기","tags":["레벨4","우테코"]},"rawMarkdownBody":"\n## SPOF\n\n### nginx\n\n- 언제 문제가 발생할 수 있을까?\n\t- 하드웨어 장애가 발생하는 경우 WAS, WS 가 모두 다운된다.\n- 어떻게 해결할 수 있을까?\n\t- 서버 분리 => nginx와 WAS 를 별개의 서버로 분리한다.\n- 해당 해결책으로 어떤 문제가 생길 수 있을까?\n\t- 서버를 분리하더라도 SPOF 가 될 가능성이 존재한다 => nginx 서버도 이중화를 진행한다.\n\n### WAS\n\n- 언제 문제가 발생할 수 있을까?\n\t- 디스크 용량 초과\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- 서버를 추가하고, 로드 밸런싱을 도입한다. standby 서버에서는 health check 를 통해 다른 서버에 장애가 발생하면 standby 서버에서 요청을 받도록 설정한다.\n\t- \n- 해당 해결책으로 어떤 문제가 생길 수 있을까?\n\t- 동시성 이슈가 발생할 수 있다.\n\n### DBMS\n\n- \n\n### AWS AZ\n\n- prod 서버와 prod DB 서버 AWS 리전 동일하게 세팅하기\n\n### 고민한 부분\n\n1. 특별히 고려해야 할 중요 기능\n- 서비스 특성 상 데이터 조회가 자주 발생한다.\n- 한 페이지 내에서 여러 번 요청을 보내는 경우가 많아 초당 요청 수가 많아질 수 있다.\n\n2. 문제가 될 수 있는 부분\n- DB: 하드웨어 장애 시 DB 장애 시간이 서버 장애 시간이 된다.\n- WS-nginx: 요청이 WAS로 포워딩되지 않는다.\n- 서버: 초당 요청이 많아지면 병목 현상 발생, Connection timeout이 빈번하게 발생할 수 있다.\n- runner: 메모리 사용량이 증가하며 리소스가 부족하게 되면 runner 실행 자체가 WAS 에 영향을 줄 수 있다.\n\n3. 적용할 수 있는 방법\n\n- WS, WAS와 분리\n- runner 서버 WAS 와 분리\n- WS, WAS, runner 서버 이중화\n- DB Replication\n\t- Master, Slave 로 이중화\n\t- Backup DB\n- 로드밸런서로 서버 부하 분산\n- 장애 발생한 서버 발생 시 로드밸런서가 다른 WAS 로 요청 전송\n- Master DB 장애 발생 시, slave DB 가 Master 로 승격. \n\n4. 발생할 수 있을 것으로 예상되는 문제\n\n- 로드밸런서가 SPOF 가 될 수 있다.\n- DB 이중화 시 동기화 문제\n\n5. 4번 해결할 아이디어\n\n- 로드밸런서 다중화"},{"excerpt":"Reflection 컴파일한 클래스를 동적으로 프로그래밍 가능하도록 자바에서 지원하는 기능. 리플렉션으로 가능한 작업? Junit 처럼  어노테이션을 표시한 메서드를 찾아서 실행 할 수 있다. 런타임 객체의 클래스, 필드, 메서드 정보를 알 수 있다. IDE 가 자동으로 getter, setter 를 생성할 수 있다. 자바 객체와 데이터베이스 테이블을 매…","fields":{"slug":"/level4-mvc/"},"frontmatter":{"date":"2023년 09월 12일 02:09","title":"레벨4 MVC 구현하기","tags":["레벨4","우테코","spring"]},"rawMarkdownBody":"\n## Reflection\n\n컴파일한 클래스를 동적으로 프로그래밍 가능하도록 자바에서 지원하는 기능.\n\n### 리플렉션으로 가능한 작업?\n\n- Junit 처럼 `@Test` 어노테이션을 표시한 메서드를 찾아서 실행 할 수 있다.\n- 런타임 객체의 클래스, 필드, 메서드 정보를 알 수 있다. \n- IDE 가 자동으로 getter, setter 를 생성할 수 있다.\n- 자바 객체와 데이터베이스 테이블을 매핑할 때 사용한다.\n\n## 웹 애플리케이션의 발전 과정\n\n### Servlet (1996)\n\n- Web Application Server, WAS\n\t- Servlet Container - Tomcat\n- WAS 를 효율적으로 다루기 위한 Java EE\n\t- Java Enterprise Edition, 기업 시스템 용 자바\n\t- 대규모 웹 애플리케이션 개발을 위한 표준\n\t\t- Servlet 을 사용하면 Thread 를 사용해서 좀 더 효율적으로 동작할 수 있게 된다.\n- Tomcat\n\t- Servlet 표준을 구현한 Servlet Container\n\t- 멀티 스레드 지원 및 관리\n\t- Http 요청 자체 처리\n\n#### 문제점\n\n디자이너들이 서블릿 소스 코드라서 수정을 못한다.  \n디자이너들이 작업하는 동안에는 그 부분을 처리 못하게 된다.  \n\n### JSP (1999)\n\n- JSP 0.92 spec 에서 JSP model1, JSP model 2 를 제안\n\t- JavaBeans: Reusable components\n\t- Java: Scripting language\n\t- Java Servlet: Compiled JavaServer Pages object\n\n### MVC (2000) \n\n- JavaWorld 에 Govind Seshadri 가 model 2를 MVC 아키텍처 패턴으로 공식화 제안\n- Apache Struts 프로젝트를 출시하며 model 2 패턴 구현 주장\n- 이후 여러 프레임워크에서 MVC 패턴을 도입했다고 주장\n\n### Framework (2003)\n\n- 대규모 웹 애플리케이션의 복잡함\n\t- Spring 은 초기 J2EE 사양의 복잡성에 대한 대응책으로 2003년에 탄생했다.\n- Spring Framework\n\t- Spring 은 기본적으로 POJO 를 사용하여 애플리케이션을 구축할 수 있도록 지원하는 기술\n- POJO\n\t- 이상적으로 말하자면, POJO 는 Java 언어 사양에 의해 강제되는 것 이외의 다른 제한에 구속되지 않는 Java 객체이다.\n\n### Non-blocking\n\n- Reactive\n\t- Non-blocking I/O\n\t- Functional\n- Node.js (2009)\n- Spring WebFlux (2020)\n\n## Servlet\n\n- 서블릿은 웹 서버 내에서 실행되는 작은 Java 프로그램이다. \n- 자바 공식 표준 기술\n\t- javax.servlet -> jakarta.servlet\n\n프레임워크를 사용하지 않아도 웹 서비스를 만들 수 있다!\n\n### 서블릿을 알아야 할까? 스프링만으로 충분하지 않을까?\n\nDispatcherServlet 도 Servlet 의 구현체이다.\n\n스프링이 잘 감싸고 있지만, Servlet 의 이해가 있어야 문제가 생겼을 때 잘 해결할 수 있다.\n\n### 서블릿 살펴보기\n\n- 라이프 사이클 메서드\n\t- init(), service(), destroy()\n\n#### 라이프 사이클이란?\n\n객체 세상에서 객체의 생성부터 처리, 종료되는 전체 사이클을 뜻한다.\n\n- servlet life-cycle method \n\t- 서블릿을 초기화하고 요청을 처리하고 종료될 때 처리할 작업을 정의하는 메서드 \n- 누가 라이프 사이클 메서드를 실행하는 걸까? \n\t- 서블릿 컨테이너 tomcat, jetty 등등\n\n## 서블릿과 서블릿 컨테이너\n\n1. 사용자 요청이 컨테이너에게 전달된다.\n2. 컨테이너는 response, request 를 생성한다.\n3. 요청에서 찾은 servlet 에게 service 메서드로 요청과 응답을 전달한다. 서블릿의 스레드가 요청을 처리한다.\n4. 요청 처리를 하고, response 를 만들어서 전달한다.\n5. 컨테이너가 응답을 사용자에게 전달한다.\n\n### 서블릿 하나로 다수 요청을 처리한다\n\n- 주의 사항\n\t- 서블릿은 서블릿 컨테이너에서 한 개만 존재한다\n\t- 하나의 서블릿에 여러 스레드가 service() 메서드를 공유한다.\n\t- service() 메서드가 멤버 변수나 static 변수를 변경하면 안 된다.\n\n"},{"excerpt":"LOG 드디어 홍보를 시작했다. 트위터에 첫 홍보했는데 ㄷㄱㄷㄱㄷ... 과연 어떻게 될 것인가...!! 기대하지는 말라했지만 그래도 기대하고 싶은 마음이다 🥹 https://twitter.com/2023shook/status/1701162561012646209?s=20 RT 이벤트 중이니 많관부 입니다 교통카드가 돌아오지를 않는다.. 돌아와 제발 다음 달…","fields":{"slug":"/2023-09-11/"},"frontmatter":{"date":"2023년 09월 11일 14:09","title":"2023년 09월 11일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 드디어 홍보를 시작했다. 트위터에 첫 홍보했는데 ㄷㄱㄷㄱㄷ... 과연 어떻게 될 것인가...!! 기대하지는 말라했지만 그래도 기대하고 싶은 마음이다 🥹 https://twitter.com/2023shook/status/1701162561012646209?s=20 RT 이벤트 중이니 많관부 입니다\n- 교통카드가 돌아오지를 않는다.. 돌아와 제발\n- 다음 달 쯤에 이사갑니다.\n\n## 배운 것\n\n- [[shook-like-issue]] 좀 더 보강했다. 다른 사람들에게 물어보고 다니려면 정리해 놓은 글이 필요할 것 같아서... 내일 마저 보강해보자.\n\n## 느낀 것\n\n- 서비스는 역시 다르구나... 회원 탈퇴했을 때 댓글이랑 좋아요를 삭제해야 하는데 그런 기능을 만들어야 하는 것 자체도 까먹었다. 그래도 더 일이 커지기 전에 오늘 발견해서 다행이다."},{"excerpt":"Thread Pool 프로그램 실행에 필요한 Thread 들을 미리 생성해놓다. Tomcat 3.2 이전에서는 요청이 들어올 때마다 Servlet 을 실행할 Thread 를 생성하고, 요청이 끝나면 destroy 했다. 이는 다음과 같은 문제가 발생하게 한다. 모든 요청에 대해 스레드 생성 / 소멸을 수행하는 것이 OS, JVM 에 큰 부담이 된다. 동시…","fields":{"slug":"/tomcat-thread-pool/"},"frontmatter":{"date":"2023년 09월 10일 06:09","title":"Tomcat Thread Pool","tags":["레벨4","우테코","tomcat"]},"rawMarkdownBody":"\n## Thread Pool\n\n프로그램 실행에 필요한 Thread 들을 미리 생성해놓다.  \nTomcat 3.2 이전에서는 요청이 들어올 때마다 Servlet 을 실행할 Thread 를 생성하고, 요청이 끝나면 destroy 했다. 이는 다음과 같은 문제가 발생하게 한다.  \n\n1. 모든 요청에 대해 스레드 생성 / 소멸을 수행하는 것이 OS, JVM 에 큰 부담이 된다.\n2. 동시에 일정 수준 이상의 다수 요청이 들어오는 경우 리소스 소모에 대한 억제가 어렵다. 순간적으로 서버가 다운되거나, 동시 요청을 처리하지 못해 발생하는 문제가 생길 수 있다.  \n\n### Thread?\n\n실행 중인 프로그램을 프로세스라고 하고, 프로세스의 실행단위가 스레드이다.  \n프로그램이 돌아가면서 여러 가지 작업들을 동시에 할 수 있다.  \n\nJava 는 One-to-One Threading-Model 로 Thread 를 생성한다.  \n\nUser Thread (Process의 스레드) 생성 시, OS Trhead (OS 레벨의 스레드) 와 연결해야 한다.  \n즉, 새로운 Thread 를 생성할 때마다 OS Kernel 의 작업이 필요해서 생성 비용이 많이 든다.  \n\n### One-to-One Threading Model 이란?\n\nJava 애플리케이션에서 스레드를 생성하면 운영체제에서도 해당 스레드에 대응하는 네이티브 스레드가 생성되는 것이다. Java 스레드가 실제 운영체제 스레드의 모든 기능을 활용할 수 있다 (ㄷㄷ)\n\n이런 특성 때문에 I/O 바운드 작업에서는 비효율적일 수 있다.\n\n#### 장점\n\n- 성능: Java 스레드가 네이티브 스레드에 직접 매핑되어 성능이 좋다.\n- 병렬처리: 현대의 멀티 코어 프로세서 환경에서 Java 스레드는 실제 CPU 코어를 활용하여 병렬 처리가 가능하다.  \n\n#### 단점\n\n- 자원 사용: 각 스레드마다 운영체제 자원이 필요하므로 과도한 스레드 생성은 성능 저하를 초래할 수 있다.  \n- 관리 비용: 너무 많은 스레드를 생성하면 스레드 간의 컨텍스트 스위칭 비용이 증가하고, 스레드 관리에 필요한 추가적인 오버헤드가 발생한다. \n\n### Thread Pool 이 왜 필요할까?\n\nThread 는 생성 비용이 커서 너무 많이 만들면 위험하다.  \n이를 해결하기 위해 pool 이 고안되었다. 미리 Thread 를 만들어 두어 재사용할 수 있게 한다.  \n\n또한 사용할 Thread 개수를 제한하여 무제한으로 스레드가 생성되지 않게 방지할 수 있다.  \n\n스프링 부트는 내장 서블릿 컨테이너 Tomcat 을 지원한다.  \n따라서 `application.yml` 을 변경해주어서 Tomcat 설정을 변경할 수 있다. \n\n### application.yml\n\n```yml\n# application.yml (적어놓은 값은 default)\nserver:\n  tomcat:\n    threads:\n      max: 200 # 생성할 수 있는 thread의 총 개수\n      min-spare: 10 # 항상 활성화 되어있는(idle) thread의 개수\n    max-connections: 8192 # 수립가능한 connection의 총 개수\n    accept-count: 100 # 작업 큐의 사이즈\n    connection-timeout: 20000 # timeout 판단 기준 시간, 20초 (기본 값 없음)\n  port: 8080 # 서버를 띄울 포트번호\n```\n\n- max-connections\n톰캣이 동시에 처리할 수 있는 Connection 의 최대 개수이다.  \nWeb 요청이 들어올 때, Tomcat 의 Connector 가 Connection 을 생성하면서 요청된 작업을 Thread Pool 의 Thread 에 연결한다.  \n해당 값이 크면 많은 수의 동시 사용자 요청을 처리할 수 있으나, 너무 큰 값은 서버 자원을 과도하게 사용하게 할 수 있어 서버의 전반적인 성능과 안정성에 영향을 줄 수 있다.  \n\n- accept-count (백로그라고 하기도 한다.)\nmax-connections 이상의 요청이 들어왔을 때 사용하는 대기열 Queue 의 크기이다.  \naccept-count 이상의 요청이 들어오면 추가적으로 들어오는 요청은 거절될 수 있다.  \n해당 값이 너무 크면 과도한 요청이 대기 상태로 유지될 수 있어 사용자가 시스템이 느려진 것처럼 느낄 수 있다. 값이 너무 작으면 초과된 요청들이 거부될 수 있다.  \naccept-count 를 통해 서버가 일시적인 트래픽 증가에 유연하게 대응할 수 있게 된다.  \n\n#### 왜 accept-count 가 상대적으로 작은 값을 갖게 될까?\n\n일반적으로 대기열이 너무 커지면 좋지 않다.  \n대기열이 너무 커지면 연결 요청이 길게 대기하게 되고, 사용자가 응답 지연을 경험하게 된다.  \n이는 시스템의 불안정성을 나타내며, 사용자에게 좋지 않은 경험을 제공한다.\n\n#### 디폴트 옵션\n\ntomcat 9.0 의 디폴트 옵션은 max-connections 200개, min-spare 25개이다. 스프링부트에서는 200개, 10 개를 디폴트 값으로 잡았다.\n\n**왜 Spring Boot 에서는 디폴트 값을 10개로 줄였을까?**\n\nGPT 에게 물어본 결과\n\n1. Spring Boot 는 제한적인 환경 (작은 크기의 클라우드 인스턴스, 개발자의 로컬 환경 등) 에서도 원활하게 동작할 수 있도록 보수적인 디폴트 환경을 제공할 수 있다.  \n2. 작은 환경에서는 너무 많은 동시 연결이나 대기 연결을 허용하면 메모리 부족 문제나 다른 리소스 부족 문제가 발생할 수 있다. 이런 문제의 발생 가능성을 줄이기 위해 낮췄을 것이다.\n\n## Thread Pool 의 Flow\n\n1. 첫 작업이 들어오면 core size 만큼의 스레드를 생성한다. \n2. 유저 요청이 들어올 때마다 작업 큐에 담아둔다. \n3. core size 의 스레드 중, 유휴상태(idle) 인 스레드가 있다면 작업 큐에서 작업을 꺼내서 스레드에 작업을 할당하여 처리한다. \n\t1. 유휴 상태인 스레드가 없다면 작업 큐에서 대기한다.\n\t2. 작업 큐가 꽉 찬다면 스레드를 새로 생성한다.\n\t3. 스레드 최대 사이즈에 도달하고 작업 큐도 꽉 차게 되면 추가 요청에 대해 connection-refused 오류를 반환한다.\n4. 태스크가 완료되면 스레드가 다시 유휴 상태로 돌아간다. \n\t1. 작업 큐가 비어있고, core size 이상의 스레드가 생성되어 있다면 스레드를 destroy 한다.\n\n## Executor\n\n`Executor` 인터페이스는 Runnable 객체를 받는 `execute` 메서드를 갖는다. \n\n```java\nExecutor executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -> System.out.println(\"Hello World\"));\n```\n\n## ExecutorService\n\n작업의 진행 상황을 제어하고 서비스 종료를 관리하는 많은 메서드가 포함되어 있다.  \n리턴된 `Future` 객체를 사용해서 실행을 제어할 수도 있다.  \n\n```java\nExecutorService executorService = Executors.newFixedThreadPool(10);\nFuture<String> future = executorService.submit(() -> \"Hello World\");\n// some operations\nString result = future.get();\n```\n\n실제로는 일반적으로 `future.get()` 을 바로 호출하지 않고, 실제로 계산 값이 필요할 때까지 호출을 미루는 것이 좋다.  \n\n`Runnable` 또는 `Callable` 을 받을 수 있다. 함수형 인터페이스나 람다로 전달 가능하다.  \n\n## ThreadPoolExecutor\n\n`corePoolSize` , `maximumPoolSize`, `keepAliveTime` 을 설정 매개변수로 갖는다.  \n\n`corePoolSize` 는 객체화 되어 스레드 풀에 유지될 코어 스레드의 수이다. 새 작업이 들어올 때 모든 코어 스레드가 사용 중이고, 작업 큐가 다 차면 poolSize 까지 `maximumPoolSize` 까지 커지는 것을 허용한다.  \n\n`keepAliveTime` 은 `corePoolSize` 를 초과해서 객체화된 초과된 스레드들이 idle 상태로 존재할 수 있는 시간 간격을 의미한다.  \n기본적으로 `ThreadPoolExecutor` 는 non-core 코어 스레드만을 삭제 대상으로 고려한다.  \n코어 스레드에도 같은 삭제 정책을 적용하려면 `allowCoreThreadTimeOut(true)` 메서드를 사용할 수 있다.  \n\n### newFixedThreadPool\n\n`corePoolSize` 와 `maximumPoolSize` 매개변수 값이 같고, `keepAliveTime` 이 0인 ThreadPoolExecutor 를 생성한다.  \n즉, 스레드 풀의 스레드 수는 항상 동일하다.  \n\n```java\nThreadPoolExecutor executor = \n  (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\n\nassertEquals(2, executor.getPoolSize());\nassertEquals(1, executor.getQueue().size());\n```\n\n### Executors.newCachedThreadPool()\n\n미리 구성된 다른 `ThreadPoolExecutor` 를 생성할 수 있다.  \n스레드 수를 입력 받지 않으며, 기본적으로 `corePoolSize` 를 0으로 설정하고 `maximumPoolSize` 를 `Integer.MAX_VALUE` 로 설정한다. `keepAliveTime` 은 60초이다.  \n\n```java\nThreadPoolExecutor executor = \n  (ThreadPoolExecutor) Executors.newCachedThreadPool();\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\nexecutor.submit(() -> {\n    Thread.sleep(1000);\n    return null;\n});\n\nassertEquals(3, executor.getPoolSize());\nassertEquals(0, executor.getQueue().size());\n```\n\n이는 스레드 풀이 작업 수를 수용하기 위해 무한대로 커질 수 있다. 그러나 스레드가 더 이상 필요하지 않은 경우 60초 이상 사용하지 않으면 폐기 된다.  \n일반적으로 애플리케이션에 수명이 짧은 작업이 많은 경우 사용한다.  \n\n내부적으로 `SynchronousQueue` 인스턴스가 사용된다.  \n삽입, 제거 작업이 항상 동시에 발생하므로 크기는 항상 0이다.  \n\n```java\nAtomicInteger counter = new AtomicInteger();\n\nExecutorService executor = Executors.newSingleThreadExecutor();\nexecutor.submit(() -> {\n    counter.set(1);\n});\nexecutor.submit(() -> {\n    counter.compareAndSet(1, 2);\n});\n```\n\n생성 후에는 immutable 하므로, `ThreadPoolExecutor` 로 캐스팅이 불가능하다.  \n\n## ScheduledThreadPoolExecutor\n\n`ThreadPoolExecutor` 를 상속받고, `ScheduledExecutorService` 를 implement 하며, 메서드가 추가된 인터페이스이다.    \n\n- `schedule` 메서드를 사용하면 지정된 딜레이 시간 후에 task 를 실행할 수 있다. \n- `scheduleAtFixedRate` 메서드는 첫 딜레이 시간 이후에 작업을 실행하고, 특정 기간동안 반복적으로 실행한다. `period` 매개변수는 작업들을 시작하는 사이 시간으로 측정되므로 실행률은 고정된다. \n- `scheduleWithFixedDelay` 메서드는 반복적으로 주어진 작업을 실행한다는  `scheduleAtFixedRate` 와 유사하지만, 딜레이 시간이 이전 작업이 끝나는 시간과 다음 작업이 시작된 사이 시간이라는 점에서 다르다. 주어진 작업의 길이만큼 실행률이 달라질 수 있다.  \n\n## ForkJoinPool\n\nJava 7에 도입된 fork, join 프레임워크의 핵심 부분이다. 이를 통해 재귀 알고리즘에서 여러 개의 작업을 생성하는 문제를 해결할 수 있다.   \n모든 작업이나 하위 작업을 실행하기 위해 자체 스레드가 필요하다. 즉, 간단한 `ThreadPoolExecutor` 를 사용하면 스레드가 빠르게 소진된다.  \n\nfork/join 프레임워크에서는 모든 작업이 여러 개의 하위 작업을 fork 하고 join 메서드를 사용하여 완료될 때까지 기다릴 수 있다.  \n\nfork/join 프레임워크의 장점은 각 작업이나 하위 작업에 대해 새 스레드를 만들지 않고, work-stealing 알고리즘을 수행한다는 것이다.  (이 부분은 자세하게 안 다루고 여기서 좀 더 자세히 볼 수 있다. https://www.baeldung.com/java-fork-join )\n\n```java\nstatic class TreeNode {\n\n    int value;\n\n    Set<TreeNode> children;\n\n    TreeNode(int value, TreeNode... children) {\n        this.value = value;\n        this.children = Sets.newHashSet(children);\n    }\n}\n\npublic static class CountingTask extends RecursiveTask<Integer> {\n\n    private final TreeNode node;\n\n    public CountingTask(TreeNode node) {\n        this.node = node;\n    }\n\n    @Override\n    protected Integer compute() {\n        return node.value + node.children.stream()\n          .map(childNode -> new CountingTask(childNode).fork())\n          .collect(Collectors.summingInt(ForkJoinTask::join));\n    }\n}\n```\n\n\n\n## 추가로 알아보면 좋은 키워드\n\n- 자바 소켓 프로그래밍\n- 스레드풀 전략\n- 적정 스레드 개수\n\n## 참고\n\n- https://velog.io/@sihyung92/how-does-springboot-handle-multiple-requests\n- https://velog.io/@mooh2jj/Tomcat-Thread-Pool-%EC%A0%95%EB%A6%AC\n- https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html -> 여기에서 tomcat 이라고 검색하면 tomcat 관련 설정이 나온다."},{"excerpt":"개요 학습 테스트를 하면서 개별 스레드를 일시 중지하면 if 절 조건이 true 가 되고 크기가 2가 된다는 게 무슨 말인지 이해가 안 돼서  에 있는 if 문에 중단점을 걸어봤다. 그런데 기존의 테스트를 70번 정도 실행했을 때는 성공하던 테스트가, 디버깅 포인트를 찍고 나니 갑자기 (거의) 100% 확률로 실패하기 시작했다. 즉, 유저가 2명이 추가되…","fields":{"slug":"/concurrency-test/"},"frontmatter":{"date":"2023년 09월 09일 08:09","title":"중단점이 있을 때 동시성 이슈가 더 잘 발생하는 이유는?","tags":null},"rawMarkdownBody":"\n## 개요\n\n```java\npackage thread.stage1;  \n  \nimport org.junit.jupiter.api.Test;  \n  \nimport static org.assertj.core.api.Assertions.assertThat;  \n  \n/**  \n * 스레드를 다룰 때 어떤 상황을 조심해야 할까?  \n * - 상태를 가진 한 객체를 여러 스레드에서 동시에 접근할 경우  \n * - static 변수를 가진 객체를 여러 스레드에서 동시에 접근할 경우  \n *  \n * 위 경우는 동기화(synchronization)를 적용시키거나 객체가 상태를 갖지 않도록 한다.  \n * 객체를 불변 객체로 만드는 방법도 있다.  \n * * 웹서버는 여러 사용자가 동시에 접속을 시도하기 때문에 동시성 이슈가 생길 수 있다.  \n * 어떤 사례가 있는지 아래 테스트 코드를 통해 알아보자.  \n */class ConcurrencyTest {  \n  \n    @Test  \n    void test() throws InterruptedException {  \n        final var userServlet = new UserServlet();  \n  \n        // 웹서버로 동시에 2명의 유저가 gugu라는 이름으로 가입을 시도했다.  \n        // UserServlet의 users에 이미 가입된 회원이 있으면 중복 가입할 수 없도록 코드를 작성했다.  \n        final var firstThread = new Thread(new HttpProcessor(new User(\"gugu\"), userServlet));  \n        final var secondThread = new Thread(new HttpProcessor(new User(\"gugu\"), userServlet));  \n  \n        // 스레드는 실행 순서가 정해져 있지 않다.  \n        // firstThread보다 늦게 시작한 secondThread가 먼저 실행될 수도 있다.  \n        firstThread.start();  \n        secondThread.start();  \n        secondThread.join(); // secondThread가 먼저 gugu로 가입했다.  \n        firstThread.join();  \n  \n        // 이미 gugu로 가입한 사용자가 있어서 UserServlet.join() 메서드의 if절 조건은 false가 되고 크기는 1이다.  \n        // 하지만 디버거로 개별 스레드를 일시 중지하면 if절 조건이 true가 되고 크기가 2가 된다. 왜 그럴까?  \n        assertThat(userServlet.getUsers()).hasSize(1);  \n    }  \n}\n```\n\n학습 테스트를 하면서 개별 스레드를 일시 중지하면 if 절 조건이 true 가 되고 크기가 2가 된다는 게 무슨 말인지 이해가 안 돼서 `UserServlet` 에 있는 if 문에 중단점을 걸어봤다.  \n\n```java\npackage thread.stage1;  \n  \nimport java.util.ArrayList;  \nimport java.util.List;  \n  \npublic class UserServlet {  \n  \n    private final List<User> users = new ArrayList<>();  \n  \n    public void service(final User user) {  \n        join(user);  \n    }  \n  \n    private void join(final User user) {  \n        if (!users.contains(user)) {    // 이 부분  \n            users.add(user);  \n        }  \n    }  \n    public int size() {  \n        return users.size();  \n    }  \n  \n    public List<User> getUsers() {  \n        return users;  \n    }  \n}\n```\n\n그런데 기존의 테스트를 70번 정도 실행했을 때는 성공하던 테스트가, 디버깅 포인트를 찍고 나니 갑자기 (거의) 100% 확률로 실패하기 시작했다.  \n\n즉, 유저가 2명이 추가되게 된 것이다. 왜 그럴까?\n\n## 이유\n\n중단점을 만나는 경우 실행중인 스레드는 일시 중지된다. 이는 스레드 스케줄링에 영향을 줄 수 있다.  \n\n1. 첫 번째 스레드가 중단점에 도달해서 일시 정지된다. \n2. 이 시점에서 두 번째 스레드는 여전히 실행 중일 수 있고, 일시 중지된 동안 자유롭게 실행된다. 즉, 유저가 추가되기 전 users 를 읽었기 때문에 비어있다고 판단했다. \n3. 이후 첫 번째 스레드를 다시 실행하면, 그 시점에는 이미 두 번째 스레드에 의해 user 가 리스트에 추가된 상태임에도 첫 번째 스레드가 조건을 만족하고 리스트에 똑같은 유저를 추가하게 된다.  \n\n이런 연유로 동시성 문제가 발생할 확률이 증가할 수 있다.  \n\n## 자바의 스레드 스케줄링\n\nJVM, 운영 체제에 의해 관리된다. JVM 은 대부분의 경우 호스트 OS 의 스레드 기능을 이용하여 자바 스레드를 구현한다. 즉, 실제 스레드 스케줄링은 대부분 OS 수준에서 이루어진다.  \n\n1. 우선순위  \n자바 스레드에는 우선순위가 있다. 높은 우선순위를 가진 \b스레드는 낮은 우선순위를 가진 스레드보다 스케줄링에서 우선적으로 고려될 가능성이 높다. 그러나 절대적으로 그런 것은 아니다.  \n\n2. 시간 할당\n일부 JVM 과 OS 에서는 시간 할당 방식을 사용하여 각 스레드에 동일한 CPU 시간을 할당하려고 한다. 이 방식은 각 스레드가 짧은 시간 동안 실행되고 다른 스레드로 전환되는 방식으로 작동한다. 이를 통해 여러 스레드가 거의 동시에 실행되는 것처럼 보이게 된다.  \n\n## 주의\n\n`@RepeatedTest` 를 할 때는 너무 큰 수로 실행하게 되면 컴퓨터의 실행 속도가 느려져서 오히려 Race Condition 을 만들기 어려울 수 있다. 따라서 적당히 큰 수로 설정하는 것이 중요하다.  \n"},{"excerpt":"생성자 mock  에서 다음과 같이 private 메서드로 세션을 생성한다. 이때 세션은 생성될 때 랜덤값을 생성하기 때문에 테스트하기 매우 곤란하다. 특히 UUID 가 겹칠 일은 사람이 걸어가다가 운석 맞을 확률이라고 한다 (ㅋㅋ) 이럴 때  를 사용한다. 이렇게 해주면 모든  이  로 1234 를 리턴하기 때문에 테스트할 수 있게 된다! try-wit…","fields":{"slug":"/mockito/"},"frontmatter":{"date":"2023년 09월 09일 05:09","title":"Mockito","tags":["test","테스트","Java"]},"rawMarkdownBody":"\n## 생성자 mock\n\n`LoginController` 에서 다음과 같이 private 메서드로 세션을 생성한다.\n\n```java\nprivate Session createSession(final User user) {  \n    final Session session = new Session();  \n    SessionManager.getInstance().add(session);  \n    session.setAttribute(\"user\", user);  \n    return session;  \n}\n```\n\n이때 세션은 생성될 때 랜덤값을 생성하기 때문에 테스트하기 매우 곤란하다.  \n특히 UUID 가 겹칠 일은 사람이 걸어가다가 운석 맞을 확률이라고 한다 (ㅋㅋ)\n\n```java\npublic Session() {  \n    this.id = UUID.randomUUID().toString();  \n}\n```\n\n이럴 때 `mockConstruct` 를 사용한다.  \n이렇게 해주면 모든 `Session` 이 `getId` 로 1234 를 리턴하기 때문에 테스트할 수 있게 된다!\n\n```java\nfinal LoginController loginController = new LoginController();  \ntry (final MockedConstruction<Session> sessionMockedConstruction = mockConstruction(Session.class,  \n    (mock, context) -> {  \n        when(mock.getId()).thenReturn(\"1234\");  \n    })  \n) {  \n    final ResponseEntity responseEntity = loginController.service(httpRequest);  \n  \n    // then  \n    assertThat(responseEntity.getHeaders()  \n            .containsHeaderNameAndValue(HttpHeaderName.SET_COOKIE, \"JSESSIONID=1234\")).isTrue();   \n}\n```\n\ntry-with-resources 를 사용하여 테스트가 끝나면 닫아준다.  \n\n### 생성자가 호출된 횟수 알아내기\n\n```java\nclass MyClass {\n    void myMethod() {\n        // do something\n    }\n}\n\n@Test\npublic void testMyMethodInvocation() {\n    try (MockedConstruction<MyClass> mocked = mockConstruction(MyClass.class)) {\n        MyClass instance1 = new MyClass();\n        MyClass instance2 = new MyClass();\n\n        instance1.myMethod();\n        instance2.myMethod();\n        instance2.myMethod();\n\n        // 첫 번째 생성된 객체의 myMethod 호출 횟수 확인\n        verify(mocked.constructed().get(0), times(1)).myMethod();\n\n        // 두 번째 생성된 객체의 myMethod 호출 횟수 확인\n        verify(mocked.constructed().get(1), times(2)).myMethod();\n    }\n}\n```\n\n`.constructed().get(x)` 로 x번째로 생성된 객체의 메서드 호출 횟수를 확인할 수 있다.\n\n**⚠️ 주의 !! 리플렉션으로 동적으로 생성된 객체는 카운팅 되지 않으니 유의하자.**\n\n## mockStatic\n\nstatic 메서드를 모킹하고 싶을 때가 있다.  \n나는 싱글톤 패턴을 사용했는데, 싱글톤의 경우 mocking 을 해주기 곤란하다.  \n`SessionManager.getInstance` 에서 내가 mock 해둔 `SessionManager` 를 리턴해주도록 변경해야 했다.  \n\n이럴 때 mockStatic 을 사용한다.\n\n```java\nfinal SessionManager sessionManager = mock(SessionManager.class);  \ndoNothing().when(sessionManager).validateSession(any());  \n  \ntry (final MockedStatic<SessionManager> mockSessionManger = mockStatic(SessionManager.class)) {  \n    mockSessionManger.when(SessionManager::getInstance)  \n        .thenReturn(sessionManager);  \n  \n    // when  \n    final boolean result = loginInterceptor.preHandle(loginHttpRequest, basicResponse);  \n  \n    // then  \n    assertAll(  \n        () -> assertThat(result).isFalse(),  \n        () -> assertThat(basicResponse.getHeaders().getHeaderValue(HttpHeaderName.LOCATION))  \n            .contains(\"/index.html\")  \n    );  \n}\n```\n\n클래스의 static 메서드가 어떤 값을 리턴할 지 지정해줄 수 있다.  \ntry-with-resources 로 테스트가 끝나면 닫아준다.\n\n## `verify()`\n\n```java\nverify(requestDispatcher, only()).forward(any(), any());\n```\n\n**모킹된 객체**에서 메서드가 몇 번 불렸는지 확인할 수 있다. \n(spy 도 가능하다.)\n\n`only()` 를 사용하면 단 한 번 호출되었다는 것을 확인할 수 있다.  \n`times()` 로 몇 번 호출했는지 체크할 수 있다."},{"excerpt":"LOG 감정 회고를 했다. 기본적으로 이번에는 회의와 관련된 이야기가 많이 나왔는데, 사실 기존에도 우리 회의 시간이 긴 편이었어서 나올 법한 주제라고 생각했다. 개인적으로 나도 컨디션이 괜찮은 날은 상관 없는데, 그렇지 않은 날에는 연속된 회의가 있을 때 힘들 때가 많았다. 감정 회고를 하면서 회의 시간을 구체화하고, 회의 전에 회의를 위한 회의 (일명…","fields":{"slug":"/2023-09-08/"},"frontmatter":{"date":"2023년 09월 08일 11:09","title":"2023년 09월 08일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 감정 회고를 했다. 기본적으로 이번에는 회의와 관련된 이야기가 많이 나왔는데, 사실 기존에도 우리 회의 시간이 긴 편이었어서 나올 법한 주제라고 생각했다. 개인적으로 나도 컨디션이 괜찮은 날은 상관 없는데, 그렇지 않은 날에는 연속된 회의가 있을 때 힘들 때가 많았다. 감정 회고를 하면서 회의 시간을 구체화하고, 회의 전에 회의를 위한 회의 (일명 회위회) 를 하면서 회의 목표를 정하고 회의하자는 의견에 모두 동의해서 앞으로는 그렇게 진행할 예정이다. 확실히 회의 목적과 결과, 시간을 리마인드하니까 시간도 절약되고, 쓸데 없는 말을 덜 하게 돼서 좋았다. 역시 우리 팀 피드백이 빨리 빨리 반영돼서 너무 좋다 짱이야 👍\n\n## 배운 것\n\n- [[level4-architecture|레벨4 강의]] 를 듣고 정리했다.\n\n## 느낀 것\n\n- 상대방이 오해하지 않게 내가 하고 싶은 말을 하는 것은 쉽지 않다. 나는 특히 (줄이려고 노력 중이지만) 불쑥 이상한 말이 나올 때도 있고, 아직 학습이 덜 돼서 그런지 상대방이 잠재적으로 상처받을 수도 있는 말을 할 때도 많다. 그렇게 말하면서 다른 사람들의 기분을 신경쓰지 않으면 편하겠지만 아무래도 난 그런 사람이 아니다. 최대한 다른 사람들을 내 기준에서는 신경 쓴다고 신경을 쓰고는 있지만, 사실 많이 어렵다. 노력 중이다. 가끔 그런 말을 하게 될 때 자책을 많이 하는 편이다. 자존감과 사회성을 등가 교환하는 느낌이다 ㅋㅋ 말을 예쁘게 하는 건 어려운 거구나. 그만큼 앞으로 노력이 많이 필요할 것 같다는 걸 느끼게 된 날이었다.\n- 친한 사람이 떠나는 건 언제나 슬프고 아쉬운 것 같다. 체인저 안녕 🥺"},{"excerpt":"무엇을 고려해야 하나 규모 확장성: 트래픽의 규모에 맞춰 확장할 수 있는지에 대한 관점 성능: 서비스의 성능이 고객의 기대 수준에 부합하는지에 대한 관점 가용성: 서비스가 의도한 목적을 달성하기 위해 정상적으로 작동하는 시간 측면의 관점 신뢰성: 정해진 성능 수준을 만족하면서 정확하게 동작하는지에 대한 관점 비용 가용성 고가용성 HA, High Avail…","fields":{"slug":"/level4-architecture/"},"frontmatter":{"date":"2023년 09월 08일 01:09","title":"Level 4 아키텍처 개선","tags":["레벨4","우테코"]},"rawMarkdownBody":"\n## 무엇을 고려해야 하나\n\n- 규모 확장성: 트래픽의 규모에 맞춰 확장할 수 있는지에 대한 관점\n- 성능: 서비스의 성능이 고객의 기대 수준에 부합하는지에 대한 관점\n- 가용성: 서비스가 의도한 목적을 달성하기 위해 정상적으로 작동하는 시간 측면의 관점\n- 신뢰성: 정해진 성능 수준을 만족하면서 정확하게 동작하는지에 대한 관점\n- 비용\n\n## 가용성\n\n### 고가용성\n\n- HA, High Availability : 정상적으로 작동하는 시간의 비율을 높이는 것\n- 9's availability: 9가 몇 개 들어가는지에 따라 다운되는 시간이 정해진다. (신기 ㄷㄷ)\n\n### SPOF\n\n단일 장애 지점. 이 지점에 문제가 생기면 전체 시스템이 문제가 생긴다.  \n\n## 사용할 수 있는 도구\n\n### 이중화 (다중화)\n\n시스템 일부에 어떤 장애가 발생했을 경우에 대비해서, 장애발생 다음에도 시스템 전체의 기능을 계속 유지하도록 예비 장치를 평상시부터 백업으로서 배치해 운용하는 일\n\n### 로드밸런서\n\n- 부하의 균형을 유지해주는 역할\n- 클라이언트로부터 들어오는 요청을 N개의 목적지로 분산시켜준다.\n- 추후 학습해보면 좋을 키워드\n\t- L4/L7 스위치\n\t- HAProxy\n\t- AWS ELB\n\n## MySQL 을 사용할 때 왜 Connection Pool 을 사용할까?\n\n- 커넥션 생성 비용이 커서요\n\n## WAS\n\n- 언제 문제가 있을 수 있을까?\n\t- OOM\n\t- 디스크 용량 초과\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- LB, 스위치를 사용한 이중화\n- 어떤 문제가 생길 수 있을까? 또는 무엇을 개발할 때 고려해야 할까?\n\t- 동시성 이슈\n\t\t- 스레드에 대한 동시성 고려에서 WAS 간의 동시성 고려로 확장된다.\n\t\t- 이런 문제가 발생할 수 있다. https://stackoverflow.com/questions/35534906/java-hashmap-getobject-infinite-loop\n\t\t- 분산락 (vs synchronized)\n\t\t\t- 서버 사이의 동시성에서는 synchronized 를 사용하는 것보다 서버 사이의 락을 가지도록 해야 한다.\n\t- 세션 정보를 어떻게 관리할 것인가?\n\t- 데이터 저장소 커넥션 제한\n\t- 모니터링 로그 확인이 어려워진다.\n\t- 베포는 어떻게 할 것인가?\n\t\t- 롤링 배포를 한다면,\n\t\t\t- 배포 중간에 장애 상황임을 알면 어떻게 하나?\n\t\t\t- 서버 대수가 많아지면 어떻게 할 것인가?\n\t- 프론트 리소스도 스프링에서 서빙한다면 다른 리소스가 제공될 수 있는 상황은 어떻게 할 것인가?\n\n## DBMS\n\n- 언제 문제가 될 수 있을까?\n\t- 시스템 부하가 커질 때\n\t- 디스크 용량 초과\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- 이중화\n\t- replication\n\t- 백업\n- 어떤 문제가 생길 수 있을까? 또는 무엇을 개발할 때 고려해야 할까?\n\t- 이중화 \n\t\t- 데이터 싱크는 어떻게 맞출까?\n\t- replication\n\t\t- writer DB 가 다운되면 어떻게 reader DB 를 writer DB 로 사용할 수 있을까?\n\t\t- replication 은 어떻게 이뤄지나?\n\t\t\t- sync vs async\n\t\t\t\t- \n\t\t\t\t- 비동기로 수행하면 쓰기 전에 읽기가 발생하면 읽을 수 없는 상태가 된다.\n\t\t\t- replication lag\n\t\t- failover 할 때 WAS 의 커넥션 풀에 있느 커넥션은 어떻게 될까\n\t- backup\n\t\t- backup 은 DB 서버에 부하가 없을까?\n\t\t- 계속해서 데이터가 변경되면 언제 데이터를 백업해야 할까?\n\n이중화 하면서 replication 하는 방법을 많이 사용한다고 한다.  \n\n이중화 하면 읽기도 두 번 보내야 하는가? -> MySQL 의 경우는 한 번만 보내면 된다 (왜?)\n## Jenkins\n\n- 언제 문제가 될 수 있을까?\n\t- 자원이 부족한 순간들\n\t- 하드웨어 장애\n- 어떻게 해결할 수 있을까?\n\t- master-agent 설정\n\t- master 이중화\n\t- 백업\n- 어떤 문제가 생길 수 있을까? 또는 무엇을 개발할 때 고려해야 할까?\n\t- master-agent 설정\n\t\t- master 가 다운되면 어떻게 하나?\n\t- master 이중화\n\t\t- 두 대의 jenkins 가 동일하게 관리될 수 있도록 어떻게 할 수 있을까?\n\n## AWS AZ\n\n- 언제 문제가 될 수 있을까?\n\t- 지진, 태풍 등으로 인한 데이터 센터 전체 이슈\n- 어떻게 해결할 수 있을까?\n\t- multi AZ\n- 어떤 문제가 생길 수 있을까? 또는 개발할 때 무엇을 고려해야 할까?\n\t- network latency\n\t- 비용\n\n## 스케일 업 vs 스케일 아웃\n\n### 스케일 인\n\n노드에 자원을 추가하여 시스템 처리량을 늘리는 방법. 컴퓨팅 자원을 좋게 하는 것\n\naka. 수직 스케일링\n\n### 스케일 아웃\n\n시스템에 노드를 추가하여 시스템의 처리량을 늘리는 방법. \n\naka. 수평 스케일링\n\n### 사용할 수 있는 도구\n\n구체적인 구현이나 사용법은 논외. 요구사항에 맞춰 동작하는 프로그램이라고 가정\n\n#### 서버 캐시\n\n- Map 과 유사하게 key-value 형태의 자료 구조를 가지고 있음\n- 메모리에 모든 데이터를 올려서 관리하며, 단일 key 조회에 대해 매우 빠른 성능을 보장한다.\n- WAS 에 올려서 사용할 수도 있고 별도의 캐시용 서버를 구축할 수도 있다.\n\n#### 검색엔진\n\n- 전문검색, 여러 조건의 검색을 포함하여 대부분의 검색에서 DBMS 보다 빠른 성능을 보장한다.\n- 집계, 통계 쿼리도 DBMS 보다 빠른 성능을 보장한다.\n\n#### 메시지 큐\n\n- 큐 형태의 자료 구조\n- 하나의 시스템에서 데이터 또는 메시지를 저장함녀 큐 형태의 자료 구조에 저장하며, 다른 시스템에서 그 값을 가져가서 처리할 수 있다.\n\n#### 프로세스 스케줄링\n\n- 원하는 시점에 프로그램을 실행하는 것\n\t- 인프라 아키텍처 다이어그램에는 특정한 역할을 하는 프로그램으로 표시한다.\n- 젠킨스 또는 크론탭, 스프링의 `@Scheduled` 어노테이션을 이용해서 실행하는 것으로 가정\n\n## 고민할 것\n\n- 과연 서비스가 성공할까? 성공하고 개선하면 안 되나?\n- 장애 발생으로 인한 손실과 투자한 비용을 고민해봤는가?\n- 모든 장애를 완벽하게 방어할 수 있나?\n\t- 예상할 수 있는 문제와 알 수 없는 문제 (방어하기 힘듦)\n\t- 장애가 발생했을 때 탓하지 않는 문화\n- 또 무엇을 할 수 있을까?\n\t- 재발 방지\n\t- 모니터링 고도화 및 빠른 복구\n\t- 모의 장애 훈련\n\n## 역정규화\n\n데이터의 개수가 많아지면 통계 쿼리를 작성하기 어렵다.  \n통계 테이블을 만들면 '읽기' 성능 측면에서 개선 가능하다.  \n대신 글을 작성할 때마다 count 를 증가시키는 추가 작업이 발생한다.  \n\n## 파티셔닝\n\n대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용할 수 있는 기능\n\n사용할 때는 하나의 테이블인 것처럼 사용하지만, 내부적으로는 N개의 테이블로 나눠서 관리  \n- 인덱스도 나눠서 관리한다.\n- 데이터가 적은 테이블의 변경이 더 쉽고, 조회가 빠르다.\n- 나눠진 테이블에는 중복으로 데이터를 넣지 않는다.\n\nMySQL 자체로 지원하는 기능이다.\n\n## 샤딩\n\n대용량의 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용하는 기능  \nN대의 DBMS에 분산해서 데이터를 관리한다.  \n\n## 무엇을 캐시할 것인가?\n\n- 데이터가 얼마나 자주 사용되는가?\n- 데이터가 얼마나 자주 갱신되는가?\n- 전체 데이터를 캐시할 것인가? 일부 데이터를 캐시할 것인가?\n\t- 지하철 노선 vs 쇼핑몰 상품\n- 캐시의 키는 무엇인가?\n- 데이터 구성을 위해 메타데이터를 캐시할까? 화면에 그려지는 데이터를 캐시할까?\n\n## 캐시를 사용할 때 문제될 수 있는 상황은?\n\n- 메모리가 무한한가?\n\t- cache eviction algorithm\n\t- TTL\n- 캐시의 데이터가 최신 데이터라는 것을 어떻게 보장할까?\n"},{"excerpt":"웹사이트 분석은 왜 필요한가? 사용자 지표를 추적하고 필요한 데이터를 수집하여 개선할 부분을 찾기 위해 사용한다. Google Analytics 무료이다. 사용자가 어디에서 유입되는지 알 수 있다. 어떤 검색어로 유입이 되었는지, 유료 광고를 클릭하는지 등 유입과 관련된 정보를 알려준다. 사용자가 서비스에 접속했을 때 세션을 추적하기 때문에, 어떤 페이지…","fields":{"slug":"/shook-site-analysis/"},"frontmatter":{"date":"2023년 09월 07일 13:09","title":"웹사이트 분석 툴 조사","tags":["shook"]},"rawMarkdownBody":"\n## 웹사이트 분석은 왜 필요한가?\n\n사용자 지표를 추적하고 필요한 데이터를 수집하여 개선할 부분을 찾기 위해 사용한다.  \n\n## Google Analytics\n\n무료이다.  \n\n사용자가 어디에서 유입되는지 알 수 있다. 어떤 검색어로 유입이 되었는지, 유료 광고를 클릭하는지 등 유입과 관련된 정보를 알려준다.  \n\n사용자가 서비스에 접속했을 때 세션을 추적하기 때문에, 어떤 페이지를 어떤 순서로 이동했는지, 어떤 위치에서 얼마나 오래 머물렀는지 알 수 있다.  \n\n그러나 개별 사용자가 해당 페이지에서 어떤 것을 하는지는 정확하게 알 수 없다.  \n\n### 장점\n\n1. 사용하기 쉽다. \n\n인증 코드를 넣기만 하면 바로 사용할 수 있다. \n\n### 단점\n\n1. 사용자 커스터마이징이 어렵다. \n2. 느리다. 데이터가 보고서로 필터링되는데까지 24시간의 지연 시간이 존재한다.\n3. 앱이나 SaaS 제품에는 적합하지 않다. 보통 웹사이트와 함께 작동하도록 설계되었다. (그러나 우리 서비스는 웹 서비스이기 때문에 단점은 아니다.)\n4. QA 프로세스만 제한적으로 제공하고 데이터의 품질관리 기능을 따로 제공하지 않는다. \n\n## Amplify\n\n프로덕트 관점에서 사용자 행동을 이해할 수 있게 제공해주는 이벤트 기반 분석 플랫폼이다. 사용자가 여러 페이지를 어떻게 이동하는지 추적하는 대신, '이벤트' 를 추적한다.  \n동영상을 재생하거나, 스크롤하는 등 행동을 추적하는 것이다.  \n\n월 1000만 이벤트까지 무료로 사용할 수 있다. \n\n### 장점\n\n1. schema 기능으로 수집한 이벤트, 이벤트 속성 및 속성 값을 잘 분류하고 설명하고 있다. 누구나 이벤트에 대한 분류 체계를 쉽게 이해할 수 있게 돕는다. 또한 의도치 않은 이벤트의 수집이나, 잘못된 형식의 데이터를 표시하거나 차단하여 수집된 데이터들에 대한 QA 프로세스를 자동화해준다.  \n2. 커스텀 뷰를 만들어 팀원들과 공유하는 것이 용이하다. 모든 팀원들이 같이 데이터를 편집할 수 있다. (이 부분은 우리 팀에서는 이점일지 의문)\n3. 쿼리 속도가 빠르다.\n\n### 단점\n\n1. 주로 모바일 분석을 위해 설계되어 웹 사용에 대한 세부 정보를 제공하지 않을 수 있다.\n2. 대부분의 기능이 pricing plan 에 포함되어 있다.\n\n## MixPanel\n\n> 제품의 사용자 경험을 개선하기 위해 데이터 기반 의사 결정에 의존하는 기업에 이상적이다. \n\n1달에 2.5만개의 데이터 포인트까지 무료로 사용 가능하다. Amplify 보다는 비교적 저렴하다. \n\n### 장점\n\n1. 데이터 시각화 기능이 좋다.\n2. A/B 테스트 기능을 지원한다.\n3. 대시보드를 자유자재로 만들 수 있다.\n4. 실시간으로 데이터를 수집한다. 유저 한 명, 한 명씩 어떤 행동을 했는지 구체적으로 확인할 수 있다. 유저들을 묶어 그룹 (코호트) 를 쉽게 만들 수 있다.\n5. 유저가 전후로 어떤 행동을 했는지 리포트 내에서 직관적인 확인이 가능하다. 또한 유저가 가장 많이 하는 행동을 기준으로 이벤트를 나열한 Top Path 방식으로 리포트를 원클릭으로 편하게 분석할 수 있다.\n\n### 단점\n\n1. Amplitude 에 비해 Mixpanel 의 인터페이스가 복잡하다는 사람들도 존재한다.\n\n### 서버에서 설정할 것\n\n- https://docs.mixpanel.com/docs/tracking/reference/java\n- https://medium.com/@marianfurdui/how-to-integrate-mixpanel-into-a-spring-boot-application-34e97c5ff039\n\n### 서버 사이드 vs 클라이언트 사이드\n\n> GPT 의 대답\n\n서버 사이드와 클라이언트 사이드 추적 간에는 각각의 장점과 단점이 있습니다. 어떤 측면에서 추적을 결정할지는 여러 요인을 고려해야 합니다:\n\n1. 데이터의 정확성:\n    \n    - 서버 사이드: 서버에서 이벤트를 전송하면 클라이언트의 문제점(브라우저 문제, 네트워크 문제 등)으로 인한 데이터 손실의 위험이 덜합니다.\n    - 클라이언트 사이드: 사용자의 실제 인터랙션(예: 페이지 뷰, 버튼 클릭)을 캡처하기에 가장 적합합니다. 하지만 AdBlockers나 네트워크 문제로 인해 이벤트가 전송되지 않을 수 있습니다.\n2. 보안:\n    \n    - 서버 사이드 : 민감한 데이터나 내부 시스템에 대한 정보를 안전하게 보호할 수 있습니다. 또한, 서버에서 검증된 데이터만 외부로 전송되기 때문에 데이터 조작의 위험이 줄어듭니다.\n    - 클라이언트 사이드: JavaScript 코드는 브라우저에서 볼 수 있기 때문에 보안상 민감한 정보는 노출되어서는 안 됩니다.\n3. 복잡성:\n    \n    - 서버 사이드: 서버 애플리케이션의 코드를 변경해야 하며, 적절한 이벤트를 포착하고 전송하는 로직을 구현해야 합니다.\n    - 클라이언트 사이드: 특정 UI 요소나 사용자 인터랙션에 대한 이벤트를 쉽게 연결할 수 있습니다.\n4. 대상 이벤트의 종류:\n    \n    - 서버 사이드 주문 완료, 결제 성공, 계정 생성 등의 서버에서만 알 수 있는 이벤트나 결과를 추적하기에 적합합니다.\n    - 클라이언트 사이드: 사용자의 페이지뷰, 마우스 클릭, 스크롤 행동 등의 클라이언트에서 발생하는 인터랙션을 추적하기에 적합합니다.\n\n결론적으로, 필요한 추적 데이터와 그 목적, 그리고 각 방식의 장단점을 종합적으로 고려하여 결정해야 합니다. 대부분의 경우, 클라이언트 사이드와 서버 사이드 추적을 동시에 사용하여 보다 완전한 사용자 분석을 수행하는 것이 바람직합니다.\n\n둘 다 하는 게 바람직하다고 한다...ㅋㅋㅋ\n\n## 참고\n\n- https://maily.so/colli/posts/fb4b16a6\n- https://brunch.co.kr/@brian-jeon/14"},{"excerpt":"개요 우리 팀의 현재  는 문제가 많다. 정합성 문제와 함께 중복 데이터가 사용자에게 전달될 가능성도 존재한다. 현재는 어떻게 해결할 수 있을지 고민하는 시간을 갖고 있다. 너무 느린 API 응답 Locust 로 API 응답 측정 DB 가 느린걸까, 애플리케이션 처리 속도가 느린 걸까 어떻게 측정할 수 있을까 그래서 어떤 게 느릴까 현재 우리의 좋아요 정…","fields":{"slug":"/shook-like-concurrency-issue/"},"frontmatter":{"date":"2023년 09월 07일 06:09","title":"S-HOOK 동시성 문제 해결","tags":["shook","레벨4","우테코","개발","spring","미완성"]},"rawMarkdownBody":"\n## 개요\n\n우리 팀의 현재 `killing_part_like` 는 문제가 많다.  \n정합성 문제와 함께 중복 데이터가 사용자에게 전달될 가능성도 존재한다.  \n\n현재는 어떻게 해결할 수 있을지 고민하는 시간을 갖고 있다.\n\n## 너무 느린 API 응답\n\n### Locust 로 API 응답 측정\n\n## DB 가 느린걸까, 애플리케이션 처리 속도가 느린 걸까\n\n### 어떻게 측정할 수 있을까\n\n### 그래서 어떤 게 느릴까\n\n## 현재 우리의 좋아요 정책\n\n- 메인에서 좋아요 순으로 정렬된 데이터를 가져온다. 현재는 서버에서 특정 기간(1시간, 30분 등)으로 캐싱하지 않고 매번 실시간으로 정렬해서 조회한다.\n- 유저가 각 노래의 킬링파트에 좋아요를 누르면 메인의 좋아요 순위가 변경될 수 있다.\n- 각 노래의 킬링파트에 유저들의 좋아요한 개수, 내가 좋아요를 눌렀는지 여부가 표시된다.\n- 어떤 노래를 들어가서 스와이프를 했을 때, 앞 뒤로 좋아요 순으로 정렬된 데이터를 각각 10개씩 받아온다.\n\n### 발생할 수 있는 문제점\n\n1. **여러 유저가 어떤 노래의 킬링파트에 대해 동시에 좋아요를 눌렀을 때, 정합성 문제가 발생할 수 있다.** => 매우 시급\n\n2. 정합성 이슈를 고려하지 않는다고 했을 때 -> 유저가 좋아요를 눌렀을 때, DB의 킬링파트 좋아요가 추가되기 때문에 기존에 사용자가 메인에서 보았던 좋아요 순 노래 리스트가 변경될 수 있다. 즉, 기존에 들었던 노래가 스와이프 했을 때 다시 등장할 수도 있다.  => 꽤나 시급\n\n3. 좋아요 수를 실시간으로 반영하기 때문에 응답을 캐싱하는 것이 불가능하다.\n\n## 해결 방법\n\n### 기술적 관점\n\n- 좋아요 정합성 이슈의 해결 방법은 [[shook-like-issue]] 에서 확인 가능합니다.\n\n#### DB Replication 을 적용한다\n\n하나는 읽기 DB, 하나는 쓰기 DB 를 둔다.  \n\n- 장점\n\t- 좋아요 읽기 작업 성능을 높일 수 있다.\n- 단점\n\t- 일관성 있는 데이터를 얻기 어려울 수 있다.\n\n### 정책적 관점\n\n좋아요 정합성 문제가 해결되었다고 가정하고 정책을 제안한다.  \n\n#### 메인 리스트를 전날 좋아요 순으로 정렬한다\n\n매 요청마다 정렬하지 않고, 전날까지 집계된 좋아요 순으로 정렬한다.  \nDB 는 그대로 실시간 업데이트 하되, 전날까지 집계된 좋아요 순 정렬을 캐싱해서 서버 인메모리에 저장한다. \n\n- 장점\n\t- 데이터 자체는 실시간으로 처리된다. DB와의 정합성 처리는 신경쓰지 않아도 된다. \n- 단점\n\t- 이전에 들었던 노래가 나오는 문제는 해결할 수 없다.\n\t- 좋아요 순 정렬된 리스트의 크기는 고정되어야 한다.\n\n#### 해당 사용자의 좋아요 순 리스트를 고정한다\n\n사용자가 좋아요 순 리스트를 클릭해서 노래 듣기를 선택하는 순간, 해당 시점의 좋아요 리스트를 사용자 id 로 인메모리에 캐싱한다.   \n그 뒤로 요청을 받을 때마다 인메모리에 캐싱된 값을 가져와서 응답한다.  \n\n메인 화면에서의 킬링파트 좋아요 많은 순 차트는 옆에 (마지막 새로고침 N분 전) 이라고 표시되도록 한다.  \n만약 새로고침을 누르거나, 다시 메인에서 요청을 보내는 경우 캐싱된 값을 업데이트 한다.\n\n- 장점\n\t- 응답 결과를 캐싱하기 때문에 성능이 매우 빠르게 향상될 것으로 예상한다.\n\t- 이전에 들었던 노래가 나오는 문제가 해결된다.\n- 단점\n\t- 사용자가 좋아요를 누른 경우, 좋아요를 누른 정보도 캐싱되어야 하는데 이 처리가 좀 빡셀 거 같다.\n\t- 좋아요 순 리스트 개수가 고정되어야 한다.\n\t- 서버가 stateful 하다.\n\t- 사용자가 많아질수록 캐싱해야 하는 양이 늘어난다.\n\n### 좋아요 처리 버퍼링\n\n차트의 순위를 결정하는 데이터는 실시간으로 수집하지만, 순위 재정렬은 일정 시간 간격으로 이루어진다.  \n\n1. 좋아요 데이터는 실시간으로 수집한다. 메모리 같은 일시적인 저장 공간에 저장된다.  \n\t1. 킬링파트의 좋아요 수는 업데이트 하지 않는다.\n\t2. 유저의 좋아요는 `killing_part_like` 테이블에 저장한다.\n2. 일정 시간마다 버퍼에 저장된 데이터를 한 번에 업데이트한다.\n\t1. 킬링파트의 좋아요 수를 한 번에 DB로 업데이트한다.\n3. DB 가 업데이트 되었기 때문에 \n\n킬링파트에 좋아요 수를 표시하되, TOP 3 옆에 마지막 업데이트 시간 표시하기  \n\n### 해결 방법 고려하기\n\n[[shook-like-issue]]"},{"excerpt":"","fields":{"slug":"/shook-deadlock-test/"},"frontmatter":{"date":"2023년 09월 07일 04:09","title":"S-HOOK 좋아요 Deadlock 확인","tags":null},"rawMarkdownBody":"\n"},{"excerpt":"개요 Locust 는 성능 테스트를 위한 도구다. 자세한 내용은 shook-load-test 확인하기. 다른 블로그에서 Locust 가 잘 사용되지 않는 이유가 러닝 커브라고 해서 한 번 써봤다. 나는 기존에 파이썬을 사용한 적이 있기 때문에 추가로 파이썬에 대해 배울 부분은 없었다. Locust 설치 테스트 스크립트 작성 우리 서비스의 좋아요 순으로 정…","fields":{"slug":"/locust/"},"frontmatter":{"date":"2023년 09월 07일 03:09","title":"Locust 사용기","tags":["테스트","spring","shook","개발"]},"rawMarkdownBody":"\n## 개요\n\nLocust 는 성능 테스트를 위한 도구다. 자세한 내용은 [[shook-load-test]] 확인하기.\n\n다른 블로그에서 Locust 가 잘 사용되지 않는 이유가 러닝 커브라고 해서 한 번 써봤다.  \n나는 기존에 파이썬을 사용한 적이 있기 때문에 추가로 파이썬에 대해 배울 부분은 없었다.   \n\n## Locust 설치\n\n```shell\npip install locust\n```\n\n## 테스트 스크립트 작성\n\n```python\nimport json  \nfrom locust import HttpUser, task, between  \n  \n  \nclass Sample(HttpUser):  \n    wait_time = between(1, 2.5)  \n  \n    def on_start(self):  \n        print(\"start\")  \n  \n    def on_stop(self):  \n        print(\"stop\")  \n  \n    @task  \n    def get(self):  \n        self.client.get(\"/api/songs/high-liked\")\n```\n\n우리 서비스의 좋아요 순으로 정렬해서 조회하는 API 를 반복 호출하도록 했다.  \n스크립트를 실행하면 `localhost:8089` 로 접속해서 유저 수, 유저 생성 latency, 테스트할 서버 URL 을 입력할 수 있다.   \n\n## 테스트 실행하기\n\n> RPS 란 서버가 지원하는 초당 요청 수를 말한다. (Request Per Second)\n\n아래와 같이 입력하면 `localhost:8089` 로 접속이 가능하다.\n\n```shell\nlocust -f 스크립트파일이름\n```\n\n### 전체 조회 API\n\n![[locust-test-chart.png]]\n\n테스트를 수행하면 다음과 같은 화면이 보인다.  \n\n이상하게 평균적으로 잘 가져오다가 한 번씩 저렇게 지표가 튀는 부분이 있었는데, 이 부분은 좀 더 알아봐야겠다. \n\n단순한 GET 요청이라 그런지 실패율은 0%.. 다행이다.\n\n### 단순 swipe API 테스트\n\n![[locust-swipe-api-test-chart.png]]\n\n스와이프 요청을 위한 API 를 테스트 해봤다.  \n다행히 생각했던 것 만큼 오래 걸리지 않았다. 왠지 모르겠는데 자꾸 95th percentile 이 감소하는 데 왜일까 ㅋㅋ\n\n### 랜덤한 API 주소로 요청 보내기\n\n테스트 코드는 다음과 같다.  \n\n```python\nimport json  \nfrom locust import HttpUser, task, between  \nimport random  \n  \n  \nclass Sample(HttpUser):  \n    wait_time = between(1, 2.5)  \n  \n    def on_start(self):  \n        print(\"start\")  \n  \n    def on_stop(self):  \n        print(\"stop\")  \n  \n    @task  \n    def get(self):  \n        song_number = random.randint(1, 20)  \n        self.client.get(\"/api/songs/\" + str(song_number))\n```\n\n\n![[locust-random-swipe-api-test.png]]\n\n이전과는 다르게 유저 수가 800 명이 되었을 때 굉장히 편차가 큰 응답 시간을 보여줬다.  \nRPS 가 400 이상일 때부터 응답 시간이 안정적이지 않다는 것을 의미한다.  \n\n이 부분은 확실하게 최적화가 필요하다.  \n\n### 데이터 10000개로 증가 후 테스트\n\n![[locust-many-datas-test.png]]\n\n동시 접속 유저 100명까지 설정, 초마다 1명씩 증가하도록 설정\n\n데이터가 166배 증가할 때 시간은 5배 증가한다.  \n이게 어떤 의미를 갖는 거고 무슨 수치인지는 잘 모르겠다.  \n\n## 후기\n\n정말 간단한 코드와 단순한 실행으로 짧은 시간 안에 테스트를 수행할 수 있었다. (코드 치는 데 1분 정도 걸린 듯 ㄷㄷ)\n\n요청 통계, 실패, 예외를 CSV 파일로 다운로드할 수 있고, Report 도 다운로드할 수 있다는 점은 큰 장점이다. Report 가 기록으로 남을 수 있으니까 관리하기 더 쉬울 것이다.  \n\n스크립트 기반이라 다른 데스크탑에서도 실행할 수 있다는 것도 좋다.  \n스크립트만 전달하면 팀원들도 쉽게 실행할 수 있으니, 많은 테스트를 수행하기 용이하다.\n\n다만 제공하는 데이터가 조금 제한적이라는 느낌을 받았다.  \n좀 더 자세한 데이터를 원한다면 다른 툴을 사용하는 것이 좋을 듯하다."},{"excerpt":",  등 다양한 툴이 존재한다. 이번 프로젝트에서 사용할 성능 테스트 툴에 대해서 알아보자. 성능 테스트란? 특정 상황에서 시스템이 어느 수준의 퍼포먼스를 내는지 측정하기 위한 테스트 방식이다. 가상의 유저를 시뮬레이션하여 실제와 비슷한 환경을 만들고, 서버에 일정 규모의 부하를 주는 방식으로 테스트한다. 일반적으로 애플리케이션의 성능을 측정하고, 최적화…","fields":{"slug":"/shook-load-test/"},"frontmatter":{"date":"2023년 09월 07일 02:09","title":"성능 테스트 툴 비교","tags":["shook","spring","개발","테스트"]},"rawMarkdownBody":"\n`nGrinder` , `JMeter` 등 다양한 툴이 존재한다.   \n이번 프로젝트에서 사용할 성능 테스트 툴에 대해서 알아보자.  \n\n## 성능 테스트란?\n\n특정 상황에서 시스템이 어느 수준의 퍼포먼스를 내는지 측정하기 위한 테스트 방식이다.  \n가상의 유저를 시뮬레이션하여 실제와 비슷한 환경을 만들고, 서버에 일정 규모의 부하를 주는 방식으로 테스트한다.  \n\n일반적으로 애플리케이션의 성능을 측정하고, 최적화하기 위해 사용한다.  \n부하 테스트, 스트레스 테스트를 포함하는 포괄적인 의미이다.  \n\n## 부하 테스트란?\n\n동시 요청이나 시스템의 성능을 측정하고자 할 때 사용하는 테스트이다.  \n부하 테스트는 시스템이나 애플리케이션의 최대 용량을 결정하거나, 결과를 예측하거나, 다른 성능 관련한 정보를 얻기 위해 특정 부하와 요청을 시스템에 가하는 테스트이다.  \n\n스프링 웹 애플리케이션의 경우, 동시 사용자나 초당 요청 수 등 다양한 요청 시나리오에 대한 애플리케이션의 응답 시간, 처리 능력, 에러 발생 빈도 등을 측정할 수 있다.\n\n## JMeter\n\nApache 에서 만든 java 기반 오픈 소스로, 오래된 테스트 툴 중 하나이기 때문에 안정적이다. 웹 서비스, 데이터베이스, FTP, 메일 서버 등 다양한 프로토콜에 대한 테스팅을 지원한다.\n\n서버, 서버 그룹, 네트워크 또는 개체에 대한 과부하를 시뮬레이션하여 강도를 테스트하거나 다양한 부하 유형에서 전체 성능을 분석하는 데 사용할 수 있다.  \n\n`BeanShell`, `Jython`, `Groovy` 등을 이용하여 스크립트를 작성할 수 있다.  \n\nGUI 를 제공하고, 테스트 플랜을 직접 구성할 수 있다. \n \n### 장점\n\n- GUI, 이메일, DB, SSL 등 지원하는 기능과 플러그인이 많다.\n- 다양한 프로토콜을 지원한다.\n- 큰 사용자 커뮤니티, 많은 플러그인으로 확장성이 뛰어나다.\n- 여러 기계에서 테스트를 동시에 실행하여 대규모 부하 테스트를 실행할 수 있다. 단, 각 에이전트를 수동으로 설정해야 한다.\n\n### 단점\n\n- 모든 기능이 다 필요한 지 의문\n- 모니터링이 불편하다.\n- 스레드 기반이라 성능 제약이 있다. \n\n## nGrinder\n\n네이버에서 만든 오픈 소스이다.  \n스크립트 생성과 테스트, 모니터링 등 성능 지표에 대한 보고서를 Web UI 로 사용할 수 있다. 여러 테스트를 동시에 실행하고, 결과를 중앙에서 모니터링할 수 있다.  \n\nnGrinder 를 사용하기 위해 `Controller` , `Agent` , `Target Server` 가 별도의 서버로 구성되어야 한다.  \n한 서버에 모두 몰려있는 경우, 서버의 자원을 나눠서 사용해야 하고, 그만큼 Context Switching 이 발생하여 순수 성능을 끌어올릴 수 없다.\n\n`groovy` 스크립트로 테스트 시나리오를 작성할 수 있다.  \n\n### 용어\n\n- `Controller` : Web UI 를 제공하고 테스트를 구성할 수 있도록 하며, 테스트를 모니터링하거나 보고서를 시각화 해주는 역할\n- `Agent` : 부하를 발생시키는 역할로, Process 와 Thread 를 사용하여 vUser (가상 사용자) 를 생성한다. `Controller` 가 생성한 테스트 스크립트에 의해 `Target Server` 에 부하를 발생시킨다. 복수의 머신에 설치하여 `Controller` 의 신호에 따라 일시에 부하를 발생시킨다. \n- `Target Server` : 테스트하고자 하는 서버. 테스트 중 발생한 오류나 CPU, Memory 의 점유율 등을 확인하고 싶다면 nGrinder Monitor 를 설치할 수 있다. \n\n`Controller`, `Agent`, `Target Server` 는 모두 각각 구축하는 것이 좋다. 세 가지 요소들을 하나의 서버로 구동한다면, 서버가 성능 테스트만을 위해 자원을 사용할 수 없게 되기 때문에 정확한 수치를 산출해내기 어렵다.\n\n### 장점\n\n- 설치만 하면 사용하기 쉽다.\n- 예약, 모니터링, ramp up, 스크립트 기능을 지원한다.\n- docker 에서 사용할 수 있다.\n- 특정 목적 (대규모 웹 애플리케이션 테스팅) 을 위해 최적화된 도구이다.\n- 웹 UI 에서 에이전트를 쉽게 관리하고 분산 테스팅을 구성할 수 있다.\n- 예약을 통해 주기적인 테스트가 가능하다.\n- WAS 기반으로 동작하여 젠킨스, 소나큐브 대시보드 같이 개발자 각각의 계정을 가질 수 있고, 계정 별 부하 테스트 히스토리를 관리할 수 있다.\n\n### 단점\n\n- agent 와 controller 를 각자 실행해야 된다. \n- controller 가 tomcat 을 필요로 한다.\n- 스레드 기반이라 성능, 동시성 제한이 있다.\n- 커뮤니티가 활발하게 활성화되지 않아 한국어로 작성된 문서가 거의 없다.\n\n## Locust\n\nPython 기반의 부하 테스팅 도구이다. 사용자 정의 테스트 시나리오를 Python 코드로 작성하여 실행할 수 있다.  \n\n1. 총 요청에 대한 RPS 와 실패율 관련 정보\n2. 응답 시간과 95% percentile\n3. 투입된 유저 수\n\n등을 보여준다.\n\n### 장점\n\n- 테스트 시작, 중지, 모니터링 및 결과 보고를 위한 웹 사용자 인터페이스를 제공한다.\n- 여러 머신에서 테스트를 동시에 실행하여 대규모 부하 테스트를 수행할 수 있다. \n- 별도의 큰 설치나 설정 없이 간단하게 실행 가능하다.\n- 스크립트 기반으로 성능 테스트가 진행된다. 명시적인 코드로 테스트 시나리오를 확인할 수 있고, 시나리오 형상 관리도 용이하다.\n- Event Driven 방식으로 사용하기 때문에 적은 리소스로도 많은 트래픽을 생성할 수 있다.\n- 통계를 다운로드 받을 수 있다.\n\n### 단점\n\n- JMeter 같은 Java 기반 도구와 달리, Python 기반이기 때문에 스프링 애플리케이션과의 통합이 덜 하다고 할 수 있다. \n- 다양한 프로토콜에 대한 내장 지원이 부족할 수 있다.\n- 파이썬 러닝 커브가 존재한다.\n\n## Pinpoint\n\nJava 로 작성된 대규모 분산 시스템 용 APM 도구이다.  \n`Transaction` 의 추적을 제공하는 APM 중 하나이다.  \n\n## 결론\n\nnGrinder 를 사용하기 위해서는 `Agent` , `Controller` 가 각각 서버로 구성되어야 하기 때문에 서버가 2대 이상 필요하게 된다. 로컬에서 `Agent` 를 실행하게 된다면 JMeter 와 차이점이 없어진다.  \n\nJMeter 는 2023년 7월에도 Release 가 올라왔기 때문에, 꾸준하게 오픈소스 업데이트가 이루어진다고 할 수 있다.  \n\n## 참고\n\n- https://techblog.woowahan.com/2572/\n- https://hudi.blog/dallog-preparing-for-performance-test/\n- https://ellune.tistory.com/68"},{"excerpt":"LOG 알고리즘 1문제 풀었다. S-HOOK 개인정보 처리방침 만들고 노래 7개 킬링파트 등록했다. 배운 것 jpa-dynamic-update 내용을 보충했다. 느낀 것 홍보 전략 너무 어렵다... 😭","fields":{"slug":"/2023-09-06/"},"frontmatter":{"date":"2023년 09월 07일 00:09","title":"2023년 09월 06일","tags":null},"rawMarkdownBody":"## LOG\n\n- 알고리즘 1문제 풀었다.  \n- S-HOOK 개인정보 처리방침 만들고 노래 7개 킬링파트 등록했다.\n\n## 배운 것\n\n- [[jpa-dynamic-update]] 내용을 보충했다.\n\n## 느낀 것\n\n- 홍보 전략 너무 어렵다... 😭"},{"excerpt":"S-HOOK의 좋아요 기능? , ,  테이블이 존재합니다. 데이터베이스 조회 성능을 개선하기 위해  테이블에 집계 컬럼인  를 추가하게 되었습니다. 통계 정보를 계속 업데이트 하기 위해 좋아요가 눌릴 때마다  를 업데이트해주어야 합니다. 즉, 다음과 같은 프로세스로 진행됩니다.  가 특정  에 좋아요 요청  테이블에  id,  id 값을 갖는 row 가 …","fields":{"slug":"/shook-like-issue/"},"frontmatter":{"date":"2023년 09월 06일 05:09","title":"S-HOOK 좋아요 정합성 이슈","tags":["shook","레벨4","우테코"]},"rawMarkdownBody":"\n## S-HOOK의 좋아요 기능?\n\n`killing_part_like`, `killing_part`, `member` 테이블이 존재합니다.  \n\n데이터베이스 조회 성능을 개선하기 위해 `killing_part` 테이블에 집계 컬럼인 `like_count` 를 추가하게 되었습니다. 통계 정보를 계속 업데이트 하기 위해 좋아요가 눌릴 때마다 `like_count` 를 업데이트해주어야 합니다.  \n\n즉, 다음과 같은 프로세스로 진행됩니다.  \n\n1. `member` 가 특정 `killing_part` 에 좋아요 요청\n\t1. `killing_part_like` 테이블에 `killing_part` id, `member` id 값을 갖는 row 가 있는지 확인\n\t\t1. 있다 => `killing_part_like` 의 `is_deleted` 가 `true` 인 경우, `false` 로 변경. `false` 인 경우, 아무것도 수행하지 않음.\n\t\t2. 없다 => `killing_part_like` 테이블에 행 추가\n2. `member` 가 특정 `killing_part` 에 좋아요 취소 요청\n\t1. `killing_part_like` 테이블에 `killing_part` id, `member` id 값을 갖는 row 가 있는지 확인\n\t\t1. 있다 => `killing_part_like` 의 `is_deleted` 가 `false` 인 경우, `true` 로 변경. `true` 인 경우, 아무것도 수행하지 않음.\n\t\t2. 없다 => 아무것도 수행하지 않음.\n\n`KillingPart` 의 업데이트 과정은 JPA 의 더티 체킹을 통해 이루어집니다.  \n최대한 도메인을 이용해서 비즈니스 로직을 수행할 수 있다는 장점이 있지만, 이 부분에서 동시성 문제가 발생할 수 있습니다.  \n\n### 왜 동시성 문제가 발생할까?\n\n위와 같이 하나의 트랜잭션이 업데이트 쿼리를 실행하는 동안, 다른 트랜잭션이 레코드를 변경하게 된다면 다음과 같은 상황이 발생한다.\n\n![[jpa-dirty-checking-concurrency-issue.png]]\n\n사용자 A의 트랜잭션이 업데이트 되기 전에 사용자 B 의 트랜잭션에서 좋아요 수를 읽어오기 때문에 정합성 이슈가 발생할 수 있습니다.  \n\n## 동시성 이슈 해결 방법\n\n이 문제를 해결하기 위해 정말 다양한 방법을 생각해보았습니다.  \n\n### 비관적 락 사용하기\n\n킬링파트에 좋아요를 하는 메서드에 비관적 락을 거는 방법이 있습니다.  \n\n비관적 락이란 대부분의 트랜잭션이 서로 충돌이 날 것이라는 상황에서 데이터베이스에 락을 걸어 동시성을 제어하는 것입니다.  \n\n이렇게 되면 A 트랜잭션이 끝날 때까지 다른 트랜잭션들이 배타락, 공유락 모두 얻을 수 없습니다. 한 번에 하나의 트랜잭션만 락을 얻을 수 있기 때문에 데이터의 정합성 문제가 해결됩니다.  \n\n그러나 비관적 락을 사용하게 되면 대기 시간이 발생할 수 밖에 없습니다. \n\n현재 서비스에서 '킬링파트 좋아요' 는 굉장히 중요한 로직을 담당하고 있습니다. 노래가 좋아요 순으로 실시간으로 정렬되기 때문에, 좋아요의 실시간 성은 매우 중요합니다.  \n\n이런 상황에서 대기 시간이 발생하는 비관적 락은 상황에 맞지 않다고 볼 수 있습니다.  \n\n### 낙관적 락 `@Version` 사용하기\n\n낙관적 락이란 대부분의 트랜잭션이 충돌이 나지 않을 것이라는 가정 하에, 데이터베이스에 락을 걸지 않고 애플리케이션 단에서 엔티티 버전 관리를 통해 동시성을 제어하는 것입니다.  \n엔티티가 변경될 때마다 Version 이 하나씩 증가하게 됩니다. 엔티티를 수정할 때 조회한 시점의 버전과 수정 시점의 버전이 일치하지 않으면 예외가 발생합니다. 단순하게 예외를 무시하게 되면 좋아요를 누른 사용자 입장에서는 이해할 수 없는 동작이 되므로, 발생한 예외는 요청을 다시 보내 달라는 등 적절한 조치가 취해져야 합니다.  \n\n그러나 저희가 처한 상황은 낙관적 락에 적합하지 않습니다.  \n킬링파트의 좋아요가 서비스 내부에서 다양하게 사용되기 때문에, 좋아요 기능은 사용자들이 가장 많이 사용하게 될 것입니다. 이때, 동일한 킬링파트에 좋아요를 누르는 행동이 빈번하게 일어나지 않을 것이라는 가정은 하기 어렵습니다.  \n\n### 직접 update 쿼리 실행하기\n\n더티 체킹을 포기하고, DB가 직접 원자적 연산을 처리하는 것입니다.  \n도메인 값을 변경하지 않고, 서비스 레이어에서 직접 레포지토리의 메서드를 호출해주어야 하므로 모든 비즈니스 로직을 도메인에서 응집하기는 불가능해집니다.   \n\n그러나 객체지향을 철저하게 지키는 것보다 정합성이 더 중요하다면 사용하는 것이 좋습니다.  \n\n직접 update 쿼리를 JPQL 로 구현하여 실행하게 되면 DB 자체에서 걸어주는 배타락 덕분에 정합성 문제가 발생하지 않습니다!  \n\nJPQL 에서 update 를 실행하므로 `@Modifying` 을 사용하게 됩니다. 다음과 같은 속성들을 `true` 로 바꿔주는 것이 좋습니다.  \n- `clearAutomatically` : 기본값은 `false` 로 `true` 로 설정하면 쿼리 실행 후에 영속성 컨텍스트를 자동으로 clear 합니다.  \n- `flushAutomatically` : 기본값은 `false` 로 `true` 로 설정하면 쿼리 실행 전에 영속성 컨텍스트를 플러시합니다.   \n\n### 이벤트 기반 아키텍처 도입하기\n\n좋아요를 누를 때 바로 `like_count` 를 업데이트하지 않고, 이벤트를 생성하고 이벤트 핸들러에서 `like_count` 를 업데이트하는 것입니다.  \n\n이벤트 처리는 일련의 순서대로 처리될 수 있기 때문에, 이렇게 하면 여러 사용자가 동시에 좋아요를 누르더라도 이벤트 순서대로 처리됩니다. 따라서 정합성을 유지할 수 있습니다.  \n\n단, 이벤트는 순서대로 처리되어야 합니다. 만약 순서대로 처리되지 않는다면 다음과 같은 상황이 발생할 수 있습니다.  \n\n1. 사용자 A와 사용자 B가 거의 동시에 같은 `killing_part`에 좋아요를 누름.\n2. 시스템은 두 이벤트를 거의 동시에 인지하고, 현재 `like_count` 값을 읽어옴 (예: 5).\n3. 두 이벤트 모두 `like_count`에 1을 더해 업데이트하려 함.\n4. 결과적으로 `like_count`는 6이 되지만, 원래 의도한대로라면 7이 되어야 함.\n\n따라서 이벤트 순서를 보장하기 위한 방법 (카프카, 이벤트 소싱 등) 을 사용하는 것이 좋습니다. \n\n#### 참고\n\n나중에 공부를 위해..  \n- https://newwisdom.tistory.com/75\n\n### Redis 사용\n\n`killing_part` 의 `like_count` 를 업데이트하기 전에 분산락을 얻는 것입니다.  \n락을 가진 인스턴스만 `like_count` 를 업데이트 할 수 있습니다. \n\n그러나 Redis 를 사용하기 위한 러닝 커브가 존재하여, 선택하지는 않았습니다.\n\n## 결론\n\n다양한 방법을 고려해보았으나, 결론적으로 팀에서는 도메인 값을 변경하지 않고, DB 의 원자적 연산을 사용해서 집계 컬럼인 `like_count` 를 조작하는 것이 가장 낫다는 판단을 내렸습니다.  \nRedis 와 이벤트 기반 아키텍처를 도입하는 것은 러닝 커브가 크기 때문에 단기간에 수행할 수 없고, 비관적 락과 낙관적 락은 서비스에서 중요한 의미를 가지는 좋아요 도메인과 맞지 않기 때문입니다.\n약간의 객체지향적 설계를 희생하게 되지만 정합성과 트레이드 오프가 되었다고 생각할 수 있을 것 같습니다.\n\n## 참고\n\n- https://golf-dev.tistory.com/73\n- https://dev-alxndr.tistory.com/45\n- https://velog.io/@ohzzi/%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A0%95%ED%95%A9%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EA%B8%B0"},{"excerpt":"란? 실제 값이 변경된 컬럼으로만 update 쿼리를 만드는 기능이다. JPA 가 아닌 하이버네이트 기능이라고 한다. 변경된 컬럼을 찾는다. 변경되는 컬럼에 따라 쿼리가 변경된다. JDBC 와 JPA JDBC 에서는  클래스를 사용할 수 있다.  는 SQL 구문을 캐시하고, ?로 작성된 파라미터 부분만 변경하며 재사용한다. JPA 도 내부적으로는 JDBC…","fields":{"slug":"/jpa-dynamic-update/"},"frontmatter":{"date":"2023년 09월 06일 04:09","title":"JPA DynamicUpdate","tags":["jpa","spring"]},"rawMarkdownBody":"\n## `@DynamicUpdate` 란?\n\n실제 값이 변경된 컬럼으로만 update 쿼리를 만드는 기능이다.  \nJPA 가 아닌 하이버네이트 기능이라고 한다.  \n\n1. 변경된 컬럼을 찾는다.\n2. 변경되는 컬럼에 따라 쿼리가 변경된다. \n\n### JDBC 와 JPA\n\nJDBC 에서는 `PreparedStatement` 클래스를 사용할 수 있다. `PreparedStatement` 는 SQL 구문을 캐시하고, ?로 작성된 파라미터 부분만 변경하며 재사용한다.   \n\nJPA 도 내부적으로는 JDBC와 `PreparedStatement` 를 사용하게 되는데, 변경된 컬럼에 대해서만 update 쿼리를 날리면 SQL 캐시 히트율이 떨어지게 될 것이다.  \n\n또한 JPA 입장에서도 추가적인 연산이 필요하다. 모든 컬럼을 수정할 때는 엔티티 객체 변경만 추적하면 됐지만, 특정 컬럼의 변화를 감지하기 위해서는 필드 수준의 추적이 필요하게 된다.   \n\n## 쓰면 좋은 경우\n\n1. 컬럼이 많은 경우  \n많은 수의 컬럼이 있는데, 몇 개의 컬럼만 자주 업데이트 하는 경우에 사용하면 좋다. 많다는 말은 모호하기 때문에 기준을 확실하게 정해야 할 듯.\n\n2. 테이블에 인덱스가 많은 경우  \n인덱스가 걸려있는 컬럼은 변경이 발생하는 인덱스를 재정렬하게 되는데, 인덱스가 많으면 많을수록 update 쿼리에 영향을 주게 된다.  \n값이 변경되지 않았다면 굳이 update 하지 않는 것이 update 쿼리 성능에 도움을 줄 수 있다.\n\n3. 데이터베이스가 컬럼 락을 지원하는 경우  \nMySQL 은 컬럼 락을 지원하지 않는다. 컬럼 락을 지원하는 DBMS (yugabyte 같은 데이터베이스) 에서 사용하기 적절하다고 한다.\n\n4. `@Version` 을 사용하지 않는 Optimistic Locking 의 경우에 사용하라고 되어 있다.  \n\n## 참고\n\n- https://multifrontgarden.tistory.com/299\n- https://recordsoflife.tistory.com/1241"},{"excerpt":"LOG 알고리즘 3문제 풀었다. 리뷰 달고 리뷰 반영하느라 40분 밖에 투자 못했는데 MST를 구하는 코드가 그렇게 어렵지 않아서 그 사이 3문제나 풀었따! 근데 사실 다 이전 문제 코드를 재활용하는 느낌이라 사실상 한 문제를 푼 거나 다름없다...ㅋㅋ 병원에 갔다왔다. 가는 길에 갑자기 비가 와서 맞고 왔는데 다시 나왔더니 비가 엄청 많이 내렸다... …","fields":{"slug":"/2023-09-05/"},"frontmatter":{"date":"2023년 09월 05일 13:09","title":"2023년 09월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 3문제 풀었다. 리뷰 달고 리뷰 반영하느라 40분 밖에 투자 못했는데 MST를 구하는 코드가 그렇게 어렵지 않아서 그 사이 3문제나 풀었따! 근데 사실 다 이전 문제 코드를 재활용하는 느낌이라 사실상 한 문제를 푼 거나 다름없다...ㅋㅋ\n- 병원에 갔다왔다. 가는 길에 갑자기 비가 와서 맞고 왔는데 다시 나왔더니 비가 엄청 많이 내렸다... 근데 지하철에서 내렸더니 비가 안 온 것처럼 멀쩡하게 그쳐 있었다. 날씨도 이상하다 ㅋㅋ\n- 에밀 리뷰를 달아주고 우르가 리뷰해준 코멘트들을 반영했다. \n\n## 배운 것\n\n- [[minimum-spanning-tree]] 를 공부했다. 크루스칼 알고리즘은 신기한 알고리즘이다.\n\n## 느낀 것\n\n레벨 4는 절대적인 시간이 부족하다. 그래서 더더욱 어떤 것에 집중해야 하는지 명확하게 정해야 한다. 나는 올해 고도화된 프로젝트를 만들고, 알고리즘을 내가 원하는 수준까지 올리는 것이 목표이다.   \n물론 나는 욕심이 많아서 하고 싶은 건 정말 많다. 이번에 미션하면서 궁금했던 톰캣 내부 구조 뜯어보기, 네트워크 공부, OS 공부, 자바 내부 동작 공부, DB 공부 등 하고 싶은 건 진짜진짜 많고 뭐든 재밌게 공부할 자신 있다.   그렇지만 우테코라는 좋은 기회를 잡은 만큼 올해는 우테코에서'만' 할 수 있는 경험들에 집중하고 싶다. (알고리즘은 올해에 본격적으로 시작한 김에 꾸준하게 열심히 해보자는 목표긴 해서 논외)    \n\n톰캣 내부 구조는 우테코 끝나고 열심히 뜯어볼 수 있다. 네트워크도, OS도, 리마큐도, 자바 내부 동작도 지금 말고 12월에, 내년에 할 수 있는 일들이다. 그러나 S-HOOK 이라는 프로젝트, 그리고 온전한 우리 팀과 함께 할 수 있는 시간은 단 11월 말까지 뿐이다. 프로젝트 고도화도 팀원들과 같이 해야 다양한 의견도 나오고 재밌을 거다. 새로운 기능을 고민하면서 기획하는 거, 지금 말고 언제 또 해볼 수 있을까? 무엇보다 우리 서비스는 실 사용자가 생길 법한 서비스라고 생각하기 때문에 더 욕심이 난다. 우테코를 수료한 뒤에 프로젝트를 마저 운영해보고 싶은 팀원들이 남더라도, 각자의 사정으로 빠지는 팀원들이 있을 것이다. 온전한 우리 팀과 프로젝트 기능들을 더 고민하고, 필요한 기능들을 만들고, 성능을 개선하는 경험을 하고 싶다. 그게 내 레벨 4 목표다.    \n\n다른 사람들이 더 많은 것을 공부하고, 더 많은 것을 알아가고, 더 멋진 성장을 할 수도 있다. 나도 강한 사람이 아니라서 그럴 때마다 흔들릴지도 모른다. 하지만 기억하자. 모든 것을 다 하는 사람이 무조건 다 잘하는 것은 아니라는 걸. 모든 걸 지금 다 할 필요도 없다는 걸! 결국 난 어제의 나를 이겨낼 거다.\n\n나는 나를 잘 안다. 할 게 많으면 분명 지칠 거고, 내가 감당할 수 있는 것보다 훨씬 많은 공부량에 압도되어 오히려 무력해질 걸 잘 알고 있다.  \n그래서 억지로 참고 있다 ㅋㅋ 미래의 나에게도 할 일은 남겨 놔야지~ 올해 다 해버리면 재미없다\n"},{"excerpt":"Spanning Tree 그래프 내부의 모든 정점을 포함하는 트리 트리의 특수한 형태이기 때문에, 모든 정점들이 연결되어 있어야 하며 사이클을 포함해서는 안 된다. 즉, 그래프의 n 개의 정점을 n-1 개의 간선으로 연결해야 한다. MST Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리를 의미한다. 모든 정점들을 가장 적은 수의 …","fields":{"slug":"/minimum-spanning-tree/"},"frontmatter":{"date":"2023년 09월 05일 13:09","title":"최소 신장 트리 (MST)","tags":["algorithms"]},"rawMarkdownBody":"\n## Spanning Tree\n\n그래프 내부의 모든 정점을 포함하는 트리\n\n트리의 특수한 형태이기 때문에, 모든 정점들이 연결되어 있어야 하며 사이클을 포함해서는 안 된다.  \n즉, 그래프의 n 개의 정점을 n-1 개의 간선으로 연결해야 한다.\n\n## MST\n\nSpanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리를 의미한다.  \n모든 정점들을 가장 적은 수의 간선과 비용으로 연결한다.  \n\nSpanning Tree 의 조건을 충족하면서, 간선의 가중치 합이 최소여야 한다.   \n\n## 구현 방법\n\n### Kruskal Algorithm\n\n그리디하게 모든 정점을 최소 비용으로 연결하는 답을 찾는다.  \n이전 단계에서 만들어진 Spanning Tree 와는 상관 없이 무조건 최소 간선만을 선택한다.  \n\n#### 순서\n\n1. 그래프의 간선들을 가중치 오름차순으로 정렬한다.\n2. 정렬된 간선 리스트에서 간선을 선택한다.\n\t1. 가장 낮은 가중치를 먼저 선택한다.\n\t2. 사이클을 형성하는 간선을 제외하고, union 연산을 수행한다.\n\n#### 코드\n\n```python\ndef find(x):  \n    if parent[x] == x:  \n        return x  \n    parent[x] = find(parent[x])  \n    return parent[x]  \n  \n  \ndef union(x, y):  \n    x_parent = find(x)  \n    y_parent = find(y)  \n  \n    if x_parent == y_parent:  \n        return  \n    if rank[x_parent] < rank[y_parent]:  \n        parent[x_parent] = y_parent  \n    else:  \n        parent[y_parent] = x_parent  \n        if rank[x_parent] == rank[y_parent]:  \n            rank[x_parent] += 1  \n  \n  \ndef kruskal():  \n    global edges, weights, heap, n  \n    parent = [i for i in range(n + 1)]  \n    result = set()  \n    edges.sort()  \n  \n    for edge in edges:  \n        weight, a, b = edge  \n        if find(a) != find(b):  \n            union(a, b)  \n            result.add(a)  \n            result.add(b)  \n            weights += weight\n```\n\n## 참고\n- https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html\n- https://ssabi.tistory.com/60"},{"excerpt":"회의 개요 레벨 4가 되면서 프로젝트와 함께 병행해야 하는 것들이 엄청나게 많아졌습니다. 미션 + 개인 공부(취업) 등... 이전에 레벨 4에서 생각하는 우선순위를 팀원들끼리 공유했었습니다. 공통적으로 10시부터 6시까지는 미션과 프로젝트에 집중하겠다는 의견이 다수였습니다. 그러나 실제로는 미션에 집중하느라 프로젝트에 어느 정도 소홀했다고 생각합니다. 레…","fields":{"slug":"/shook-level4/"},"frontmatter":{"date":"2023년 09월 04일 12:09","title":"S-HOOK 레벨4 슬기롭게 헤쳐나가기","tags":["shook","레벨4","우테코"]},"rawMarkdownBody":"\n## 회의 개요\n\n레벨 4가 되면서 프로젝트와 함께 병행해야 하는 것들이 엄청나게 많아졌습니다.   \n미션 + 개인 공부(취업) 등...   \n\n이전에 레벨 4에서 생각하는 우선순위를 팀원들끼리 공유했었습니다.   \n공통적으로 10시부터 6시까지는 미션과 프로젝트에 집중하겠다는 의견이 다수였습니다.   \n\n그러나 실제로는 미션에 집중하느라 프로젝트에 어느 정도 소홀했다고 생각합니다.   \n레벨 4에 구현할 기능, 홍보 기획, 실 사용자 유치 계획 등 아직도 확실하게 정해진 것이 없고, 프로젝트 관련 회의는 한 번도 하지 못했습니다. (물론 내일 하긴 함)   \n\n따라서 **우테코에 있는 10시~6시에 미션과 프로젝트에 팀원 각각이 어느 정도의 비중을 둘 것인지에 대해 이야기할 것**을 제안합니다.   \n\n모든 팀원이 프로젝트에 무조건 집중해야 한다고 주장하는 이야기가 아닙니다.   \n팀원 각자의 상황은 모두 다르다는 것을 알고 있어요.   \n제출해야 하는 미션이 우선인 팀원, 개인 공부에 어느 정도의 비중(혹은 높게)을 두고 싶은 팀원, 프로젝트 기능 개발을 주로 진행하고 싶은 팀원도 있을 수 있죠.   \n\n그러니 각자의 우선순위에 맞게 프로젝트의 비중을 나누는 것에 대해 논의하는 건 어떨까요.   \n이런 제안을 하는 것은 굉장히 조심스럽지만, 개인적으로는 레벨4 프로젝트를 진행하기 위해서 필수적인 논의라고 생각합니다.   \n\n## 제안 전에 이야기 할 내용\n\n**프로젝트가 1순위가 아니어도 괜찮습니다. 다른 분들도 그렇게 생각하실거라 생각합니다 😊**\n\n레벨 4 를 쭉 이 방식대로 진행하겠다! 라는 마음가짐으로 **솔직하게** 대답해주세요 😁   \nHappy Case 는 잠시 제쳐두고, 현재 생각할 수 있는 Worst Case 만 생각하겠습니다.   \nWorst Case 일 때가 가장 확장성 있는 계획을 세울 수 있을 것 같거든요.  \n\n- 팀원들 각각이 미션 혹은 개인 공부 / 프로젝트에 어느 정도 비중을 두고 싶은지\n\t- 개인 공부는 미션을 위한 추가 공부도 포함합니다.\n\t- 미션과 프로젝트에 투자하는 시간은 우테코에 있는 시간을 기준으로 합니다. 즉, 우테코에 있는 8시간을 어떻게 나눠쓸 것인지 말해주시면 됩니다.\n\t- 레벨 4에 있을 미션 난이도는 첫 미션의 난이도로 가정합니다. (이후 미션이라고 해서 더 쉬울 것 같지는 않아 보입니다.)\n\t- 미션을 진행할 수 있는 기간도 첫 미션의 기간으로 가정합니다. (백엔드는 이번 미션 마감일이 너무 짧았으니 미션을 진행할 수 있는 시간이 4일이라고 가정합시다.)\n\n## 제안 혹은 의견\n\n결론적으로는 제안하는 것은 '미션 혹은 개인 공부' 와 '프로젝트' 비중에 따라 개발하는 기능을 나누는 것입니다.   \n\n미션이나 개인 공부에 좀 더 비중을 두고 싶은 팀원은 서비스의 유지 보수를 담당하고,   \n프로젝트에 비중을 두고 싶은 팀원은 실 사용자의 피드백에서 파생되는 새로운 기능을 개발하는 것으로 분리하는 것은 어떨까요?   \n\n제안이 받아들여진다면, 더 논의해보아야 하겠지만 개인적으로 구상해보았을 때 각각 다음과 같은 기능들을 담당하게 될 것 같습니다.   \n\n서비스의 유지/보수는 기존 론칭 페스티벌에서 제기된 버그 수정, 현재 서비스에서 크리티컬하게 문제가 되는 기능, 혹은 기존 기능에서 고도화해야 하는 부분을 맡을 수 있을 것 같습니다.    \n\n신규 기능 개발은 론칭 페스티벌에서 제안된 새로운 기능들, 실 사용자의 피드백에서 파생되는 신규 기능들을 기획 / 개발할 것 같습니다. 혹은 지금은 크리티컬하지 않은 추가 기능들을 개발/고도화할 수도 있을 것 같네요.   \n\n단 미션, 개인 공부 등에 비중을 두는 팀원들은 그만큼 프로젝트에 참여할 수 있는 시간적인 비율이 적기 때문에, 기획된 신규 기능의 가부를 결정하는 투표에서 일정 배수 (ex. 0.7, 0.8 등) 로 의견을 반영하는 것이 좋을 것 같습니다.   \n\n**!!!! 팀원의 의견을 배제하는 게 아니고, 기능 개발이 일부 팀원끼리만 이루어진다는 것도 아닙니다 !!!!**\n유지 보수 팀원들도 프로젝트 개발하는 S-HOOK 팀원입니다. 다만 프로젝트 비중을 어느 정도로 둘 지를 정하자는 것 뿐입니다.\n\n더 나은 의견 있다면 Discussion 댓글이나 회의 시간에 제안해주세요 ˙ᵕ˙\n\n## 예상 시간\n\n1시간 이내로 마무리 하시죠! (가능하다면...)\n\n## 이야기\n\n프로젝트: 회의 + 코드 치는 시간\n\n- 아코\n\t- 미션 6시간, 프로젝트 2시간 (회의만 가정)\n\t- 비중은 미션에 좀 더 높게\n- 우코\n\t- 프로젝트 2-6시 (4시간) 그 외는 미션 혹은 우테코 생활\n- 스플릿\n\t- 미션: 4시간, 프로젝트: 4시간\n- 코난\n\t- 미션: 2시간, 프로젝트: 6시간 (1시-2시부터 6시까지)\n\t- 일과 학습의 병행이 큰 주제. 학습이 주객전도되면 안 된다고 들었다. 학습할 때 포기할 부분, 가치판단이 존재한다.\n- 베로\n\t- 미션: 1시간, 프로젝트: 7시간\n- 도밥\n\t- 미션: 5시간, 프로젝트: 3시간\n\t- 이후에 프로젝트를 할 것도 같다.\n- 바론\n\t- 미션: 3시간, 프로젝트: 5시간\n\n## 제안\n\n- 아코\n\t- 팀 프로젝트는 7명이 모여서 하는 건 사실상 불가능하다고 생각한다. 기능 담당, 세분화는 유닛 단위로 진행되어야 할 것 같다. 다 같이 하는 것도 있지만, 유닛 단위로 처리하는 것이 좋아보인다. 프로세스가 비동기로 가야 될 거 같다.\n\n### 프로젝트 타임\n\n프로젝트 타임을 정해서 궁극적인 이유가 궁금하다.   \n모두의 참여율이 어느 정도 확보?  \n눈치 보일 일이 줄어든다.  \n\n- 이슈 단위로 일정 추정을 해서, 시간이 덜 걸리는 일을 분배하는 것은 어떤가  \n- 같은 스쿼드로 묶는다고 해도 프론트 / 백 의 속도가 달라질 수 있다.\n\t- 기능 구현할 때 백 + 프론트가 같이 하는 걸 스쿼드라고 한다.\n\n스프린트를 잡아서 일정 추정이 되면 그 때 투자할 수 있는 시간을 스프린트 회의 때 말해서 주 단위로 추정해보자. 고정이 아니라 스프린트마다 달라질 수 있다...  \n\n## 스프린트\n\n주 단위로 합시다 그럼  \n\n- 스프린트 일정\n\t- 9/6 스프린트 회의 ~ 9/13\n\n### 스프린트 회의\n\n2시 ~ 3시\n\n- 해야 할 일과 일정 확정\n- 이슈 단위 분배\n\t- 이번 주 일정 추정 공유\n"},{"excerpt":"LOG 기분이 다운된다............. 뭔가 힘이 안 나는 날인 거 같다. 오늘 하려고 했던 일들도 내일로 미뤘다. 근데 왜 기분이 별로인지 모르겠다. 피곤한가 알고리즘 1문제 풀었다. 오늘은 스트릭 15일 차 S-HOOK 이 모집해야 하는 가입자 100명 ㅎ 우리가 처음에 냈던 거에는 300명이었는데 100명이라 오히려 다행이라고 생각했다. (사…","fields":{"slug":"/2023-09-04/"},"frontmatter":{"date":"2023년 09월 04일 07:09","title":"2023년 09월 04일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 기분이 다운된다............. 뭔가 힘이 안 나는 날인 거 같다. 오늘 하려고 했던 일들도 내일로 미뤘다. 근데 왜 기분이 별로인지 모르겠다. 피곤한가\n- 알고리즘 1문제 풀었다. 오늘은 스트릭 15일 차\n- S-HOOK 이 모집해야 하는 가입자 100명 ㅎ 우리가 처음에 냈던 거에는 300명이었는데 100명이라 오히려 다행이라고 생각했다. (사실 1000명이면 어떡하지했다...)\n\n## 배운 것\n\n- [[algorithm-tips]] 분리 집합에서 사이클을 찾는 방법을 알아냈다.\n\n## 느낀 것\n\n- 평소보다 밥을 잘 먹고 있다. 특히 오늘은 진짜 잘 먹은 듯..\n- 죠왓서 진행시켜\n"},{"excerpt":"비트마스킹이란 이진 숫자를 이용해서 데이터의 집합을 표현하거나, 그 데이터에 특정 연산을 수행하는 기술이다. 비트를 사용하여 데이터의 존재, 상태를 나타내기 때문에 매우 효율적인 메모리 사용이 가능하다. 비트마스킹 연산 특정 비트 확인 n 번째 비트가 1인지 0인지 확인하기 위해 AND 연산을 사용한다. 특정 비트 켜기 (설정)\nOR 연산을 사용하여 n …","fields":{"slug":"/bit-masking/"},"frontmatter":{"date":"2023년 09월 01일 12:09","title":"비트마스킹","tags":["algorithms"]},"rawMarkdownBody":"\n## 비트마스킹이란\n\n이진 숫자를 이용해서 데이터의 집합을 표현하거나, 그 데이터에 특정 연산을 수행하는 기술이다.   \n비트를 사용하여 데이터의 존재, 상태를 나타내기 때문에 매우 효율적인 메모리 사용이 가능하다. \n\n## 비트마스킹 연산\n\n1. 특정 비트 확인   \n\tn 번째 비트가 1인지 0인지 확인하기 위해 AND 연산을 사용한다.\n\n```python\n(mask & (1 << n)) # n 번째 비트가 1이면 결과는 1, 0이면 0\n```\n\n2. 특정 비트 켜기 (설정)\n\tOR 연산을 사용하여 n 번째 비트를 1로 만든다.\n\n```python\nmask |= (1 << n)\n```\n\n3. 특정 비트 끄기 (초기화)\n\tAND, NOT 연산을 사용하여 n 번째 비트를 0으로 만든다.\n\n```python\nmask &= ~(1 << n)\n```\n\n4. 특정 비트 토글\n\tXOR 연산을 사용하여 n 번째 비트를 반전시킨다.\n\n```python\nmask ^= (1 << n)\n```\n"},{"excerpt":"비용이 최소가 되는 해밀턴 사이클을 찾는 문제이다. N <= 11 일 때 O(N!) 의 브루트포스 풀이가 가능하다.\nN <= 12 일 때 백트래킹 풀이가 가능하다.\nN <= 16 일 때 DP 와 BitMasking 을 사용하여 O(N^2 * 2^n) 풀이가 가능하다. 1, 2, 3, 4, 5 어느 정점에서 출발하든 최적의 순회 경로는 동일하므로, 한 정점…","fields":{"slug":"/tsp/"},"frontmatter":{"date":"2023년 09월 01일 12:09","title":"TSP 외판원 순회 문제","tags":["algorithms"]},"rawMarkdownBody":"\n비용이 최소가 되는 해밀턴 사이클을 찾는 문제이다.\n\nN <= 11 일 때 O(N!) 의 브루트포스 풀이가 가능하다.\nN <= 12 일 때 백트래킹 풀이가 가능하다.\nN <= 16 일 때 DP 와 BitMasking 을 사용하여 O(N^2 * 2^n) 풀이가 가능하다.\n\n1, 2, 3, 4, 5 어느 정점에서 출발하든 최적의 순회 경로는 동일하므로, 한 정점에서 시작하는 것만 고려해도 된다. \n\n## Brute-Force 풀이\n\n모든 가능한 경로의 조합을 구하고, 그 중에서 최단 경로를 찾는다.   \n가능한 경로의 조합은 N! 이므로, 시간 복잡도는 O(N!) 이다.   \n\n## DP + Bitmasking\n\nHeld-Karp 알고리즘에 기반한 풀이라고 한다.   \n[[bit-masking]]\n\n### 아이디어\n\n1. 각 도시의 부분 집합에 대한 최적의 경로를 계산하고 저장하기 위해 2차원 DP 테이블을 사용한다.\n2. 비트마스킹을 사용해서 각 도시의 부분 집합을 표현하고, 이를 DP 테이블의 인덱스로 사용한다.\n\n### 구현하기\n\n1. DP 테이블은 `[n][2^n]` 이다. (n 은 도시의 수)\n2. `dp[i][j]` 는 도시 i 를 마지막으로 방문하고, 비트마스크 j 로 표현된 도시들의 부분 집합을 방문한 최소 거리\n3. 모든 도시 부분집합을 순회하며 dp 테이블을 채운다.\n\n```python\n\n```"},{"excerpt":"LOG 드디어 플레 달성했다!!! 흑흑 1년만에 플레 등반 진짜 힘들었다... 골드1 에 1년 있었는데 플레라니 감회가 새롭네요... 그렇지만 아직도 갈길이 먼 것 같네요 그치만 기뻐 🥹 S-HOOK 에서 사용하는 기능은 허가 없이 사용해도 저작권 문제 없다고 한저협에서 말씀해주셔서 드디어 홍보 시작할 수 있따!!!!!! 이 부분 때문에 며칠을 고민했는지…","fields":{"slug":"/2023-09-01/"},"frontmatter":{"date":"2023년 09월 01일 03:09","title":"2023년 09월 01일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 드디어 플레 달성했다!!! 흑흑 1년만에 플레 등반 진짜 힘들었다... 골드1 에 1년 있었는데 플레라니 감회가 새롭네요... 그렇지만 아직도 갈길이 먼 것 같네요 그치만 기뻐 🥹\n- S-HOOK 에서 사용하는 기능은 허가 없이 사용해도 저작권 문제 없다고 한저협에서 말씀해주셔서 드디어 홍보 시작할 수 있따!!!!!! 이 부분 때문에 며칠을 고민했는지.. 드디어 저작권 논란에서 해방이다. \n- 오리랑 40분 정도 커피챗했다. 이전 기수 이야기도 듣고, 5기 이야기도 했는데 되게 재밌었다. 같은 우테코 사람들이랑은 말이 너무 잘 통하는 듯\n\n## 배운 것\n\n- [[bit-masking]], [[tsp]] 에 대해 공부했다.\n- 에스프레소에는 물이 들어간다.\n\n## 느낀 것\n\n- 뭐든 노력하면 되는 거였나? 내가 지금까지 꾸준한 노력을 해본적이 없다는 가설에 힘이 실리고 있다."},{"excerpt":"2023-09-01 2023-09-04 2023-09-05 2023-09-06 2023-09-08 2023-09-11 2023-09-15 2023-09-16 2023-09-17 2023-09-19 2023-09-20 2023-09-21 2023-09-24 2023-09-25 2023-09-26 2023-09-27","fields":{"slug":"/2023-09/"},"frontmatter":{"date":"2023년 09월 01일 03:09","title":"2023년 09월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-09-01]]\n- [[2023-09-04]]\n- [[2023-09-05]]\n- [[2023-09-06]]\n- [[2023-09-08]]\n- [[2023-09-11]]\n- [[2023-09-15]]\n- [[2023-09-16]]\n- [[2023-09-17]]\n- [[2023-09-19]]\n- [[2023-09-20]]\n- [[2023-09-21]]\n- [[2023-09-24]]\n- [[2023-09-25]]\n- [[2023-09-26]]\n- [[2023-09-27]]\n"},{"excerpt":"9/1 강의 더 깊이 파고들기 각종 도구들을 겨우 지금하는 작업을 완료하는 데 필요한 정도로만 배우고 있다. 그럴 땐 도구나 기술 분야, 각종 기법 같은 것을 깊이 파고드는 법을 배우자. 지금은 Spring 을 깊게 파볼 수 있는 기회다. 대성당을 짓는다고 했을 때 돌무더기를 쌓는 일을 단순하게 보는 것이 아니라, 대성당을 쌓기 위한 일이라고 생각하자. …","fields":{"slug":"/level4-tomcat/"},"frontmatter":{"date":"2023년 09월 01일 01:09","title":"레벨4 Tomcat 미션","tags":["레벨4","spring"]},"rawMarkdownBody":"\n# 9/1\n\n## 강의\n\n- 더 깊이 파고들기\n\t- 각종 도구들을 겨우 지금하는 작업을 완료하는 데 필요한 정도로만 배우고 있다.\n\t- 그럴 땐 도구나 기술 분야, 각종 기법 같은 것을 깊이 파고드는 법을 배우자. 지금은 Spring 을 깊게 파볼 수 있는 기회다. \n\t- 대성당을 짓는다고 했을 때 돌무더기를 쌓는 일을 단순하게 보는 것이 아니라, 대성당을 쌓기 위한 일이라고 생각하자. 개념을 쌓는 것이 지루하지만 그 과정이 가치있다는 것을 알아야 한다.\n\t- 개념의 근원을 따라가는 연습을 하라. 공식 문서가 잘 안 되어 있다면 디버깅을 해보거나, 역컴파일, 리버스 엔지니어링을 해보자.\n\n# 9/6\n\n## Cookie & Session\n\n### HTTP 는 Stateless 가 맞는가?\n\n무상태라면 클라이언트 식별은 어떻게 하는 걸까?  \n-> 쿠키를 통해 클라이언트가 상태를 저장하도록 한다.  \n\n### Cookie\n\n- 사용자를 식별하고 세션을 유지하는 웹 기술\n- 웹 서버는 사용자를 식별하기 위한 유일한 값을 할당한다. Set-Cookie 에 이름=값; 형태로 반환한다. \n- 브라우저는 쿠키 정보를 저장할 책임이 있다.  \n\n세션은 서버에서 값을 저장하고 id 를 발급한다.  \n클라이언트와 서버는 Cookie 를 통해 Session Id 를 주고 받는다.  \n\n## Thread\n\n코드는 JVM 에서 돌아가는데, JVM 내부의 process, main thread 에서 실행된다.  \n지금까지는 Single Thread 로 실행해온 것.  \n\n여러 작업을 한 번에 실행하고 싶을 때\n\n### 자바 프로그램의 메모리 구조\n\nJVM Spec, Java SE 20 기준\n\nRun-Time Data Areas \n- Method Area (static)\n\t- 런타임 상수 풀\n\t- 필드 및 메서드 데이터\n\t- 메서드 및 생성자 코드\n- Heap\n\t- 인스턴스\n\t- 배열\n- JVM Thread\n\n### Concurrency\n\n동시에 여러 작업을 처리할 때 Thread 를 사용한다. => 웹 서버\n\n`connector.start` 를 하면 thread 가 생성된다.\n\n### Thread-safe class\n\n- 상태 변수를 스레드 간에 공유하지 않는다.\n- 상태 변수를 변경할 수 없도록 만든다. -> 인스턴스 변수에 final 붙이는 이유\n- 상태 변수에 접근할 때는 언제나 동기화를 사용한다.\n- 캡슐화나 데이터 은닉은 안전한 클래스 작성에 도움이 된다. \n\n"},{"excerpt":"LOG 알고리즘 2문제 풀었다. 마지막 문제 재귀 풀이는 진짜 파이썬이라 억까당한 거다... C++ 이었으면 메모리 초과 안 났을 문제인데 파이썬이라 틀렸다. 스트릭 11일차 미쳤다 ㄷㄷ 올해 안에 500문제 달성은 할 수 있을 듯?? 오늘 내내 팀원들과 저작권 문제에 대해 이야기했다. 역시 쉽지 않다.. 우리끼리 말해봤자 뭐가 나올 거 같진 않아서 법률…","fields":{"slug":"/2023-08-31/"},"frontmatter":{"date":"2023년 08월 31일 14:08","title":"2023년 08월 31일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 2문제 풀었다. 마지막 문제 재귀 풀이는 진짜 파이썬이라 억까당한 거다... C++ 이었으면 메모리 초과 안 났을 문제인데 파이썬이라 틀렸다. 스트릭 11일차 미쳤다 ㄷㄷ 올해 안에 500문제 달성은 할 수 있을 듯??\n- 오늘 내내 팀원들과 저작권 문제에 대해 이야기했다. 역시 쉽지 않다.. 우리끼리 말해봤자 뭐가 나올 거 같진 않아서 법률 자문을 받기로 했다. 큰 문제는 안 될 것 같지만 혹시 모르는 우리의 불안을 해소하기 위한 비용으로 생각하면 나쁘지 않다.\n\n## 배운 것\n\n- pypy가 파이썬에 비해 속도는 빠르지만 메모리를 더 많이 사용한다고 한다.\n\n## 느낀 것\n\n- 요즘따라 사소한 오해로 발생하는 일이 많은 것 같다. 그렇고보니 스터디 카페에 적혀있는 말이 생각난다. '오늘따라 사는 게 힘들다면 역시 내가 귀여운 탓인가라고 생각하자'... 맞말인 듯 ㅋㅋ\n- 테코톡 준비 언제하지...\n"},{"excerpt":"요구사항 ‘사용자 유치 계획’은 여러분들의 서비스를 어떻게 홍보하고, 사용자를 끌어모을 예정인지 고민해 보신 후에, 해당 계획과 실행 결과를 공유해 주시면 됩니다. 일회성 이벤트 마케팅(쿠폰 등)이 아닌, 유지 가능한 계획을 세워주세요. 단순히 가입한 유저의 숫자가 중요한 것이 아닙니다. 실제 사용자의 경험과 피드백으로 이어지는 게 중요해요! 이전에 작성…","fields":{"slug":"/shook-user-inducement-plan/"},"frontmatter":{"date":"2023년 08월 31일 07:08","title":"실사용자 유치 계획","tags":["shook","레벨4"]},"rawMarkdownBody":"\n## 요구사항\n\n> ‘사용자 유치 계획’은 여러분들의 서비스를 어떻게 홍보하고, 사용자를 끌어모을 예정인지 고민해 보신 후에, 해당 계획과 실행 결과를 공유해 주시면 됩니다.  \n\n- 일회성 이벤트 마케팅(쿠폰 등)이 아닌, 유지 가능한 계획을 세워주세요.  \n- 단순히 가입한 유저의 숫자가 중요한 것이 아닙니다. 실제 사용자의 경험과 피드백으로 이어지는 게 중요해요!  \n- 이전에 작성한 서비스 소개 글을 다시 한번 돌아보며 우리의 핵심 사용자는 누구이며, 그들을 어떻게 만날 수 있을지 고민해 보는 것도 좋겠네요 :)\n\n## 정량적 수치\n\n서비스 가입자 100명\n\n## 언제\n\n- 기한: 23.09.22\n\n## 어디서\n\n- 신곡이 나온 그룹의 팬카페\n- 음악 커뮤니티\n- 트위터\n\t- 어떻게 공유할까\n- 위버스\n\t- 링크 업로드 가능\n\n## 어떻게\n\n### 총공 방식 -> 등록할 사용자 위주의 홍보\n\n#### 변경된 점\n\n- 모든 노래는 뮤비를 기준으로 한다.\n\n#### 그 전에 정해야 하는 것\n\n1. 어떤 아이돌을 타겟할 것인가\n\t1. 최근에 컴백한 아이돌\n\t2. 팬층이 두터운 아이돌\n2. 어떤 노래들을 넣을 것인가\n\t1. 노래 개수\n\t2. 노래 종류\n\t3. 신곡 포함 여부\n3. 얼마나 홍보해야 할까\n\t- 한 사이클은 2일 정도로\n4. 언제부터 홍보해야 할까\n\t- 22일 전까지 아무리 적어도 홍보를 1-cycle은 해야 한다\n5. 어떻게 홍보해야 할까\n\t- 홍보 문구\n\t\t- https://s-hook.com 에서 누구누구의 노래 중에서 가장 좋았던 킬링파트를 수집하고 있더라구요 🥰 저는 누구누구 노래 1:30~1:40 등록해봤습니다 ㅎㅎ 여러분도 한 번 해보세요!! 9월 8일까지 등록할 수 있다고 하네용\n\t- 홍보 위치\n\t\t- 트위터\n\t\t- 위버스\n\t- 홍보 주기\n\t\t- 인당 5개씩?\n\n#### 홍보를 위해 꼭!!!!!!! 필요한 기능들\n\n1. 노래 탐색을 위한 스와이프 가이드?\n\t- 처음 사용하는 사용자는 노래 탐색을 위해 스와이프를 해야 하는지 알 수 없음\n2. 등록 중인 노래 리스트를 5개 미만 캐러셀 => 교체가 필요할 것 같다\n\n#### 홍보를 위해 추가로 구현하면 좋을 선택 기능들\n\n- 각 킬링파트 모집 중인 노래마다 킬링파트 등록 리스트 필요할 듯 (지금까지 등록된 킬링파트들 + 킬링파트에 투표한 수)\n- 아티스트 카테고리 기능\n\t1. 등록을 위한 카테고리인가?\n\t2. 탐색을 위한 카테고리인가?\n- 등록 중인 노래 검색\n\n#### 고민해봐야 할 것들\n\n- 정해진 킬링파트 외에 다른 킬링파트를 투표하고 싶은 사람들은 어떻게 해야 할까\n\t- 일단 소비를 목적으로 할까\n\t- 의외로 새로운 파트를 등록하고 싶어하는 사람들이 많은 듯\n- 현재 모집하는 사용자는 우리 서비스의 무엇을 제공하기 위해 설정된 것인가\n\t- 이미 그 노래는 들었을 것이다. 자신이 아는 부분을 사람들에게 알려주는 ... 그 쪽으로 메리트 갖게 하자\n\t- 팬들이 등록한 노래가 데이터로 쌓이게 되지 않을까요\n- 사용자가 노래를 추가할 수 있도록 검색을 열어둘까?\n- 어느 정도로 정책을 손 댈 것인가\n- 사용자 피드백은 어떻게 받을까\n\t- 새로운 기능 추가는 사용자의 피드백을 기반으로 개선하는 것이 좋을 것 같다\n\n### 탐색할 사용자를 위한 홍보\n\n- BUV GROUND: https://ground.buv.co.kr/\n\t- 홍보 게시판 게시\n- HIPHOPPLAYA: https://hiphopplaya.com/g2/bbs/board.php?bo_table=freetalk\n\t- 자유 게시판\n\n## 사용자 유치 계획\n\n노래 추천이 가능하고, 좋아하는 노래 정보를 공유할 수 있는 커뮤니티에 홍보\n\n### 1. 에브리타임, 네이버 지식인, 오픈 채팅방 등 커뮤니티 홍보\n\n노래 추천 글이나 게시판, 채팅방 같은 커뮤니티에 서비스로 접근할 수 있는 링크를 공유한다. 멜론이나 특정 음원 사이트가 아닌 S-HOOK 서비스에서 노래를 들을 수 있는 url 을 공유하여 홍보할 예정이다.  \n\n### 2. 노래 추천 오픈 채팅방 운영\n\n현재 활성화 되어 있는 오픈 채팅방에서는 보통 유튜브 링크나 카카오 뮤직, 멜론 링크를 사용하는 경우가 많다. 그래서 S-HOOK 의 링크를 공유하여 홍보하기 어려운 오픈 채팅방들도 존재한다.  \n\n일시적이지 않고 지속적으로 S-HOOK 서비스를 중심으로 노래를 공유할 수 있는 창구를 만들기 위해 오픈 채팅방을 운영하여 서비스를 홍보할 예정이다.\n\n### 3. 서비스 홍보를 위한 트위터 계정 봇 운영\n\n인스타그램은 광고를 하지 않으면 일반 사용자의 알고리즘에 노출되기 어렵다. 또한 인스타그램 특성상, S-HOOK을 소개하는 계정이 활성화되기 어려운 부분이 있다.\n\n트위터는 K-POP 팬들뿐만 아니라 음악을 좋아하는 팬들이 많이 존재한다. 계정의 팔로워가 적더라도 게시글 공유가 활발한 트위터의 특성 상, 한 번만 노출이 되어도 더 많은 사용자들에게 노출될 가능성이 높다.\n\n멜론 탑 100 노래들을 제공할 예정이기 때문에, 멜론 차트 순위에 존재하는 노래 킬링파트를 빨리 들을 수 있다는 특징을 강조해서 홍보할 예정이다.\n\n## 지속적인 홍보를 위한 계획\n\n- 팀에서 운영하는 오픈 채팅방, SNS 계정을 사용하여 지속적으로 서비스를 사용자들에게 알린다.\n- 멜론 탑 100 노래를 주기적으로 업데이트하여 최신 인기 노래들의 킬링파트들을 통해 사용자가 노래를 빠르게 접할 수 있도록 한다.\n"},{"excerpt":"문제가 되는 부분 음원 저작권 필요 Youtube 영상 저작권 쟁점 Embed 링크를 공유하는 것이 저작권을 침해하는가? 무슨 저작권을 침해하는가? 음원 저작권? 영상 저작권? 판례에 대한 해석 판례 우리 홈페이지에서 구현된 형태 프레이밍 링크 게재된 링크를 클릭했을 때, 홈페이지 일부가 내 홈페이지 속 프레임 내에서 작동하도록 하는 방식이다. 임베디드 …","fields":{"slug":"/shook-copyright/"},"frontmatter":{"date":"2023년 08월 31일 03:08","title":"S-HOOK 저작권 관련 조사","tags":["shook","레벨4"]},"rawMarkdownBody":"\n## 문제가 되는 부분\n\n- 음원 저작권 필요\n- Youtube 영상 저작권\n\n## 쟁점\n\n### Embed 링크를 공유하는 것이 저작권을 침해하는가?\n\n- 무슨 저작권을 침해하는가?\n\t- 음원 저작권?\n\t- 영상 저작권?\n\n### 판례에 대한 해석\n\n[판례](https://casenote.kr/%EB%8C%80%EB%B2%95%EC%9B%90/2017%EB%8B%A4222757)\n\n## 우리 홈페이지에서 구현된 형태\n\n### 프레이밍 링크\n\n게재된 링크를 클릭했을 때, 홈페이지 일부가 내 홈페이지 속 프레임 내에서 작동하도록 하는 방식이다.\n\n### 임베디드 링크\n\n유튜브나 다른 웹사이트의 영상, 음악 등의 창작물을 내 홈페이지에서 바로 재생할 수 있게 하거나 자동으로 재생될 수 있도록 게재하는 방식\n\n### 주로 말하는 견해\n\n- 법원은 링크를 눌렀을 때 저작권이 있는 페이지로 이동하지 않고 바로 저작물을 볼 수 있는 프레이밍 링크나 임베디드 링크의 경우, 저작권 침해에 해당할 수 있다고 보고 있습니다. 방송사나 크리에이터의 허락을 받지 않고, 쇼핑몰에서 바로 영상이 재생되도록 했다면 김비바 사장님은 저작권을 침해한 것으로 볼 수 있습니다. 만약 직접 임베디드 링크를 하지 않았더라도, 불법으로 동영상이 재생되게 만든 사이트의 링크를 게재했다면 저작권 침해 방조죄가 성립될 수 있습니다. [자료](https://blog.tossbusiness.com/articles/legal2-5)\n- 불법 복제물이거나 저작권 침해물인 것을 알면서도 이런 불법 콘텐츠에 연결되는 링크를 게시하는 것 역시 저작권 침해의 방조범이 될 수 있다. (대법원 2021.9.9. 선고 2017 도 19025 전원합의체판결) [판결](https://casenote.kr/%EB%8C%80%EB%B2%95%EC%9B%90/2017%EB%8F%8419025)\n\n## 판례의 핵심 부분\n\n- 대법원 2017. 9. 7. 선고 2017다222757 판결 손해배상(기) & 서울고등법원 2017. 3. 30. 선고 2016나2087313 판결 손해배상(기) 각공2017상,247 상고     \n\n**판시사항**\n\n갑이 인터넷 사이트를 개설한 후 해외 동영상 공유 사이트에 저작권자인 을 방송사 등의 허락을 받지 않고 게시된 방송 프로그램에 대한 임베디드 링크(embedded link)를 게재하여 이용자들이 무료로 시청할 수 있도록 한 사안에서, 갑의 링크행위는 을 방송사 등의 전송권을 직접 침해하는 행위로는 보기 어려우나, 해외 동영상 공유 사이트 게시자의 공중송신권(전송권) 침해행위에 대한 방조에는 해당한다고 한 사례\n\n**판결**\n\n- 대법원 2021.9.9. 선고 2017 도 19025 전원합의체판결\n\n> (다) 저작권 침해물 링크 사이트에서 침해 게시물에 연결되는 링크를 제공하는 경우 등과 같이, 링크 행위자가 정범이 공중송신권을 침해한다는 사실을 충분히 인식하면서 그러한 침해 게시물 등에 연결되는 링크를 인터넷 사이트에 영리적ㆍ계속적으로 게시하는 등으로 공중의 구성원이 개별적으로 선택한 시간과 장소에서 침해 게시물에 쉽게 접근할 수 있도록 하는 정도의 링크 행위를 한 경우에는 침해 게시물을 공중의 이용에 제공하는 정범의 범죄를 용이하게 하므로 공중송신권 침해의 방조범이 성립한다. 이러한 링크 행위는 정범의 범죄행위가 종료되기 전 단계에서 침해 게시물을 공중의 이용에 제공하는 정범의 범죄 실현과 밀접한 관련이 있고 그 구성요건적 결과 발생의 기회를 현실적으로 증대함으로써 정범의 실행행위를 용이하게 하고 공중송신권이라는 법익의 침해를 강화ㆍ증대하였다고 평가할 수 있다. 링크 행위자에게 방조의 고의와 정범의 고의도 인정할 수 있다.\n\n-> 즉, 침해 게시물을 링크를 통해 제공하면서 공중송신권을 침해한다는 사실을 충분히 인식하고 있으면서도 지속적으로 게시를 유지하는 경우 공중송신권 침해의 방조범이 성립한다.\n\n결론적으로 서비스 내에서 공유하는 것은 침해 게시물이어야 한다.\n\n## 단어\n\n### 공중송신권\n\n저작물을 공중이 수신하거나 접근하게 할 목적으로 무선 또는 유선통신의 방법에 의해 송신하거나 이용에 제공할 수 있는 권리\n\n- 방송권\n\t- 공중송신 중 공중이 동시에 수신하게 할 목적으로 음/영상 또는 음과 영상등을 송신하는 권리를 말한다. 저작자, 저작자 또는 저작재산권자로부터 저작물을 방송할 권리를 양도받은 자 또는 이용허락을 받은 자는 저작물을 방송할 권리를 가진다.\n- 전송권\n- 디지털음성송신권\n\n## 법률 자문 자료 준비\n\n안녕하세요 기업산하 개발교육기관에서 교육받는 개발자들끼리 유튜브 영상을 이용한 서비스를 개발하고 있습니다. 개발 중인 서비스는 영리 목적이 아니며, 수익을 창출할 계획도 존재하지 않습니다. \n\n서비스 링크는 https://s-hook.com 입니다.\n\n저희 서비스에서 유튜브에 업로드된 영상들을 재생하고 있는데, 영상에서 재생되는 음악에 대한 저작권 관련 문제가 있을지 문의드립니다.\n\n현재 개발하고 있는 서비스의 기능 중, 저작권이 우려되는 기능은 서비스 내에서 사용하는 유튜브 영상의 음원 저작권 문제입니다.\n\n[사진]\n- 사용자가 특정 버튼 (유튜브와 관련되지 않은 서비스 자체 버튼) 을 눌러 유튜브 영상의 특정 부분을 5~15초 가량 재생할 수 있습니다. \n- 유튜브의 플레이어 재생 버튼을 눌러 전체 영상을 재생할 수 있습니다.\n- 영상은 사용자가 버튼을 클릭하기 전에는 자동 재생 되지 않습니다.\n\n이때, **유튜브 영상에서 나오는 음악을 저희가 추가적으로 저작권을 확보해야하는 것인지 궁금합니다.**  \n1. 원저작권자 혹은 원저작권자의 허락을 받은 채널에서 업로드한 공식 음악 영상을 저희 서비스에서 재생했을 때, 저작권적으로 문제가 되는 부분이 있는지\n2. 서비스 내에서 공식 영상이 아닌, 음원을 가지고 2차 가공한 (ex. 팬 가사 영상) 영상을 서비스에서 사용하는 경우 저작권적으로 문제 되는 부분이 있는지\n\nPS\n질문과 관련된 서비스의 기능과 배경 지식을 간략하게 전달드리겠습니다.\n\n유튜브에서 제공하는 Embeded Player (임베디드 링크) 를 사용해서 서비스 내에서 영상을 재생하고 있습니다. 즉, 서비스에서 사용하는 영상은 유튜브 영상이라는 것을 사용자가 알 수 있습니다. \n- Embeded Player 는 유튜브가 제공하는 약관에 따라 사용하고 있습니다. Embeded Player 와 관련된 자세한 내용은 [링크] 에서 확인하실 수 있습니다.\n\n## 결론\n\n한국저작권협회에서 우리가 사용하는 영상들에 대한 허가는 따로 받지 않아도 법에 저촉되지 않을 것 같다고 말씀해주셨다. 저작권료를 따로 낼 필요도 없다고 한다! 드디어 홍보를 할 수 있다 ^^"},{"excerpt":"그래프 floyd-warshall-algorithm bellman-ford-algorithm 이진 트리 순회 문제 후위 순회의 끝은 root 이다. 중위 순회와 후위 순회 입력 받아 전위 순회 구하기 분리 집합 사이클 찾기 x와 y 를 union 하려고 하는데, 이미 x와 y 의 부모가 같은 경우 사이클이 존재한다고 할 수 있다.","fields":{"slug":"/algorithm-tips/"},"frontmatter":{"date":"2023년 08월 30일 08:08","title":"알고리즘 Tips","tags":["algorithms"]},"rawMarkdownBody":"\n## 그래프\n\n- [[floyd-warshall-algorithm]]\n- [[bellman-ford-algorithm]]\n\n### 이진 트리 순회 문제\n\n- 후위 순회의 끝은 root 이다.\n- 중위 순회와 후위 순회 입력 받아 전위 순회 구하기\n\n```python\nimport sys\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef find_tree(in_start, in_end, post_start, post_end):\n    if in_start > in_end or post_start > post_end:\n        return\n    root = post_order[post_end]\n    print(root, end=' ')\n    root_index = in_order_index[root]\n    left_size = in_order_index[root] - in_start\n    find_tree(in_start, root_index - 1, post_start, post_start + left_size - 1)\n    find_tree(root_index + 1, in_end, post_start + left_size, post_end - 1)\n\n\nn = int(input())\nin_order = list(map(int, input().split()))\npost_order = list(map(int, input().split()))\nin_order_index = [0] * (n + 1)\nfor i in range(n):\n    in_order_index[in_order[i]] = i\nfind_tree(0, n - 1, 0, n - 1)\n```\n\n## 분리 집합\n\n- 사이클 찾기\n\t- x와 y 를 union 하려고 하는데, 이미 x와 y 의 부모가 같은 경우 사이클이 존재한다고 할 수 있다.\n\n```python\ndef is_cycle(x, y):\n\treturn find(x) == find(y)\n\nfor i in range(m):  \n\ta, b = map(int, input().split()) \n\tif is_cycle(a, b): \n\t\t# 사이클이 존재한다.\n```"},{"excerpt":"LOG 레벨 인터뷰가 있었다. CORS 를 준비를 많이 못해가서 그 부분 답변이 미흡했다. 그 외에는 답변을 잘 한 것 같은데, 좀 더 기술 쪽으로 딥한 질문이 나왔다면 좋았을 것 같다. 배운 것 cors 를 정리했다. 느낀 것","fields":{"slug":"/2023-08-30/"},"frontmatter":{"date":"2023년 08월 30일 04:08","title":"2023년 08월 30일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 레벨 인터뷰가 있었다. CORS 를 준비를 많이 못해가서 그 부분 답변이 미흡했다. 그 외에는 답변을 잘 한 것 같은데, 좀 더 기술 쪽으로 딥한 질문이 나왔다면 좋았을 것 같다.\n\n## 배운 것\n\n- [[cors]] 를 정리했다.\n\n## 느낀 것"},{"excerpt":"LOG 오늘 하려고 목표했던 일은 잘 끝냈는데, 시간 계산을 잘못한 탓인지 6시에 가야하는 약속에 1시간이나 늦어버렸다... 너무너무 미안하기도 하고 하필 비오는 날이라 버스랑 지하철도 밀려서 마음이 너무 안 좋았다. 그에 더해서 (오늘 시간이 많았음에도 불구하고) 레벨인터뷰 준비도 하나도 못하고, 알고리즘도 못 풀고, 질문도 많이 생각 못했다는 생각에 …","fields":{"slug":"/2023-08-29/"},"frontmatter":{"date":"2023년 08월 29일 13:08","title":"2023년 08월 29일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 오늘 하려고 목표했던 일은 잘 끝냈는데, 시간 계산을 잘못한 탓인지 6시에 가야하는 약속에 1시간이나 늦어버렸다... 너무너무 미안하기도 하고 하필 비오는 날이라 버스랑 지하철도 밀려서 마음이 너무 안 좋았다. 그에 더해서 (오늘 시간이 많았음에도 불구하고) 레벨인터뷰 준비도 하나도 못하고, 알고리즘도 못 풀고, 질문도 많이 생각 못했다는 생각에 심란했다. 그게 표정이랑 행동에 드러났는지 걱정도 시키고 😭 미안한 일밖에 생각이 안 나네요 오늘은\n- 머리도 아프다 이제 ㅠㅠㅠㅠ\n\n## 배운 것\n\n- [[level3-level-log]] 관련해서 공부했다. 깊게는 못함..\n\n## 느낀 것\n\n- 주변 사람 걱정시키지 말고 오해할 만한 행동들은 얼른 얼른 정정하자.\n- 오늘 감정 기복은 나도 이해가 안 되네.. something is wrong\n"},{"excerpt":"스플릿 리소스 서비스의 어떤 부분을 개발하시면서 서버가 비즈니스 로직의 리소스를 담당하는 것이 좋을 것 같다는 생각을 하셨나요? 협업 프로젝트를 하다보면 어쩔 수 없이 협업을 할 수 밖에 없는 상황이 생길텐데, 어떻게 리소스를 줄일 수 있을까요? 모니터링 서비스 모니터링에서는 어떤 지표를 모니터링해야 할까요? or 모니터링할 지표를 선택한 기준이 있을까요…","fields":{"slug":"/level3-level-log-questions/"},"frontmatter":{"date":"2023년 08월 29일 10:08","title":"레벨3 레벨인터뷰 질문 정리","tags":["레벨3","우테코"]},"rawMarkdownBody":"\n## 스플릿\n\n### 리소스\n- 서비스의 어떤 부분을 개발하시면서 서버가 비즈니스 로직의 리소스를 담당하는 것이 좋을 것 같다는 생각을 하셨나요?\n\n### 협업\n- 프로젝트를 하다보면 어쩔 수 없이 협업을 할 수 밖에 없는 상황이 생길텐데, 어떻게 리소스를 줄일 수 있을까요?\n\n### 모니터링\n- 서비스 모니터링에서는 어떤 지표를 모니터링해야 할까요?\n\t- or 모니터링할 지표를 선택한 기준이 있을까요?\n### 로깅\n- 로그를 남기기 위해 `println()` 을 사용하지 않고, logback 라이브러리를 사용하신 이유가 있을까요?\n\t- (println 은 I/O operation 이기 때문에 synchronized 가 붙어 있어 상당한 성능 저하가 발생할 수 있다.)\n- 로깅되는 정보는 어떤 것들이 있나요?\n\t- 로깅하시는 각 레벨들이 어떤 의미를 가지고 있는지 알고 계신가요?\n\t- 커스텀 예외들은 개발자가 의도한 예외이기 때문에,  INFO 레벨이 좋을까요, 아니면 WARN 레벨이 좋을까요? \n- S-HOOK 의 로그 전략에 대해 알려주세요.\n- 현재 Request 에 대한 로깅도 진행하고 계신가요?\n\t- Request 에 대한 로깅이 필요할까요? 왜 필요할까요?\n\t- 실패한 Request 도 로깅하는 것이 좋을까요?\n\n### CI & CD\n\n- jenkins 로 넘어가야 할 것 같다고 느끼신 적이 있다면, 이유가 무엇이었을까요? 없다면 어떤 부분에서 github action 이 jenkins 보다 나은 점은 무엇이 있을까요?\n- CI & CD 에 대해 설명해주세요\n\t- CI / CD 를 하는 이유는 무엇이라고 생각하시나요?\n\t- CD 과정에서 어려우셨던 점은 없으셨나요? 어떻게 해결하셨나요?\n- github runner 를 사용했을 때의 단점은 무엇이라고 생각하시나요? \n\n## 로건\n\n### Transactional\n\n### Lock\n\n- 어떤 부분에서 데드락 및 동시성 문제가 있었나요?\n\t- 낙관적 락과 비관적 락에 대해 설명해주세요.\n\t- 기존의 낙관적 락을 적용했을 때는 어떤 문제가 발생할 수 있나요?\n\t- 비관적 락을 적용했을 때의 성능상 문제는 없을까요?\n\t- 낙관적 락과 비관적 락이 스프링에서 어떻게 구현되어 있나요?\n- 반정규화?\n\n### 세션\n\n- 펀잇 팀에서 세션을 사용하셨는데, 세션을 채택하신 이유가 궁금합니다.\n\n## 달리\n\n- CI / CD 란?\n- apache 도 있고, nginx 도 있는데 nginx 를 사용하신 이유가 있으실까요?\n- 어떤 지표를 모니터링하고 계신가요?\n\t- prometheus 와 grafana 가 어떤 서버에 올라가 있나요? \n\t\t- 분리했다면 왜 분리하셨나요? 어떤 부분에서 취약점이 있을까요?\n\t- 서버 부하는 어느 정도 측정되고 있나요?\n\t- prometheus 와 cloudwatch 를 비교했을 때 어떤 부분이 좋을까요?\n- 도커를 사용하셨는데, 도커를 사용하셨을 때의 이점은 무엇인가요?\n\t- 도커를 사용하면 어떤 점이 좋나요?\n- nginx 를 도커로 띄우신 이유는 무엇인가요?\n\n## 서기 - 루쿠\n\n- 서비스에 대해 간단하게 설명해주세요\n- 팀에서 어떤 역할을 하셨나요?\n- 치명적인 버그를 찾고 해결했던 경험이 있으셨나요?\n\t- batch 메서드를 사용하지 않고 deleteByIds 를 사용하여 해결했다.\n- 삭제할 때 영속성 전이는 사용하지 않았나요?\n- HTTPS 에 대해 적어주셨는데, 서비스에 어떻게 적용하셨나요?\n- 인증서는 어떻게 발급하셨나요?\n\t- certbot 을 사용했다. let's encrypt 라는 인증 기관에서 인증서를 발급 받았다.\n- handshake 과정에서 대칭키를 만들어 암호화를 한다고 했는데, 그 부분을 좀 더 자세히 설명해주세요\n- CORS 정책을 적용하신 배경이 무엇인가요?\n- 코드 상에서 어떻게 CORS 정책을 적용하셨나요?\n\t- WebMVCConf, nginx\n- nginx preflight 설정을 어떻게 하셨는지 좀 더 자세히 알려주세요.\n- OAuth 를 사용하셨는데, 왜 카카오의 OAuth 를 사용하셨나요?\n\t- 나이대와 성별을 투표 통계를 통해 알려주고 싶었다. 좀 더 정확한 정보를 받고 싶어 카카오톡을 선택했다.\n\t- 구글 같은 경우 연령대, 성별을 마음대로 입력해도 가입 가능하지만, 카카오의 정보는 좀 더 신뢰성이 있다고 생각했다.\n- OAuth 를 구현할 때 어려웠던 점은 무엇이었나요?\n- OAuth 통신 과정에 대해 설명해주세요.\n- Votogether 라는 프로젝트를 보았을 때, 투표를 해야 해서 동시성 문제가 발생할 수 있을 것 같아요. 어떤 부분을 고려했는지, 어떤 부분이 어려웠는지 듣고 싶습니다.\n\t- 기능 개발에 초점을 맞춰서 동시성 문제는 아직 해결하지 못했다. 프론트 쪽에서 낙관적 업데이트를 통해 처리하고 있다.\n- 현재는 다른 사용자들이 동시에 투표하는 것에 대해서는 대응이 되어 있지 않은 상태인가요?\n- JPA 를 사용하면서 엔티티 연관관계 매핑을 어떤 기준으로 하셨는지 궁금합니다.\n- 그 과정에서 객체지향적인 설계와 DB 패러다임과 충돌되는 경우는 없었나요?\n- 이 프로젝트를 진행하며 겪었던 가장 인상깊었던 에피소드가 있을까요?\n- 회의를 한 뒤에 일을 하는 방식의 변화가 있었나요?\n- 기술적인 부분의 트러블 슈팅을 말해주세요.\n\t- 기술 전파\n- 팀적으로 협업할 때 누구는 기술적으로 많이 아는 사람이 있고, 베이스가 부족한 사람이 있는데, 루쿠는 어디에 포함되어 있다고 생각하셨나요?\n- 기술적으로 뛰어난 크루들과 함께 협업했을 때 아쉬웠던 점이 무엇이었나요?\n- 팀 프로젝트에서 해결해야 하는 과제들이 있는데 고루 분배해서 성장하는 것도 중요합니다. 루쿠가 주도적으로 해결하거나 학습적으로 맡은 부분이 있는지, 그런 부분이 잘 분배되지 않았다면 팀적으로 어떤 노력을 했는지 궁금합니다.\n\n## 옵저버\n\n### 체인저\n\n#### 레벨 학습\n- 발생하는 문제를 여러 가지 형태로 해결했던 경험을 하나하나 말해주는 부분이 좋았다.\n- 질문에서 인정할 부분은 인정하고, 자신만의 의견을 피력하는 모습이 인상 깊었다.\n- 첫 번째, 두 번째와 같이 답변의 순서를 말해주고 답변하는 모습이 좋았다.\n\n#### 인터뷰 / 말하기\n- 시선 처리, 제스처 모두 적당했다. 잘 생각나지 않는 내용은 말의 속도를 늦춰가면서 끊기지 않게 말하는 게 굉장했다.\n\n### 모디\n#### 레벨학습\n- 서비스에서 해당 기술을 사용하게 된 배경과 기술을 통해 어떤 것을 수행했는지 답변 내부에서 명확하게 분리되어 있어서 전달력이 좋았다.\n- 마치 앞에 써져 있는 기술블로그를 읽는 듯한 답변이어서 대단하다고 생각했습니다. 그만큼 문제 상황과 근거가 확실하게 제시되어 있는 답변이라 좋았습니다. \n\n#### 인터뷰 / 말하기\n- 프로젝트에 있었던 경험과 예시를 기반으로 답변하는 방식이 좋았다.\n- 답변에 대한 예시가 조금 길어지는 부분이 있었다. 사람마다 차이가 있을 수 있지만, 개인적으로는 예시를 좀 더 간략하게 제시하면 더 좋을 것 같다."},{"excerpt":"WS, WAS WS 주로 정적 컨텐츠를 클라이언트에 제공한다. 클라이언트의 요청에 따라 파일을 찾아 그대로 반환한다. Apache, nginx 가 있다. WAS 동적인 컨텐츠를 처리하는 데 필요한 로직을 실행하고 결과를 웹 서버에 전달하여 클라이언트에게 제공하는 역할을 한다. Tomcat, JBoss 가 있다. 웹 서버가 정적인 컨텐츠를 처리하면서 동적 …","fields":{"slug":"/level3-level-log/"},"frontmatter":{"date":"2023년 08월 29일 08:08","title":"레벨3 레벨로그","tags":["레벨로그","레벨3","우테코"]},"rawMarkdownBody":"\n## WS, WAS\n\n- WS\n\t- 주로 정적 컨텐츠를 클라이언트에 제공한다. 클라이언트의 요청에 따라 파일을 찾아 그대로 반환한다.\n\t- Apache, nginx 가 있다.\n- WAS\n\t- 동적인 컨텐츠를 처리하는 데 필요한 로직을 실행하고 결과를 웹 서버에 전달하여 클라이언트에게 제공하는 역할을 한다. \n\t- Tomcat, JBoss 가 있다.\n- 웹 서버가 정적인 컨텐츠를 처리하면서 동적 요청은 WAS 로 전달하는 방식으로 작동한다.\n\n### nginx\n\n- 수 많은 동시 연결을 효율적으로 처리할 수 있다. 제한된 수의 worker process 를 사용하여 수천 개의 동시 연결을 처리할 수 있다.\n- 클라이언트 요청을 실제 서버로 전달하고, 해당 서버의 응답을 클라이언트에게 반환한다.\n- 캐싱\n\t- 백엔드 서버의 응답을 캐시에 저장하고, 후속 요청에 대해 캐시된 데이터를 반환하여 백엔드 서버의 부하를 줄일 수 있다.\n- Reverse proxy\n\t- 서버 측에서 설정되며, 클라이언트의 요청을 받아 내부 서버에 전달하고 응답을 다시 클라이언트에게 반환하는 서버이다. \n\t- 로드밸런싱으로 여러 서버 간의 트래픽을 분산하여 부하를 줄일 수 있다.\n\t- 자주 요청되는 컨텐츠를 캐싱하여 빠른 응답 시간을 제공한다.\n\t- 리버스 프록시에서 SSL/TLS 연결을 종료하고(즉, 암호화를 해제하고), 내부 네트워크로는 암호화되지 않은 연결을 사용할 수 있다. 이를 통해 백엔드 서버에서의 암호화/복호화 처리 부하를 줄일 수 있다.\n\t- 내부 서버의 실제 IP 주소와 구조를 숨길 수 있어, 외부의 악의적인 공격으로부터 보호할 수 있다.\n- Front proxy\n\t- 클라이언트 쪽에서 설정되고, 클라이언트의 요청을 받아 서버로 중계하는 서버이다.\n\t- 특정 웹사이트나 서비스 접근을 차단하거나 허용한다. 데이터 압축 또는 캐싱을 통해 대역폭 사용을 줄인다.\n\n#### Certbot\n\n- 자동 갱신을 위해서는 우분투에 기본 설치되어 있는 `Crontab` 을 사용하여 Cerbot 이 만료되는 주기로 갱신하는 스크립트를 작성하여 실행시켜주면 된다.\n\n### HTTP, HTTPS\n\n두 가지는 모두 데이터를 전송하는 데 사용되는 프로토콜이다. \n\n#### HTTP\n\n- 데이터는 암호화되지 않고 평문으로 전송된다. \n- 인증서가 필요하지 않다.\n- 기본 포트번호가 80이다.\n\n#### HTTPS\n\n- SSL/TLS 인증서가 필요하다. \n\t- SSL (Secure Sockets Layer) 나 TLS (Transport Layer Security) 를 사용하여 암호화되어 전송된다. 이를 통해 데이터의 기밀성과 무결성이 보장된다.\n- 기본 포트번호는 443 이다.\n- 과거에는 HTTPS 가 암호화 / 복호화 과정으로 인해 HTTP 에 비해 성능 저하가 있었으나, 현재는 최적화된 알고리즘과 하드웨어 가속 기술로 차이가 거의 미미한 수준이다.\n- 웹사이트의 보안성을 향상시키기 때문에, 많은 검색엔진들이 HTTPS 를 사용하는 웹사이트에 SEO 가점을 제공한다.\n\n## JPA\n\n- JPA 와 객체지향 - 엔티티 사이의 연관관계\n- OSIV 설정을 꺼 두었을 때, 컨트롤러까지 영속성 컨텍스트가 유지되지 않기 때문에 조회한 엔티티가 영속 상태를 유지하지 않고, 영속성 컨텍스트의 변경 감지도 동작하지 않는다.\n- Entity 생명주기\n\n### 영속성 컨텍스트\n\n인스턴스로 존재하는 엔티티를 관리하고 영속화시키는 논리적 영역\n\n### 생명 주기\n\n- 비영속\n\t- 엔티티가 영속성 컨텍스트와 전혀 관련이 없다.\n- 영속\n\t- 영속성 컨텍스트에서 관리되고 있는 상태이다. DB 에 저장된 상태가 아니다.\n\t- persist 를 사용하여 비영속 엔티티를 영속상태로 만들 수 있다.\n\t- Entity Manager 가 DB에서 조회해온 데이터도 영속 상태인 엔티티가 된다.\n\t- 영속 상태인 같은 엔티티를 조회하면 DB 접근을 하지 않고 1차 캐시 저장소에 있는 엔티티를 반환한다.\n- 준영속\n\t- 영속성 컨텍스트에서 관리되던 엔티티가 영속성 컨텍스트에서 관리되지 않는 것이다.\n\t- 방법\n\t\t- 엔티티 매니저의 `detach()` 사용\n\t\t- 영속성 컨텍스트 전체를 초기화 시키는 `clear()` -> 쿼리문 저장소의 보관된 쿼리들도 모두 초기화된다. 모든 엔티티가 전부 준영속 상태가 된다.\n\t\t- 영속성 컨텍스트 닫는 `close()` 사용\n- 삭제\n\t- 엔티티를 영속성 컨텍스트에서 관리하지 않게 되고, 해당 엔티티를 DB 에서 삭제하는 DELETE 쿼리를 보관한다.\n\n### Dirty Checking\n\n트랜잭션이 끝나는 시점에 최초 조회 상태에서 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영해준다.    \n\n영속성 컨텍스트가 관리하는 엔티티에만 적용된다.    \n\n### OSIV\n\n영속성 컨텍스트를 뷰까지 열어두는 기능이다. 스프링 프레임워크에서는 기본적으로 true 로 설정되어 있다.\n\n켜져있는 경우, 트랜잭션이 끝나도 영속 상태를 유지한다. 이런 경우, 실시간 트래픽이 중요한 애플리케이션에서 커넥션이 모자라서 서비스 장애의 원인이 될 수 있다.\n\n꺼져있는 경우, 트랜잭션이 끝나면 즉시 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. 커넥션 리소스를 낭비하지 않아 좋지만, 지연 로딩을 모두 트랜잭션 안에서 처리해야 한다는 단점이 있다.\n\n동일한 트랜잭션을 사용하는 경우, 항상 같은 영속성 컨텍스트를 사용하게끔 구현되어 있다. 다른 트랜잭션은 다른 영속성 컨텍스트를 사용한다.\n\n만약 서버 사이드 렌더링을 수행하는 경우 문제가 될 수 있다.     \n조회한 엔티티와 연관된 엔티티를 함께 사용해야 한다. 연관 엔티티는 지연 로딩으로 설정되었다고 가정하자.     \n이때, 조회된 엔티티는 프록시 객체로 Presentation layer 에 반환된 상태이다.     \n결론적으로 실제 데이터를 불러오려고 초기화를 시도할 때 지연 로딩이 작동하지 않아 예외가 발생한다. \n\n#### 문제점\n\n- Presentation Layer 가 엔티티를 변경할 수 있다. OSIV 설정이 켜진 상태에서는 변경 감지가 작동하므로, 변경된 값이 바로 DB 에 반영되어 버릴 수 있다는 것이다. \n- 트랜잭션 롤백 시 주의해야 한다.\n- Presentation Layer 에서 엔티티가 변경되고 난 후, 비즈니스 로직을 실행하면 실제 엔티티가 수정될 수 있다.\n\n#### 스프링의 OSIV\n\n스프링 프레임워크가 제공하는 OSIV 는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV 이다.     \n\n1. 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 생성한다. (트랜잭션은 시작하지 않는다.)\n2. 서비스 계층에서 트랜잭션을 시작할 때, 1번에서 미리 생성해 둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.\n3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 영속성 컨텍스트는 종료되지 않는다.\n4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 '유지' 한다.\n5. 서블릿 필터나 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때, 플러시를 호출하지 않고 바로 종료한다.\n\n#### 트랜잭션 없이 읽기\n\n영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다.    \n그러나 단순 조회는 트랜잭션 없이도 가능하다.\n\n#### 그래서?\n\n- admin 페이지 같이 실시간 트래픽이 중요하지 않은 경우 OSIV 를 사용해도 괜찮다.\n- command 와 query 를 분리하는 것이 좋다.\n\t- 명령 (command) 서비스, 조회 (query) 서비스를 분리한다. Query Service 에서는 DTO projection 을 사용한다.\n\n### DTO Projection\n\n엔티티 대신에 DTO 를 편리하게 조회할 때 사용한다.     \n엔티티의 일부 속성만 가져오고 싶을 때 사용할 수 있다.      \nJoin 한 모든 내용 대신, 노래와 전체 좋아요만 가져오려고 사용했다.\n\n#### 인터페이스 기반 Projection\n\n구현 객체는 JPA 가 프록시로 만들어준다.\n\nprojection 된 결과 객체는 영속성이 유지되지 않는다.\n\n#### 클래스 기반 Projection\n\n생성자의 파라미터 이름으로 Projection 이 동작한다.\n쿼리에 패키지 이름까지 다 써줘야 한다.\n\n#### Open Projection\n\n인터페이스에 정의된 메서드에 대한 구체적인 구현을 제공할 수 있다.    \n개발자가 원하는 로직에 따라 값을 반환하게 된다.\n\n#### Closed Projection\n\n인터페이스에 정의된 메서드만 사용되며, 엔티티의 특정 속성에 직접 매핑된다.\n\n#### 주의\n\nprojection 을 사용하면 기존 설정을 무시하고 eager loading 을 하는 듯하다.\n\n## CORS\n\n- 다른 origin 끼리 리소스를 공유하게 할 수 있다. SOP 정책으로 동일하지 않은 다른 출처의 스크립트가 실행되지 않도록 브라우저에서 사전에 방지한다.\n- Preflight Request\n- Credentialed Request\n\n### CORS 설정\n\n- nginx 에서 설정\n\t- METHOD 이름이 OPTION 인 경우 허용한다.\n\n## JWT\n\n인증에 필요한 정보들을 JSON 으로 표현한 데이터 토큰이다.    \n토큰 자체가 서명되어 있고, 인증에 필요한 정보들을 지니고 있다.   \n\n### 구조\n\n- Header\n\t- 토큰의 타입, 서명에 사용된 알고리즘에 대한 정보가 담겨 있다.    \n\t- 우리 서비스에서는 HS256 을 사용했다.\n- Payload\n\t- 토큰을 통해 제공되는 데이터들이 key-value 형태로 들어가 있다.\n\t- iat : 해당 토큰이 발급된 시간\n\t- exp: 해당 토큰의 만료 시간\n\t- 토큰의 발급 대상, 토큰 제목, 토큰의 활성화 날짜, 토큰 발급자, 토큰 식별자 등이 있다. \n- Signature\n\t- 서명에 대한 정보이다. 헤더와 페이로드를 인코딩한 값을 합치고 특정 알고리즘과 특정 키로 암호화되어 있는 값이다.    \n\t- 헤더와 페이로드는 Base64 로 인코딩 되어 있는 값이므로 시그니쳐를 추가하여 위변조를 판별한다.\n\n### 암호화 방식\n비대칭 암호 방식을 이용해서 암호화한다.    \n\n### 세션과 비교\n세션 방식은 브라우저와 웹 서버가 연결되어 브라우저가 종료될 때까지의 시점이다.    \n클라이언트는 요청시 쿠키에 세션 아이디를 저장해서 보내고, 서버는 전달받은 세션 아이디로 DB 에서 세션을 조회한다.    \n\n#### 세션 장점\n- 세션 아이디가 탈취되더라도 DB 에 저장된 세션을 삭제하면 된다.\n- 쿠키에 아무런 의미가 없는 세션 ID 가 저장되므로, 탈취되더라도 해석할 수 없다.\n\n#### 세션 단점\n- 매 요청 시마다 세션 저장소를 조회해야 하는 단점이 존재한다.\n- 서버에 세션 객체를 저장하므로 사용자가 다수일 경우 부하가 높아진다.\n- scale out 시 모든 서버가 접근할 수 있도록 별도의 중앙 세션 관리 시스템이 필요하다.\n- 서버가 추가될 경우, 각 서버마다 세션 정보가 저장되므로 확장성이 좋지 않다.\n\n#### JWT 장점\n- JWT 가 이미 인증된 정보이므로, 이를 저장하기 위한 저장소가 필요하지 않다. \n- 서버에서 클라이언트 상태를 저장할 필요가 없다.\n- 서버 측 부하를 낮출 수 있다.\n\n#### JWT 단점\n- 토큰을 강제로 만료시킬 방법이 없다.\n- 페이로드에 민감한 정보를 담기 어렵다.\n- 토큰이 쿠키나 로컬스토리지 등에 저장되므로 탈취당할 위험이 존재한다.\n\n### Refresh Token\n\nAccess Token 의 유효기간을 짧게 해서 보안을 강화하면서도, 사용자가 자주 로그인하지 않도록 하기 위해서 등장했다.     \n\n#### Refresh Token 이 탈취된다면, 대비하는 방법\n\n- RTR : Refresh Token 을 한 번만 사용할 수 있도록 한다. 새로운 Access Token 을 발급받을 때마다 Refresh Token 도 새롭게 발급한다. 이미 사용된 Refresh Token 임을 검사해서 서비스 측에서 탈취를 확인할 수도 있다.\n\n보안적 측면에서 DB 에 저장하고, RTR 과 같은 방법으로 안전하게 관리하는 것이 좋다.     \n\n"},{"excerpt":"LOG 알고리즘 3문제 풀었다. 처음으로 백준 스트릭 7일 넘겼다..ㅋㅋㅋ 용우, 세진과 설입에서 점심 먹었다. 동기들 또 오랜만에 만나니까 재밌었다. 내년에 학교 갔을 때도 아는 동기들 많았으면 좋겠다. 배운 것 lis 내용을 보강했다. 파이썬에서는 이분 탐색으로 LIS 배열을 어떻게 구하는지 공부했다. 느낀 것 아직은 언제까지 집중해야 지치지 않는지 …","fields":{"slug":"/2023-08-27/"},"frontmatter":{"date":"2023년 08월 27일 09:08","title":"2023년 08월 27일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 3문제 풀었다. 처음으로 백준 스트릭 7일 넘겼다..ㅋㅋㅋ\n- 용우, 세진과 설입에서 점심 먹었다. 동기들 또 오랜만에 만나니까 재밌었다. 내년에 학교 갔을 때도 아는 동기들 많았으면 좋겠다.\n\n## 배운 것\n\n- [[lis]] 내용을 보강했다. 파이썬에서는 이분 탐색으로 LIS 배열을 어떻게 구하는지 공부했다.\n\n## 느낀 것\n\n- 아직은 언제까지 집중해야 지치지 않는지 모르겠다. 오늘도 알고리즘 풀다가 완전히 지쳐버려서 힘들었다. 내일부터는 뽀모도로 공부법을 도입해봐야지\n- 나는 지금 주체적인 삶을 살고 있나? 정말로 내 인생에서 내가 주인공일 수 있을까? 나는 주변의 행동, 말투, 이야기에 내가 너무나도 쉽게 흔들린다는 걸 알고 있다. 내가 믿었던 것에 의심을 가지지 않는 방법도 잘 모르겠다. 이런 건 고쳐야 하는 걸까?\n- 여전한 것 같다가도, 또 아닌 것 같다가도, 다시 이런 생각을 한다. 나는 아직 약한 사람이다. 그래도 예전보다는 솔직하다. 지금은 그 사실에 만족하자. 내일은 오늘보다 더 나아가자."},{"excerpt":"LOG 점심으로 바싹 불고기를 먹었는데 맛있었다. 채그로에 가서 알고리즘을 풀었다. 카페도 크고 공부할 곳도 많아서 좋았다. 새로 산 펜이 너무 마음에 든다. 부드럽게 잘 써져서 좋다. 배운 것 느낀 것 평소보다 많이 먹지는 못하고 있다. 식사할 때 갑자기 물이 마시고 싶어져서 계속 마시게 되는데, 그러다 보니 배를 채우지는 못하고 있다. 내 못난 행동을…","fields":{"slug":"/2023-08-25/"},"frontmatter":{"date":"2023년 08월 25일 05:08","title":"2023년 08월 25일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 점심으로 바싹 불고기를 먹었는데 맛있었다.\n- 채그로에 가서 알고리즘을 풀었다. 카페도 크고 공부할 곳도 많아서 좋았다. \n- 새로 산 펜이 너무 마음에 든다. 부드럽게 잘 써져서 좋다.\n\n## 배운 것\n\n## 느낀 것\n\n- 평소보다 많이 먹지는 못하고 있다. 식사할 때 갑자기 물이 마시고 싶어져서 계속 마시게 되는데, 그러다 보니 배를 채우지는 못하고 있다.\n- 내 못난 행동을 경계하자."},{"excerpt":"플로이드-워셜 알고리즘 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구할 수 있는 알고리즘이다. (ㄷㄷ) 플로이드-워셜 알고리즘은 단계마다 '거쳐 가는 노드' 를 기준으로 알고리즘을 수행한다. 또한 정점의 개수가 V일 때, V 번 만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 DP 라고 볼 수 있다. 점화식은 다음과 같다.…","fields":{"slug":"/floyd-warshall-algorithm/"},"frontmatter":{"date":"2023년 08월 24일 07:08","title":"플로이드-워셜 알고리즘","tags":["algorithms","graph"]},"rawMarkdownBody":"\n## 플로이드-워셜 알고리즘\n\n모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구할 수 있는 알고리즘이다. (ㄷㄷ)    \n플로이드-워셜 알고리즘은 단계마다 '거쳐 가는 노드' 를 기준으로 알고리즘을 수행한다.     \n\n또한 정점의 개수가 V일 때, V 번 만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 DP 라고 볼 수 있다.     \n\n점화식은 다음과 같다.     \n\n![[floyd-warshall-dp.png]]\n\n즉, 기존에 저장된 거리보다 a 에서 k 로 가는 거리 + k 에서 b 로 가는 거리가 더 짧으면 갱신한다는 뜻이다.     \n\n## 수행 과정\n\n1. 주어진 그래프에 맞게 최단 거리 테이블을 갱신해둔다. \n2. 1 ~ N 번 정점을 거쳐가는 경우를 고려하여 테이블을 갱신한다. \n\n## 코드\n\n```python\ndef floyd_warshall(n, dist):  \n    for i in range(1, n + 1):  \n        for a in range(1, n + 1):  \n            for b in range(1, n + 1):  \n                dist[a][b] = min(dist[a][b], dist[a][i] + dist[i][b])\n```\n\n## 주의할 점\n\n정점의 개수가 V 일 때, V 번의 단계를 수행하면서 단계마다 O(V^2) 의 연산을 수행하여 현재 정점을 거쳐가는 모든 경로를 고려한다.     \n\n따라서 시간 복잡도가 O(V^3) 이므로 정점의 개수 값이 작을 경우에만 사용해야 한다.     "},{"excerpt":"벨만-포드 알고리즘 한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘이다. 다익스트라 알고리즘과는 달리, 간선의 가중치가 음수일 때도 최단 거리를 구할 수 있다. 정점 - 1 번의 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구한다. 언제나 다익스트라 알고리즘에서의 최적의 해를 포함하게 된다. 시간복잡도는  로 느리다. 다익…","fields":{"slug":"/bellman-ford-algorithm/"},"frontmatter":{"date":"2023년 08월 24일 07:08","title":"벨만-포드 알고리즘 정리","tags":["algorithms","graph"]},"rawMarkdownBody":"\n## 벨만-포드 알고리즘\n\n한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘이다.    \n다익스트라 알고리즘과는 달리, 간선의 가중치가 음수일 때도 최단 거리를 구할 수 있다.     \n\n정점 - 1 번의 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구한다.     \n언제나 다익스트라 알고리즘에서의 최적의 해를 포함하게 된다.\n\n시간복잡도는 $O(VE)$ 로 느리다.    \n\n### 다익스트라 알고리즘\n\n방문하지 않은 노드들 중에서 현재 노드에서 최단 거리가 가장 짧은 노드를 선택하여 한 단계씩 최단 거리를 구한다.    \n\nPQ 를 사용한 개선된 다익스트라 알고리즘을 사용했을 때 시간 복잡도는 $O(E log V)$ 이다.     \n\n## 수행 과정\n\n1. 출발 노드를 설정한다.\n2. 출발 노드의 최단 거리 테이블을 초기화한다.\n3. 다음의 과정을 (정점의 개수 - 1) 만큼 반복한다.\n\t1. 모든 간선 E 개를 하나씩 확인한다.\n\t2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.\n\n### 음수 간선 사이클 존재 여부 확인하기\n\n음수 간선 사이클이 존재하는지 확인하기 위해서는 3번 과정을 한 번 더 수행하여, 최단 거리 테이블이 갱신되는 경우 음수 간선 사이클이 존재한다고 판단할 수 있다.      \n\n> 어떻게 음수 간선 사이클이 존재한다고 판단할 수 있을까?\n\n사이클이 존재하는 경우, 사이클을 계속해서 돌면서 사이클 내부의 노드에서 다른 노드로 가는 비용을 무한히 줄일 수 있다.      \n원래는 3번의 과정을 마쳤을 때, 모든 노드를 확인하여 최단 거리가 확정되었기 때문에 더 이상 값이 변경되지 않는다.\n\n## 코드\n\nBOJ 11657 의 정답과 동일하다.\n\n```python\nimport sys  \n  \ninput = sys.stdin.readline  \nINF = float('inf')  \n  \nn, m = map(int, input().strip().split())  \ngraph = list()  \n  \nfor _ in range(m):  \n    a, b, cost = map(int, input().strip().split())  \n    graph.append((a, b, cost))  \n  \n  \ndef bellman_ford(start):  \n    dist = [INF] * (n + 1)  \n    dist[start] = 0  \n    for i in range(n):  \n        for start, next_node, cost in graph:  \n            if dist[start] != INF and dist[next_node] > dist[start] + cost:  \n                if i == n - 1:  \n                    return -1  \n                dist[next_node] = dist[start] + cost  \n    return dist  \n  \n  \nresult = bellman_ford(1)  \nif result == -1:  \n    print(-1)  \nelse:  \n    for i in range(2, n + 1):  \n        print(result[i] if result[i] != INF else -1)\n```\n\n## 주의할 점\n\n벨만-포드 알고리즘은 |V| - 1 만큼 순회하므로 O(V), 매번 O(E) 만큼 탐색하므로 O(|V||E|) 가 된다.    \n\n그런데 밀집 그래프의 경우 E 는 V^2 에 가까워지므로, 최악의 경우 O(V^3) 이 된다. \n(밀집 그래프는 간선의 수가 최대 간선의 수에 가까운 그래프를 말한다.)\n\n다익스트라 알고리즘에 비해 시간 복잡도가 높으므로, 벨만-포드 알고리즘은 간선의 가중치에 음수가 존재할 경우에만 채택하는 것이 좋다.     "},{"excerpt":"LOG TIL 을 일주일 간 못 썼다. 레벨3 때는 바빠서 못 썼고, 방학 되어서는 공부하고 노느라 못 썼다. 이제 다시 열심히 써볼까 한다. 알고리즘 5문제 풀었다. 목표는 이번 달 안에 플레5 찍기 알고리즘 풀려고 샀던 펜을 다 썼다. 영풍문고에 가서 펜을 두 개나 샀다. 더 열심히 해서 또 펜을 사고 싶다. 배운 것 bellman-ford-algor…","fields":{"slug":"/2023-08-24/"},"frontmatter":{"date":"2023년 08월 24일 07:08","title":"2023년 08월 24일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- TIL 을 일주일 간 못 썼다. 레벨3 때는 바빠서 못 썼고, 방학 되어서는 공부하고 노느라 못 썼다. 이제 다시 열심히 써볼까 한다.\n- 알고리즘 5문제 풀었다. 목표는 이번 달 안에 플레5 찍기\n- 알고리즘 풀려고 샀던 펜을 다 썼다. 영풍문고에 가서 펜을 두 개나 샀다. 더 열심히 해서 또 펜을 사고 싶다.\n\n## 배운 것\n\n- [[bellman-ford-algorithm]] 에 대해 공부했다.\n- [[floyd-warshall-algorithm]] 에 대해 공부했다.\n\n## 느낀 것\n\n- 집중력이 좋아지고, 한 문제에 싫증내지 않고 계속해서 집중할 수 있게 되니 알고리즘 푸는 게 재밌다. 나도 끈기있게 할 수 있는 사람이었군 신기하다\n- 벌써 4일차 스트릭! 스트릭도 계속해서 유지해보자. 최대 6일인데..ㅋㅋㅋ 이번에야말로 스트릭 갱신을 위해 파이팅\n- 2023년 안에 코테 볼 수 있는 수준으로 알고리즘 실력 끌어올리기. 아자아자"},{"excerpt":"Monitor Lock 과 synchronized Java 의 synchronized 키워드가 동기화를 제공하는 방법인 Monitor Lock 에 대해 알아본다. 또한 Monitor Lock 이 사용되는 이유와 어떤 경우에 사용되면 좋은지 알아본다. Lock 왜 사용할까? critical section 에 대해 상호 배제 (mutual exclusion)…","fields":{"slug":"/java-synchoronized/"},"frontmatter":{"date":"2023년 08월 21일 07:08","title":"모니터와 synchronized","tags":["java"]},"rawMarkdownBody":"\nMonitor Lock 과 synchronized\n\nJava 의 synchronized 키워드가 동기화를 제공하는 방법인 Monitor Lock 에 대해 알아본다. 또한 Monitor Lock 이 사용되는 이유와 어떤 경우에 사용되면 좋은지 알아본다.\n\n## Lock\n\n### 왜 사용할까?\n\n1. critical section 에 대해 상호 배제 (mutual exclusion) 을 제공한다. 공유 데이터를 한 스레드만 접근할 수 있도록 제한하는 것을 의미한다.\n2. 스레드 간의 협업 또는 동기화의 역할을 수행한다. 어떤 작업을 완료하거나 특정 상태에 도달하는 경우 다른 스레드에 알려주어 해당 스레드가 동작할 수 있도록 한다.\n\n## Intrinsic Locks\n\nSynchronization (동기화) 은 내장 락, 모니터 락이라고 알려진 내부 엔티티를 중심으로 구축된다.\n\n## 동시성\n\n프로그램, 알고리즘, 또는 문제의 여러 부분이나 단위를 결과에 영향을 주지 않고 순서 없이 또는 부분적으로 실행할 수 있는 기능\n\nhttps://en.wikipedia.org/wiki/Concurrency_(computer_science)\n\n### Read-Modify-Write 패턴\n\n## 참고\n\n- https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\n- https://backtony.github.io/java/2022-05-04-java-50/\n- http://happinessoncode.com/2017/10/04/java-intrinsic-lock/\n- https://www.baeldung.com/java-synchronized"},{"excerpt":"Lock 왜 사용할까? critical section 에 대해 상호 배제 (mutual exclusion) 을 제공한다. 공유 데이터를 한 스레드만 접근할 수 있도록 제한하는 것을 의미한다. 스레드 간의 협업 또는 동기화의 역할을 수행한다. 어떤 작업을 완료하거나 특정 상태에 도달하는 경우 다른 스레드에 알려주어 해당 스레드가 동작할 수 있도록 한다. 생…","fields":{"slug":"/monitor-lock-and-java-synchoronized/"},"frontmatter":{"date":"2023년 08월 21일 07:08","title":"monitor lock과 synchronized","tags":["java","os","cs"]},"rawMarkdownBody":"\n## Lock\n\n### 왜 사용할까?\n\n1. critical section 에 대해 상호 배제 (mutual exclusion) 을 제공한다. 공유 데이터를 한 스레드만 접근할 수 있도록 제한하는 것을 의미한다.\n2. 스레드 간의 협업 또는 동기화의 역할을 수행한다. 어떤 작업을 완료하거나 특정 상태에 도달하는 경우 다른 스레드에 알려주어 해당 스레드가 동작할 수 있도록 한다.\n\n## 생산자 소비자 문제 3.5, 6.1\n\n생산자 프로세스는 정보를 생산하고, 소비자 프로세스는 정보를 소비한다.  \n\n사과 10개를 담을 수 있는 바구니가 있다고 하자.  \n생산자는 바구니에 사과를 1개 넣고, 소비자는 바구니에서 사과를 1개씩 먹는다. 바구니의 크기는 10으로 고정되어 있고, 더 많은 양을 넣을 수 없다. \n\n해당 상황을 코드로 표현하면 다음과 같다.  \n\n생산자는 다음과 같이 행동할 것이다.  \n\n```java\nwhile (true) {\n\twhile (count == BASKET_SIZE) {\n\t\t// 아무것도 하지 않는다.\n\t}\n\n\tbuffer[in] = apple;\n\tin = (in + 1) % BASKET_SIZE;  // 마지막 버퍼 포인터 위치 변경\n\tcount++;\n}\n```\n\n소비자는 다음과 같이 행동할 것이다. \n\n```java\nwhile (true) {\n\twhile (count == 0) {\n\t\t// 아무것도 하지 않는다.\n\t}\n\n\tout = (out + 1) % BASKET_SIZE;\n\tcount--;\n}\n```\n\n각 코드를 개별적으로 수행하면 올바르게 동작하지 않을 것이다.  count 가 5일 때 생산자와 소비자가 동시에 count++, count-- 를 수행하면 count 는 4, 5, 6 의 값을 가질 수 있다. 동시성이 보장되지 않는 것이다.  \n\n## 세마포어의 한계 6.7\n\n잘못 사용하면 발견하기 어려운 타이밍 오류를 야기할 수 있다. 해당 타이밍 오류들은 특정 실행 순서로 실행되었을 때만 발생하고, 이런 순서가 항상 발생하는 것은 아니기 때문에 찾기 굉장히 어렵다.\n\n반드시 wait -> signal 의 순서로 사용해야 하는데, 개발자의 실수로 다음과 같은 코드가 작성되면 다양한 유형의 오류들이 너무나도 쉽게 발생할 수 있다. \n\n```java\n/* 1 */\nsignal(semaphore);\n// critical section\nwait(semaphore);\n\n/* 2 */\nwait(semaphore);\n// critical section\nwait(semaphore);\n```\n\n이를 해결하기 위해 동기화 도구를 통합하여 고급 언어 구조물을 제공하면, 개발자의 오류를 최대한 막을 수 있을 것이다.\n\n## Monitors 6.7\n\n모니터 타입은 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정의한 일련의 연산자 집합을 포함하는 ADT 이다.  \n또한 모니터 내에 정의된 함수만이 오직 모니터 내에 지역적으로 선언된 변수들과 형식 매개변수들에만 접근할 수 있다. 마찬가지로 모니터 내의 지역 변수는 오직 지역 함수만이 접근할 수 있다.  \n\n모니터 구조를 사용하면 모니터 안에 항상 하나의 프로세스만이 활성화되도록 보장해준다. 그러므로 프로그래머가 이와 같은 동기화 제약 조건을 명시적으로 코딩할 필요가 없다. \n\n### 부가적인 동기화 기법\n\n동기화 기법들은 `condition` 이라는 구조물로 제공될 수 있다. 자신의 On-Demand 동기화 기법을 작성할 필요가 있는 프로그래머는 `condition` 형의 변수를 정의할 수 있다.  \n\n```java\ncondition x, y;\n```\n\n`condition` 형 변수에 호출될 수 있는 연산은 `wait()` 과 `signal()` 만이 가능하다.  \n`x.wait()` 은 해당 연산을 호출한 프로세스는 다른 프로세스가 `x.signal()` 을 호출할 때까지 일시 중지되어야 한다는 것을 의미한다.  \n\n`x.signal()` 연산은 정확히 하나의 일시 중지 프로세스를 재개한다. 일시 중지된 프로세스가 없으면 `signal` 연산은 아무런 효과가 없다. 즉, x의 상태는 마치 연산이 전혀 실행되지 않는 것과 같다. \n\n`x.signal()` 연산이 프로세스 P 에 의해 호출될 때, 조건 x와 연관된 suspend 된 프로세스 Q 가 있다고 가정하자. 당연하게도 일시 중지된 스레드 Q 가 실행을 재개한다면, signal 을 보낸 스레드 P는 반드시 대기해야 한다. 그렇지 않으면 P와 Q가 모니터 안에서 동시에 활성화된다.  \n\n그러나 두 프로세스는 개념적으로 실행을 계속할 수 있다는 사실을 유의해야 한다. 다음과 같은 두 가지 가능성이 있을 수 있다. \n\n1. Signal and wait: P는 Q가 모니터를 떠날 때까지 기다리거나 다른 조건을 기다린다.\n2. Signal and continue: Q는 P가 모니터를 떠날 때까지 기다리거나 또는 다른 조건을 기다린다. \n\nP가 이미 모니터 안에서 실행되고 있었기 때문에, signal-and-continue 옵션을 선택하는 것이 더 합리적인 것처럼 보인다. 그러나 만약 스레드 P 를 계속하도록 허용한다면, Q가 재개될 때까지 Q가 기다리고 있는 논리적 조건이 이미 참이 아닐 수도 있다. \n\n두 가지 방법을 절충한 방법도 있다. 스레드 P 가 `signal()` 연산을 실행하면 즉시 모니터를 떠나고 Q 를 즉시 재개한다. \n\n### 세마포어로 모니터 구현\n\n각 모니터마다 `mutex` 라는 이진 세마포가 정의되고 그 초기 값은 1이다. 프로세스는 모니터로 들어가기 전에 `wait(mutex)` 를 실행하고, 모니터를 나온 후에 `signal(mutex)` 를 실행한다.\n\n모니터 구현 시 signal-and-wait 기법을 사용한다. (왜지?) Signaling 프로세스는 실행 재개되는 프로세스가 모니터를 떠나든지, 아니면 `wait()` 할 때까지 그 자신이 다시 기다려야 하므로 `next` 라는 이진 세마포어가 추가로 필요하게 되고, 0으로 초기화한다. Signaling 프로세스는 자신을 중단시키기 위해 `next` 를 사용한다. 정수형 변수 `next_count` 도 `next` 에서 일시 중지 되는 프로세스 개수를 세기 위해 사용한다.  \n\n```java\nwait(mutex);\n...\nbody of F\n...\n\nif(next_count > 0) {   // 일시 중지된 프로세스 수가 있는 경우\n\tsignal(next);\n}\nelse {\n\tsignal(mutex);\n}\n```\n\n조건 변수를 세마포어로 구현하는 방법은 다음과 같다.  \n\n```java\nx_count++;\nif(next_count > 0) {\n\tsignal(next);\n}\nelse {\n\tsignal(mutex);\n}\nwait(x_sem);\nx_count--;\n```\n\n`x.signal()` 연산은 다음과 같이 구현할 수 있다. \n\n```java\nif(x_count > 0) {\n\tnext_count++;\n\tsignal(x_sem);\n\twait(next);\n\tnext_count--;\n}\n```\n\n위와 같은 코드로 모니터를 구현하는데 사용될 수 있다. \n\n### 모니터 내에서 프로세스 수행 재개\n\n조건 변수 x에 여러 프로세스가 일시 중지 되어 있고, 어떤 프로세스가 `x.signal()` 연산을 수행했다면 일시 중지된 프로세스 중 어느 프로세스가 수행 재개될 것인가를 어떻게 결정할까?\n\n가장 간단한 방법은 FCFS 순이다. 즉, 가장 오래 기다렸던 프로세스가 가장 먼저 깨어난다. 그러나 많은 경우 이런 간단한 스케줄링 기법은 충분하지 않다.  \n\n이때 conditional-wait 구조를 사용할 수 있다. \n\n```java\nx.wait(c);\n```\n\nc는 정수 expression 이고, 수식은 `wait()` 연산이 호출될 때 값이 계산된다.  \nc의 값은 우선순위 번호라고 불리고, 일시 중지되는 프로세스의 이름과 함께 저장된다.  \n`x.signal()` 이 수행되면 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 수행 재개 된다.  \n\n`ResourceAllocator` 는 한 개의 자원을 여러 프로세스 사이에 할당해 준다. 각 프로세스는 자원을 할당받기 원하면 그 자원을 사용할 최대 시간을 지정한다. 모니터는 이 중 가장 적은 시간을 희망한 프로세스에 자원을 할당해준다. \n\n```java\nmonitor ResourceAllocator {\n\tboolean busy;\n\tcondition x;\n\n\tvoid acquire(int time) {\n\t\tif(busy) {\n\t\t\tx.wait(time);\n\t\t}\n\t\tbusy = true;\n\t}\n\n\tvoid release() {\n\t\tbusy = false;\n\t\tx.signal();\n\t}\n\n\tinitialization_code() {\n\t\tbusy = false;\n\t}\n}\n```\n\n모니터의 개념은 위에서 예시한 순서가 그대로 지켜지는 것을 보장해주지는 않는다. 다음과 같은 문제가 발생할 수 있다. \n\n- 프로세스가 자원에 대한 허락을 받지 않고 자원을 액세스할 경우\n- 프로세스가 자원에 대한 허락을 받은 다음 그 자원을 방출하지 않을 경우\n- 프로세스가 자원에 대한 허락을 받지 않았는데도 그 자원을 방출할 경우\n- 프로세스가 자원에 대한 허락을 받은 다음 방출하지 않은 상태에서 또 그 자원을 요청하는 경우\n\n위 문제는 세마포어를 사용할 때도 동일한 문제가 발생한다.  \n모니터처럼 프로그래머가 정의한 고급 연산의 올바른 사용법에서도 문제가 발생할 수 있는 것이다.  \n\n이 문제를 해결하기 위한 방법은 자원 액세스 연산 자체를 `ResourceAllocator` 내부에 두는 것이다. 그러나 이렇게 하면 스케줄링을 우리가 코딩한 스케줄링 방식이 아닌 모니터 자체의 스케줄러에 맡기는 것과 다름 없다.  \n\n따라서 프로세스들이 올바른 순서를 지키도록 보장하기 위해서는 `ResourceAllocator` 모니터와 모니터가 관리하는 자원을 사용하는 모든 프로그램을 검사해야 한다.  \n\n이 시스템이 제대로 작동하는지를 알려면 두 가지를 검사해야 한다.  \n\n1. 프로세스들이 모니터를 정확한 순서에 맞춰 호출해야 하는지 검사해야 한다.\n2. 비협조적인 프로세스가 액세스 제어 프로토콜을 사용하지 않아서 모니터가 정한 상호 배제 규칙 경로를 무시하여 공유 자원을 직접 액세스하지 않는다는 것을 보장해야 한다. \n\n이 조건들이 보장됐을 때만 시간 종속적인 오류가 일어나지 않고, 따라서 원하는 스케줄링이 지켜진다는 것을 보장할 수 있다.  \n\n## Java Monitors\n\nJava 는 스레드 동기화를 위한 모니터와 같은 병생성 기법을 제공한다.  \n`BoundedBuffer` 클래스는 생산자와 소비자 문제의 해결안을 구현한다.\n\nJava 의 모든 객체는 하나의 락과 연결되어 있다. 메서드가 `synchronized` 로 선언된 경우 메서드를 호출하려면 객체와 연결된 락을 획득해야 한다.  \n`BoundedBuffer` 클래스의 `insert()` 나 `remove()` 메서드와 같은 메서드를 정의할 때 `synchronized` 를 선언하면 `synchronized` 메서드가 된다. \n\n`synchronized` 메서드를 호출하려면 `BoundedBuffer` 의 객체 인스턴스와 연결된 락을 소유해야 한다.  \n다른 스레드가 이미 락은 소유한 경우, `synchronized` 메서드를 호출한 스레드는 BLOCKED 되어 객체의 락에 설정된 `entry set` (진입 집합) 에 추가된다.  \n\n### 진입 집합\n\n진입 집합이란 락이 가용한 경우 호출 스레드가 객체 락의 소유자가 되어 메서드로 진입하고, 스레드가 메서드를 종료하면 락이 해제된다.  \n\n락이 해제될 때 락에 대한 진입 집합이 비어있지 않으면 JVM 은 해당 집합에서 락 소유자가 될 스레드를 임의로 선택한다.  \n('임의로' 라는 뜻은 java 명세가 해당 집합의 스레드를 특정 순서로 구성해야 한다는 것을 요구하지 않는다는 뜻이다. 그러나 실제로 대부분의 가상 머신은 FIFO 정책에 따라 진입 집합의 스레드를 정렬한다.)\n\n### 대기 집합\n\n락을 갖는 것 외에도 모든 객체는 스레드 집합으로 구성된 대기 집합과 연결된다.  \n대기 집합은 처음에는 비어 있다가, 스레드가 `synchronized` 메서드에 들어가면 객체 락을 소유한다.  \n그러나 해당 스레드는 특정 조건이 충족되지 않아 계속할 수 없다고 결정할 수 있다.  \n\nex. 생산자가 `insert()` 를 호출했는데 버퍼가 가득찬 경우, 스레드는 락을 해제하고 계속할 수 있는 조건이 충족될 때까지 기다린다.  \n\n- [I] 블록 동기화\n락이 획득된 시점과 해제된 시점 사이의 시간은 락 범위 (lock scope) 로 정의된다.  \n공유 데이터를 조작하는 코드의 비율이 적은 `synchronized` 메서드는 너무 큰 락 범위를 생성할 수 있다.  \n이런 경우 전체 메서드를 동기화하는 것보다 공유 데이터를 조작하는 코드 블럭만 동기화 하는 것이 좋다.  \n이런 설계로 인해 락 범위가 더 작아진다.  \n\n```java\npublic someMethod() {\n\t/* non-critical section */\n\tsynchronized(this) {\n\t\t/*critical section*/\n\t}\n\n\t/* remainder section */\n}\n```\n\n## Intrinsic Lock (고유 락)\n\nJava 의 동기화는 Intrinsic Lock 또는 Monitor lock 으로 알려진 내부 엔티티를 중심으로 만들어졌다.  \n\n고유 락은 동기화의 두 가지 측면, 객체의 상태에 대한 독점적 접근을 강제하고, 가시성에 필수적인 발생 전 관계를 설정하는 데 중요한 역할을 한다. \n\n객체의 필드에 대한 배타적이고 일관적인 접근이 필요한 스레드는 객체에 접근하기 전에 객체의 고유 락을 얻어야 하고, 접근이 완료되면 고유 락을 release(해제)해야 한다. \n\n스레드가 락을 획득한 시점부터 락을 해제한 때까지 '락을 소유했다' 라고 한다. 한 스레드가 고유 락을 소유하고 있는 경우, 다른 스레드는 동일한 락을 얻을 수 없다. 다른 스레드가 락을 얻으려고 시도하면 block 된다.\n\n스레드가 고유 락을 해제하면 해당 작업과 다음에 동일한 락을 얻는 작업 간에 선후 관계가 설정된다.  \n\n### synchronized 메서드의 락\n\n`synchronized` 메서드를 호출하면 해당 메서드의 객체에 대한 고유 락을 자동으로 획득하고, 메서드가 리턴될 때 락을 해제한다.\n\n정적 메서드의 경우 정적 `synchronized` 메서드가 호출되는 경우는 스레드가 클래스와 연관된 클래스 객체에 대한 고유 락을 획득하게 된다. (기반 되는 객체가 없으므로)  \n따라서 클래스의 정적 필드에 대한 접근은 클래스의 모든 인스턴스에 대한 락과 구별되는 락으로 제어된다.  \n\n- [?] 생성자에도 `synchronized` 가 가능한가?\n➡️ 불가능하다. 대신 생성자의 바디 부분에 `synchronized` 를 넣어서 필요한 경우 동기화를 할 수는 있다.\n\n### synchronized 코드\n\n`synchronized` statement 를 사용하여 `synchronized` 코드를 만들 수 있다.  \n`synchronized` statement 는 고유 락을 제공하는 객체를 지정해야 한다.  \n\n```java\npublic void addName(String name) {\n\tsynchronized(this) {\n\t\tlastName = name;\n\t\tnameCount++;\n\t}\n\tnameList.add(name);\n}\n```\n\n위 예제에서 `addName` 메서드는 `lastName`, `nameCount` 의 변경 사항을 동기화해야 하지만, 다르나 객체의 메서드 호출은 동기화하지 않아야 한다. (synchronized statment 에서 다른 객체의 메서드를 호출하면 Liveness 문제가 발생할 수 있다. )\n\nsynchronized statement 가 없으면 `nameList.add` 를 호출하기 위한 목적으로만 동기화되지 않은 별도의 메서드가 있어야 한다.\n\nsynchronized statement 는 세분화된 동기화를 통해 동시성을 개선하는 데 도움이 된다.  \n\n```java\npublic class MsLunch {\n    private long c1 = 0;\n    private long c2 = 0;\n    private Object lock1 = new Object();\n    private Object lock2 = new Object();\n\n    public void inc1() {\n        synchronized(lock1) {\n            c1++;\n        }\n    }\n\n    public void inc2() {\n        synchronized(lock2) {\n            c2++;\n        }\n    }\n}\n```\n\n## Java의 고유 락 재진입 (Reentrancy)\n\n스레드는 다른 스레드가 갖고 있는 락을 획득할 수는 없지만, 이미 소유하고 있는 락은 얻을 수 있다.  \n\n```java\npublic class Reentrancy {\n\tpublic synchronized void a() {\n\t\tSystem.out.println(\"a\");\n\t}\n\n\tpublic synchronized void b() {\n\t\tSystem.out.println(\"b\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Reentrancy().a();\n\t}\n}\n```\n\n자바의 Intrinsic Lock 은 재진입 가능하다. (락의 획득이 호출 단위가 아닌 스레드 단위로 일어나기 때문에) 즉, 이미 락을 획득한 스레드는 같은 락을 얻기 위해 대기할 필요가 없다. \n\n만약 자바의 고유 락이 재진입 가능하지 않다면, 해당 코드는 a 메서드 내부의 b 를 호출하는 지점에서 self deadlock 이 발생할 것이다.  \n\n### structured lock\n\n고유 락을 이용한 동기화는 `structured lock` (구조적인 락) 이라고 한다. `synchronized` 블록 단위로 락의 획득 / 해제가 일어나므로 구조적이라고 한다. `synchronized` 블록을 진입할 때 락 획득이 일어나고, 블록을 벗어날 때 락의 해제가 일어난다. 따라서 구조적인 락 A, B가 있을 때 A 획득 -> B 획득 -> B 해제 -> A 해제는 가능하지만, A 획득 -> B 획득 -> A 해제 -> B 해제 는 불가능하다. \n\n이런 순서로 락을 사용해야 하는 경우 `ReentrantLock` 과 같은 명시적인 락을 사용해야 한다.  \n\n### 가시성\n\n락을 사용하면 가시성의 문제가 사라진다.  \nJava 의 `synchronized` 키워드는 한 스레드가 수정한 내용이 다른 스레드에서 보이게 한다.  \n즉, 스레드가 락을 획득하는 경우 그 이전에 쓰인 값들의 가시성을 보장한다.  \n\n`synchronized` 블록에 들어갈 때와 나갈 때, 변수의 변경 사항은 모든 스레드에게 보여진다. 즉, 한 스레드가 `synchronized` 블록에서 변수를 수정하고 블록을 빠져나오면, 해당 변경 사항이 모든 스레드에 보여진다.\n\n#### (안 넣을 내용) Java 의 `synchronized` 는 어떻게 가시성을 제공하는가?\n\n**Java Memory Model (JMM)**\nJava 프로그램의 동시성 동작을 정의한다. 여러 스레드가 어떻게, 언제 메모리를 볼 수 있는지에 대한 규칙을 제공한다. `synchronized` 는 JMM 규칙에 따라 동작한다.\n\n가시성을 제공하는 메커니즘은 다음과 같다.\n1. 스레드가 관련된 객체의 monitor lock 을 획득한다.\n2. 스레드가 monitor lock 을 해제할 때, 해당 스레드의 로컬 메모리에 있던 변경 사항들이 주 메모리로 플러시 된다. 이로 인해 다른 스레드가 이후에 동일한 lock 을 획득하여 `synchronized` 블록에 들어갈 때, 해당 스레드가 가장 최근의 변경 사항들을 볼 수 있게 된다. \n3. JMM에는 happens-before 관계라는 개념이 존재한다. `synchronized` 의 happens-before 규칙은 이렇다. \n\t- 스레드 A 가 monitor lock 을 해제하기 전에 수행한 모든 동작들은 스레드 B 가 동일한 모니터 락을 획득한 후에 수행하는 모든 동작들보다 먼저 일어난 것으로 간주된다.\n\n- [?] happens-before 규칙?\n다중 스레드 환경에서 메모리 동작의 순서와 가시성을 보장하기 위한 관계를 설명한다. 이 관계는 **메모리 쓰기가 특정 동작 후에 언제 메모리 읽기에 보이게 될 것인지를 정의하는 데**에 사용된다. \n\nhappens-before 규칙의 일부는 다음과 같다. \n1. **프로그램 순서 규칙**: 한 스레드 내에서, 한 문장이 다음 문장보다 앞서 있다면, 첫 번째 문장의 동작은 두 번째 문장의 동작보다 `happens-before` 관계에 있다.\n2. **모니터(lock) 규칙**: `synchronized` 블록의 잠금 해제는 같은 락에 대한 후속 잠금 획득보다 `happens-before` 관계에 있다.\n3. **volatile 변수 규칙**: `volatile` 변수에 대한 쓰기는 같은 변수에 대한 후속 읽기보다 `happens-before` 관계에 있다.\n4. **스레드 시작 규칙**: 스레드 A에서 `Thread B.start()`를 호출하는 것은 스레드 B의 모든 동작보다 `happens-before` 관계에 있다.\n5. **스레드 종료 규칙**: 스레드 A의 모든 동작은 다른 스레드 B에서 `A.join()`이 성공적으로 반환되기 전보다 `happens-before` 관계에 있다.\n### Java Object 의 `wait()`, `notify()`\n\n```java\npackage java.lang;  \n  \npublic class Object {  \n\t...\n    public final native void notify();  \n  \n    public final native void notifyAll();  \n  \n\tpublic final void wait() throws InterruptedException {  \n\t\twait(0L);  \n\t}  \n\t  \n\tpublic final native void wait(long timeoutMillis) throws InterruptedException;  \n\t  \n\tpublic final void wait(long timeoutMillis, int nanos) throws InterruptedException {  \n\t        if (timeoutMillis < 0) {  \n\t            throw new IllegalArgumentException(\"timeoutMillis value is negative\");  \n\t        }  \n\t  \n\t        if (nanos < 0 || nanos > 999999) {  \n\t            throw new IllegalArgumentException(  \n\t                                \"nanosecond timeout value out of range\");  \n\t        }  \n\t  \n\t        if (nanos > 0 && timeoutMillis < Long.MAX_VALUE) {  \n\t            timeoutMillis++;  \n\t        }  \n\t  \n\t        wait(timeoutMillis);  \n\t    }  \n\t    \n\t    ...\n\t}\n}\n```\n\n모든 자바 객체는 `Object` 를 상속받으므로, 모든 자바 객체가 `wait()`, `notify()` 를 갖게 된다.  \n스레드가 어떤 객체의 `wait()` 를 호출하면 해당 객체의 intrinsic lock 을 얻기 위해 BLOCKED 상태로 진입한다.  \n\n스레드가 어떤 객체의 `notify()` 를 호출하면 해당 객체 intrinsic lock 을 얻기 위해 해당 객체 intrinsic lock에 대기중인 스레드 하나를 깨운다.  \n\n### `wait()` 메서드 호출 시\n\n스레드가 `wait()` 메서드를 호출하면 다음과 같은 현상이 발생한다.  \n\n1. 스레드가 객체의 락을 해제한다.\n2. 스레드 상태가 BLOCKED 로 설정된다.  \n3. 스레드는 해당 객체의 대기 집합으로 넣어진다.  \n\n생산자가 `insert()` 메서드를 호출하고, 버퍼가 가득 찬 걸 확인하면 `wait()` 메서드를 호출한다.  \n해당 호출은 락을 해제하고 생산자를 BLOCKED 하여 생산자를 개체의 대기 집합에 둔다. 생산자가 락을 해제했기 때문에 소비자는 궁극적으로 `remove()` 메서드로 진입하여 생산자를 위한 버퍼의 공간을 비운다.  \n\n![[monitor-wait-set.png]]\n\n소비자 스레드는 생산자가 진행할 수 있다는 것을 어떻게 알릴까?  \n보통 스레드가 `synchronized` 메서드를 종료하면 이탈 스레드는 객체와 연결된 락만 해제하여 진입 집합에서 스레드를 제거하고 락 소유권을 넘겨준다. \n그러나 `insert()` 및 `remove()` 메서드 끝에서 `notify()` 메서드를 호출한다. \n\n```java\npublic synchronized void insert(E item) {\n\twhile(count == BUFFER_SIZE) {\n\t\ttry {\n\t\t\twait();\n\t\t}\n\t\tcatch (InterruptedException ie) { }\n\t}\n\n\tbuffer[in] = item;\n\tin = (in + 1) % BUFFER_SIZE;\n\tcount++;\n\n\tnotify();   // notify 호출\n}\n\n/* Consumers call this method */\npublic synchronized E remove() {\n\tE item;\n\n\twhile(count == 0) {\n\t\ttry {\n\t\t\twait();\n\t\t}\n\t\tcatch (InterruptedException ie) { }\n\t}\n\n\titem = buffer[out];\n\tout = (out + 1) % BUFFER_SIZE;\n\tcount--;\n\n\tnotify();\n\n\treturn item;\n}\n```\n\n반드시 `synchronized` 블록 내에서만 호출이 가능하다. `wait()` 은 락 소유권을 넘겨주어야 하기 때문에, 만약 `wait()` 를 호출하는 스레드가 락을 소유하고 있지 않다면 에러가 발생한다.\n\n- [!] `sleep()` 과의 차이점\n`sleep()` 메서드는 현재 스레드를 잠시 멈추게만 할 뿐, 락의 소유권을 넘기지는 않는다. 잠든 스레드는 여전히 락을 가지고 있다. 이 때문에 우선순위가 낮은 스레드가 우선순위가 높은 스레드를 BLOCK 시키는 우선순위 역전 현상이 발생하기도 한다.\n\n락을 소유하던 스레드는 락 소유권을 넘겨주면서 WAITING 또는 TIMED_WAITING 상태로 변하게 된다. WAITING, TIMED_WAITING 상태의 스레드는 `notify` 나 `notifyAll` 메서드를 호출하여 RUNNABLE 상태로 변경 가능하다. (TIMED_WAITING 스레드 경우에는 생성자를 이용하여 특정 시간을 설정하고 대기하고, 특정 시간이 지나면 자동으로 RUNNABLE 상태로 변경된다.)\n\n### `notify()` 메서드 호출 시\n\n1. Wait Set 의 스레드 리스트에서 임의의 스레드 T 를 선택한다. (보통 FIFO 로 선택된다.)\n2. 스레드 T 를 Wait Set 에서 Entry Set 으로 이동한다. \n3. T의 상태를 BLOCKED 에서 Runnable 으로 설정한다. \n\nT는 이제 다른 스레드와 락 경쟁을 할 수 있다.  \nT 가 락 제어를 다시 획득하면 `wait()` 호출에서 복귀하여 count 값을 다시 확인할 수 있다.  \n\n### `notifyAll()` 메서드 호출 시\n\n`wait()` 을 건 모든 스레드들을 한 번에 깨운다.\n\n### 가정\n\n`wait()` 및 `notify()` 메서드 \n\n1. 생산자는 `insert()` 메서드를 호출하고, 락이 사용가능한지 확인한 후, 메서드로 진입한다. 메서드에 들어가면 생산자는 버퍼가 가득 찼음을 확인하고 `wait()` 을 호출한다. `wait()` 호출은 객체 락을 해제하고 생산자 상태를 BLOCKED 로 설정하고 생산자를 객체의 대기 집합으로 둔다.\n2. 소비자는 이제 객체에 대한 락을 사용할 수 있으므로 `remove()` 메서드를 호출하고 진입한다. 소비자는 버퍼에서 항목을 제거하고 `notify()` 를 호출한다. 소비자가 여전히 객체에 대한 락을 소유하고 있다. \n3. `notify()` 호출은 객체의 Wait Set 에서 생산자를 제거하고 생산자를 Entry Set 으로 이동하고 생산자의 상태를 Runnable 으로 설정한다.  \n4. 소비자가 `remove()` 메서드를 종료한다. `remove()` 메서드를 종료하면 객체의 락이 해제된다.  \n5. 생산자가 락을 다시 얻으려고 시도하고 성공한다. `wait()` 호출에서 실행을 재개한다. 생산자는 `while` 루프를 검사하고 버퍼에 여유 공간이 있는지 확인한 후 `insert()` 메서드의 남은 부분을 진행한다. 객체의 Entry Set 에 스레드가 없으면 `notify()` 호출은 무시된다. 생산자가 메서드를 종료하면 객체에 대한 락이 해제된다.  \n\n`synchronized wait()` 과 `notify()` 기법은 Java 에서 처음부터 제공되었다. 그러나 `Java API` 이후 버전에서는 훨씬 더 융통성 있고 강력한 락 기법이 도입되었다.  \n\n## Reentrant Lock\n\nAPI 에서 사용 가능한 가장 간단한 락 기법은 `ReentrantLock` 이다. 여러 가지 면에서 위 메서드처럼 작동한다. `ReentrantLock` 은 단일 스레드가 소유하며 공유 자원에 대한 상호 배타적 액세스를 제공하는 데 사용된다. 그러나 공정성 매개변수 설정과 같은 몇 가지 추가 기능이 제공된다. \n\n- [?] 공정성이란 오래 기다린 스레드에 락을 줄 수 있는 설정을 말한다. JVM 명세는 객체 락의 대기 집합의 스레드가 특정 방식으로 정렬되어야 한다는 것을 명시하지 않기 때문에 가능하다. \n\n스레드는 `lock()` 메서드를 호출하여 `ReentrantLock` 을 획득한다. 락을 사용할 수 있거나 `lock()` 을 호출한 스레드가 이미 락을 소유하고 있는 경우, `lock()` 은 호출 스레드는 소유자가 `unlock()` 을 호출하여 락이 배정될 때까지 BLOCKED 된다. 이것이 재진입이라고 명명된 이유이다. \n\n락을 사용할 수 없는 경우 호출 스레드는 소유자가 `unlock()` 을 호출하여 락이 배정될 때까지 BLOCKED된다. `ReentrantLock` 은 `Lock` 인터페이스를 구현한다. \n\n```java\nLock key = new ReentrantLock();\n\nkey.lock();\ntry {\n\t/* critical section */\n}\nfinally {\n\tkey.unlock();\n}\n```\n\n`lock()` 메서드를 통해 락을 획득하고, critical section 이 완료되거나, `try` 블록 내에서 예외가 발생하면 락이 해제되도록 한다.  \n\n단, `lock()` 은 checked 예외를 발생시키지 않으므로 `try` 절에 넣지 않는다.  \n\n이유는 다음과 같다. \n`try` 절 내에 `lock()` 을 배치하고 `lock()` 이 호출될 때 unchecked 예외가 발생하면 (`OutofMemoryError` 등) 문제가 발생할 수 있다.  \n`finally` 는 `unlock()` 을 호출하는데, 락이 획득된 상태가 아니면 `unlock()` 이 `IllegalMonitorStaateException` 을 발생시킨다.  \n\n**`ReentrantLock` 은 블록 구조를 가지고 있지 않기 때문에, `finally` 블록 내에서 `unlock()` 메서드를 사용하여 락을 명시적으로 해제해주어야 한다!**\n\n해당 예외가 `lock()` 을 호출할 때 발생한 unchecked 예외를 대신하게 되기 때문에 실패한 원인을 찾기 어렵게 만든다.  \n\n`ReentrantLock` 은 상호 배제를 제공하지만, 여러 스레드가 공유 데이터를 읽기만 하고 쓰지 않을 때는 너무 보수적인 전략일 수 있다.  (7.1.2 에서 설명했다네요)\n이를 위해 `ReentrantReadWriteLock` 을 제공한다. Reader 는 여러 개일 수 있지만, writer 는 반드시 하나여야 하는 락이다.\n\n### `synchronized` vs `ReentrantLock`\n\nintrinsic lock 과 `ReentrantLock` 은 동일한 락과 메모리 시멘틱을 제공한다. `ReentrantLock` 의 성능은 Intrinsic Lock 의 성능을 압도하는 것처럼 보인다. 그렇다면 왜 synchronized 를 deprecated 하지 않고, 모든 동시성 코드가 `ReentrantLock` 으로 바꾸지 않는 걸까?\n\n`ReentrantLock` 은 intrinsic lock 이 실용적이지 않은 상황을 위한 도구이다. time out, polling, 중단 가능한 락 획득, 공정한 queueing 또는 not-blocking 구조 락과 같은 고급 기능이 필요한 경우에 사용하고, 그렇지 않다면 `synchronized` 를 선택해라.\n\nJava 5.0 에서는 JVM 이 어떤 스레드가 `ReentrantLock` 을 보유하는지 알 수 없어서 스레딩 문제를 디버깅하는 데에 도움을 줄 수 없었다. \n\nintrinsic lock 은 명시적 락에 비해 여전히 상당한 이점이 존재한다. 가장 주목할만한 점은 친숙하고, 간단하다는 것이다. 많은 기존 프로그램에서 intrinsic lock 을 사용하고 있는데 이를 혼용하게 되면 혼란을 야기할 수 있다. 락은 동기화보다 훨씬 더 위험한 도구다.\n\n## Intrinsic Lock vs Monitor\n\nJava 의 Intrinsic Lock 과 Monitor 는 사실상 동일한 개념이다.  \n\n- [i] Intrinsic Locks (내장 락)\nJava의 모든 객체는 내부적으로 Intrinsic Lock 을 갖는다.  \n해당 락은 `synchronized` 메서드나 `synchronized` 블록에 들어갈 때 자동으로 획득된다. \n내장 락이 활성화된 상태에서는 해당 락을 소유하고 있는 스레드만 해당 코드 블록을 실행할 수 있다. \n\n- [i] Monitor\nMonitor 는 상호 배타적인 코드의 실행을 돕는 동기화 메커니즘이다.  \nJava 의 모든 객체는 하나의 모니터를 가진다.  \n`wait()` , `notify()`, `notifyAll()` 등의 메서드를 통해 조건 변수를 다루고 스레드 간의 통신을 할 수 있다.  \n\n## 궁금한 점\n\n- `wait()`, `notify()` 가 어떻게 다른 스레드에게 전달되는 것인가? (OS 단에서)\n\t- \n- 왜 Java 의 모든 객체는 하나의 모니터를 가지도록 구현되었을까?\n\t- 모든 객체에 모니터를 내장함으로써 개발자는 추가적인 동기화 메커니즘을 별도로 구현하거나 탐색할 필요 없이 동시성 제어를 할 수 있다.\n\t- 개발자가 어떤 객체든 동기화를 위해 `synchronized` 를 사용할 수 있다는 일관성이 생긴다.\n\t- 그러나 메모리 오버헤드가 있다. 실제로 대부분의 객체는 동기화가 필요하지 않을 수 있다. 이런 이유로 JVM 구현자들이 모니터에 대한 오버헤드를 최소화하기 위한 다양한 최적화 전략을 사용하고 있다.\n- 그렇다면 왜 멀티 스레드 환경에서 synchronized 는 안 좋을까?\n- Monitor lock 은 왜 필요한가?\n- 세마포어와 비교했을 때 Monitor Lock 이 이점을 갖는 부분은 무엇인가?\n\t- 개발자의 실수로 발생하는 에러를 줄일 수 있다.\n\t- 개발자가 따로 동기화를 수행하기 위한 코드를 작성하지 않아도 된다.\n- Monitor Lock 은 어떤 부분에서\b단점을 갖는가?\n\t- \n- Java 에서 재진입을 허용하게 된 이유는 무엇인가?\n\t- 정확하게는 재진입이 될 수 밖에 없다. 스레드 단위로 고유 락을 획득할 수 있기 때문에 굳이 락을 가지고 있는 경우 다시 획득할 필요가 없기 때문이다.\n- 가시성 문제란 무엇인가?\n- happens-before 란 무엇인가?\n\t- 위에 있음\n- 생산자-소비자 문제란 무엇인가?\n\t- 위에 있음\n- 생산자-소비자 문제는 왜 해결해야 하는가?\n\t- 생산자 소비자가 동시에 동작하면 버퍼 오버플로우, 버퍼 언더플로우가 발생할 수 있다. 또한 생산자와 소비자가 동시에 공유 자원에 접근하면 데이터의 무결성이 손상될 수 있다.\n\t- 무한 대기 상태에 빠진 스레드나 프로세스가 리소스를 계속 점유하게 되어 시스템의 효율성이 저하된다.\n- Java 에서 Monitor Lock 을 가지게 됨으로써 얻을 수 있는 이점은 무엇인가?\n- notify() 를 수행했을 때 다음 스레드는 어떻게 결정되는가?\n\t- 거의 대부분 무작위로 결정된다. JLS, JVM 사양에는 공정성과 스케줄링에 대한 언급이 없다. 그러나 자바 객체 중 `ReentrantLock` 의 경우 fairness 를 제공하는 락을 만들 수 있다. \n- java 말고 다른 언어에도 Monitor lock 이 적용된 곳이 있는가?\n- Monitor Lock 이 적용되지 않은 언어가 있다면 어떻게 구현되어 있는가?\n- `ReentrantLock` 은 상호 배제를 제공하지만, 여러 스레드가 공유 데이터를 읽기만 하고 쓰지 않을 때는 너무 보수적인 전략일 수 있다. => 왜일까?\n\t- 여러 스레드가 동시에 데이터를 읽을 때, 해당 데이터가 변경되지 않는 한 데이터의 일관성이나 무결성에 문제가 생기지 않는다. 그러나 모든 읽기 연산에 `ReentrantLock` 을 사용하면 동시에 수행될 수 있는 여러 읽기 연산이 서로 블로킹될 수 있다. 이는 불필요한 대기 시간으로, 전체 시스템의 처리량 / 성능을 저하시킨다.\n\t- 읽기 연산만 있는 경우에도 락과 해제를 관리하는 코드를 추가해야 한다. 이는 코드의 복잡성을 높이고, 락을 해제하는 것을 잊어버릴 위험이 있다.\n- java 객체는 어떻게 intrinsic lock 을 내장하고 있는가?\n\t- \n- `notify()` 는 `wait()` 중인 스레드에만 알리나?\n\t- `notify()` 나 `notifyAll` 메서드는 `wait()` 으로 인해 대기 중인 스레드들만 깨운다.\n\t- WAITING: `wait()`, `join()`, `LockSupport.park()` 등의 메서드 호출로 인해 대기 중인 상태이다. `notify`, `notifyAll` 메서드에 의해 깨어날 수 있다.\n\t- BLOCKING: 스레드가 내장 락을 획득하기 위해 대기 중인 상태. 다른 스레드가 현재 그 락을 보유하고 있을 때 이 상태로 전환된다. 해당 락이 풀릴 때까지 BLOCKED 상태로 대기한다.\n\t\t- 현재 락을 보유하고 있는 스레드가 synchronized 블록을 나오면서 락을 해제하게 되면, JVM 은 BLOCKED 상태의 스레드 중 하나를 선택하여 해당 락을 획득하게 된다. 선택된 스레드는 RUNNABLE 상태로 전환되어 실행을 재개한다.\n\t- RUNNABLE: 스레드가 실행될 수 있는 상태. 실제로 CPU 시간을 얻어 실행되고 있는 상태나 실행을 위해 준비된 상태를 포함한다.\n- `wait()` 을 하면 고유 락이 해제되나?\n\t- 그렇다. `wait()` 메서드를 호출하면 현재 스레드가 해당 객체의 고유 락을 해제하고, WAITING, TIMED_WAITING 상태로 진입한다.\n- JVM 이 fairness 를 보장하지 않는 이유는 무엇일까?\n\t- 스레드들이 요청한 순서대로 락을 획득하게 해야 하기 때문에, 추가적인 관리 로직이 필요하다. 이 과정에서 락 획득 / 해제 시에 추가 오버헤드가 있을 수 있다.\n\t- 락을 획득하기 위해 대기하는 스레드들에게 순서대로 락을 할당하면 CPU 캐시 locality 가 저하될 수 있다. 스레드가 락을 획득한 직후에 실행하면 그 스레드의 데이터는 CPU 캐시에 존재할 확률이 높다. fairness 를 보장하면서 락을 실행하면, 다른 스레드가 락을 획득하게 되어 캐시 미스가 더 자주 발생할 수 있다.\n\t- 자바 intrinsic lock 은 성능 최적화를 우선시하는 경향이 있어서 fairness 를 보장하지 않는다.\n- `wait` 과 block 의 우선순위?\n\t- 공식적으로 정의되어 있지 않다. 해당 우선순위는 JVM 과 OS 의 스레드 스케줄링 정책에 따라 다를 수 있다. 일반적으로 스레드 스케줄링은 JVM 내부 구현과 운영 체제에 의존하고, Java 언어 자체에서는 특정 우선순위를 정의하지 않는다.\n- `wait()` 메서드는 언제 깨어날 수 있을까?\n\t- 다른 스레드가 `notify()`, `notifyAll` 을 호출했을 때\n\t- `wait(long timeout)` 같이 타임아웃과 함께 호출된 경우\n\t- 스레드가 인터럽트되었을 때 \n\t\t- 스레드 종료 요청: 긴 작업을 수행하는 스레드가 있을 때, 해당 작업을 중단하도록 요청하는 경우 (ex. 백그라운드에서 파일을 다운로드하는 스레드가 있을 때 사용자가 중단 버튼을 누르면 인터럽트를 통해 스레드에 중단을 요청할 수 있다.)\n\t\t- 대기 중인 스레드 깨우기: `sleep()` , `wait()`, `join()` 등의 메서드로 인해 대기 중인 스레드를 깨울 때, 인터럽트가 발생하면 `InterruptedException` 이 발생한다.\n\t\t- I/O 작업 중인 스레드에 인터럽트: 특정 자바 I/O 작업은 블로킹될 수 있다.\n\t\t- `interrupt()` 메서드를 사용하면 스레드 인터럽트를 발생시킬 수 있다.\n\t- [[spurious-wakeups]] 이 발생한 경우\n- 왜 while 문을 돌면서 `wait()` 을 해야 하는가?\n\t- [[spurious-wakeups]] 를 방지하기 위해서\n## 목차\n\n1. 세마포어의 한계와 Monitor Lock 의 필요성\n2. Java 의 Monitor Lock: Intrinsic Lock\n3. Java Monitors 코드\n4. Reentrant Lock 소개\n5. 성능과 가시성\n6. 결론: Monitor Lock 의 중요성과 Java 에 적용된 것 요약\n\n## 참고\n\n- https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\n- https://backtony.github.io/java/2022-05-04-java-50/\n- http://happinessoncode.com/2017/10/04/java-intrinsic-lock/\n- https://www.baeldung.com/java-synchronized\n- https://happy-coding-day.tistory.com/entry/JAVA-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\n- https://www.youtube.com/watch?v=yWprp019_n4&t=967s\n"},{"excerpt":"","fields":{"slug":"/why-string-is-final/"},"frontmatter":{"date":"2023년 08월 21일 05:08","title":"왜 Java 에서 String 은 불변인가?","tags":["java","string","미완"]},"rawMarkdownBody":"\n"},{"excerpt":"과정 회고 중... 새로운 기술을 적극적으로 도입하고, 팀원들을 설득하는 과정이 많은 공부가 되었습니다.\n팀원들의 방식대로 개발을 하게 되면서, 지금까지 해오던 방식과 다른 방식으로 개발하게 되었습니다. 팀에서 정한 방식과 내가 정한 방식의 장단을 비교할 수 있었던 것이 성장에 도움이 되었습니다.\n내 의견만 밀고 나가는 것만이 정답이 아님을 알게 되었습니…","fields":{"slug":"/level3-launching-festival-retrospect/"},"frontmatter":{"date":"2023년 08월 19일 03:08","title":"론칭 페스티벌 회고","tags":["레벨3","우테코","shook","회고","미완성"]},"rawMarkdownBody":"\n## 과정 회고 중...\n\n새로운 기술을 적극적으로 도입하고, 팀원들을 설득하는 과정이 많은 공부가 되었습니다.\n팀원들의 방식대로 개발을 하게 되면서, 지금까지 해오던 방식과 다른 방식으로 개발하게 되었습니다. 팀에서 정한 방식과 내가 정한 방식의 장단을 비교할 수 있었던 것이 성장에 도움이 되었습니다.\n내 의견만 밀고 나가는 것만이 정답이 아님을 알게 되었습니다. 팀원들과 충분히 상의하고, 프로젝트 주제에 대한 싱크를 맞춘 후에 프로젝트를 진행하는 것이 얼마나 중요한 일인지 알게 되었습니다.\n데드라인이 2주 정도로 맞춰져 있어 일정에 맞춰 개발할 수 있게 되었습니다."},{"excerpt":"LOG 팀원들은 밤샘을 한다... 마음만은 함께야 다들 파이팅 배운 것 swagger API 문서를 열려면 swagger 의 css, js 파일이 필요한데,  의 정적 파일에 접근할 때 root 만 접근할 수 있기 때문에 ubuntu 로 접근하면 권한 문제가 발생한다. ubuntu 에도 권한을 부여해주면 접근할 수 있다!!! 궁금한 것 느낀 것","fields":{"slug":"/2023-08-17/"},"frontmatter":{"date":"2023년 08월 17일 09:08","title":"2023년 08월 17일","tags":null},"rawMarkdownBody":"## LOG\n\n- 팀원들은 밤샘을 한다... 마음만은 함께야 다들 파이팅\n\n## 배운 것\n\n- swagger API 문서를 열려면 swagger 의 css, js 파일이 필요한데, `/var/nginx` 의 정적 파일에 접근할 때 root 만 접근할 수 있기 때문에 ubuntu 로 접근하면 권한 문제가 발생한다. ubuntu 에도 권한을 부여해주면 접근할 수 있다!!!\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"Spring Framework 에서 제공하는 서블릿 필터이다.  를 상속하고 있다.\n리버스 프록시나 로드 밸런서 같은 중개자 서버에 의해 설정된  헤더를 처리하는 역할을 수행한다. removeOnly 로 구성할 수도 있는데, 이 경우 헤더를 제거하지만 사용하지는 않는다. 메서드  는 단일 요청 스레드 내에서 요청당 한 번만 호출되도록 보장한다. : ,  …","fields":{"slug":"/forwarded-header-filter/"},"frontmatter":{"date":"2023년 08월 17일 04:08","title":"ForwardedHeaderFilter","tags":["spring"]},"rawMarkdownBody":"\n## `ForwardedHeaderFilter`\n\nSpring Framework 에서 제공하는 서블릿 필터이다. `OncePerRequestFilter` 를 상속하고 있다.\n리버스 프록시나 로드 밸런서 같은 중개자 서버에 의해 설정된 `X-Forwarded-*` 헤더를 처리하는 역할을 수행한다.\n\nremoveOnly 로 구성할 수도 있는데, 이 경우 헤더를 제거하지만 사용하지는 않는다.\n\n### 메서드\n\n- `doFilterInternal` 는 단일 요청 스레드 내에서 요청당 한 번만 호출되도록 보장한다.\n- `setRemoveOnly`: `Forwarded`, `X-Forwarded-*` 헤더만 제거되고 그 안의 정보는 무시되는 모드를 활성화한다.\n\n## 역할\n\n1. URL Reconstruction\n원본 요청의 스키마 `X-Forwarded-Proto` , 호스트 `X-Forwarded-Host`, 포트 `X-Forwarded-Port` 및 경로 접두사 `X-Forwarded-Prefix` 에 관한 정보를 이용하여 요청 URL 을 재구성한다.\n애플리케이션 내에서 `HttpServletRequest` 를 사용해서 URL 정보를 조회할 때, 리버스 프록시나 로드 밸런서 뒤에서의 원래 요청 정보를 바탕으로 한 올바른 URL 정보를 얻을 수 있다.\n\n2. Scheme & Remote Address\n`X-Forwarded-Proto` 헤더를 기반으로 요청 스키마 (http, https) 를 업데이트한다.\n`X-Forwarded-For` 헤더를 사용하여 원래 클라이언트의 IP 주소를 알아낸다. 이렇게 하면 `HttpServletRequest.getRemoteAddr()` 호출 시 원래 클라이언트의 IP 를 반환할 수 있다.\n\n3. Clearing Forwarded Headers\n필터는 처리 후 `X-Forwarded-*` 헤더를 요청에서 제거할 수 있다. 보안 목적으로 유용하다.\n\n## Spring 에 설정하기\n\n`ForwardedHeaderFilter` 는 자동으로 활성화되지 않는다.\n\n```yml\nserver:\n\tforward-headers-strategy: framework\n```\n\n이렇게 `application.yml` 을 설정해주면 `ForwardedHeaderFilter` 가 자동으로 등록되어 사용될 수 있다.\n\n## 알아보기\n\n지원하는 헤더들은 다음과 같다.  \n\n```java\nstatic {  \n    FORWARDED_HEADER_NAMES.add(\"Forwarded\");  \n    FORWARDED_HEADER_NAMES.add(\"X-Forwarded-Host\");  \n    FORWARDED_HEADER_NAMES.add(\"X-Forwarded-Port\");  \n    FORWARDED_HEADER_NAMES.add(\"X-Forwarded-Proto\");  \n    FORWARDED_HEADER_NAMES.add(\"X-Forwarded-Prefix\");  \n    FORWARDED_HEADER_NAMES.add(\"X-Forwarded-Ssl\");  \n    FORWARDED_HEADER_NAMES.add(\"X-Forwarded-For\");  \n}\n```\n\n### `doFilterInternal`\n\n```java\n@Override  \nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,  \n       FilterChain filterChain) throws ServletException, IOException {  \n  \n    if (this.removeOnly) {  \n       ForwardedHeaderRemovingRequest wrappedRequest = new ForwardedHeaderRemovingRequest(request);  \n       filterChain.doFilter(wrappedRequest, response);  \n    }  \n    else {  \n       HttpServletRequest wrappedRequest =  \n             new ForwardedHeaderExtractingRequest(request);  \n  \n       HttpServletResponse wrappedResponse = this.relativeRedirects ?  \n             RelativeRedirectResponseWrapper.wrapIfNecessary(response, HttpStatus.SEE_OTHER) :  \n             new ForwardedHeaderExtractingResponse(response, wrappedRequest);  \n  \n       filterChain.doFilter(wrappedRequest, wrappedResponse);  \n    }  \n}\n```\n\n`ForwardedHeaderExtractingRequest` 로 래핑한 뒤, filterChain 으로 전달한다.\n\n#### `ForwardedHeaderRemovingRequest` \n\n`removeOnly` 가 설정되어 있을 때 변환되는 Request 이다.\n\n```java\nprivate static class ForwardedHeaderRemovingRequest extends HttpServletRequestWrapper {  \n  \n    private final Set<String> headerNames;  \n  \n    public ForwardedHeaderRemovingRequest(HttpServletRequest request) {  \n       super(request);  \n       this.headerNames = headerNames(request);  \n    }  \n  \n    private static Set<String> headerNames(HttpServletRequest request) {  \n       Set<String> headerNames = Collections.newSetFromMap(new LinkedCaseInsensitiveMap<>(Locale.ENGLISH));  \n       Enumeration<String> names = request.getHeaderNames();  \n       while (names.hasMoreElements()) {  \n          String name = names.nextElement();  \n          if (!FORWARDED_HEADER_NAMES.contains(name)) {  \n             headerNames.add(name);  \n          }  \n       }       return Collections.unmodifiableSet(headerNames);  \n    }  \n  \n    // Override header accessors to not expose forwarded headers  \n  \n    @Override  \n    @Nullable    \n    public String getHeader(String name) {  \n       if (FORWARDED_HEADER_NAMES.contains(name)) {  \n          return null;  \n       }  \n       return super.getHeader(name);  \n    }  \n  \n    @Override  \n    public Enumeration<String> getHeaders(String name) {  \n       if (FORWARDED_HEADER_NAMES.contains(name)) {  \n          return Collections.emptyEnumeration();  \n       }  \n       return super.getHeaders(name);  \n    }  \n  \n    @Override  \n    public Enumeration<String> getHeaderNames() {  \n       return Collections.enumeration(this.headerNames);  \n    }  \n}\n```\n\n`FORWARDED_HEADER_NAMES` 를 요청할 때, 빈 Enumeration list 를 반환하거나, null 을 리턴한다.\n\n### `ForwardedHeaderExtractingRequest`\n\n```java\nprivate static class ForwardedHeaderExtractingRequest extends ForwardedHeaderRemovingRequest {  \n  \n    @Nullable  \n    private final String scheme;  \n  \n    private final boolean secure;  \n  \n    @Nullable  \n    private final String host;  \n  \n    private final int port;  \n  \n    @Nullable  \n    private final InetSocketAddress remoteAddress;  \n  \n    private final ForwardedPrefixExtractor forwardedPrefixExtractor;  \n  \n  \n    ForwardedHeaderExtractingRequest(HttpServletRequest servletRequest) {  \n       super(servletRequest);  \n  \n       ServerHttpRequest request = new ServletServerHttpRequest(servletRequest);  \n       UriComponents uriComponents = UriComponentsBuilder.fromHttpRequest(request).build();  \n       int port = uriComponents.getPort();  \n  \n       this.scheme = uriComponents.getScheme();  \n       this.secure = \"https\".equals(this.scheme) || \"wss\".equals(this.scheme);  \n       this.host = uriComponents.getHost();  \n       this.port = (port == -1 ? (this.secure ? 443 : 80) : port);  \n  \n       this.remoteAddress = UriComponentsBuilder.parseForwardedFor(request, request.getRemoteAddress());  \n  \n       String baseUrl = this.scheme + \"://\" + this.host + (port == -1 ? \"\" : \":\" + port);  \n       Supplier<HttpServletRequest> delegateRequest = () -> (HttpServletRequest) getRequest();  \n       this.forwardedPrefixExtractor = new ForwardedPrefixExtractor(delegateRequest, baseUrl);  \n    }  \n  \n  \n    @Override  \n    @Nullable    \n    public String getScheme() {  \n       return this.scheme;  \n    }  \n  \n    @Override  \n    @Nullable    \n    public String getServerName() {  \n       return this.host;  \n    }  \n  \n    @Override  \n    public int getServerPort() {  \n       return this.port;  \n    }  \n  \n    @Override  \n    public boolean isSecure() {  \n       return this.secure;  \n    }  \n  \n    @Override  \n    public String getContextPath() {  \n       return this.forwardedPrefixExtractor.getContextPath();  \n    }  \n  \n    @Override  \n    public String getRequestURI() {  \n       return this.forwardedPrefixExtractor.getRequestUri();  \n    }  \n  \n    @Override  \n    public StringBuffer getRequestURL() {  \n       return this.forwardedPrefixExtractor.getRequestUrl();  \n    }  \n  \n    @Override  \n    @Nullable    \n    public String getRemoteHost() {  \n       return (this.remoteAddress != null ? this.remoteAddress.getHostString() : super.getRemoteHost());  \n    }  \n  \n    @Override  \n    @Nullable    \n    public String getRemoteAddr() {  \n       return (this.remoteAddress != null ? this.remoteAddress.getHostString() : super.getRemoteAddr());  \n    }  \n  \n    @Override  \n    public int getRemotePort() {  \n       return (this.remoteAddress != null ? this.remoteAddress.getPort() : super.getRemotePort());  \n    }  \n}\n```\n\nHEADER 에서 `X-Forwarded` 정보를 뽑아내어 baseUrl 을 복원한다."},{"excerpt":"상황 설명 S-HOOK 은 로그인 된 회원만 투표, 좋아요, 댓글 활동을 할 수 있습니다. 그러려면 인증/인가 로직이 필수적으로 필요합니다. 해당 사용자가 우리 회원인지 확인하고, 회원인 경우에만 투표 / 좋아요 / 댓글 기능을 쓸 수 있게 만들어야 하기 때문이죠. 이를 위해 OAuth + JWT 인증 로직을 도입했는데요, JWT 를 통해 클라이언트로 전…","fields":{"slug":"/interceptor-argument-resolver-authenticated/"},"frontmatter":{"date":"2023년 08월 16일 01:08","title":"Interceptor 나 Argument Resolver 에서 member를 조회해서 컨트롤러로 전달해주면 안 되나?","tags":["spring","interceptor","argument-resolver","shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 상황 설명\n\nS-HOOK 은 로그인 된 회원만 투표, 좋아요, 댓글 활동을 할 수 있습니다.     \n그러려면 인증/인가 로직이 필수적으로 필요합니다. 해당 사용자가 우리 회원인지 확인하고, 회원인 경우에만 투표 / 좋아요 / 댓글 기능을 쓸 수 있게 만들어야 하기 때문이죠.      \n\n이를 위해 OAuth + JWT 인증 로직을 도입했는데요, JWT 를 통해 클라이언트로 전달되는 값은 회원의 id 값입니다.      \n\n현재 s-hook 의 코드에서는 interceptor 단에서 따로 id를 통해 member 가 존재하는지 조회하지 않습니다. 토큰이 유효하기만 한다면 그대로 파싱된 id 를 argument resolver 로 전달하는 로직입니다.     \n\n이런 인증 과정에 대해 들었던 개인적인 의문과 이에 답할 수 있는 여러 의견들을 정리해보았습니다.\n\n## 의문이 들었던 부분들\n\n### 회원의 id 를 interceptor 에서 검증하지 않아도 될까?\n\n가장 먼저 의문이 들었던 부분은 `JWT 내부에 들어있는 회원의 id 값을 검증하지 않아도 될까?`  라는 것입니다.     \n\n토큰 내부에 있는 id 가 데이터베이스에 존재하지 않는 member 라면 문제가 발생할 수도 있지 않을까요? \n#### JWT\n\n결론만 말하자면, 저희 서비스에서 사용하는 JWT 에서는 토큰 내부에 있는 값을 검증할 '필요가 없습니다'\n\n그 이유는 JWT 의 목적에 있습니다.     \n\nJWT 는 데이터를 암호화하기 위함이 아닌, 데이터의 무결성을 보장하기 위한 목적으로 설계 되었습니다. 즉, 데이터가 변조되지 않았다는 것만을 확인하기 위한 것입니다.     \n\n또한 JWT 는 사용자 인증 후에 '서버' 로부터 발급받는 것이므로, 토큰이 발급되는 시점에서 사용자는 이미 검증되었다고 간주합니다.    \n\n따라서 토큰이 유효하고, 변조되지 않았고, 토큰이 만료되지 않았다면 토큰 내부의 데이터는 신뢰할 수 있다고 볼 수 있습니다. 물론 JWT 를 생성할 때 필요한 secret key 는 반드시 외부에 노출되지 않았어야 하겠지요.\n\n#### JWT 인증 과정\n\nJWT 의 인증을 위해서는 다음과 같은 과정을 수행해야 합니다.     \n\n1. 토큰의 서명 확인\n2. 유효 기간 확인\n3. 토큰 발급자 확인\n4. 토큰 수신자 확인\n5. 토큰 고유 식별자 확인\n\n이런 인증 과정을 모두 통과한 JWT 는 우리 서버에서 발급한 토큰이라고 간주되어, 내부의 데이터를 신뢰할 수 있습니다.     \n\n무엇보다 JWT 를 사용하는 주된 이유는 인증 후에 사용자의 상태나 세션 정보를 저장하지 않고, 서버에서 stateless 하게 시스템을 운영하기 위해서입니다. \n\n즉, 매 요청마다 사용자의 ID 와 비밀번호를 검증하는 것을 피하기 위해 JWT 를 사용하는 것이죠.\n\n### 사용자의 ID 는 민감한 정보가 아닐까?\n\nJWT 를 생성할 때 중요하게 고려해야 하는 사항이 있습니다. JWT 는 암호화를 하는 것이 아니기 때문에 내부의 데이터가 민감한 정보인 경우, 불특정 다수에게 정보가 노출될 수 있습니다.    \n\n그러므로 S-HOOK 서버에서 발행한 JWT 내부에 들어가는 사용자의 ID 는 민감한 정보가 아니어야 합니다.     \n\n그렇다면 사용자 ID 는 민감한 정보가 아닐까요?\n마찬가지로 '저희 서비스에서는' YES 입니다.    \n\nS-HOOK 은 사용자 ID 만으로 수행할 수 있는 요청은 존재하지 않습니다. ID 를 가지고 서버 시스템 내부를 조작하거나 특정 행동을 수행할 수는 없습니다.     \n\n또한 대개의 경우, 사용자 ID 는 민감한 정보로 간주되지 않는다고 합니다. 사용자 ID 를 JWT 페이로드에 포함하는 것이 관행일 만큼 말이죠.     \n\n### 컨트롤러 메서드 파라미터에 Member 객체를 넘겨주면 안 될까?\n\nJWT 내부의 ID 를 검증하지 않아도 되는 건 이제 알겠습니다.     \n\n그렇다면 컨트롤러 메서드 파라미터로 Member id 를 전달하는 대신, Member 를 만들어서 보내주면 안 되는 걸까요?     \n\n현재 인증 로직에서는 Member 가 필요한 각 서비스마다 `MemberService` 를 주입 받아 id 로 Member 를 조회하는 중복 코드가 존재합니다. Interceptor 나 Argument Resolver 가 대신 `MemberService` 를 주입 받아서 Member 를 만들어준다면 중복 코드도 없어지고 좋지 않을까요?\n\n#### 계층적 관점으로 보았을 때 괜찮을까?\n\n먼저 계층적 관점에서 살펴보겠습니다.     \nInterceptor 와 Argument Resolver 에서 Member 를 조회해도 '괜찮은 걸까요'?\n\nS-HOOK 의 코드는 Layered Architecture 를 기반으로 설계되었습니다.     \n\n계층적 구조를 따르면 각 계층마다 명확한 책임을 가지고 있어서, 기능과 역할을 더 쉽게 관리할 수 있습니다.    \n또한 각 계층을 독립적으로 개발 / 테스트할 수 있어 단위 테스트가 용이합니다.    \n특히 특정 계층의 구현이 변경되어도 다른 계층에 비교적 적은 영향을 미칩니다. 이를 통해 유지보수와 확장성을 향상시킬 수 있습니다.     \n\n그렇다면 Argument Resolver / Interceptor 에서 Member 를 조회하면 계층적 구조를 위반해서 문제가 발생할까요?     \n\n엄밀히 말하면 계층적 구조를 위반한다고도 볼 수 있습니다. Interceptor 와 Argument Resolver 는 Web Layer 에 속한다고 생각한다면, Application Layer 에 속하는 `MemberService` 에 접근하는 것은 Presentation Layer 를 거치지 않아 규칙을 위반한 것이기 때문이죠.\n\n그러나 실용적으로 생각했을 때, 횡단 관심사인 `Member` 의 조회를 Interceptor 나 Argument Resolver 에서 수행하는 것은 효율적이고 편리한 접근 방식입니다.      \n\n다만 아래와 같은 문제점이 발생할 수 있다는 것은 인지해야 합니다.     \n\n1. 테스트가 복잡하다.\n도메인 객체가 Argument Resolver / Interceptor 를 통해 전달되는 경우, 컨트롤러의 단위 테스트를 작성할 때 코드가 복잡해질 수 있습니다.     \n\n2. 코드의 유연성이 떨어질 수 있다.\n도메인 객체의 조회 로직이나 생성 방식이 변경되는 경우 Argument Resolver / Interceptor 로 영향이 전파될 수 있습니다.\n\n문제점을 충분히 이해했고 감안할 수 있는 부분이라고 생각된다면, 다음으로 넘어가 봅시다!\n\n#### 도메인 객체가 Presentation 계층에 노출되었을 때 문제점은 없을까?\n\nArgument Resolver 나 Interceptor 에서 Member 를 조회한다면, 컨트롤러 메서드 파라미터로 Member 객체가 전달됩니다.     \n이로써 비즈니스 로직이 포함된 도메인 객체가 Presentation 계층에 노출되었다고 볼 수 있습니다. 이럴 때 발생할 수 있는 문제점은 없을까요?\n\n**문제점**\n\n1. 도메인과 컨트롤러의 결합도가 증가합니다.\n도메인 객체에 변경이 발생한 경우, Presentation Layer 에도 영향을 줄 수 있으므로 시스템의 결합도가 높아진다고 볼 수 있습니다.     \n\n2. 비즈니스 로직의 흐름을 파악하기 어려울 수 있습니다.\n서비스가 직접적으로 인증 / 인가 로직을 포함하지 않기 때문에, 프로젝트 팀원이 아닌 사람이 비즈니스 로직의 전체 흐름을 파악하기 어려울 수 있습니다.     \n\n그러나 현재 저희 애플리케이션에서는 단순히 ID 로 Member 를 조회하는 로직만 수행하기 때문에, 아직까지 위의 문제점이 크게 문제가 되는 부분은 없을 듯 합니다. (프로젝트를 함께 진행하고 있는 팀이 계층간의 분리를 중시한다면 다른 판단을 내릴 수도 있을 것입니다)\n\n### Interceptor vs Argument Resolver\n\n그렇다면 Interceptor 또는 Argument Resolver 를 사용하는 것이 좋지 않을까? 라고 생각하셨을 겁니다.\n그렇다면 둘 중 어디에서 `MemberService` 를 사용하여 Member 를 조회하는 것이 좋을까요?\n\n#### Member 를 interceptor 에서 조회하자\n\nInterceptor 는 요청의 전처리 / 후처리와 요청 / 응답의 변경, 로깅, 인증과 권한 체크 같은 기능을 수행할 때 사용됩니다. 또한 여러 컨트롤러에 대해 동일한 로직을 적용하고 싶을 때 효과적으로 사용할 수 있습니다.     \n\n그러나 Interceptor 에서 id로 부터 Member 를 생성하는 것은 Interceptor 가 수행해야 하는 일을 넘어섰다고도 볼 수 있습니다.    \nid 값으로부터 Member 를 조회하여 전달하는 것은 '요청과 응답을 가공' 하는 것과는 거리가 멀기 때문입니다.     \n\n또한 Interceptor 는 요청의 생명 주기 내에서 `preHandle`, `postHandle`, `afterCompletion` 에서 동작하므로, 파라미터를 변환하는 데에 적합한 생명주기를 갖고 있다고 말하기 어려울 수 있습니다. 변환될 Member 는 요청 전체에서 사용되는 것이 아닌, 컨트롤러의 메서드 파라미터로 전달되어 Service 로 넘겨지기 위해서 사용되기 때문입니다. \n\n그러므로 Interceptor 에서는 JWT 의 유효성 검사나 권한을 체크하는 등, 인증 / 인가와 관련된 로직을 수행하는 것이 더 적합하다고 할 수 있겠습니다.\n\n#### Member 를 Argument Resolver 에서 조회하자\n\nArgument Resolver 는 컨트롤러의 메서드 파라미터를 동적으로 생성하거나 변환하는 로직을 구현할 때 주로 사용됩니다.    \n\nJWT 로부터 얻은 사용자의 ID 를 Member 로 변환하기 위해 Member 를 조회하는 것은 Argument Resolver 가 수행하는 것이 어색하지 않습니다.\n\n#### JPA를 사용할 때 발생할 수 있는 문제점\n\n> 오 그러면 Argument Resolver 에서 Member 조회해서 컨트롤러로 전달해야겠다 😄\n\n그러나 이 글을 읽고 계시는 분이 프로젝트에서 JPA 를 사용하신다면 반드시 고려하셔야 하는 사항이 있습니다.     \n\n**OSIV**\n\nOSIV 는 Open Session In View 의 약자로, JPA 의 Session 이나 Hibernate 의 SessionFactory 가 HTTP 요청의 시작부터 종료까지 열린 상태로 유지되게 하는 패턴입니다.     \nSpring 에서는 기본적으로 활성화가 되어 있지만, 하나의 세션 안의 트랜잭션들이 동일한 영속성 컨텍스트를 공유하기 때문에 주의를 요합니다.      \n\n(OSIV 에 대해서는 추후 글을 자세하게 적어보겠습니다.)\n\nArgument Resolver 에서 주의해야 하는 경우는 **OSIV 설정이 꺼져있을 때** 입니다.     \n\n다음과 같이 yaml 파일에서 OSIV 설정을 꺼줄 수 있습니다.\n\n```yaml\nspring:\n\tjpa:\n\t\topen-in-view: false\n```\n\nArgument Resolver 가 `MemberService` 로 Member 를 조회한다고 해봅시다.\n\n```java\n@Component  \npublic class AuthArgumentResolver implements HandlerMethodArgumentResolver {  \n  \n    private final AuthContext authContext;  \n    private final MemberService memberService;  \n  \n    public AuthArgumentResolver(final AuthContext authContext, final MemberService memberService) {  \n        this.authContext = authContext;  \n        this.memberService = memberService;  \n    }  \n  \n    @Override  \n    public boolean supportsParameter(final MethodParameter parameter) {  \n\t\treturn parameter.hasParameterAnnotation(Authenticated.class);  \n    }  \n  \n    @Override  \n    public Object resolveArgument(  \n        final MethodParameter parameter,  \n        final ModelAndViewContainer mavContainer,  \n        final NativeWebRequest webRequest,  \n        final WebDataBinderFactory binderFactory  \n    ) {  \n        return memberService.findById(authContext.getMemberId());  \n    }  \n}\n```\n\n실험을 위해 기존에 Argument Resolver 로부터 Member 의 ID 를 전달받던 `KillingPartLikeController` 를 다음과 같이 변경했습니다.     \n\n```java\npublic class KillingPartLikeController {  \n  \n    private final KillingPartLikeService killingPartLikeService;  \n  \n    @PutMapping  \n    public ResponseEntity<Void> createLikeOnKillingPart(  \n        @PathVariable(name = \"killing_part_id\") final Long killingPartId,  \n        @Valid @RequestBody final KillingPartLikeRequest request,  \n        @Authenticated final Member member  \n    ) {  \n        killingPartLikeService.updateLikeStatus(killingPartId, member, request);  \n  \n        return ResponseEntity.status(HttpStatus.CREATED).build();  \n    }  \n}\n```\n\n`KillingPartCommentService` 에서는 `EntityManager` 를 가져와서 Member 가 존재하는지 확인해보겠습니다.     \n\n```java\n@Transactional(readOnly = true)  \n@Service  \npublic class KillingPartLikeService {  \n  \n    private final KillingPartRepository killingPartRepository;  \n    private final MemberRepository memberRepository;  \n    private final KillingPartLikeRepository likeRepository;  \n  \n    @Autowired  \n    private EntityManager entityManager;  \n  \n    @Transactional  \n    public void updateLikeStatus(  \n        final Long killingPartId,  \n        final Member member,  \n        final KillingPartLikeRequest request  \n    ) {  \n        System.out.println(\"====================Member 가 존재할까====================\");  \n        System.out.println(entityManager.contains(member));  \n        System.out.println(\"====================결과 출력 완료====================\");  \n        \n        ...\n    }\n```\n\n이렇게 설정해두고, 실제 요청을 보내게 되면 `MemberService` 에서 열린 새로운 트랜잭션의 영속성 컨텍스트에는 Argument Resolver 에서 조회한 Member 가 포함되어 있지 않는 것을 볼 수 있습니다.    \n\n![[entity-manager-cannot-find-member.png]]\n\n왜 이런 일이 발생했을까요?     \n\nArgument Resolver 에서 Member 를 조회한 후에 컨트롤러에 전달합니다. 그런데 `MemberService` 의 트랜잭션이 닫히면서 조회한 Member 는 준영속 상태가 됩니다.     \n준영속 상태인 엔티티가 영속성 컨텍스트에 포함되기 위해서는 DB 에서 Member 를 다시 조회해야 합니다.      \n\n결국 Service의 메서드 파라미터로 전달된 Member 에 변경이 발생했어도 영속성 컨텍스트는 변경 감지를 할 수 없게 됩니다.     \n\n현재 저희 서비스에서는 Member 가 변경되는 일이 존재하지 않습니다. 그러나 추후 OSIV 설정을 꺼 둔 상태에서 Member 에 변경이 발생하는 경우 문제의 원인을 찾기 힘들 것입니다.      \n\n따라서 JPA 를 사용하고 OSIV 설정을 꺼두었을 경우, Argument Resolver 나 Interceptor 에서 Member 를 조회해서 컨트롤러로 전달할 때 주의해야 합니다.     \n\n## 결론\n\n> 그래서 뭐 어떻게 하면 좋다는 거야 🤷🏻‍♂️\n\n라는 생각이 드실지도 모르겠습니다.      \n\n제 나름의 결론은 다음과 같습니다.\n\n- JWT 를 사용할 때 토큰 내부의 값을 검증할 필요는 없다.\n- Argument Resolver 와 Interceptor 중에서는 Argument Resolver 에서 Member 를 조회하는 것이 낫다.\n- OSIV 설정이 꺼져 있고, 비즈니스 로직 상에서 Member 의 변경이 발생할 가능성이 있는 경우 오히려 준영속 상태의 Member 를 조회하기 위한 쿼리가 추가로 발생하므로, 중복 코드가 발생하더라도 Service 에서 Member 를 조회하는 것이 좋아보인다.\n\n제 결론이 정답은 아니고 다양한 상황이 있을 수 있으므로 상황에 맞게 사용하시면 좋겠습니다."},{"excerpt":"5분 스피치 주제 여러분, 이런 경험 없으셨나요? 여기 맨날 듣던 노래 말고 다른 좋은 노래 듣고 싶다. 그런데 노래를 처음부터 듣기는 귀찮아... 결국 이렇게 똑같은 노래를 다시 들어보신적 없으신가요? 이 노래 들어봐 너무 좋아! 하면서 노래를 추천했는데, 첫 소절만 들어보고 별로라고 하는 친구 때문에 클라이막스가 진짜 좋다고 제발 클라이막스를 들어달라…","fields":{"slug":"/shook-five-minute-speech/"},"frontmatter":{"date":"2023년 08월 15일 03:08","title":"S-HOOK 5분 스피치","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 5분 스피치 주제\n\n여러분, 이런 경험 없으셨나요?\n\n여기 맨날 듣던 노래 말고 다른 좋은 노래 듣고 싶다. 그런데 노래를 처음부터 듣기는 귀찮아... 결국 이렇게 똑같은 노래를 다시 들어보신적 없으신가요?\n\n이 노래 들어봐 너무 좋아! 하면서 노래를 추천했는데, 첫 소절만 들어보고 별로라고 하는 친구 때문에 클라이막스가 진짜 좋다고 제발 클라이막스를 들어달라고 애원하는 B 씨도 있습니다.\n\n왜 이런 상황들이 발생했을까요?\n바로, 노래를 첫 소절부터 들을 때, 한 번에 좋은 노래인지 파악할 수 없다는 문제 때문입니다. 첫 소절부터 좋은 노래는 흔치 않으니까요.      \n그렇다면 노래를 듣자마자 좋은 노래인지 알 수 있다면 어떨까요?       \n\nS-HOOK 은 이 질문에서부터 시작합니다.      \n\nS-HOOK 의 핵심 가치는 지금 들을 좋은 노래를 슉! 하고 빠르게 찾자는 것입니다.      \n\n이를 위해서는 총 세 가지가 필요합니다.      \n\n첫 번째, '다함께' 입니다.     \nS-HOOK 의 킬링파트는 모든 유저와 함께 만들어져야 합니다.     \n\n두 번째, '빠르게' 입니다.     \n킬링파트만으로 다양한 노래를 빠르게 탐색할 수 있어야 합니다.     \n\n세 번째, '즐겁게' 입니다.     \n킬링파트를 들어보고, 다른 사람들과 의견을 나누며 S-HOOK 을 사용하는 것이 즐거운 경험이어야 합니다.\n\n이 핵심가치를 실현하기 위한 S-HOOK 의 기능들을 소개합니다.     \n\nS-HOOK 에서는 사람들이 요즘 어떤 노래를 듣는지 알 수 있습니다.       \n유저들이 가장 많이 좋아했던 노래들을 들어보실 수 있습니다.\n\n다음은 노래를 빠르게 찾을 수 있는 기능, 킬링파트입니다.      \n킬링파트는 5초에서 15초의 길이로 지정되어 있고, 오른쪽의 버튼을 누르면 킬링파트 영상 url 을 복사할 수 있습니다. 재생 버튼을 누르면 킬링파트가 재생됩니다.      \n\n킬링파트를 이용해서 처음부터 노래를 들을 필요 없이, 사람들이 가장 좋아하는 킬링파트를 들어볼 수 있습니다.     \n스와이프로 노래를 넘기며 많은 노래를 빠르게 들어보세요!\n\nS-HOOK 의 킬링파트는 유저들의 참여로 만들어집니다.      \n킬링파트의 길이를 선택하고, 슬라이더로 범위를 지정한 뒤, 등록할 수 있습니다.     \n만약 여러분이 좋아하는 노래가 있으시다면 그 노래의 킬링파트에 기여해보세요!        \n\n모두가 믿고 들을 수 있는 킬링파트를 위해, 로그인을 하지 않은 유저는 킬링파트를 등록할 수 없습니다.     \n\n킬링파트가 마음에 드신다면, 좋아요를 눌러 킬링파트에 대한 여러분의 관심을 표현하실 수 있습니다. \n만약, 킬링파트에 대해 의견이 있으시다면, 킬링파트 댓글로 여러분의 의견을 나누어주세요. \n\n내가 예전에 좋아했던 부분을 다시 들어보고 싶다면, 마이페이지에서 좋았던 킬링파트들을 언제든지 다시 들어보세요.     \n\n좋은 음악이 필요한 순간, S-HOOK이 여러분과 함께 하겠습니다.       \n지금까지 S-HOOK 의 발표였습니다. 감사합니다.   "},{"excerpt":"LOG 배운 것  에서 읽기 전용 트랜잭션으로 멤버를 조회한 후, 컨트롤러에 전달한다. 그러나 읽기 전용 트랜잭션이 종료되면서, 멤버는 준영속 상태가 된다. 준영속 상태인 엔티티를 다시 영속성 컨텍스트에 포함하려면 다시 조회해야 한다. 궁금한 것 느낀 것","fields":{"slug":"/2023-08-16/"},"frontmatter":{"date":"2023년 08월 15일 02:08","title":"2023년 08월 16일","tags":null},"rawMarkdownBody":"## LOG\n\n## 배운 것\n\n- `interceptor` 에서 읽기 전용 트랜잭션으로 멤버를 조회한 후, 컨트롤러에 전달한다. 그러나 읽기 전용 트랜잭션이 종료되면서, 멤버는 준영속 상태가 된다. 준영속 상태인 엔티티를 다시 영속성 컨텍스트에 포함하려면 다시 조회해야 한다.\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"테스트 격리가 되지 않으면 발생하는 문제 인수 테스트 메서드를 추가했는데, 이전에는 잘 동작하던 테스트가 깨지는 상황이 발생했다.  문제는 테스트 격리가 되어 있지 않기 때문이다. 조회를 하기 위해 repository 로 값을 저장해둔 상태였는데, 다른 테스트 메서드에서 조회할 때 다른 테스트 메서드에서 저장해둔 값이 함께 조회된 것이었다.  에 이전에 …","fields":{"slug":"/test-isolation/"},"frontmatter":{"date":"2023년 08월 12일 16:08","title":"S-HOOK 테스트 격리","tags":["shook","테스트","레벨3","우테코","spring","trouble-shooting"]},"rawMarkdownBody":"\n## 테스트 격리가 되지 않으면 발생하는 문제\n\n인수 테스트 메서드를 추가했는데, 이전에는 잘 동작하던 테스트가 깨지는 상황이 발생했다.    \n\n![[acceptance-test-failed.png]]\n\n문제는 테스트 격리가 되어 있지 않기 때문이다.    \n\n조회를 하기 위해 repository 로 값을 저장해둔 상태였는데, 다른 테스트 메서드에서 조회할 때 다른 테스트 메서드에서 저장해둔 값이 함께 조회된 것이었다.     \n\n```java\n@DisplayName(\"특정 노래를 조회할 때, 이전 노래와 다음 노래의 정보를 담은 응답을 반환한다.\")  \n@Test  \nvoid findById() {  \n    // given  \n    final VotingSong beforeSong = votingSongRepository.save(  \n        new VotingSong(\"제목1\", \"비디오URL\", \"이미지URL\", \"가수\", 20));  \n    final VotingSong standardSong = votingSongRepository.save(  \n        new VotingSong(\"제목2\", \"비디오URL\", \"이미지URL\", \"가수\", 20));  \n  \n    // when  \n    final VotingSongSwipeResponse response = RestAssured.given().log().all()  \n        .when().log().all()  \n        .get(\"/voting-songs/{voting_song_id}\", standardSong.getId())  \n        .then().log().all()  \n        .statusCode(HttpStatus.OK.value())  \n        .extract()  \n        .body().as(VotingSongSwipeResponse.class);  \n  \n    // then  \n    final List<VotingSongResponse> expectedBefore = Stream.of(beforeSong)  \n        .map(VotingSongResponse::from)  \n        .toList();  \n  \n    assertAll(  \n        () -> assertThat(response.getBeforeSongs()).usingRecursiveComparison()  \n            .isEqualTo(expectedBefore),  \n        () -> assertThat(response.getCurrentSong()).usingRecursiveComparison()  \n            .isEqualTo(VotingSongResponse.from(standardSong)),  \n        () -> assertThat(response.getAfterSongs()).isEmpty()  \n    );  \n}\n```\n\n`getBeforeSongs` 에 이전에 등록했던 값들이 마구 추가되어 있었다.\n\n인수테스트에서 테스트 사이에 영향을 줄 수 없도록, 인수테스트 격리를 해보자!\n\n## 테이블 TRUNCATE 하기\n\n```java\npackage shook.shook.support;  \n  \nimport jakarta.annotation.PostConstruct;  \nimport jakarta.persistence.Entity;  \nimport jakarta.persistence.EntityManager;  \nimport jakarta.persistence.PersistenceContext;  \nimport jakarta.persistence.metamodel.EntityType;  \nimport java.util.List;  \nimport org.springframework.context.annotation.Profile;  \nimport org.springframework.stereotype.Component;  \nimport org.springframework.transaction.annotation.Transactional;  \n  \n@Component  \n@Profile(\"test\")  \npublic class DataCleaner {  \n  \n    private static final String TRUNCATE_FORMAT = \"TRUNCATE TABLE %s\";  \n    private static final String ALTER_TABLE_FORMAT = \"ALTER TABLE %s ALTER COLUMN ID RESTART WITH 1\";  \n    private static final String CAMEL_CASE_REGEX = \"([a-z])([A-Z]+)\";  \n    private static final String SNAKE_CASE_REGEX = \"$1_$2\";  \n  \n    private List<String> tableNames;  \n  \n    @PersistenceContext  \n    private EntityManager entityManager;  \n  \n    @PostConstruct  \n    public void findDatabaseTableNames() {  \n        tableNames = entityManager.getMetamodel().getEntities().stream()  \n            .filter(DataCleaner::isEntityClass)  \n            .map(DataCleaner::convertCamelCaseToSnakeCase)  \n            .toList();  \n    }  \n  \n    private static boolean isEntityClass(final EntityType<?> e) {  \n        return e.getJavaType().getAnnotation(Entity.class) != null;  \n    }  \n  \n    private static String convertCamelCaseToSnakeCase(final EntityType<?> e) {  \n        return e.getName().replaceAll(CAMEL_CASE_REGEX, SNAKE_CASE_REGEX).toLowerCase();  \n    }  \n  \n    @Transactional  \n    public void clear() {  \n        entityManager.flush();  \n        entityManager.clear();  \n        truncate();  \n    }  \n  \n    private void truncate() {  \n        for (String tableName : tableNames) {  \n            entityManager.createNativeQuery(String.format(TRUNCATE_FORMAT, tableName))  \n                .executeUpdate();  \n            entityManager.createNativeQuery(String.format(ALTER_TABLE_FORMAT, tableName))  \n                .executeUpdate();  \n        }  \n    }}\n```\n\n### 설명\n\ntest 프로필에서만 bean 이 주입되도록 `@Profile(\"test\")` 를 달아주었다.     \n\n**`findDatabaseTableNames()`**\n\n해당 bean이 생성된 이후에 entity 클래스들을 가져와서 클래스 이름을 Camelcase 에서 snake_case 로 변경해준다.     \nDB 테이블 이름은 snake_case 이기 때문이다!\n\n**`clear()`**\n\n쓰기 지연 저장소에 남아있는 쿼리들을 모두 수행한다.     \n영속성 컨텍스트에 남아있는 데이터들을 모두 삭제한 후, 테이블을 `TRUNCATE` 한다.\n\n**`truncate()`**\n\n테이블을 `TRUNCATE` 하고, auto-increment 된 PK 값을 1로 돌려 놓는다.\n\n## `AcceptanceTest` 클래스 생성\n\nS-HOOK 에서 인수테스트는 공통적으로 `@SpringBootTest` 를 사용한다.     \n따라서 모든 인수테스트에서 동일하게 테스트 격리를 수행하기 위해 + `DataCleaner` 를 언제나 `@Autowired` 하는 귀찮음을 덜기 위해 공통 부분을 `AcceptanceTest` 클래스로 분리했다.    \n\n```java\npackage shook.shook.support;  \n  \nimport io.restassured.RestAssured;  \nimport org.junit.jupiter.api.BeforeEach;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.boot.test.context.SpringBootTest;  \nimport org.springframework.boot.test.context.SpringBootTest.WebEnvironment;  \nimport org.springframework.boot.test.web.server.LocalServerPort;  \n  \n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)  \npublic class AcceptanceTest {  \n  \n    @Autowired  \n    private DataCleaner dataCleaner;  \n  \n    @LocalServerPort  \n    private int port;  \n  \n    @BeforeEach  \n    void setUp() {  \n        RestAssured.port = port;  \n        dataCleaner.clear();  \n    }  \n}\n```\n\n이제 인수테스트를 작성할 때 `AcceptanceTest` 를 상속 받아 사용하면 된다.    \n\n```java\nclass VotingSongControllerTest extends AcceptanceTest {\n\t// ...\n}\n```\n\n![[acceptance-test-success.png]]\n\n테스트 격리가 완료되어 모든 테스트가 통과하는 것을 볼 수 있다!"},{"excerpt":"운영 서버 설정 커스텀 로그 저장을 위해  내부에 app, warn, error 디렉터리를 추가했다. ( 는 새로 만든 디렉터리) nginx 설정 먼저 nginx 를 설치한다. Certbot 설정 SSL 인증서 발급을 위해 Certbot 을 설치한다. 여러 개의 도메인 인증서 발급을 위해 다음과 같이 작성한다. 팀 이메일을 입력하고 생성했더니 에러가 발생…","fields":{"slug":"/shook-prod-server-setting/"},"frontmatter":{"date":"2023년 08월 11일 09:08","title":"S-HOOK 운영 서버 설정 실록","tags":["aws","shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 운영 서버 설정\n\n커스텀 로그 저장을 위해 `/etc/log` 내부에 app, warn, error 디렉터리를 추가했다. (`/etc/log` 는 새로 만든 디렉터리)\n### nginx 설정\n\n먼저 nginx 를 설치한다.\n\n```bash\nsudo apt-get install nginx\n```\n\n```bash\ncd /etc/nginx\n```\n\n### Certbot 설정\n\nSSL 인증서 발급을 위해 Certbot 을 설치한다. \n\n```bash\nsudo apt-get install certbot python3-certbot-nginx\n```\n\n여러 개의 도메인 인증서 발급을 위해 다음과 같이 작성한다.\n\n```bash\nsudo certbot --nginx -d s-hook.com -d www.s-hook.com\n```\n\n팀 이메일을 입력하고 생성했더니 에러가 발생했다.    \n\n문제는... 가비아 서브 도메인이 잘못 설정되어 있었다.     \n\n기존에는 CNAME 으로 호스트 이름에 dev, 값에 `s-hook.com` 으로 해두었는데, 기존 `s-hook.com` 개발 서버로 연결되었다. CNAME 을 사용하면 기존 도메인으로 리다이렉트 해주는 듯 하다.      \n\n해결 방법은 쉽다!     \nA 레코드로 호스트 이름에 새로운 서브도메인으로 사용할 prefix를 작성하고 (ex. dev) 값에 새로운 운영 서버 ip 를 작성한다.      \n\n![[gabia-cname-a-record.png]]\n\n기존 개발 서버가 사용하는 도메인을 운영 서버에서 등록하려고 했는데, 등록할 수 없다는 에러가 발생했다.     \n\n원인은 이미 도메인이 연결되어서 그렇다! \n\n### 개발 서버 도메인 인증서 삭제\n\n기존에 개발 서버에서 `s-hook.com` 을 사용하고 있었기 때문에 `s-hook.com` 을 사용하기 위해서는 개발 서버의 인증서를 삭제해야 한다.     \n\n`certbot delete --cert-name s-hook.com` 로 기존 도메인을 삭제했다.     \n또한 nginx default 파일 (`/etc/nginx/sites-enabled`)에서 certbot 이 작성한 코드를 삭제한다.\n\n개발 서버에는 개발 서브 도메인을 새롭게 연결해주었다.     \n\n프론트엔드 .env.production 파일의 도메인 이름을 변경해준 뒤, frontend 파일들을 재빌드했다.\n\n```bash\nsudo npm ci\nsudo npm run build\n```\n\n이렇게 하면 `dev.s-hook.com` 은 개발서버로 연결되어 새롭게 접속할 수 있다.\n\n### 다시 운영 서버 인증서 발급\n\n운영 서버에서 해당 도메인에 대해 새롭게 인증서를 발급받는다.      \n\n```bash\nsudo certbot --nginx -d s-hook.com www.s-hook.com\n```\n\n여기까지 진행하면 certbot 이 nginx 파일을 바꿔준다.    \n\n```bash\nnginx -t\nsudo service nginx restart\n```\n\n### 서브 모듈 설정\n\nS-HOOK 은 민감한 정보를 보호하기 위해 서브 모듈을 사용한다.     \n\n그러나 서버에 아무 설정도 하지 않으면 운영 서버에서 서브 모듈을 pull 받아올 수 없다. private 레포이기 때문에 권한이 없기 때문이다.     \n따라서 운영 서버에도 서브 모듈을 사용하려면 SSH 설정을 해주어야 한다!     \n\n```bash\nssh-keygen -t rsa\n```\n\n다음과 같이 ssh 키를 생성한다.      \n생성된 ssh key를 서브모듈 레포지토리 owner 의 SSH Key 에 넣어주면 된다.     \n\n![[ssh-key-register.png]]\n\n새롭게 서브모듈을 설정하므로 init 을 해주어야 한다.    \n\n```bash\ngit submodule init\ngit submodule update\n```\n\n여기까지 했는데 갑자기 Username 을 적으라고 한다.\n\n![[submodule-exception.png]]\n\n아무리 Username 과 Password 를 쳐도 소용 없다.    \n서브모듈을 등록하기 위해 서브 모듈을 삭제하고, 캐시도 지웠다.    \n\n```bash\nrm -rf shook-security/\ngit rm -r --cached shook-security\n```\n\nEC2에서 발급한 Key 를 등록하고, Git Submodule add 를 다시 진행한다.    \nSSH 주소는 서브모듈의 ssh git 링크를 가져와야 한다.     \n\n![[submodule-ssh-address.png]]\n\n중간에 npm 이 없어서 `sudo apt-get install npm` 을 해주었다.    \n\n순탄하게 설치될 줄 알았으나.... npm 설치하는데 서버가 죽을뻔했다.    \n아예 서버 접속이 안 됐다.     \n한 10분 기다려서 접속됐는데 free -m 해보니 메모리를 다 쓰고 있었다.     \n\n`npm --version` 하는데 10분째다.     \n\n![[dying-shook-prod-server.png]]\n\n그래서 일단 타자라도 치기 위해 npm 을 죽였다...ㅋㅋㅋ    \n\n```bash\nsudo kill -9 3897\n```\n\n### 스왑 메모리 설정\n\n이런 일이 발생하지 않게 하기 위해 스왑 메모리를 설정했다.    \n\n```bash\nsudo fallocate -l 4G /swapfile # 스왑 메모리의 크기는 4G 로 설정했다. \nsudo chmod 600 /swapfile # 읽기 / 쓰기 권한을 소유자에게 부여한다.\nsudo mkswap /swapfile  # swapfile 설정\nsudo swapon /swapfile # swap 메모리 켜기\n```\n\n### 다시 npm 설치\n\n잘못된 버전의 npm 을 삭제하고 LTS npm 을 설치한다.\n\n```bash\nsudo apt-get remove npm\nsudo apt-get install npm\n```\n\n도밥 왈, npm install 은 frontend 파일이 있는 곳에서 수행해야 한다고 한다.     \n\nnode 버전이 안 맞아서 node 버전 업그레이드도 해줬다.    \n\n```bash\nsudo n lts  # 노드 최신 버전 업그레이드\nhash -r # 캐시 삭제\n```\n\nfrontend 에서 `sudo npm install` 을 수행한다.    \n\n### frontend 배포\n\nfrontend 가 요청을 보낼 url 을 설정해준다.    \n\n`/frontend/.env` 의 `.env.production` 에 API 를 요청할 도메인 이름을 적어준 후, frontend 파일을 빌드한다.    \n\n```bash\nsudo npm ci\nsudo npm run build\n```\n\n### Java 설치\n\n백엔드 배포를 하다가 Java 가 없는 걸 발견했다.     \n즉시 설치해주자. \n\n```bash\n wget -O- https://apt.corretto.aws/corretto.key | sudo apt-key add - \n sudo add-apt-repository 'deb https://apt.corretto.aws stable main'\n\nsudo apt-get install -y java-17-amazon-corretto-jdk\n```\n\n백엔드 배포를 했더니 에러가 발생했다!! build가 잘 됐다는 뜻이다 드디어 ㅠㅠㅠ\n\n![[shook-prod-slack-notification.png]]\n\n운영 DB 를 설정해주지 않았기 때문에 에러가 발생했다.      \n그래도 슬랙으로 에러 알림이 잘 오는 것을 확인했다.    \n\n이제 운영 DB를 설정해보자!\n## 운영 DB 설정하기\n\n### pem 키 옮기기\n\nDB 서버는 프라이빗 ip 만 존재하기 때문에 운영 서버로만 접근할 수 있다.     \n그래서 로컬에 있는 운영 서버 pem 키를 운영 서버로 전송했다.     \n\n```bash\nscp -i 2023-shook.pem 2023-shook.pem ubuntu@우리ip:~\n```\n\nbad permission 에러를 막기 위해 pem key 에 권한을 부여한다.    \n\n```bash\nchmod 400 2023-shook.pem\n```\n\n운영 서버에서 DB 서버로 접속한다.     \n\n```bash\nssh -i pemkey이름 ubuntu@DB서버ip\n```\n\n### MySQL 설치\n\nMySQL 을 사용할 것이므로 MySQL 을 설치해준다.    \n\n```bash\nsudo apt-get update\nsudo apt-get install mysql-server\n```\n\nMySQL을 실행한다.     \n\n```bash\nsudo systemctl start mysql\n```\n\n다 했으니 MySQL 에 접속해보자!\n\n```bash\nsudo /usr/bin/mysql -u root -p\n```\n\n잘 접속된다!\n\n팀 내부에서 root 대신 새로운 사용자를 등록하기로 했기 때문에, MySQL 에 새로운 사용자를 추가하자.\n\n### MySQL 사용자 추가\n\n새로운 사용자를 추가하기 위해서는 다음과 같이 설정해주면 된다.\n\n```mysql\ncreate user 사용자이름@운영서버ip identified by '비밀번호';\n```\n\n하다가 잘못된 유저를 만든 경우 (우리의 경우...) 유저를 삭제해준다.    \n\n```mysql\ndrop user '사용자이름'@'호스트';\n```\n\n사용자를 만든 뒤에, 권한을 설정해준다.    \n모든 권한을 주려면 아래와 같이 설정한다.    \n\n```mysql\ngrant all privileges on *.* to '사용자이름'@'호스트';\nflush privileges;\n```\n\n### 데이터베이스 생성\n\n운영 서버에서 사용할 데이터베이스를 생성해준다.   \n\n```mysql\ncreate database 데이터베이스이름;\n```\n\n현재 `sql.init=always` 설정이 되어 있기 때문에 data.sql 을 삭제했다.    \n\n기존에 dev 용으로 사용하던 더미 데이터가 운영 DB에 올라가면 안 되기 때문이다.     \n이제 더 이상 `sql.init` 설정은 사용하지 않을 예정이다.    \n\n### bind-address\n\n외부 접속을 허용해주기 위해 `/etc/mysql/mysql.conf.d` 의 `mysqld.cnf` 에 들어가서 bind-address 를 수정해준다.   \n\n설정 파일을 수정하고, mysql 을 재시작한다.\n\n```bash\nsudo systemctl restart mysql\n```\n\n## 백엔드 배포\n\n### log 디렉터리 권한 에러\n\n배포를 시작하는데 log 에 권한 에러가 발생했다.    \n로그와 관련된 모든 디렉터리에 권한을 할당해주었다.     \n\n```bash\nsudo chmod 775 etc/\nsudo chmod 777 app\nsudo chmod 777 error\nsudo chmod 777 warn\n```\n\n이렇게 했더니 DB Connection Refused 가 발생했다.    \n로그 파일을 보다보니까 서버 시간 설정을 까먹었다는 사실을 발견했다.\n### 서버 시간 설정하기\n\n서버 시간을 서울 시간대로 변경해주었다.    \n\n```bash\nsudo timedatectl set-timezone Asia/Seoul\n```\n\n이 과정을 거쳐... 드디어 백엔드 서버를 배포했더니 잘 됐다!!!!!\n\n![[shook-prod-swagger.png]]\n\nswagger 가 열리는 걸 보니 잘 돌아갑니다 ^^\n\n너무 힘드네요 진짜로"},{"excerpt":"프로젝트 요구사항에 모니터링 CloudWatch 란","fields":{"slug":"/shook-cloudwatch/"},"frontmatter":{"date":"2023년 08월 11일 08:08","title":"CloudWatch 도입 고민기","tags":["shook","레벨3","모니터링","우테코"]},"rawMarkdownBody":"\n프로젝트 요구사항에 모니터링\n\n## CloudWatch 란"},{"excerpt":"도입 계기 S-HOOK 에서는 서비스 내부에서 앨범 자켓 이미지를 사용한다.  초기에는 mania DB 이미지 url 을 그대로 사용하려고 했으나 굉장히 큰 문제가 발생했다. 바로 maniaDB API 요청 속도가 매우매우매우매우 느리다는 것이다... 아래가 maniaDB API 를 그대로 사용했을 때의 이미지 로딩 속도이다.  파일 크기도 1MB 정도로…","fields":{"slug":"/shook-s3-introduce/"},"frontmatter":{"date":"2023년 08월 11일 06:08","title":"S-HOOK S3 도입 요청","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 도입 계기\n\nS-HOOK 에서는 서비스 내부에서 앨범 자켓 이미지를 사용한다.     \n\n![[shook-image-list.png]]\n\n초기에는 mania DB 이미지 url 을 그대로 사용하려고 했으나 굉장히 큰 문제가 발생했다.     \n바로 maniaDB API 요청 속도가 매우매우매우매우 느리다는 것이다...\n\n아래가 maniaDB API 를 그대로 사용했을 때의 이미지 로딩 속도이다.    \n\n![[maniadb-image-load-rate.png]]\n\n파일 크기도 1MB 정도로 큰 편인데, 1.2MB 파일을 가져오는데 43.52초가 걸린다.     \n곡이 사용자에게 리스트 형태로 보여지기 때문에, 많은 이미지가 한 번에 로딩되어야 한다.     \n어떤 이미지는 빠르게 로딩되고, 어떤 이미지는 느리게 로딩된다면 사용자에게 좋지 않은 경험이 될 것이다.    \n\n물론 다른 API 를 사용할 수도 있다.      \n멜론의 앨범 자켓 이미지 url 을 그대로 가져오는 것이다.     \n그렇지만 이 방법은 단순히 다른 서비스의 image url을 임의로 도용하는 것이기 때문에 문제가 발생할 가능성이 크다.    \n\n따라서 S3 에 앨범 자켓 이미지를 저장한 후, S3에서 앨범 자켓 이미지를 가져오는 방식을 사용하기로 결정하였다.     "},{"excerpt":"트랜잭션 논리적 작업 단위 transactional ACID 속성 원자성: 트랜잭션과 관련된 작업은 모두 실행되거나 모두 실패함 일관성: 트랜잭션은 참조 무결성 등의 제약 조건을 위반하지 않고 유효한 상태에서 또 다른 유효한 상태로 변경함 격리성: 트랜잭션은 다른 트랜잭션이 존재하지 않는 것처럼 서로 간섭 없이 수행되어야 한다. 지속성: 트랜잭션 커밋 후…","fields":{"slug":"/level3-last-lecture/"},"frontmatter":{"date":"2023년 08월 11일 01:08","title":"쿼리 실행 계획","tags":null},"rawMarkdownBody":"\n## 트랜잭션\n\n- 논리적 작업 단위\n\n[[transactional]]\n\n### ACID 속성\n\n- 원자성: 트랜잭션과 관련된 작업은 모두 실행되거나 모두 실패함\n- 일관성: 트랜잭션은 참조 무결성 등의 제약 조건을 위반하지 않고 유효한 상태에서 또 다른 유효한 상태로 변경함\n- 격리성: 트랜잭션은 다른 트랜잭션이 존재하지 않는 것처럼 서로 간섭 없이 수행되어야 한다.\n- 지속성: 트랜잭션 커밋 후에는 시스템이 중단되거나 장애가 발생해도 데이터가 그대로 유지되어야 한다.   \n\n`@@autocommit` 이 지정되면 statement 하나 당 커밋이 된다. 기본적으로는 1로 설정되어 있는 듯\n\n## 격리 수준\n\n- 트랜잭션이 동시에 변경을 수행하고 쿼리를 수행할 때 성능과 안정성, 일관성 및 결과 재현성 간의 균형을 미세 조정하는 설정\n\t- 트랜잭션이 동시에 수행될 때 다른 트랜잭션에서 변경하거나 조회하는 데이터를 어디까지 볼 수 있도록 허용할 것인지에 대한 설정\n\n## 인덱스\n\n### 인덱스 구분\n\n- primary vs secondary\n\t- mysql 은 모든 key 에 대해 index 를 만든다.\n- key는 자료를 식별하는 값, index는 자료의 구조\n\n"},{"excerpt":"LOG 태풍이 와서 재택을 했다. 근데 태풍이 너무 조용히 지나감 ㅋㅋㅋ 그냥 집에서 쉰 사람 됐다 😄 오늘 t1 과 kt 의 플옵 2라운드가 있었다. 서머 2라운드 때 1승 7패하기도 했고, 아무래도 다들 합을 맞추기에는 어려울 거 같아서 당연히 패자조 갈 생각하고 있었는데 이겼다 !!!!!!!!!!!!!! 흑흐그ㅠㅡㅡ흐그흑 다들 최고야.... 결승 직…","fields":{"slug":"/2023-08-10/"},"frontmatter":{"date":"2023년 08월 10일 14:08","title":"2023년 08월 10일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 태풍이 와서 재택을 했다. 근데 태풍이 너무 조용히 지나감 ㅋㅋㅋ 그냥 집에서 쉰 사람 됐다 😄\n- 오늘 t1 과 kt 의 플옵 2라운드가 있었다. 서머 2라운드 때 1승 7패하기도 했고, 아무래도 다들 합을 맞추기에는 어려울 거 같아서 당연히 패자조 갈 생각하고 있었는데 이겼다 !!!!!!!!!!!!!! 흑흐그ㅠㅡㅡ흐그흑 다들 최고야.... 결승 직행 달다... 🥹\n- 오늘 내내 리팩토링했다. 4차 데모데이 직전에 갑자기 큰 변경 사항들이 막 생겨서 기능 파티 하는 중 ^^... 얼른 기능 개발하고 데모데이 발표 준비도 해야 한다\n\n## 배운 것\n\n\n## 궁금한 것\n\n## 느낀 것\n- "},{"excerpt":"LOG 텀블러 설거지를 하는 걸 깜빡했더니 텀블러에 곰팡이가 폈다..ㅎ 무서워서 먹지 못하는 중 ㅋㅎㅋㅎㅋㅎㅋㅎㅋ.... 당분간은 세제물을 넣어두어야 겠다.... 제이슨이 대신 버려주셨다 ㅎ... 다행인걸까 ㅋㅋㅋㅋ 배운 것  : 현재 timezone 을 확인할 수 있다. 궁금한 것 느낀 것","fields":{"slug":"/2023-08-09/"},"frontmatter":{"date":"2023년 08월 09일 04:08","title":"2023년 08월 09일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 텀블러 설거지를 하는 걸 깜빡했더니 텀블러에 곰팡이가 폈다..ㅎ 무서워서 먹지 못하는 중 ㅋㅎㅋㅎㅋㅎㅋㅎㅋ.... 당분간은 세제물을 넣어두어야 겠다....\n\t- 제이슨이 대신 버려주셨다 ㅎ... 다행인걸까 ㅋㅋㅋㅋ\n\n## 배운 것\n\n- `select now(), @@system_time_zone as timezone;` : 현재 timezone 을 확인할 수 있다.\n\n## 궁금한 것\n\n## 느낀 것"},{"excerpt":"무중단 배포 서비스를 다운시키지 않고 배포하는 것. 요즘 큰 회사들은 서비스 점검 공지를 보이지 않는다. 인프라 변경 JPA DDL auto 설정 또는 flyway 를 이용하여 운영 DB의 스키마를 관리하고 있지는 않은가?   => 운영 환경에서는 거의 사용하지 않는다. 운영 환경에서는 alter 권한이 없는 사용자를 사용한다. 롤백 롤백이란 배포한 서비…","fields":{"slug":"/rollback-release/"},"frontmatter":{"date":"2023년 08월 08일 01:08","title":"배포와 롤백 강의","tags":["우테코","레벨3"]},"rawMarkdownBody":"\n## 무중단 배포\n\n서비스를 다운시키지 않고 배포하는 것. 요즘 큰 회사들은 서비스 점검 공지를 보이지 않는다.\n\n## 인프라 변경\n\nJPA DDL auto 설정 또는 flyway 를 이용하여 운영 DB의 스키마를 관리하고 있지는 않은가?\n- `spring.jpa.hibernate.ddl-auto: update`\n- `spring.flyway.enbaled:true`\n=> 운영 환경에서는 거의 사용하지 않는다. 운영 환경에서는 alter 권한이 없는 사용자를 사용한다. \n\n## 롤백\n\n롤백이란 배포한 서비스를 이전 상태 (버전) 으로 돌리는 것\n\n### 롤백과 문제 상황\n\n코드를 배포할 때 스키마 변경을 했다면 롤백은 어떻게 하지?\n프론트엔드와 백엔드 중 무엇을 먼저 롤백할 것인가?\n배포한 뒤 문제가 생겨 핫픽스를 했는데, 롤백해야 하느나 상황이 되면 어떻게 하지?\n롤백을 하려고 했는데 실패한다면?\n\n운영 환경과 개발 환경은 다를 수 있다.\n- 인프라 구성\n- 데이터의 양\n\n"},{"excerpt":"보통 API 자동화 툴이라고 하면 swagger, REST API docs 가 자주 고려된다. 서치하다보니 추가로 restdocs-api-spec 이라는 라이브러리도 알게 되어 각각의 장단점을 함께 비교해보려고 한다. Swagger swagger 는 OpenAPI 사양을 사용하기 때문에, 표준화된 형식을 지원한다. 또한 우리의 프론트엔드 팀원들이 API …","fields":{"slug":"/api-docs-search/"},"frontmatter":{"date":"2023년 08월 07일 13:08","title":"S-HOOK API 자동화 툴 정하기","tags":["shook","레벨3","spring"]},"rawMarkdownBody":"\n보통 API 자동화 툴이라고 하면 swagger, REST API docs 가 자주 고려된다.     \n서치하다보니 추가로 restdocs-api-spec 이라는 라이브러리도 알게 되어 각각의 장단점을 함께 비교해보려고 한다.    \n\n## Swagger\n\nswagger 는 OpenAPI 사양을 사용하기 때문에, 표준화된 형식을 지원한다.    \n\n또한 우리의 프론트엔드 팀원들이 API 문서 페이지에서 직접 API 호출을 시도해볼 수 있는 대화형 인터페이스를 제공한다.     \n\n무엇보다 시작하기 쉽다. swagger 의존성만 있어도 API 문서를 만들어준다!\n\n### 단점\n\n가장 크고 자주 지적되는 단점은 프로덕션 코드에 swagger 코드가 침투한다는 것이다.     \n컨트롤러에 swagger 코드가 추가되어 가독성을 떨어뜨릴 수 있다는 단점이 있다.    \n\nTest 를 강제하지 않기 때문에 문서의 신뢰도를 높게 유지하기 어려운 문제가 있다. \n\n## Spring REST docs\n\n가장 손꼽히는 장점은 테스트로부터 API 문서를 생성하므로 문서는 언제나 실제 코드와 함께 최신 상태라는 것이 보장된다.    \nintegration 테스트를 작성해서, 테스트가 통과해야만 문서가 작성된다. 따라서 문서의 신뢰도가 높게 유지된다.     \n개발 리소스가 발생하기는 하지만, 테스트를 강제하기 때문에 유지보수에도 도움이 된다고 한다.    \n\nswagger 와는 달리 컨트롤러 코드에 어노테이션을 달지 않아도 된다. 소스 코드에 변경을 주지 않기 때문에 비즈니스 로직과 테스트케이스가 분리된다는 장점이 있다.\n\n### 단점\n\nascii docs 를 써야 한다.... 테스트 코드가 추가될 때마다 ascii doc 에 적어야 한다.     \n또한 Swagger UI 와 다르기 때문에, 클라이언트 쪽에서 API 를 호출해볼 수 없다. \n\n추가적으로 UI 가 swagger 에 비해서는 우아하지 않다. (예쁜 것도 중요하다.)     \n\n그러나 테스트 코드가 변경될 떄마다 직접 문서를 수정해야 하는 상황이 발생할 수 있다. (즉, 매우 귀찮다.)\n"},{"excerpt":"LOG 백준 17299 번을 풀었다. 처음엔 생각해낼 줄 알았는데 시간초과가 계속 나서 결국 답을 봤다 🥺 알고리즘 아자자... 배운 것  by 바론 코드  를 쓰면 내부의 값을 소문자로 바꿔준다!  를 사용하면 리스트에 있는 값들의 빈도 수를 자동으로 세 준다. 궁금한 것 느낀 것 알고리즘 어려워 ㅠㅠ","fields":{"slug":"/2023-08-07/"},"frontmatter":{"date":"2023년 08월 07일 11:08","title":"2023년 08월 07일","tags":null},"rawMarkdownBody":"\n## LOG\n- 백준 17299 번을 풀었다. 처음엔 생각해낼 줄 알았는데 시간초과가 계속 나서 결국 답을 봤다 🥺 알고리즘 아자자...\n\n## 배운 것\n- `@Query(\"SELECT s FROM Song s WHERE LOWER(s.singer.name) = LOWER(:singer)\")` by 바론 코드\n\t- `LOWER` 를 쓰면 내부의 값을 소문자로 바꿔준다!\n- `Collections.Counter(리스트)` 를 사용하면 리스트에 있는 값들의 빈도 수를 자동으로 세 준다.\n\n## 궁금한 것\n\n## 느낀 것\n- 알고리즘 어려워 ㅠㅠ"},{"excerpt":"LOG 배운 것 python 의 slicing 은 O(K) (K는 slicing 될 리스트의 크기) 의 시간 복잡도를 갖는다. python list 비교는 == 으로 가능하다... ㄷㄷ 내부 구현: 두 리스트의 길이가 다르면 O(1). 최악의 경우 O(N) 의 선형 시간 복잡도. 궁금한 것 느낀 것","fields":{"slug":"/2023-08-06/"},"frontmatter":{"date":"2023년 08월 06일 07:08","title":"2023년 08월 06일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n\n- python 의 slicing 은 O(K) (K는 slicing 될 리스트의 크기) 의 시간 복잡도를 갖는다.\n- python list 비교는 == 으로 가능하다... ㄷㄷ\n\t- 내부 구현: 두 리스트의 길이가 다르면 O(1). 최악의 경우 O(N) 의 선형 시간 복잡도.\n\n## 궁금한 것\n\n## 느낀 것"},{"excerpt":"LOG 배운 것  을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴해주고, key 가 존재하지 않을 때는 지정한 값을 리턴한다.  을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴하고, key 가 존재하지 않을 때는 지정한 값을 저장한 후, 값을 리턴한다. 궁금한 것 느낀 것 DP 공부를 하기도 했고, 과외를 하면서…","fields":{"slug":"/2023-08-05/"},"frontmatter":{"date":"2023년 08월 05일 05:08","title":"2023년 08월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n\n- `{dict 이름}.get(가져올 key 값, key 값이 없을 때 리턴할 값)` 을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴해주고, key 가 존재하지 않을 때는 지정한 값을 리턴한다.\n- `{dict 이름}.setdefault(가져올 key 값, key 값이 없을 때 저장할 값)` 을 사용하면 내가 원하는 key 값이 존재할 때는 value 를 리턴하고, key 가 존재하지 않을 때는 지정한 값을 저장한 후, 값을 리턴한다.\n\n## 궁금한 것\n\n## 느낀 것\n- DP 공부를 하기도 했고, 과외를 하면서 계속 설명을 하다보니 이제 좀 이해가 잘 된다. 재미없는 분야에 대해서는 이해가 느린 편이라... 이렇게 남에게 설명하면서 이해하는 게 가장 쉬운 듯."},{"excerpt":"어느덧 2주 후면 4차 데모데이고, 레벨3가 끝난다. S-HOOK 프로젝트를 진행한 후로 시간이 많이 흐른 지금 프로젝트 회고를 작성해보려고 한다. S-HOOK 이란 스플릿의 아이디어로 시작된 S-HOOK은 주제를 보자마자 하고 싶었던 프로젝트였다. 그때 당시의 서비스 소개는 대략적으로 '킬링파트로 노래를 추천하는 서비스' 라고 적혀있었던 것 같다. 그래…","fields":{"slug":"/shook-third-demoday-retrospect/"},"frontmatter":{"date":"2023년 08월 04일 11:08","title":"S-HOOK 3차 데모데이 회고","tags":["회고","shook","레벨3","우테코"]},"rawMarkdownBody":"\n어느덧 2주 후면 4차 데모데이고, 레벨3가 끝난다.     \nS-HOOK 프로젝트를 진행한 후로 시간이 많이 흐른 지금 프로젝트 회고를 작성해보려고 한다.    \n\n## S-HOOK 이란\n\n스플릿의 아이디어로 시작된 S-HOOK은 주제를 보자마자 하고 싶었던 프로젝트였다.   \n그때 당시의 서비스 소개는 대략적으로 '킬링파트로 노래를 추천하는 서비스' 라고 적혀있었던 것 같다. 그래서 인공지능을 쓰는 프로젝트일 것 같아 잘 될까? 하는 회의적인 시각도 있었다.    \n\n스플릿은 자신이 도입부만 들어보고 별로라고 생각했던 노래가, 나중에 들었을 때 좋은 노래였다는 것을 알게 된 후에 기획하게 된 서비스라고 했다.      \n\n우리의 서비스, S-HOOK 은 좋아하는 노래의 '킬링파트'를 다른 사람들과 공유할 수 있다. 또한 노래의 가장 좋은 부분인 '킬링파트'를 먼저 들어봄으로써 새로운 노래를 빠르게 탐색할 수 있다.     \n\n### 비하인드\n\n사실 이런 정의를 내릴 수 있게 된 것도 그렇게 오래되지는 않았다 ㅋㅋㅋ    \n다들 프로젝트를 해보았다면 알 것이다. 모두가 나와 같은 생각을 하고 있다고 생각하지만 모두가 다 다른 각자의 생각을 갖고 있을 때가 훨씬 많다는 것을.\n\n우리 팀도 동일했다. '이게 이런 기능 아니었어?', '이거 하자고 한 거 아니었어?' 라는 말을 수없이 했다. 수없이 했던 이야기를 반복했고, 수없이 똑같은 문제에 대해 토론했다.      \n\n특히 1차 데모데이, 2차 데모데이 기간까지는 우리도 우리 서비스가 무엇인지 명확하게 정의내리기 어려웠다.     \n\n### 가장 많이 생각했던 페르소나\n\n가장 고민했던 것은 우리 서비스가 제공하고 싶은 가치였다. \n\n1차 데모데이 때 정했던 첫 페르소나는 다음과 같다.    \n\n```markdown\n인디음악 매니아\n- 27세 바쁜 직장인\n- 인디음악 매니아\n- 콘서트 좋아함\n\nNeed\n- 자신만의 숨은 명곡을 뽐내고 싶다\n- 노래 중 자신만의 핵심 파트를 뽐내고 싶다\n- 내가 좋아하는 가수의 다른 노래 중 좋은 노래를 찾고 싶다\n```\n\n이때 코치분들에게 '주어진 기능에 맞춰서 페르소나를 지정한 것은 아닌가?' 라는 피드백을 받았다. 아무래도 구현하기로 계획했던 기능이 '등록 / 공유', '조회' 였어서 더 그런 것 같다.     \n팀 내에서도 그런 의견이 나왔어서, 이후로 페르소나 정립을 다시 해야 했다.     \n\n처음 정했던 아이디어 대로라면 공유에 초점을 둔 서비스가 맞았다. 그렇지만 공유를 통해서 우리가 사용자에게 '줄 수 있는 가치' 는 너무나도 모호했다. \n\n너무나도 어려운 시간이었지만, 다시 페르소나를 구축했다.    \n그렇게 새롭게 만들어진, 2차 데모데이까지의 페르소나는 다음과 같다.     \n공유에 초점을 둔 페르소나이다.\n\n```markdown\n킬링파트를 등록하고 공유하는 것이 메인인 페르소나\n\n- 내가 좋아하는 부분을 사람들도 좋아한다는 걸 인정받고 싶다.\n    - 내가 좋아하는 걸 다른 사람들도 좋아한다고 느낄 때의 인정 (보편적)\n        - 사람들이 좋아할 만한 부분을 공유 / 내가 좋아하는 걸 역시 다른 사람들도 좋아하네 → 대중적인 귀\n```\n\n이 페르소나를 정할 때, S-HOOK이 공유에 초점을 둔 서비스일까? 추천에 초점을 둔 서비스일까? 를 계속해서 고민했다.     \n\n추천에 초점을 두게 되면 어쩔 수 없이 사용자의 취향을 알아야만 했는데, 현실적으로 우리가 짧은 기간 안에 구현할 수 없는 기능이라 결론 내렸다.     \n\n따라서 공유에 초점을 둔 페르소나를 선정하기로 했고, 그 중에서도 사람들에게 킬링파트를 공유하고, 자신의 음악 취향을 인정받고 싶은 사용자를 타겟으로 한 페르소나를 만들었다.\n\n그러나 이 페르소나에도 하나의 문제점이 있었다.    \n\n해당 페르소나에게 '인정받는 느낌'을 주기 위해 지금까지 높은 득표를 한 킬링파트에 투표를 하게 되면 '축하한다는 메시지'와 '등수'를 띄워주었다. 이를 위해서는 킬링파트의 득표수가 숨겨져야 했고, 결국 킬링파트 투표를 하고 싶지 않은 사용자는 킬링파트를 확인할 수 없게 되었다.    \n\n그렇다. 우리가 줄 수 있는 인정에는 한계가 있었다.     \n처음에는 내가 등록한 킬링파트의 순위가 높다면 사용자가 '인정받았다' 라고 생각하지 않을까? 라고 생각했다.    \n그러나 그렇게 기능을 제공하게 되면 사용자는 높은 등수의 킬링파트를 계속해서 '찾기만 하는' 등수 퀴즈 서비스 정도로 S-HOOK 을 인지하게 될 것이다. 또한 킬링파트 리스트를 보여주지 않는다면, 킬링파트를 찾기만을 원하는 사용자들을 대거 놓치게 된다. 그것은 우리가 원하는 방향이 아니었다. \n\n그래서 결국 공유를 통한 '인정'을 주는 것은 제외했다. 2차 데모데이에 구현한 기능들은 '공유' 할 수 있게 하는 기능이었다고 정의하기로 했다.     \n\n그리고 지금, 3차 데모데이 까지의 페르소나는 다음과 같다.     \n\n```markdown\n사람들이 많이 소비하는 노래를 찾고 싶은 페르소나\n\n### Needs\n\n- 들어보지 않은 좋은 노래를 찾고 싶다.\n- 최근에 사람들이 많이 소비한 노래들 중에서 안 들어본 좋은 노래를 찾고 싶다.\n\n### Goals\n\n- 새로운 노래의 킬링파트들을 들어보며 좋은 노래인지 판단할 수 있었다.\n```\n\n킬링파트 소비에 목적을 둔 페르소나이다.     \n그렇지만 여전히 순탄하게 정해지지는 않았다...ㅋㅋㅋ\n\n![[third-demoday-persona-1.png]]\n![[third-demoday-persona-2.png]]\n길었던 3차 데모데이 페르소나 회의의 일부분이다.\n\n3차 데모데이 페르소나를 정하면서도 토론이 오갔다. 이 날은 페르소나에 대한 이야기만 5시간을 했다.     \n모두들 우리의 서비스가 제공하고 싶은 가치가 무엇인지 확신하지 못해서 긴 시간을 회의한 것이라 생각한다. 시간은 오래 걸렸지만, 서비스를 위해서는 너무나도 필요한 시간이었다.     \n\n팀원 각자의 의견들을 들어보고, 각 의견들의 모순점을 찾아내고, 모순의 해결점을 찾아내는 회의를 했다.     \n어떤 서비스를 만들고 싶은지, 어떤 서비스가 되었으면 좋겠는지, 이 가치를 실현하는 데 있어서 이런 기능들이 필요한 지... 와 관한 이야기를 했다. 그렇게 정해진 페르소나다.\n\n그렇다. 우리가 고민했던 것은 결국 '사용자' 다.\n\n우리는 서비스를 통해 **사용자**에게 어떤 가치를 줄 수 있나?      \n우리의 서비스를 통해 **사용자**가 얻어갔으면 하는 것은 무엇인가?     \n궁극적으로 우리의 서비스를 통해 **사용자**의 니즈를 달성할 수 있을까?     \n\n라는 질문들에 대답하기 힘겨웠던 날들이 많았다.     \n\n이를 해결하기 위해 했던 회의들은 끝도 없다. 우리 팀은 다른 팀들 사이에서 '회의 많이 하는 팀' 으로 불리고 있었으니까. 오히려 개발보다도 서로의 싱크를 맞추기 위한 회의를 더 많이 했던 것 같다.    \n\n결국 우리가 내린 결론은 이것이다.\n\n우리의 핵심은 유저들이 킬링파트를 만들어 나가며 즐겁게 소비하는 플랫폼을 만드는 것이다.  \n그 중에서는 여러 가치가 있는데\n\n- 노래의 킬링파트를 유저들이 만들어 나간다.\n- 자신이 등록한 파트를 지인들에게 편하게 제공할 수 있다.\n- 유저들이 새로운 노래를 찾는데 킬링파트가 도움이 되도록 한다.\n\n결국 이 가치를 찾기 위해서 멀리 돌아왔고, 그런 과정을 통해 팀원 모두가 인정할 수 있는 서비스와 가치가 만들어졌다고 생각한다.     \n\n무엇보다 기쁜 것은 서비스가 바라보는 것이 기술과 기능이 아니라, '사용자' 라는 것이다.     \n그러니 우리는 앞으로 개발을 할 때 '왜 이런 기능을 만들어야 하지?' 라는 의문에 휘둘리지 않을 것이다. 이미 그런 고민들은 6주 동안 했다.     \n\n### 다음으로 제공할 가치는?\n\n이제 기본적으로 '공유'하고, '소비'하는 페르소나에 대한 정의가 완료되었으므로 사용자의 편의를 높여줄 수 있는 가치들을 구상했다.    \n\n```\n- 사용자에게 신뢰성 있는 킬링파트를 제공한다.\n- 킬링파트를 편리하게 소비할 수 있다.\n```\n\n여담이지만, 각 스프린트마다 구현해야 할 '가치'를 잡고 가는 것은 정말 좋은 방법이다.    \n팀원들 모두 가치를 반영하는 방향으로 움직일 수 있고, 불필요한 기능들을 쳐낼 수도 있다.     \n다들 한 번 시도해보시길.\n\n각각의 가치들을 잘 반영하는 방향으로 마지막 4차 데모데이도 잘 준비하려 한다.     \n\n---\n2차 데모데이까지는 기획 지적을 많이 받았는데, 이번에는 기획이 아닌 UX, UI 지적을 받아서 오히려 좋다. 기획은 어느 정도 틀이 잡힌 것 같다. (이제서야)     \n\n브라운이 구현도가 높아서 실제 서비스를 쓰는 것 같다고 해주셔서 너무 기분 좋았다.     \n4차 데모데이가 끝나고 만들어질 S-HOOK 이 기대된다.     "},{"excerpt":"LOG 3차 데모데이가 있었다. 사실 우리 팀 모두 다 얻어맞을 각오하고 반성하는 대답 적어갔는데 칭찬을 많이 받아서 기뻤다!! 그렇지만 어제 다른 크루들 / 지인들에게 받았던 피드백인 '투표하는 방법을 모르겠다' 같은 UX 관련 내용들은 함께 계속해서 이야기해봐야 할 것 같다. 배운 것 궁금한 것 느낀 것 우리 팀은 기획 관련 회의가 많아서 개발 부분에…","fields":{"slug":"/2023-08-04/"},"frontmatter":{"date":"2023년 08월 04일 07:08","title":"2023년 08월 04일","tags":null},"rawMarkdownBody":"\n## LOG\n- 3차 데모데이가 있었다. 사실 우리 팀 모두 다 얻어맞을 각오하고 반성하는 대답 적어갔는데 칭찬을 많이 받아서 기뻤다!! 그렇지만 어제 다른 크루들 / 지인들에게 받았던 피드백인 '투표하는 방법을 모르겠다' 같은 UX 관련 내용들은 함께 계속해서 이야기해봐야 할 것 같다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n- 우리 팀은 기획 관련 회의가 많아서 개발 부분에서는 조금 뒤처지고 있지 않나라는 생각을 (잠시) 했었는데, 오히려 그 방향이 옳았던 것 같다. 사용자가 어떤 것을 필요로 할 것이고, 우리 서비스로 어떤 것을 얻어가고 싶은지 모든 팀원들이 반복해서 고민했기 때문에 혼란이 적었다. 기술을 고민하는 것도 좋지만, 사용자의 니즈에 따라서 기술이 고안 되어야 한다는 것을 다시 한 번 느끼는 계기가 되었다. \n- 우리 팀 테트리스 왤케 열심히 함 "},{"excerpt":"현재 S-HOOK 의 서비스 DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 합니다. 그 중에서 S-HOOK은  를 채택하게 되었는데, 이유는 다음과 같습니다. WebClient 란? 웹으로 API 를 호출하기 위해 사용되는 Http Client 모듈 중 하나이다. 기존의 동기 API 를 제공할 뿐만…","fields":{"slug":"/shook-webclient-reason/"},"frontmatter":{"date":"2023년 08월 03일 07:08","title":"WebClient를 도입하게 된 이유","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n현재 S-HOOK 의 서비스 DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 합니다.     \n\n그 중에서 S-HOOK은 `WebCient` 를 채택하게 되었는데, 이유는 다음과 같습니다.      \n\n## WebClient 란?\n\n웹으로 API 를 호출하기 위해 사용되는 Http Client 모듈 중 하나이다.     \n기존의 동기 API 를 제공할 뿐만 아니라, nonblocking 과 async 접근 방식을 지원하며 효율적인 통신이 가능하다.\n\n## RestTemplate을 사용하지 않는 이유\n\n### Maintenance Mode의 RestTemplate\n\n> NOTE: As of 5.0 this class is in maintenance mode, with only minor requests for changes and bugs to be accepted going forward. Please, consider using the org.springframework.web.reactive.client.WebClient which has a more modern API and supports sync, async, and streaming scenarios.\n\n> 5.0 버전부터 `RestTemplate` 은 maintenance mode 에 있으며, 앞으로는 사소한 변경과 버그 요청만 받아들여질 예정입니다. 동기, 비동기, streraming 서비스를 지원하는 최신 API 가 포함된 `WebClient` 를 고려해 보세요.\n\nSpring 의 공식 문서에서도 Spring 5.0 부터는 해당 모듈에 기능을 추가하지 않을 것이라고 명시되어 있습니다. 즉, `RestTemplate` 은 버전 업그레이드가 수행되면 Deprecated 될 수도 있습니다.    \n\n따라서 향후 대응을 위해 `WebClient` 로 작성하는 것이 좋을 것이라 생각합니다. (사실 이게 가장 큰 이유입니다.)     \n\n### non-blocking, async 지원\n\n`RestTemplate` 의 경우는 `synchronous`, `blocking call` 만 가능하지만, `WebClient` 는 `async`, `nonblocking` 을 지원합니다.     \n\n이후 외부 API 에 요청을 보낼 때 `async`, `nonblocking` 요청이 필요하게 될 경우에는 `WebClient` 가 강점을 가진다고 할 수 있겠습니다.     \n\n그러나 현재 `WebClient` 가 사용된 부분은 `blocking` 으로 동작하고 있습니다. 외부 API 에서 받아오는 요청을 가공해서 사용자에게 보내주어야 하기 때문에 요청이 받아질 때까지 기다려야 합니다.     \n그러므로 현재로써는 큰 장점은 아니지만, 추후 해당 기능이 필요해지는 경우 `RestTemplate` 보다 강점을 갖게 될 것입니다.     \n\n### 동시 사용자 성능\n\nSpring Boot 2 부터 IO 가 빈번한 경우에 성능이 향상되었습니다.    \n\n동시 사용자의 규모가 별로 없는 경우에는 `RestTemplate` 을 사용하는 것은 별 문제 없지만, 어느 정도의 규모가 있는 경우에는 `WebClient` 를 선택하는 것이 바람직하다고 할 수 있습니다.     \n\n### 구현 상의 이점\n\n`WebClient` 는 예외처리를 람다로 할 수 있습니다. \n\n다음은 S-HOOK 에서 사용한 코드 중 일부입니다.\n\n```java\nprivate ManiaDBAPISearchResponse getResultFromManiaDB(final String searchUrl) {  \n    return webClient.get()  \n        .uri(searchUrl)  \n        .accept(MediaType.TEXT_XML)  \n        .acceptCharset(StandardCharsets.UTF_8)  \n        .retrieve()  \n        .onStatus(HttpStatusCode::is4xxClientError, (clientResponse) -> {  \n            throw new ExternalApiException.ManiaDBClientException();  \n        })  \n        .onStatus(HttpStatusCode::is5xxServerError, (clientResponse) -> {  \n            throw new ExternalApiException.ManiaDBServerException();  \n        })  \n        .bodyToMono(ManiaDBAPISearchResponse.class)  \n        .block();  \n}\n```\n\n이렇게 status 마다 각 예외를 람다 함수로 따로 처리해줄 수 있습니다.    \n\n그러나 `RestTemplate` 을 사용하는 경우, 반드시 `try-catch` 를 사용해주어야 합니다.    \n마찬가지로 S-HOOK 의 코드 중 일부입니다.\n\n```java\npublic GoogleMemberInfoResponse getMemberInfo(final String accessToken) {  \n    try {  \n        ...\n    } catch (HttpClientErrorException e) {  \n        throw new OAuthException.InvalidAccessTokenException();  \n    } catch (HttpServerErrorException e) {  \n        throw new OAuthException.GoogleServerException();  \n    }\n```\n\n사람마다 취향차이가 있을 수 있지만, 개인적으로는 람다로 예외처리를 하는 방식이 좀 더 우아해보입니다. \n\n---\n위와 같은 이유로 S-HOOK 에서는 외부 API 를 호출할 때, `WebClient` 를 도입하기로 결정하였습니다.    \n"},{"excerpt":"지난 피드백 내용 🎙️ S-HOOK 개별 피드백: 등록과 투표를 하나의 플로우에 보여주려고 하다보니, 사용자 입장에서 플로우가 잘 이해되지 않았다는 피드백 🎧 등록을 삭제하고, 투표라는 말로 통일했다. 투표 페이지에서는 '투표'가 메인 기능이며, '공유'가 부가 기능이라는 것을 확실하게 이해시키기 위해 투표 페이지를 다음과 같이 (FE 에서 반영된 부분이므…","fields":{"slug":"/shook-third-demoday/"},"frontmatter":{"date":"2023년 08월 02일 08:08","title":"S-HOOK 3차 데모데이 자료","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 지난 피드백 내용\n\n🎙️ S-HOOK 개별 피드백: 등록과 투표를 하나의 플로우에 보여주려고 하다보니, 사용자 입장에서 플로우가 잘 이해되지 않았다는 피드백\n\n🎧 등록을 삭제하고, 투표라는 말로 통일했다. 투표 페이지에서는 '투표'가 메인 기능이며, '공유'가 부가 기능이라는 것을 확실하게 이해시키기 위해 투표 페이지를 다음과 같이 (FE 에서 반영된 부분이므로 이 부분 내용 추가 필요) 재구성했다.\n\n🎙️ S-HOOK 개별 피드백: 서비스 내부에서 사용자에게 만족감을 주려고 하는 방식이 와닿지 않았다는 피드백\n\n🎧 파트에 투표할 때 보여졌던 '순위', '축하' 키워드를 제거했다.\n\n🎙️ 공통 피드백: 대부분의 팀이 공유의 중요성을 강조하고 있는데, 공유가 적절하게 이루어지고 있는가?\n\n- 부족하다고 느꼈던 부분\n\t- FE, BE 끼리 API 명세를 공유하는 데에는 소홀했던 것 같다.\n\t- 해결한 문제를 wiki로 공유하기로 했는데, wiki 에 글을 생각보다 많이 못 썼다. (공적인 글이라는 부담감, markdown 의 불편함 등의 이유)\n\n- 해결책\n\t- 임시로 API 명세 자동화 툴 (swagger) 을 사용하여 명세가 변경될 때마다 자동으로 업데이트 될 수 있게 했다.\n\t- 팀 블로그를 개설했다. wiki는 팀 전체 아키텍쳐, 공통의 관심사에 관한 내용을 정리하고, 팀 블로그에는 트러블 슈팅 과정, 기술 도입기 등 기술과 관련된 포스팅을 하기로 결정했다.\n\n## 다음 데모 진행사항\n\n> 다음 데모까지 해결하고 싶은 가치\n\n- 사용자에게 신뢰도 있는 킬링파트를 제공한다.\n- 사용자들이 킬링파트를 더 편리하게 소비할 수 있도록 돕는다.\n\n> 가치로부터 도출된 구현 예정 기능\n\n1. 내가 원하는 노래를 찾아서 투표하고 싶어! 🎫 -> 노래 검색 기능\n2. 신뢰도 있는 킬링파트를 위해 노래 하나의 킬링파트 투표는 한 표씩만! 👮🏻‍♀️ -> 로그인\n\t**로그인 구현 후, 구현할 기능들**\n\t1. 내가 좋아했던 킬링파트는 어디? 모아보고 싶어! 😁 -> 내가 투표한 킬링파트 모아보기 기능\n\t2. 이 킬링파트에 대한 사람들의 의견이 궁금해 🤔 -> 킬링파트별 댓글 기능\n3. 내가 좋아하는 장르 노래를 들어보고 싶어! 🤓 -> 장르별 노래 필터 기능\n\n"},{"excerpt":"LOG 알고리즘 문제 2개나 풀었다. 사실 옆에서 같이 푼 문제 다시 본 거긴 하지만.. 그래도 뿌듯하다~ 꾸준히 풀었다는 것에 의의 두자. shook-third-demoday 준비했다. 오늘 내내 데모데이 준비 ㅠ 배운 것  의 기본값은  이다. 궁금한 것 느낀 것 shook 드디어 킥보드 완성..! 다음 데모데이 때는 꼭 자전거가 되어보자 ~ S-HO…","fields":{"slug":"/2023-08-03/"},"frontmatter":{"date":"2023년 08월 02일 06:08","title":"2023년 08월 03일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 알고리즘 문제 2개나 풀었다. 사실 옆에서 같이 푼 문제 다시 본 거긴 하지만.. 그래도 뿌듯하다~ 꾸준히 풀었다는 것에 의의 두자.\n- [[shook-third-demoday]] 준비했다. 오늘 내내 데모데이 준비 ㅠ\n\n## 배운 것\n- `defaultdict(bool)` 의 기본값은 `False` 이다.\n\n## 궁금한 것\n\n## 느낀 것\n- shook 드디어 킥보드 완성..! 다음 데모데이 때는 꼭 자전거가 되어보자 ~\n- S-HOOK 을 다른 사람들에게 써보라고 했는데, 투표 버튼을 못 찾는 사람들이 많았다. UX 에 좀 더 신경써야겠다."},{"excerpt":"⚖️ 알게 된 것들을 종류 가리지 않고 적는 개인 위키입니다. 이번 달의 TIL: 2025년 02월의 TIL✨ 지금 아무것도 못한다고 해서 앞으로도 아무것도 못하는 건 아니다. 그러나 지금부터 아무것도 하지 않는다면 나는 앞으로 아무것도 못할 것이다. Introduction 안녕하세요! 실패로부터 배우는 과정을 즐기는 개발자, 김은솔입니다. 당면한 문제 해…","fields":{"slug":"/readme/"},"frontmatter":{"date":"2023년 08월 01일 13:08","title":"VERO WIKI","tags":null},"rawMarkdownBody":"\n**⚖️ 알게 된 것들을 종류 가리지 않고 적는 개인 위키입니다.**\n\n이번 달의 TIL: [[2025-02|2025년 02월의 TIL✨]] \n\n> 지금 아무것도 못한다고 해서 앞으로도 아무것도 못하는 건 아니다. 그러나 지금부터 아무것도 하지 않는다면 나는 앞으로 아무것도 못할 것이다.\n\n## Introduction\n\n안녕하세요! 실패로부터 배우는 과정을 즐기는 개발자, 김은솔입니다.  \n당면한 문제 해결을 위해 당연한 하나의 정답보다 가능해 보이는 열 가지의 방법을 팀원과 함께 논의하는 것을 좋아합니다.    \n서비스의 방향은 사용자를 향해야 한다고 생각합니다. 데이터에 기반하여 사용자 경험을 향상시키기 위해 노력해왔습니다.   \n새롭게 알게 된 것이 있으면 글로 정리하여 팀원과 공유합니다. 팀원이 모르는 지식은 의미가 없다고 생각하여 배운 것들을 팀원과 공유하는 문화를 만들고자 합니다.   \n문제를 해결하기 위한 새로운 기술을 도입하는 과정에 관심이 많습니다.    \n## Languages & Technologies\n\n- Languages: **Java**, Kotlin, Python, SQL\n- Technologies: **Spring Boot**, Spring Data JPA, Ktor, AWS, nginx\n- Other: Git, MySQL, Unit, Integration testing"},{"excerpt":"설정 파일  에 설정했다. health-check 외부 nginx 가 헬스 체크 API 를 호출하기 위해서는 헬스 체크 API 를 구현해야 한다.\n헬스 체크 시 인증을 적용하여 외부 접근을 제한한다. 도커로 스프링 애플리케이션 분리하기 docker vs docker-compose docker 각 컨테이너에 대한 명령어를 명시적으로 실행하므로, 어떤 동작이…","fields":{"slug":"/shook-nginx/"},"frontmatter":{"date":"2023년 08월 01일 13:08","title":"nginx 설정기","tags":["shook","nginx","레벨3","우테코"]},"rawMarkdownBody":"\n## 설정 파일\n\n`sites-enabled/default` 에 설정했다.\n\n### health-check\n\n외부 nginx 가 헬스 체크 API 를 호출하기 위해서는 헬스 체크 API 를 구현해야 한다.\n헬스 체크 시 인증을 적용하여 외부 접근을 제한한다.\n\n## 도커로 스프링 애플리케이션 분리하기\n\n### docker vs docker-compose\n\n**docker**\n- 각 컨테이너에 대한 명령어를 명시적으로 실행하므로, 어떤 동작이 발생하는지 쉽게 이해할 수 있다.\n- 각 환경의 컨테이너를 수동으로 관리하고 업데이트해야 한다. 네트워크 설정, 볼륨 마운트 등의 추가 구성을 각 컨테이너마다 수동으로 처리해야 할 수 있다.\n\n**docker-compose**\n- `docker-compose.yml` 파일에 블루 그린 환경 구성을 미리 정의하면, 한 명령으로 전환 및 배포를 수행할 수 있다. 모든 설정과 서비스 설정이 `docker-compose.yml` 파일에서 관리된다. \n- `docker-compose` 의 구성, 명령어에 대해 학습해야 해서 학습 곡선이 존재한다.\n\n블루-그린 배포 전략을 사용하는 경우 `docker-compose` 가 더 적합하다. \n- 모든 설정을 `docker-compose.yml` 파일에서 관리할 수 있어 일관성이 유지되어 블루와 그린 환경을 빠르게 교체할 수 있다.\n- 한 명령어로 블루 그린 환경을 전환할 수 있다.\n- 추가 서비스나 설정을 포함하기 위해 `docker-compose.yml` 파일만 수정하면 된다.\n\n> 추가 ) GPT 답변\n> \n> `docker-compose`가 `docker` 명령어에 비해 관리 및 운영 측면에서 더 효과적인 이유는 여러 가지입니다:\n> 1. **설정 중앙화**: `docker-compose`를 사용하면 모든 서비스 및 컨테이너 관련 설정을 하나의 `docker-compose.yml` 파일에 중앙화하여 관리할 수 있습니다. 이렇게 하면 여러 컨테이너와 서비스에 대한 설정을 일관성 있게 유지할 수 있습니다. \n> 2. **단순화된 명령어**: `docker-compose`는 여러 컨테이너를 동시에 시작, 중지, 재시작하는 등의 작업을 간소화합니다. 예를 들어, 여러 컨테이너를 한번에 시작하려면 `docker-compose up`만 실행하면 됩니다.\n> 3. **네트워크 관리**: `docker-compose`를 사용하면 여러 컨테이너 간의 네트워크 연결 및 설정이 훨씬 간단해집니다. `docker-compose.yml` 파일에서 네트워크 설정을 명시적으로 정의할 수 있습니다. \n> 4. **확장성**: 서비스를 확장하거나 추가적인 컨테이너를 포함시키기 위해선 `docker-compose.yml` 파일만 수정하면 됩니다. 이후 `docker-compose up -d`를 실행하여 변경 사항을 적용할 수 있습니다. \n> 5. **재사용성**: `docker-compose.yml` 파일은 다른 환경이나 팀원 간에도 쉽게 공유하고 재사용할 수 있습니다. 이로 인해 배포나 개발 환경의 일관성을 유지하기 쉽습니다. \n> 6. **문서화**: `docker-compose.yml` 파일 자체가 어떤 서비스들이 있고, 어떻게 연결되어 있는지에 대한 문서의 역할을 합니다. 즉, 새로운 팀원이나 다른 관리자가 시스템을 이해하기 위해 참조할 수 있는 좋은 자료가 됩니다.\n\n"},{"excerpt":"CI에서도 Jenkins 를 사용하지 않았던 만큼, Github Action workflow와 동일한 문법을 사용하는 Github self-hosted runner를 사용하기로 했다. 그런데 생각보다 힘든 작업이었다... 설정하는 데 시간도 오래 걸렸다. CD file 개발 서버에서 QA 용으로 사용할 CD 파일이다. 특정 트리거를 달아두지 않고, 수동으…","fields":{"slug":"/github-self-hosted-runner/"},"frontmatter":{"date":"2023년 08월 01일 12:08","title":"Github Self-hosted Runner 설정","tags":["github","shook","레벨3","우테코","trouble-shooting"]},"rawMarkdownBody":"\nCI에서도 Jenkins 를 사용하지 않았던 만큼, Github Action workflow와 동일한 문법을 사용하는 Github self-hosted runner를 사용하기로 했다.     \n\n그런데 생각보다 힘든 작업이었다... 설정하는 데 시간도 오래 걸렸다.\n\n## CD file\n\n개발 서버에서 QA 용으로 사용할 CD 파일이다.     \n특정 트리거를 달아두지 않고, 수동으로 실행시킬 수 있도록 설정해두었다.    \n\n```yml\nname: Backend Develop Deploy (CD)\n\non:\n  workflow_dispatch:\n    inputs:\n      branch:\n        description: 'Branch Name'\n        required: true\n\njobs:\n  build:\n    name: Backend Deploy\n    runs-on: shook-runner\n\n    steps:\n      - name: Log pwd\n        shell: bash\n        run: pwd\n      - name: Log Branch Name\n        shell: bash\n        run: echo \"${{ github.event.inputs.branch }}\"\n      - name: Deploy\n        shell: bash\n        run: bash /home/ubuntu/deploy.sh ${{ github.event.inputs.branch }}\n```\n\n```yml\non:\n  workflow_dispatch:\n```\n\n위 설정을 추가하면, github 내부에서 브랜치를 지정해서 workflow를 실행할 수 있는 버튼이 생긴다.     \n\n![[workflow-dispatch-button.png]]\n\n`github.event.inputs.branch` 를 하게 되면 다음과 같이 workflow 실행할 때 같이 입력할 수 있는 값 입력 창이 생긴다.    \n\n![[cd-workflow-input.png]]\n\n## 발생한 Issues\n\n### Server가 끝까지 실행되지 않는 문제\n\n![[self-hosted-runner-error.png]]\n\nStarting ShookApplication 이라는 문구가 나오지 않고, Application 이 종료되었다.  \n\n그렇지만 이 부분은 우리 잘못이었다.    \nddl-auto를 사용하지 않고, 테이블 스키마를 바꾸었는데 테이블을 적용해주지 않으니 connection과 관련한 예외가 발생한 것이다.    \n\n데이터베이스에 추가한 컬럼을 넣어주니 해결되었다.    \n\n### Github Runner 실행 종료 후, Server가 종료되는 현상\n\nGithub Runner 내부에서 Server process 가 실행되었기 때문에, Github Runner 가 실행 종료 되면서 Server process 를 함께 종료하는 문제가 발생했다.    \n\n이 경우, Github Runner 같은 일반 프로그램이 Server Application 을 종료할 수 없도록 `sudo nohup java -jar ...` 처럼 서버를 실행할 때 `sudo` 권한으로 실행하여 문제를 해결했다.    \n\n### nohup.out 이 없어지는 현상\n\nself-hosted runner를 사용하면, runner 에서 서버 애플리케이션을 실행해서 그런지 nohup.out 파일이 어디에도 나타나지 않는다.    \n\n이런 경우에는 배포 스크립트에 다음과 같이 적어주면 해결 된다.    \n\n`sudo nohup java -jar /home/ubuntu/shook.jar > /home/ubuntu/2023-shook/backend/build/libs 2>&1 &` \n\n애플리케이션에서 발생하는 로그들을 어디에 저장할 지 명시해주게 되면, github self-hosted runner 화면에서는 더 이상 서버 실행 로그가 표시되지 않는다.    \n\n![[unexisted-nohup-log.png]]\n\n대신 위에서 명시한 경로에 nohup.out 에 로그가 쌓이게 된다.    \n\n## 단점이라고 생각되는 것들\n\n생각보다 로그가 빈약하다. 어떤 부분에서 예외가 발생하고, 어디에서 발생한 문제인지 알 수가 없다.     \n\nrunner 에서 예외가 발생했는지 아닌지도 알 수 없다. runner 는 성공적으로 수행됐지만, 우리 서버에서는 예외가 발생했을 수도 있다. \n\n디버깅이 너무 어렵다. 로그가 빈약하다보니 우리가 결국 EC2 내부에 들어가서 어디가 잘못됐을 지 무한 추측을 해야만 한다...\n\nJenkins 는 겪어보지 못해 모르겠지만, 생각보다 러닝커브가 있다.     \nyml 파일을 쓰는 것이 오래 걸리는 게 아니라, Runner가 어떤 동작을 하는지 모르니 예외 처리하기가 힘들다.     \n\n"},{"excerpt":"LOG 3시간 동안 self-hosted runner 설정하느라 좀 힘들었다.. 한 번에 될 줄 알았는데 시간이 늘어져서 더 그런 것 같다. 그래도 오늘 안에 끝낼 수 있었어서 다행이다. 아픈데도 3시간 동안이나 열심히 참여해준 스플릿 👍 다들 수고 많았어 🥹 드디어 프론트엔드 페이지를 배포했다. 우리도 이제 페이지에서 요청을 보낼 수 있다 🥹 우리 프론…","fields":{"slug":"/2023-08-01/"},"frontmatter":{"date":"2023년 08월 01일 02:08","title":"2023년 08월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 3시간 동안 self-hosted runner 설정하느라 좀 힘들었다.. 한 번에 될 줄 알았는데 시간이 늘어져서 더 그런 것 같다. 그래도 오늘 안에 끝낼 수 있었어서 다행이다. 아픈데도 3시간 동안이나 열심히 참여해준 스플릿 👍 다들 수고 많았어 🥹\n- 드디어 프론트엔드 페이지를 배포했다. 우리도 이제 페이지에서 요청을 보낼 수 있다 🥹 우리 프론트 짱짱\n\n## 배운 것\n- [[github-self-hosted-runner]] 를 설정했다.\n- [[spring-profile-trouble-shooting]] 의 local 프로필 내용이 덮어씌워지는 현상을 정리했다.\n- 코난이 설명해준 엄청난 이야기\n\t- 프론트 페이지를 통해 요청이 들어왔을 때, nginx 로 요청이 전달되어 우리 서버 내부의 정적 파일을 찾아서 넘겨준다. 정적 파일은 브라우저로 전달되는데, 이때 발생하는 API 요청은 EC2의 정적 파일이 아닌 브라우저의 정적 파일에서 발생한다. (리액트가 브라우저에서 실행된다고 했다. 내 방식대로 이해해서 정확하진 않을 수도 있다) \n\n## 궁금한 것\n\n## 느낀 것\n- 피곤하면 효율이 안 나온다.\n- 알고리즘이 후순위로 밀릴 때가 잦은 것 같다.\n- Github Runner를 사용할 때, 실제 브랜치에 반영되지 않으면 테스트 해볼 수 없어서 그 부분도 불편한 듯 ㅠ"},{"excerpt":"2023-08-01 2023-08-03 2023-08-04 2023-08-05 2023-08-06 2023-08-07 2023-08-09 2023-08-10 2023-08-16 2023-08-17 2023-08-24 2023-08-25 2023-08-27 2023-08-28 2023-08-29 2023-08-30 2023-08-31","fields":{"slug":"/2023-08/"},"frontmatter":{"date":"2023년 08월 01일 02:08","title":"2023년 08월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-08-01]]\n- [[2023-08-03]]\n- [[2023-08-04]]\n- [[2023-08-05]]\n- [[2023-08-06]]\n- [[2023-08-07]]\n- [[2023-08-09]]\n- [[2023-08-10]]\n- [[2023-08-16]]\n- [[2023-08-17]]\n- [[2023-08-24]]\n- [[2023-08-25]]\n- [[2023-08-27]]\n- [[2023-08-28]]\n- [[2023-08-29]]\n- [[2023-08-30]]\n- [[2023-08-31]]\n"},{"excerpt":"Local Profile 실행이 안 되는 문제 현재 default profile을 실행시키고 있으므로, 서브 모듈에 존재하는 prod profile은 실행되지 않아야 한다. 그런데 애플리케이션을 실행시키니, 이런 예외가 발생했다.  옵션은 '활성화 되는' 프로필에 있어야 한다. 마찬가지로  옵션도 그렇다. local 환경에서는 'prod' 가 활성 프로필…","fields":{"slug":"/spring-profile-trouble-shooting/"},"frontmatter":{"date":"2023년 07월 31일 13:07","title":"Spring profile Trouble shooting","tags":["spring","개발","trouble-shooting"]},"rawMarkdownBody":"\n## Local Profile 실행이 안 되는 문제\n\n```bash\n22:18:51.159 [main] ERROR org.springframework.boot.SpringApplication -- Application run failed\norg.springframework.boot.context.config.InactiveConfigDataAccessException: Inactive property source 'Config resource 'class path resource [shook-security/application.yml]' via location 'classpath:shook-security/application.yml'' imported from location 'class path resource [shook-security/application.yml]' cannot contain property 'spring.profiles.group.prod' [origin: class path resource [shook-security/application.yml] - 4:13]\n```\n\n현재 default profile을 실행시키고 있으므로, 서브 모듈에 존재하는 prod profile은 실행되지 않아야 한다.     \n그런데 애플리케이션을 실행시키니, 이런 예외가 발생했다.     \n\n```yml\n# 기존 prod\nspring:  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n  config:  \n\timport: classpath:shook-security/application-jwt.yml, classpath:shook-security/application-oauth.yml\n...\n```\n\n`spring.profiles.group` 옵션은 '활성화 되는' 프로필에 있어야 한다.    \n마찬가지로 `spring.profiles.include` 옵션도 그렇다.    \n\nlocal 환경에서는 'prod' 가 활성 프로필이 아니기 때문에, 예외가 발생하는 것이다.    \n\n그러므로 다음과 같이 변경하면 된다.    \n\n```yml\n# 기존 prod 에서는 group 설정을 삭제한다.\n...\n```\n\n```yml\n# 기본 application.yml 에 group 설정을 해준다.\n\nspring:  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n  config:  \n    import: classpath:shook-security/application.yml\n```\n\n## local 프로필이 prod 프로필을 덮어 씌우는 문제\n\ngithub self-hosted runner 를 설정하면서, 로그를 확인했다.    \n분명 개발 서버에서는 prod 프로필으로 설정되어야 하는데, 이상하게도 데이터베이스 username은 prod 유저 이름인데, 데이터베이스 url이 local 프로필의 url 이었다.     \n\n왜 이런 상황이 발생했을까?\n\n```yml\n# main/resources 내부의 기본 application.yml\nspring:  \n  config:  \n    import: classpath:shook-security/application.yml  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n  \n---  \nspring:  \n  datasource:  \n    driver-class-name: org.h2.Driver  \n    url: jdbc:h2:mem:shook  \n  \n  sql:  \n    init:  \n      mode: always  \n      schema-locations: classpath:schema.sql  \n      data-locations: classpath:data.sql  \n  \n  jpa:  \n    properties:  \n      hibernate:  \n        format_sql: true  \n        show-sql: true  \n    hibernate:  \n      ddl-auto: validate\n```\n\n이때, 불러와지는 prod 프로필은 파일 하단이 아닌, local 프로필 위에 작성된다.     \n다음과 같이 말이다. \n\n```yml\n# main/resources 내부의 기본 application.yml\nspring:  \n  config:  \n    import: classpath:shook-security/application.yml  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n\n---\nprod profile....\n  \n---  \nspring:  \n  datasource:  \n    driver-class-name: org.h2.Driver  \n    url: jdbc:h2:mem:shook  \n...\n```\n\n따라서 prod 프로필에만 존재하는 username, password 는 제대로 설정된 반면, 중복되게 정의된 `spring.datasource.url` 은 local 프로필의 내용으로 덮어씌워진 것이다.     \n\n그렇다면 어떻게 해결할 수 있을까?      \n\n답은 간단하다. local profile 의 이름을 정해주면 된다.     \n\n```yml\nspring:  \n  config:  \n    import: classpath:shook-security/application.yml  \n  profiles:  \n    group:  \n      prod: oauth, jwt  \n    active: local  \n  \n---  \nspring:  \n  config:  \n    activate:  \n      on-profile: local\n...\n```\n\nlocal 에서는 실행했을 때 local 프로필로 실행될 수 있도록 `active` 설정을 해주고, `on-profile` 로 이름을 명시해준다.     \n\n이전 파일에서는 local profile 이라는 명시가 없었기 때문에, 그냥 해당 application.yml 파일이 실행될 때 같이 실행되는 설정으로 인식한 듯 하다.    \n\n이렇게 하면 정상적으로 각 프로필을 지정하는 것을 볼 수 있을 것이다.    \n\n## Profile에 대한 짧은 지식\n\n- profile 파일 이름으로 `application-{profile-name}.yml` 을 적으면, 굳이 `spring.config.activate.on-profile` 에 이름을 명시하지 않아도 잘 동작한다.    \n\n- `spring.config.import` 는 대부분의 경우 없어도 잘 동작한다고 한다. 즉, yml 파일이 다른 경로에 있어도 알아서 prod를 읽어온다... 그렇지만 명시적으로 적어주는 게 좋다고 한다.    "},{"excerpt":"DTO Projection 이란 엔티티 대신에 DTO 를 편리하게 조회할 때 사용한다. 엔티티의 일부 속성만 가져오고 싶을 때 사용할 수 있다. 프로젝트에서 Join 한 모든 내용 대신, 노래 정보와 전체 좋아요만 가져오려고 사용했다. 인터페이스 기반 Projection 구현 객체는 JPA 가 프록시로 만들어 준다. projection 된 결과 객체는 영…","fields":{"slug":"/jpa-dto-projection/"},"frontmatter":{"date":"2023년 07월 31일 12:07","title":"JPA의 DTO Projection","tags":["jpa","database"]},"rawMarkdownBody":"\n## DTO Projection 이란\n\n엔티티 대신에 DTO 를 편리하게 조회할 때 사용한다.     \n엔티티의 일부 속성만 가져오고 싶을 때 사용할 수 있다.      \n프로젝트에서 Join 한 모든 내용 대신, 노래 정보와 전체 좋아요만 가져오려고 사용했다.\n\n## 인터페이스 기반 Projection\n\n구현 객체는 JPA 가 프록시로 만들어 준다.\n\nprojection 된 결과 객체는 영속성이 유지되지 않는다.\n\n### interface projection 은 언제 써야 할까?\n\ninterface projection 은 다음과 같은 부분에서 이점을 갖는다. 보통 가독성 측면의 장점이 많은 것 같다.\n\n단순하다. (개인적으로 가장 장점이라 생각한다) 원하는 필드에 해당하는 getter 메서드로 인터페이스를 선언하기만 하면 Spring Data 가 알아서 처리해준다.    \n\n생성자가 필요없다. 그렇지만 이 부분은 lombok 을 쓰면 되니 class projection 에 비해 큰 장점이라고 하기는 어려울 수도 있다.    \n\n현재 dto projection으로 가져오는 데이터가 단순한 평면 구조의 데이터이고, 클래스 내부에서 추가 가공이 이루어지지 않기 때문에 굳이 class projection 을 사용하지 않아도 될 듯 하다.    \n중첩된 DTO가 있는 복잡한 데이터 구조가 필요하거나, DTO 생성자에서 계산을 수행하는 경우에는 class projection이 좋은 선택이 될 수도 있다고 한다.\n\n## 클래스 기반 Projection\n\n생성자의 파라미터 이름으로 Projection 이 동작한다.\n쿼리에 패키지 이름까지 다 써줘야 한다.\n\n## Class Projection 사용 시 주의 점\n\nClass projection을 사용할 때, query 앞에 패키지 경로를 적지 않으면 작동을 하지 않습니다.    \n\n```java\n@Query(\"SELECT NEW shook.shook.song.domain.SongTotalVoteCountDto(s, COUNT(v)) ... \")\n```\n\n이런 식으로 query 내부에 패키지를 적어줘야 합니다.    \n\n## Open Projection\n\n인터페이스에 정의된 메서드에 대한 구체적인 구현을 제공할 수 있다.    \n개발자가 원하는 로직에 따라 값을 반환하게 된다.\n\n## Closed Projection\n\n인터페이스에 정의된 메서드만 사용되며, 엔티티의 특정 속성에 직접 매핑된다.\n\n## 주의\n\nDTO projection 을 사용하면 기존 설정을 무시하고 eager loading 을 하는 듯하다."},{"excerpt":"LOG 아침부터 의자에 올라가고 싶은 날이었다.. 가끔 아침부터 에너지가 주체 안 되는 날이 있는데 그게 바로 오늘이었다. 끝나고 잠실에 놀러갔다. 토리, 포이, 망고랑 저녁으로 신천직화를 먹었다. 오랜만에(?) 잠실 와서 그런가 13층인지 14층인지 헷갈렸다 ㅋㅋㅋ 배운 것 를 사용할 때 가져오는 Response가 0-1개라면 를 사용해야 한다. 100…","fields":{"slug":"/2023-07-27/"},"frontmatter":{"date":"2023년 07월 27일 14:07","title":"2023년 07월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 아침부터 의자에 올라가고 싶은 날이었다.. 가끔 아침부터 에너지가 주체 안 되는 날이 있는데 그게 바로 오늘이었다.\n- 끝나고 잠실에 놀러갔다. 토리, 포이, 망고랑 저녁으로 신천직화를 먹었다. 오랜만에(?) 잠실 와서 그런가 13층인지 14층인지 헷갈렸다 ㅋㅋㅋ \n\n## 배운 것\n- `WebClient`를 사용할 때 가져오는 Response가 0-1개라면 `Mono`를 사용해야 한다.\n- 1000ms 는 1초다.\n\n## 궁금한 것\n\n## 느낀 것\n- 토리가 저녁에 잠실 거실 풍경(?)을 보면서 감동적이라고 한 게 너무 웃겼다 ㅋㅋㅋ\n"},{"excerpt":"발단 S-HOOK의 검색 기능을 구현하면서, 많은 노래를 검색할 수 있어야 하는 기능이 필요해졌다. 그래서 maniaDB의 API 를 사용해서 가수 이름, 노래 이름으로 조회하는 검색 API 를 추가하기로 했다. 그런데 maniaDB의 search API 는 리턴되는 Response가 XML이다... 그렇기 때문에 기존에 우리가 사용하던 JSON DTO의…","fields":{"slug":"/spring-xml-parsing/"},"frontmatter":{"date":"2023년 07월 26일 14:07","title":"Spring에서 외부 API XML Response 파싱하기","tags":["spring","shook","레벨3","우테코","미완성"]},"rawMarkdownBody":"\n## 발단\n\nS-HOOK의 검색 기능을 구현하면서, 많은 노래를 검색할 수 있어야 하는 기능이 필요해졌다.    \n그래서 maniaDB의 API 를 사용해서 가수 이름, 노래 이름으로 조회하는 검색 API 를 추가하기로 했다. \n\n그런데 maniaDB의 search API 는 리턴되는 Response가 XML이다... 그렇기 때문에 기존에 우리가 사용하던 JSON DTO의 방식을 그대로 사용할 수가 없다. \n\nSpring 에서 XML 을 파싱하는 방법에 대해 알아보자.\n\n## 참고\n\n- [GPT와 나눈 대화](https://chat.openai.com/share/7a487192-168b-4d19-b8d8-5689a40f177e)"},{"excerpt":"현재 S-HOOK DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 한다. 그 중에서 S-HOOK은  를 채택했는데, 이유는 다음과 같다. RestTemplate 란? 간단하고 사용하기 쉽다. sync-blocking 으로 작동한다. 모든 주요 HTTP 메서드에 대해 메서드를 제공하여 모든 종류의 HT…","fields":{"slug":"/spring-external-api-call-method/"},"frontmatter":{"date":"2023년 07월 26일 08:07","title":"Spring 에서 외부 API를 호출하는 방법 비교","tags":["spring","shook","레벨3"]},"rawMarkdownBody":"\n현재 S-HOOK DB에 들어있는 노래 외에, ManiaDB 에 있는 노래를 조회하기 위해 외부 API 에 요청을 보내야 한다.     \n\n그 중에서 S-HOOK은 `WebCient` 를 채택했는데, 이유는 다음과 같다.      \n\n## RestTemplate 란?\n\n간단하고 사용하기 쉽다. sync-blocking 으로 작동한다.    \n모든 주요 HTTP 메서드에 대해 메서드를 제공하여 모든 종류의 HTTP 요청을 쉽게 수행할 수 있다.    \n\n그러나 Spring 5부터 `RestTemplate` 에 대한 업데이트는 없다. 따라서 새 프로젝트에서는 `WebClient` 를 사용하는 것을 추천한다고 한다.     \n\n## WebClient\n\nSpring MVC 에서도 `WebClient` 를 사용할 수 있다.     \nNon-blocking 으로 동작하여 많은 수의 동시 요청을 효율적으로 처리하는 데 적합하여 확장성을 향상시킬 수 있다.    \n\n그러나 Spring MVC 에서 사용되는 경우, non-blocking 특성이 각 request-response 주기에 대해서 스레드가 block 되는 서블릿 기반 애플리케이션에서는 이점이 없을 수도 있다.     \n\n또한 Spring MVC 애플리케이션의 동기식 메서드에서 `WebClient` 호출 결과를 사용해야 하는 경우, 다음과 같이 `block()` 을 호출하여 결과를 기다려야 할 수도 있다.     \n\n```java\nMono<String> result = webClient.get()\n   .uri(\"/api/resource\")\n   .retrieve()\n   .bodyToMono(String.class);\n\n// To get the result synchronously\nString response = result.block();\n```\n\n일반적으로 reactive programming 에서는 권장되지 않는다고 한다.\n\n## Feign\n\nNetflix 에서 개발 후, 나중에 Spring Cloud 생태계에 통합되었다.    \nSpring Cloud 애플리케이션으로 작업 중이고, 로드 밸런싱과 같은 다른 Spring Cloud 기능과 쉽게 통합하려는 경우, 좋은 선택이 될 수 있다.    \n\n그러나 Spring Cloud context 에 있지 않은 경우, 과한 구현이 될 수 있다.     \n\n## 결론...\n\n아무래도 이미 deprecated 된 `RestTemplate` 을 쓰는 것보다는 `WebClient` 를 사용해봐야겠다.    \n\n추후 다른 글을 작성해보겠다."},{"excerpt":"Search API v0.5 Request url:  노래 이름 검색:  노래 이름 검색은 검색어가 포함된 노래를 전부 리턴하는 듯 가수 이름으로도 노래를 검색할 수 있다. 다만 가수 이름에 검색어만 포함되어 있으면 전부 리턴하는 것 같음. 데이터 개수는 1부터 100까지 가능하다. 페이지네이션은 존재하지 않고, 최대 100개의 데이터만 가져올 수 있다.…","fields":{"slug":"/shook-maniadb/"},"frontmatter":{"date":"2023년 07월 26일 07:07","title":"maniaDB 정리 문서","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## Search API v0.5\n\n### Request \n\n- url: `http://www.maniadb.com/api/search/[keyword]/?sr=[artist|album|song]&display=[1~100]&key=[apikey]&v=[version]`\n\n- 노래 이름 검색: `http://www.maniadb.com/api/search/노래이름검색어/?sr=song&display=데이터개수&key=example&v=0.5`\n\t- 노래 이름 검색은 검색어가 포함된 노래를 전부 리턴하는 듯\n\t- 가수 이름으로도 노래를 검색할 수 있다. 다만 가수 이름에 검색어만 포함되어 있으면 전부 리턴하는 것 같음.\n\n- 데이터 개수는 1부터 100까지 가능하다. 페이지네이션은 존재하지 않고, 최대 100개의 데이터만 가져올 수 있다.\n\napi key 는 추후 변경 가능하다. 기존에는 이메일 validation check를 했었으나, 현재는 하고 있지 않다고 한다.\n\n### Response\n\nXML 로 이루어져 있다.\n\n#### 노래 검색\n- item: 검색된 결과 \n\t- title: 노래 이름\n\t- runningtime: 곡 길이 (없는 값도 존재한다)\n\t- maniadb:album\n\t\t- title: 앨범 이름\n\t\t- image: 앨범 이미지\n\t- maniadb:trackartists\n\t\t- maniadb:artist\n\t\t\t- name: 가수 이름\n"},{"excerpt":"LOG 절댓값 힙, 가장 증가하는 부분 수열 2를 풀었다. 배운 것  를 하면 db 확장자를 갖는 파일을 모두 삭제할 수 있다. spring properties를 사용해서 h2의 기본 username, password를 설정 안 하면 그냥 빈 값으로 넣고 들어가야 한다. github action에서 특정 디렉터리의 변경만 감지하고 싶다면 다음과 같이 작성…","fields":{"slug":"/2023-07-26/"},"frontmatter":{"date":"2023년 07월 26일 01:07","title":"2023년 07월 26일","tags":null},"rawMarkdownBody":"## LOG\n- 절댓값 힙, 가장 증가하는 부분 수열 2를 풀었다.\n\n## 배운 것\n- `rm *.db` 를 하면 db 확장자를 갖는 파일을 모두 삭제할 수 있다.\n- spring properties를 사용해서 h2의 기본 username, password를 설정 안 하면 그냥 빈 값으로 넣고 들어가야 한다.\n- github action에서 특정 디렉터리의 변경만 감지하고 싶다면 다음과 같이 작성하면 된다.\n\n```yaml\non:\n  pull_request:\n    ...\n    paths:\n      - \"backend/**\"\n```\n\n- lower_bound\n\n```python\ndef lower_bound(lo, hi, target_index):  \n    while lo < hi:  \n        mid = (lo + hi) // 2  \n        if dp[mid] >= a[target_index]:  \n            hi = mid  \n        else:  \n            lo = mid + 1  \n  \n    return hi\n```\n\n- [[spring-external-api-call-method]] 을 정리했다.\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG 준에게 SHOOK 피드백을 부탁했다. 가치있는 피드백을 받아서 기분좋다. 킬링파트에 대한 리액션을 할 수 있다면 더 재밌을 것 같다. 서비스를 사용하는 순간에 대한 맥락이 존재한다면 사용자에게 공감을 더 받을 수 있고, 확실하게 사용자에게 어필할 수 있는 수단이 될 듯. 킬링파트라는 포인트는 재밌다. 돈카라 김치 우동은 별로야... 스플릿이 먹은 …","fields":{"slug":"/2023-07-25/"},"frontmatter":{"date":"2023년 07월 25일 07:07","title":"2023년 07월 25일","tags":null},"rawMarkdownBody":"## LOG\n\n- 준에게 SHOOK 피드백을 부탁했다. 가치있는 피드백을 받아서 기분좋다.\n\t- 킬링파트에 대한 리액션을 할 수 있다면 더 재밌을 것 같다.\n\t- 서비스를 사용하는 순간에 대한 맥락이 존재한다면 사용자에게 공감을 더 받을 수 있고, 확실하게 사용자에게 어필할 수 있는 수단이 될 듯.\n\t- 킬링파트라는 포인트는 재밌다.\n- 돈카라 김치 우동은 별로야... 스플릿이 먹은 모둠카츠랑 바론이 먹은 치킨 가라아게 카레는 맛있다고 했다. 나중엔 카레 먹어봐야지\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG upper bound 문제를 풀었다. 사실 물어보면서 푼 문제지만 뿌듯하네요 발목 약을 꾸준히 먹었다. SHOOK 페르소나에 대해 다시 이야기하고, 3차 데모데이 어떤 기능을 구현할지 회의했다. 배운 것 lower-bound-and-upper-bound 에 upper bound의 주의할 점을 배웠다. shook-persona 에 SHOOK 의 가치…","fields":{"slug":"/2023-07-24/"},"frontmatter":{"date":"2023년 07월 25일 00:07","title":"2023년 07월 24일","tags":null},"rawMarkdownBody":"## LOG\n- upper bound 문제를 풀었다. 사실 물어보면서 푼 문제지만 뿌듯하네요\n- 발목 약을 꾸준히 먹었다. \n- SHOOK 페르소나에 대해 다시 이야기하고, 3차 데모데이 어떤 기능을 구현할지 회의했다.\n\n## 배운 것\n- [[lower-bound-and-upper-bound]] 에 upper bound의 주의할 점을 배웠다.\n- [[shook-persona]] 에 SHOOK 의 가치와 페르소나 관련 이야기를 추가했다.\n \n## 궁금한 것\n\n## 느낀 것\n- 역시 회의로 싱크를 맞추는 것이 굉장히 굉장히 중요하다... 우리 회의가 많고 절대적인 시간도 길지만 확실히 가치가 있다."},{"excerpt":"우리 팀의 서비스를 한 줄로 소개한다면? 누구나 듣던 노래들이 지루하고, 지겨워질 때가 있습니다. 그렇지만 좋은 노래를 찾으려면 다시 추천을 받고, 처음부터 들어봐야 하는 과정이 귀찮아 그냥 듣던 노래를 들었던 적이 있지 않으신가요? 도입부가 별로여서 듣지 않았던 노래가 나중에 들어보니 하이라이트가 내 취향이어서 놀랐던 경험은 한 번쯤 있으셨을 겁니다. …","fields":{"slug":"/shook-service-introduce/"},"frontmatter":{"date":"2023년 07월 24일 06:07","title":"S-HOOK 서비스 소개 글","tags":["shook","레벨3","우테코","기획"]},"rawMarkdownBody":"\n### 우리 팀의 서비스를 한 줄로 소개한다면?\n\n누구나 듣던 노래들이 지루하고, 지겨워질 때가 있습니다. \n\n그렇지만 좋은 노래를 찾으려면 다시 추천을 받고, 처음부터 들어봐야 하는 과정이 귀찮아 그냥 듣던 노래를 들었던 적이 있지 않으신가요?     \n도입부가 별로여서 듣지 않았던 노래가 나중에 들어보니 하이라이트가 내 취향이어서 놀랐던 경험은 한 번쯤 있으셨을 겁니다.      \n\n저희는 좋은 노래를 찾기 위한 과정들에 걸리는 시간들을 줄이고 싶었습니다.    \n어떻게 하면 좋은 노래를 빠르게 찾을 수 있을지 고민하다, 노래의 가장 좋은 부분인 '킬링파트'만 들어보고 노래를 찾을 수 있는 서비스 'S-HOOK' 을 만들었습니다.     \n\nS-HOOK에서는 노래를 끝까지 들어볼 필요는 없습니다. 킬링파트만 먼저 들어보고, 마음에 든다면 노래를 끝까지 들어보는 거죠. 이제는 더 이상 마음에 들지 않는 노래까지 처음부터 들으실 필요 없습니다.     \n\n등록된 킬링파트가 마음에 들지 않으시다면, 직접 킬링파트를 등록하실 수도 있습니다!     \nS-HOOK은 내가 추천한 노래를 다른 사람들이 듣고 좋아하는 걸 즐기시는 분들을 환영합니다.     \n사람들이 많이 등록한 파트는 그 노래의 '킬링파트'가 됩니다. 내가 선정한 파트가 '킬링파트'로 선정되는 즐거움을 느껴보세요. \n\n이제 당신도 S-HOOK의 혁신적인 음악 탐색 방식을 통해, 새로운 최애곡을 몇 초 만에 만드실 수 있습니다. 더 이상 곡을 찾는 데 많은 시간을 쓸 필요가 없습니다. \n\n### 최종본\n  \n가끔 노래를 끊임없이 반복해서 듣다 보면 지루함이 찾아오곤 합니다. 새로운 노래를 찾기 위해 알고리즘에게 추천을 받아보고, 처음부터 들어보는 과정은 때로는 지루하고 귀찮기만 합니다. 또한, 도입부가 별로여서 넘겼던 노래가 나중에는 당신의 취향에 딱 맞는 노래였던 경험은 한 번쯤 있으셨을 거라 생각합니다.\n\n그런 당신을 위해 'S-HOOK'이라는 서비스를 만들었습니다.     \nS-HOOK는 노래의 가장 강렬한 부분인 '킬링파트'만을 듣고 당신의 새로운 최애곡을 발견할 수 있게 도와줍니다.\n\n더 이상 노래를 처음부터 끝까지 들어보며 시간을 낭비할 필요가 없습니다. 킬링파트만 먼저 들어보고, 마음에 든다면 노래를 끝까지 들을 수 있습니다. 이를 통해, 당신이 원하지 않는 노래를 처음부터 들을 필요가 없어져 빠르게 노래를 탐색할 수 있습니다.    \n\n등록된 '킬링파트'보다 더 좋은 부분을 알고 계신가요? 그렇다면 직접 파트를 등록해보세요! \nS-HOOK에서는 자유롭게 좋아하는 노래의 파트를 등록할 수 있습니다. 당신이 좋아하는 파트가 '킬링파트' 로 선정되는 즐거움을 느껴보세요. \n\nS-HOOK를 통해 빠르게 새로운 음악을 탐색하고, 나만의 새로운 최애곡을 몇 초 만에 발견하세요. S-HOOK에서 당신의 새로운 음악을 찾는 여정을 시작하세요!\n\n## 중간 글\n\n\"강렬한 인상을 주는 노래 한 소절\", 유저들이 킬링파트를 만들고 공유하며 즐기는 서비스 S-HOOK입니다.\n\n가끔 노래를 끊임없이 반복해서 듣다 보면 지루함이 찾아오지 않으신가요?\n새로운 노래를 찾기 위해 알고리즘의 추천을 받아보고, 처음부터 들어보는 과정은 때때로 지루하고 귀찮게 느껴집니다.\n도입부가 별로여서 넘겼던 노래가 나중에는 취향에 딱 맞는 노래였던 적도 있을 거에요.\n\n그런 당신을 위해 'S-HOOK'이라는 서비스를 만들었습니다.\n'S-HOOK'은 노래의 가장 강렬한 부분인 '킬링파트'만을 듣고 당신의 새로운 최애곡을 발견할 수 있게 도와줍니다.\n\n### 자유롭게 킬링파트를 등록하고 공유하세요 🗽\n\n현재 '킬링파트' 보다 더 좋은 부분을 알고 계신가요? 그렇다면 직접 파트를 등록해보세요!\nS-HOOK에서는 좋아하는 노래의 파트를 자유롭게 등록할 수 있습니다.\n당신이 좋아하는 파트가 '킬링파트' 가 되는 즐거움을 느껴보세요.\n\n### 킬링파트만으로 음악을 더 효율적으로 탐색하세요 🔍\n\n더 이상 노래를 처음부터 끝까지 들어보며 시간을 낭비할 필요가 없습니다.\n많은 유저들로부터 인정받은 킬링파트를 먼저 들어보고, 빠르게 당신의 취향에 맞는 노래를 파악할 수 있습니다.\n\nS-HOOK과 함께 여러분의 킬링파트를 유저들과 나누세요\n\n## 최종본\n\n출근길, 이어폰에서 흘러나오는 어제와 똑같은 노래와 우울한 기분.     \n무언가 새로운 음악을 들어보고 싶지만, 알 수 없는 노래의 시작과 끝을 다 듣기엔... 짧은 출근 시간.\n\n> 어쩌면 오늘 들어볼 노래 10곡 중에 내 새로운 최애 곡이 있을 수도 있잖아?\n\n하지만 노래를 다 들어보기엔 피곤하고, 시간이 아까워.\n\n이런 당신에게 필요한 것, 바로 **'S-HOOK'** 입니다!\n\n### 킬링파트로 음악을 더 효율적으로 탐색하세요 🔍\n\nS-HOOK은 노래의 가장 좋은 부분, 킬링파트만을 선별해 여러분에게 제공합니다.     \n지금 듣는 이 노래가 당신의 취향에 맞는 노래인지 30초 내로 확인해 보세요!\n\n더 이상 좋은 노래를 찾기 위해 처음부터 끝까지 들어보며 시간을 낭비하지 않아도 됩니다.     \n당신의 귀를 사로잡는 바로 그 순간만을 즐기세요!\n\n### 당신의 킬링파트, 사람들과 나눠보세요 ✨\n\n당신의 선택으로 노래에 새로운 생명을 불어넣어 보세요! S-HOOK은 여러분의 킬링파트를 모아 새로운 노래의 킬링파트를 선정합니다.  \n당신만 알던 킬링파트가 모두가 아는 킬링파트로 기억될 기회를 놓치지 마세요.      \n함께 만들어 가는 음악 이야기에 참여해 보세요!\n\n### 핫한 노래, 놓치지 마세요 🔥\n\nS-HOOK 유저들이 어떤 노래를 자주 듣는지 궁금하다면? S-HOOK에서 사람들이 많이 찾는 노래의 킬링파트를 바로 들어보세요.     \n핫한 트렌드를 놓치지 말고 함께 즐겨봐요 🔥\n\n이제, 당신의 출근길을 S-HOOK이 함께합니다.      \n매일 새로운 음악과 함께 오늘 하루를 특별하게 시작하세요 🎧"},{"excerpt":"upper bound x 값보다 큰 값이 처음으로 나타나는 위치 인덱스로 찾기 값으로 찾기 lower bound x 값 이상인 값이 처음으로 나타나는 위치 인덱스로 찾기 값으로 찾기 lower_bound, upper_bound 의 불변식 불변식에 따라  는 반복문 내부에서 불변이다. 따라서  도 성립한다. 이때,  와  는 모두 정수이기 때문에,  가 성…","fields":{"slug":"/lower-bound-and-upper-bound/"},"frontmatter":{"date":"2023년 07월 23일 14:07","title":"Lower Bound, Upper Bound","tags":["알고리즘"]},"rawMarkdownBody":"## upper bound\n\nx 값보다 큰 값이 처음으로 나타나는 위치\n\n### 인덱스로 찾기\n\n```python\ndef upper_bound(lo, hi, target_index):  \n    while lo < hi:  \n        mid = (lo + hi) // 2  \n        if dp[mid] <= a[target_index]:  \n            lo = mid + 1  \n        else:  \n            hi = mid  \n      \n    return hi\n```\n\n### 값으로 찾기\n\n```python\ndef upper_bound(lo, hi, value):\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif dp[mid] <= value:\n\t\t\tlo = mid + 1\n\t\telse: # dp[mid] > value  => 조건에 맞는 값이\b지만, 혹시나 dp[mid] 값보다 더 작은 값이 존재할 수도 있다.\n\t\t\thi = mid\n\treturn hi\n```\n\n```ad-warning\nlo 는 조건에 맞지 않는 값이므로 이 값보다는 큰 값을 확인해야 한다.\nhi 는 조건에 맞는 값이지만 혹시 다른 값이 value 보다 크지는 않은지 확인해야 한다.\n```\n\n## lower bound\n \nx 값 이상인 값이 처음으로 나타나는 위치\n\n### 인덱스로 찾기\n\n```python\ndef lower_bound(lo, hi, target_index):  \n    while lo < hi:  \n        mid = (lo + hi) // 2  \n        if dp[mid] >= a[target_index]:  \n            hi = mid  \n        else:  # dp[mid] < a[target_index] or value\n            lo = mid + 1  \n  \n    return hi\n```\n\n### 값으로 찾기\n\n```python\ndef lower_bound(lo, hi, value):\n\twhile lo < hi:\n\t\tmid = (lo + hi) // 2\n\t\tif dp[mid] < value: # 조건에는 만족하지만, 더 큰 값이 있을 수도 있다.\n\t\t\tlo = mid + 1\n\t\telse: # 조건에 만족하는 값(value 가 존재하는 경우)과 만족하지 않는 값이다.\n\t\t\thi = mid\n\treturn lo\n```\n\n```ad-warning\nlo 는 다음 루프에서 실패할 수도 있는 값을 넣어 검증하는 것이다. \nlo 와 hi 가 같아지는 경우는 반드시 조건에 만족하는 값이 되므로 lo 는 mid + 1 이어야 한다.\n```\n\n## lower_bound, upper_bound 의 불변식\n\n불변식에 따라 $lo < hi$ 는 반복문 내부에서 불변이다.  \n따라서 $lo < (lo + hi) / 2 < hi$ 도 성립한다.  \n\n이때, $lo$ 와 $mid$ 는 모두 정수이기 때문에, $lo < mid < hi$ 가 성립한다는 뜻은 $lo$ 와 $mid$, $mid$ 와 $hi$ 의 차이는 1 이상이라는 뜻과 같다.  \n\n즉, $mid$ 에 1을 더했을 때, 다음과 같은 식이 성립한다는 뜻이다.  \n\n$$mid + 1 \\le hi$$\n\nwhile 루프의 내부가 끝났을 시점에는 언제나 $lo \\le hi$ 가 성립한다. 그러므로 while 문이 끝났을 때는 반드시 $lo == hi$ 라는 것이 보장된다.  \n\n결론: lo 를 리턴하나 hi 를 리턴하나 결과는 똑같을 것이다. \n\n## 주의할 점\n\n- upper bound 에서 hi는 안 되는 값이어야 한다.\n"},{"excerpt":"LOG 발목 검사를 받으러 정형외과에 갔는데, 아킬레스 힘줄염?이라고 했다. 근데 아무리 생각해도 아킬레스 건 다친 건 아닌 거 같은데 ㅋㅋㅋㅋ 그냥 왼쪽 발 복사뼈 아래 쪽이 아픈 건데. 물리 치료까지 받았다. 과외 끝나고 비 안 와서 얼른 뛰어 가고 있었는데 갑자기 비가 왕창 와서 육교 밑에서 비를 피했다... 이제 우리나라도 semi 열대 지방이다.…","fields":{"slug":"/2023-07-22/"},"frontmatter":{"date":"2023년 07월 22일 13:07","title":"2023년 07월 22일","tags":null},"rawMarkdownBody":"\n## LOG\n- 발목 검사를 받으러 정형외과에 갔는데, 아킬레스 힘줄염?이라고 했다. 근데 아무리 생각해도 아킬레스 건 다친 건 아닌 거 같은데 ㅋㅋㅋㅋ 그냥 왼쪽 발 복사뼈 아래 쪽이 아픈 건데. 물리 치료까지 받았다.\n- 과외 끝나고 비 안 와서 얼른 뛰어 가고 있었는데 갑자기 비가 왕창 와서 육교 밑에서 비를 피했다... 이제 우리나라도 semi 열대 지방이다. 스콜이 내린다;;\n- 비 올 때 steal the show 들으니까 좋았다.\n\n## 배운 것\n- [[fibonaci-matrix]] 를 공부했다. 뒷고리즘\n\n## 궁금한 것\n\n## 느낀 것"},{"excerpt":"보통 피보나치 수열은 O(N) 으로 구할 수 있다. 그런데 피보나치 수 6 에서는 N이 1,000,000,000,000,000,000 이다..ㅋㅋㅋ N 이 엄두도 안 난다 ㄷㄷ 이런 경우에 사용할 수 있는 행렬 곱셈으로 피보나치 수열을 구하는 방법이 있다. 미래의 나를 위한 글이기 때문에 증명은 생략한다. 풀이는 행렬 곱셈과 완전히 동일하다. 단순히  를…","fields":{"slug":"/fibonaci-matrix/"},"frontmatter":{"date":"2023년 07월 22일 13:07","title":"행렬 곱셈으로 피보나치 수 구하기","tags":["알고리즘"]},"rawMarkdownBody":"\n보통 피보나치 수열은 O(N) 으로 구할 수 있다.    \n그런데 [피보나치 수 6](https://www.acmicpc.net/problem/11444) 에서는 N이 1,000,000,000,000,000,000 이다..ㅋㅋㅋ N 이 엄두도 안 난다 ㄷㄷ\n\n이런 경우에 사용할 수 있는 행렬 곱셈으로 피보나치 수열을 구하는 방법이 있다.     \n미래의 나를 위한 글이기 때문에 증명은 생략한다. \n\n```python\ndef solve(n):  \n    if n == 1:  \n        return BASE  \n  \n    half = solve(n // 2)  \n    value = multiply(half, half)  \n    if n % 2 == 1:  \n        value = multiply(value, solve(1))  \n    return value  \n  \n  \ndef multiply(a, b):  \n    result = [[0, 0], [0, 0]]  \n    for i in range(2):  \n        for j in range(2):  \n            for k in range(2):  \n                result[i][j] += a[i][k] * b[k][j]  \n            result[i][j] %= p  \n    return result  \n  \n  \nn = int(input())  \nBASE = [[1, 1], [1, 0]]  \np = 1000000007  \n  \nprint(solve(n)[0][1])\n```\n\n풀이는 행렬 곱셈과 완전히 동일하다.     \n단순히 `BASE = [[1, 1], [1, 0]]` 를 N번 곱하면 된다. 이때, 피보나치 수열의 N번째 값은 BASE 를 N번 곱한 값의 `[0][1]` 값이나, `[1][0]` 값이다."},{"excerpt":"CORS Cross-Origin Resource Sharing. 어떤 출처에서 실행중인 웹 애플리케이션이 다른 출처의 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제 Origin URL 은 protocol, Host, Path, Query String, Fragment, 포트 번호로 구성되어 있다.  을 예시로 들어보자. Protoco…","fields":{"slug":"/cors/"},"frontmatter":{"date":"2023년 07월 20일 06:07","title":"CORS","tags":["네트워크","개발"]},"rawMarkdownBody":"\n## CORS\n\nCross-Origin Resource Sharing. 어떤 출처에서 실행중인 웹 애플리케이션이 다른 출처의 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제\n\n### Origin\n\nURL 은 protocol, Host, Path, Query String, Fragment, 포트 번호로 구성되어 있다.\n\n`https://vero.wiki:443/til/2023-08?page=1#오늘` 을 예시로 들어보자.\n\n- Protocol: `https://`\n- Host: `vero.wiki`\n- Port: `443` (생략 가능)\n- Path: `/til/2023-08`\n- Query String: `?page=1`\n- Fragment: `오늘`\n\n이 중, Protocol, Host, Port 3가지가 같으면 동일 출처 (origin) 이라고 한다.\n\n### SOP\n\nSame-Origin Policy. 같은 출처에서만 리소스를 공유할 수 있다는 정책이다.    \n다른 출처로부터 조회한 자원들의 읽기 접근을 막아 다른 출처의 공격을 예방한다.    \n\n그러나 웹에서 다른 출처의 리소스를 가져와서 사용하는 일은 흔하다. 이런 예외 상황을 위해 CORS 정책을 지킨 리소스 요청은 출처가 다르더라도 허용하기로 했다.\n\n### 왜 SOP 가 생겨났을까?\n\n웹 초기 단계에서 웹 보안의 기본 원칙으로 도입되었다. 다양한 웹 사이트와 서비스가 정보와 리소스를 공유하는 환경에서 동작할 때, 다른 출처의 리소스에 자유롭게 액세스하는 것은 큰 보안 위험을 야기할 수 있다.\n\nSOP 는 정보의 무분별한 액세스를 제한한다. 웹사이트 A 의 스크립트가 웹사이트 B 의 데이터와 리소스에 접근할 수 있다면, 웹사이트 A 가 B의 사용자 데이터를 쉽게 읽어올 수 있을 것이다. 이는 CSRF 나 XSS 공격이 발생했을 때 사용자의 민감한 정보가 노출되는 결과가 발생할 수 있다.\n\n(`Cross-Site Scripting` , 즉 XSS 공격이란 공격자가 악의적인 스크립트를 웹 페이지에 삽입하여 다른 사용자가 스크립트를 실행하게 하는 공격이다.)\n\n### 출처를 비교하는 로직의 주체\n\n출처를 비교하는 로직은 브라우저에 구현되어 있다. CORS 정책을 위반하는 리소스 요청을 서버로 보내더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다고 설정된 경우가 아니면 서버는 정상적으로 응답한다.     \n\n즉, 서버간 통신을 할 때에는 이 정책이 적용되지 않는다.\n\n## Preflight Request\n\n본 요청을 보내기 전에 보내는 예비 요청이다. OPTION 메서드가 사용된다.    \n\nOrigin 헤더에 현재 요청하는 origin을 담고, Access-Control-Request-Method 헤더에는 요청하는 HTTP 메서드, Access-Control-Request-Headers 에는 요청 시 사용할 헤더를 담아 서버로 요청을 전송한다.\n\n브라우저가 서버에게 예비 요청을 먼저 보내고, 서버는 이 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고 금지하는지에 대한 정보를 응답 헤더에 담아 브라우저에 돌려준다.\n\n브라우저가 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교한 후, 요청을 보내도 안전하다고 판단되면 본 요청을 보낸다. \n\n## Simple Request\n\nCORS Preflight 를 발생시키지 않는 요청이다.    \n예비 요청 없이 본 요청만으로 CORS 정책 위반 여부를 검사하기도 한다.\n\n예비 요청없이 바로 서버에게 본 요청을 보낸 후, 응답 헤더에 `Access-Control-Allow-Origin` 과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다. \n\n다음과 같은 조건들을 모두 만족해야만 예비 요청을 생략할 수 있다.\n\n1. 요청의 메서드는 GET, HEAD, POST 중 하나여야 한다.\n2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width 를 제외한 헤더를 사용하면 안 된다. \n3. 만약 Content-Type 을 사용하는 경우 application/x-www-form-urlencoded, multipart/form-data, text/plain 만 허용된다.\n\n위 조건을 보면 알겠지만, 조건이 굉장히 까다롭기 때문에 대부분 만족시키기 어렵다.\n\n## Credentialed Request\n\n다른 출처간 통신에서 보안을 강화하고 싶을 때 사용하는 방법이다. \n\n요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션은 credentials 옵션으로, 다음과 같은 값을 사용할 수 있다.\n\n1. same-origin (기본값) : 같은 출처 간 요청에만 인증 정보를 담는다.\n2. include: 모든 요청에 인증 정보를 담는다.\n3. omit: 모든 요청에 인증 정보를 담지 않는다.\n\nsame-origin 이나 include 를 사용하여 리소스 요청에 인증 정보가 포함되면, 브라우저는 다음과 같은 규칙을 추가하여 좀 더 엄격하게 검사한다.    \n\n1. Access-Control-Allow-Origin 에는 와일드 카드를 사용할 수 없으며, 명시적인 URL 을 제공해야 한다.\n2. 응답 헤더에는 반드시 Access-Control-Allow-Credentials: true 가 존재해야 한다.\n\n## 참고\n- https://velog.io/@prayme/CORS-%EC%A0%95%EB%B3%B5%EA%B8%B0\n"},{"excerpt":"LOG 발목이 나은 줄 알았는데 안 나았다. 역시 병원에 갈 걸 그랬나 ㅋㅋ 데모데이 전 날... 처음으로 S-HOOK 데모를 봤는데 간지 ㄷㄷ 프론트가 열심히 일해준 덕분에 무사히 데모를 할 수 있을 거 같다. 배운 것  : nginx 테스트  : nginx 다시 켜기  : vim 에서 마우스로 커서를 움직일 수 있다. 궁금한 것 느낀 것 역시 프론트가…","fields":{"slug":"/2023-07-20/"},"frontmatter":{"date":"2023년 07월 20일 04:07","title":"2023년 07월 20일","tags":null},"rawMarkdownBody":"\n## LOG\n- 발목이 나은 줄 알았는데 안 나았다. 역시 병원에 갈 걸 그랬나 ㅋㅋ\n- 데모데이 전 날... 처음으로 S-HOOK 데모를 봤는데 간지 ㄷㄷ 프론트가 열심히 일해준 덕분에 무사히 데모를 할 수 있을 거 같다.\n\n## 배운 것\n- `sudo nginx -t` : nginx 테스트\n- `sudo service nginx reload` : nginx 다시 켜기\n- `:set mouse=a` : vim 에서 마우스로 커서를 움직일 수 있다.\n\n## 궁금한 것\n\n## 느낀 것\n- 역시 프론트가 있어야 뭔가 된다. 분명 백엔드만 있는 서비스는 아무도 안 쓸 거다.. ㅋㅋㅋㅋㅋㅋ 터미널과 까만 창, json으로 뭘 할 수 있는데!!! 슉 프론트 짱"},{"excerpt":"백엔드 기술 스택 개발에 들어가기 앞서, 팀원들과 함께 기술스택을 정하는 시간을 가졌다. Spring Boot 3.1 ver 이 부분을 정하는 것이 핫 포포포테이토였다. (아코 왈) 우리 팀 뿐만 아니라 다른 모든 팀들의 핵심 기술 스택이었다고 생각한다. 왜 Spring Boot를 사용하는가? Spring을 사용하는 경우 외부 라이브러리나 여러가지 dep…","fields":{"slug":"/shook-tech-stack/"},"frontmatter":{"date":"2023년 07월 19일 08:07","title":"S-HOOK 기술 스택","tags":["shook","레벨3","우테코"]},"rawMarkdownBody":"\n## 백엔드 기술 스택\n\n개발에 들어가기 앞서, 팀원들과 함께 기술스택을 정하는 시간을 가졌다.\n\n### Spring Boot 3.1 ver\n\n이 부분을 정하는 것이 핫 포포포테이토였다. (아코 왈)     \n우리 팀 뿐만 아니라 다른 모든 팀들의 핵심 기술 스택이었다고 생각한다.\n\n#### 왜 Spring Boot를 사용하는가?\n\nSpring을 사용하는 경우 외부 라이브러리나 여러가지 dependency를 추가하고 설정하는 많은 리소스가 필요하다.\n\n구성해야하는 여러가지 세부적인 라이브러리에 대한 레퍼런스를 추상화된 spring boot 라이브러리로 제공하기 때문에 편리하다.\n\n#### 왜 버전을 3.1.x 이상으로 사용하는가?\n\n우리는 우테코 기간 내내 Spring Boot는 2.7 ver 를 사용해왔다.    \n그러나 2.7 ver, 3.0 ver 의 OSS support 기간은 2023년 11월까지다.\n\nOSS Support 기간 동안은 Spring 커뮤니티의 지원을 통해 무료 보안 업데이트 및 버그 수정을 제공한다.    \n우리 팀은 프로젝트 이후에도 서비스를 진행하고 싶었기 때문에, OSS Support 가 가장 긴 3.1 ver를 사용하기로 했다.    \n\nOSS Support 는 여기에서 확인할 수 있다. -> https://spring.io/projects/spring-boot#support\n\n### Java 17 ver\n\n이 부분도 논란(?)이 많았다. \n\n일단 Spring Boot 3.1 ver 를 사용하는 순간부터 Java 17 이상을 사용하는 것이 필수였다.    이 이유가 가장 크다...\n\n또한 Java 17 이상의 버전 중 유일한 LTS 버전이라는 점에서 장점을 갖고 있다.    \nLTS 버전은 일반 버전 보다 보안 업데이트의 지원 기간이 길다.     \n\n따라서 Java 17 을 사용하기로 결정했다. \n\n## Spring Data JPA\n\nORM 프레임워크인 JPA를 사용하기로 했다.     \n\nDB 주도 설계와 객체지향 설계 패러다임 사이의 간극을 줄임으로써 객체지향 설계에 집중할 수 있다.     \n\nORM 프레임워크를 사용하지 않게 되면 코드가 DB에 의존하기 때문에 변경 사항이 모든 쿼리에 영향을 미칠 가능성도 생긴다.     \n\n또한 세부적인 구현 내용을 파악하기 위해 쿼리를 굳이 보지 않아도 되고, 데이터베이스 벤더의 변경에 유연하다.\n\n## Lombok\n\nLombok을 사용하게 되면 코드의 가독성이 올라간다. 모든 필드에 대한 getter 가 필요할 때, 예상 가능한 코드 (getter) 가 계속 추가되므로\n\n또한 코드에서 변경이 발생하게 되었을 때, getter, 생성자 같은 코드를 변경하는 데 소비되는 리소스가 줄어드는 점이 좋았다.    \n\n위와 같은 이유로 Lombok을 도입했다.      \n\n"},{"excerpt":"Git Branch 전략 재확립 Git Flow 에서 Github Flow로 변경하였다. 이전 Branch 전략  현재 Branch 전략  전략 재확립 이유 현재 프로젝트 상황에서는 단순한 Github Flow가 관리가 더 용이하다. 모든 개발 내용이 main으로 중심으로 이루어져서, develop, main의 싱크를 신경쓰지 않아도 된다. 웹 서비스이므…","fields":{"slug":"/shook-second-demoday/"},"frontmatter":{"date":"2023년 07월 19일 07:07","title":"2차 데모데이 자료 준비","tags":["shook","데모데이","레벨3","우테코"]},"rawMarkdownBody":"\n## Git Branch 전략 재확립\n\n- Git Flow 에서 Github Flow로 변경하였다.\n- 이전 Branch 전략\n```mermaid\n---\ntitle : S-HOOK Git diagram\n---\n%%{init: { 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': false } } }%%\ngitGraph\ncommit\nbranch feature\ncheckout feature\ncommit\ncommit\ncommit\ncheckout main\nmerge feature\nbranch hotfix\ncommit\ncommit\ncheckout main\nmerge hotfix\n```\n\n![[current-shook-git-branch-strategy.png]]\n\n- 현재 Branch 전략\n\n```mermaid\n---\ntitle : S-HOOK Git diagram\n---\n%%{init: { 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel': false } } }%%\ngitGraph\ncommit\nbranch develop order: 2\ncommit\ncommit\ncheckout main\nmerge develop\nbranch hotfix order: 1\ncommit\ncheckout main\nmerge hotfix\ncheckout develop\nmerge hotfix\nbranch feature order: 3\ncommit\ncommit\ncommit\ncheckout develop\nmerge feature\ncheckout main\ncheckout develop\nbranch fix order: 4\ncommit\ncheckout develop\nmerge fix\ncheckout main\nmerge develop\n```\n\n![[prev-shook-git-branch-strategy.png]]\n\n- 전략 재확립 이유\n\t- 현재 프로젝트 상황에서는 단순한 Github Flow가 관리가 더 용이하다.\n\t- 모든 개발 내용이 main으로 중심으로 이루어져서, develop, main의 싱크를 신경쓰지 않아도 된다.\n\t- 웹 서비스이므로 버전을 관리할 필요가 없다고 판단했다.\n\t- 브랜치가 파생될 수 있는 곳이 main 밖에 없어 충돌 가능성이 적다.\n\n## 3차 데모데이에 구현할 기능\n\n- 로그인\n\t- 소셜 로그인\n\t- 그냥 로그인\n\t- 암호화\n\t\t- jwt\n\t\t- session\n- 유저들이 투표한 킬링파트를 볼 수 있다.\n- 유저들이 투표한 TOP 3 킬링파트를 볼 수 있다.\n- 킬링파트를 많이 알아본 순(?)으로 음잘알 배지를 제공한다.\n- 지정된 파트의 영상을 재생할 수 있다.\n- 파트 투표할 시 댓글도 함께 쓸 수 있도록 한다. (베로 개인 의견)\n- 등록한 파트를 공감하는 비율이 노래의 총 파트 투표 중에 몇 퍼센트인지 알려준다.\n- 등록하기 전에는 파트 순위를 볼 수 없고, 등록 후에 파트 순위를 볼 수 있다.\n- 파트 순위를 즉시 확인하는 기능 -> 대신 음잘알 배지나 순위에는 반영되지 않도록 한다. (베로 개인 의견)\n\n## 피드백\n\n### 코치 피드백\n\n#### S-HOOK\n\n- 기능에 집중하고, 기술에 집중하지 않는 것이 좋다.\n- 로그인 하지마\n\t- mock 유저를 사용해서 기능을 구현하자. 굳이 소셜이냐 뭐냐 고민 안 해도 될 듯.\n\t- 고도화는 레벨 4에\n- 애자일하게 진행하자. 애자일의 각 단위 때마다 의미가 있는 부분을 구현해야 한다.\n- 투표라는 말에 혼선이 존재한다. (모달에서 보여주는 '투표' 라는 말을 빼자)\n\t- 우리끼리 투표라는 말을 사용했지만, 다음 스프린트 때는 없어질 수도 있다.\n\t- 스프린트마다 용어를 다시 정의하기도 한다. 그것이 애자일이다 by 브라운\n\t\t- 이제야 깨달아요.. 이제 다시 투표라는 말이 나올 수도 있게 됐다. 역시 선견지명을 가지신 브라운 (10/15)\n- 사용자가 우리의 서비스를 사용할 때, 플로우를 공부(?) 해야 할 수도 있다. (사용 방식이 잘 와닿지 않는다는 것일지도)\n- 핵심적인 기능을 먼저 만들어서 우리가 전달하고자 하는 가치를 진짜 전달할 수 있을지 없는지를 검증하고 세부적으로 진행하는 것이 좋다.\n\t- 일단 만들어보고 -> 세부 사항을 검증해라\n\n#### 다른 팀\n\n- 기능 우선순위를 두고 구현해야 한다.\n\n### 개인 의견\n\n- 서비스의 기능 플로우를 좀 더 명확하게 보여주자.\n\t- 해당 기능을 통해 어떤 것을 의도했는지도 적어주면 좋을 거 같다.\n- 다음 데모데이 기능을 말할 때, 다음 데모데이의 중심 가치와 함께 발표하자.\n\t- 중심 가치가 우리 서비스의 어떤 가치를 충족할 수 있을지 함께 발표하자.\n- 3차 데모데이에 전달하고 싶은 우리 서비스의 가치에 대해 싱크를 맞추자. (내가 대답 못함..)\n- 질문 대답 같이 하는 거 좋은 듯\n- 구현할 기능 옆에 어떤 것을 의도했는지 적으면 좋을 듯\n- 로그인 했을 때 안 했을 때 나눠서 데모하는 것도 좋을 듯\n\n### 나에 대한 피드백\n\n- 답변할 때 생각 정리하고 말하기\n- 답변하기 전에 할 말 적어두기\n- 열린 자세로 의견을 수용하기\n- 의견을 비난이라고 속단하지 않기\n\n## 회고\n\n이 글 올리면 다들 잘 안 볼 거 같으니 여기다가 2주차 데모데이 회고를 적는다.\n\n### 함께하는 팀\n\n팀은 하나다. 우리는 장난스럽게 하는 말이기도 하지만, 나는 이 말을 가장 잘 지키는 팀은 우리라고 생각한다.    \n문제는 함께 해결하고, 고민은 함께 나눈다.    \n찬성 의견이든 반대 의견이든 누구나 의견이 있다면 말할 수 있고, 함께 의논할 수 있다.     \n내가 원했던 협업의 모습을 띠는 것 같아 뿌듯했다.    \n\n이번 협업에서 내가 가장 중요하게 생각했던 것은 소통이다.    \n다른 건 아니어도 좋으니, 편하게 의견을 낼 수 있는 팀이라면 좋겠다고 생각했다.     \n우리 팀에서 만족하는 부분은 바로 의견 제시가 자유롭고, 반대 의견도 함께 의논하는 분위기라는 것이다.     \n\n특히 내가 주류 의견이든, 반대 의견이든 의견을 많이 내는 편인데, 팀의 누구도 그런 쓸데 없는 고민을 왜 하느냐고 질책하지 않는다. 오히려 공감하고, 함께 고민해주어서 감사할 때가 많았다.\n\n사실 너무나도 많이 말한 이야기인 것 같지만 ㅋㅋㅋ 페르소나를 다시 재정의해야 했던 시간이 있었다.\n\n물론 모두가 반대 의견 내기를 즐기는(?) 것은 아니다.    \n사람들의 특성 때문이기도 하고, 일정을 맞추지 못할까 봐 넘어가는 사람들도 있을 것이다. 나는 그런 이유로 넘어가는 것은     \n그렇지만 반대 의견을 내는 것이 '상대방의 기분을 안 좋게 하기 때문에' 안 하는 사람들은 없어서 정말정말정말정말 다행이라고 생각한다. 더해서 반대 의견이 나왔다고 해서 기분이 안 좋아지는 팀원도 없어서 정말정말 다행이다.    \n\n레벨3에서 다행히도 좋은 팀을 만난 것 같아 감사하고, 팀과 함께 하는 시간이 즐겁다.     \n\n### 그리고 팀원들\n\n나는 내 의견이 있고, 시간의 압박 속에서 반대 의견도 잘 말할 수 있지만 의견 중 하나를 택 일 하는 것이 어렵다. 내 의견에 큰 미련이 없어 내 의견이 채택되지 않아도 괜찮다.      \n그래서 그런지 스플릿이 같은 파트라서 더 시너지가 난다고 생각한다.     \n스플릿은 의견도 확고하고, 자신만의 근거가 있다. 그리고 어떤 의견 하나를 확실하게 정하는 것을 잘한다. 특히 백엔드에서 회의를 할 때, 제시된 대안들 모두 좋은 경우가 많다. 그 중에서 하나를 확실하게 골라준다. 그 덕분인지 의견 결정 과정에서 의견 결정이 미뤄지지 않아 데드라인을 맞추는 것이 어렵지 않았다.    \n\n바론은 의견 정리를 잘한다. 여러 가지 의견이 나오다보면 의견이 섞이는 때가 많은데, 그럴 때마다 항상 의견 정리를 잘 해준다. 특히 나한테 도움되는 부분이라고 할 수 있다 ㅋㅋ 나는 의견이 섞이다 보면 무슨 이야기를 하고 있었는지, 어떤 거에 대해 의견을 내고 있었는지 까먹는데 바론이 의견 정리해줄 때마다 다시 회의 주제로 돌아갈 수 있다.    \n룰에 대해서도 자주 리마인드를 해주어서 초기에 정했던 규칙을 그나마 많이 지킬 수 있었다.    다른 사람들도 회의하면 시간 생각 없이 계속 하다가 지치는 편인데 바론의 회의 시간 리마인드가 굉장히 도움이 되었다. \n\n아코는 의견을 자주 내는 편은 아니지만, 고민을 많이 한 뒤에 의견을 내기 때문에 도출된 의견이 중요한 관점의 의견일 때가 많다. 가끔 아코가 반대 의견을 낼 때도 있는데, 하나의 의견에 매몰되지 않고 다양한 관점으로 문제를 바라볼 수 있는 시각을 제공해줘서 많은 도움이 되었다.\n\n우코는 이해력이 빠르다. 나는 내 의견을 말로 정리하기 힘들어서 일단 떠오르는 생각들을 말로 내뱉고 다른 사람들이 이해하기를 바라는 편인데 그럴 때마다 한 번에 이해해줘서 정말 고마울 때가 많다...ㅋㅋㅋ 특히 팀원의 주류와 다른 의견이 나왔을 때, 반대 의견에도 지속적으로 의견을 물어봐주어서 팀 내에서 소수의 의견이 묻히는 일이 없다!     \n\n코난은 다른 사람의 의견에 근거를 더해주는 역할을 잘한다. 다른 사람들이 의견을 냈을 때 어떤 부분에서 그 의견이 좋다고 느꼈는지, 이런 부분에서도 좋을 것이라 생각한다는 의견을 덧붙여준다. \n프론트엔드의 든든한 기둥이다. 집중력이 좋고, 작업 속도도 빨라서 어떤 기능이든 뚝딱 만들어낸다. 이번에 youtube iframe 도 금방 학습하고, 기능을 응용해서 우리 서비스에 맞는 기능을 빠르게 만들어주었다. \n\n도밥은 우리가 기획한 내용들이 실제 서비스에 어떻게 반영되어야 할 지 리마인드해준다. 이런 방향으로 페이지를 보여줄 수 있다, 이런 과정을 통해 기능을 제공할 수 있겠다는 말을 해주어서 서비스를 확실하게 구상할 수 있다. 특히 기획이 마무리 되고 대략적인 서비스 플로우를 생각할 때 도밥의 능력이 더 빛을 발한다.     \n하나의 목표가 정해지면, 정해진 목표에 완전히 몰입한다. 우리 팀 중에서 개발에 가장 시간을 많이 쏟는 팀원이라고 생각한다. \n\n### Emotion Meeting\n\n리사가 웃겨했던 우리 팀 감정회고 시간...ㅋㅋㅋ\n우리 팀은 금요일마다 저녁을 함께 먹는다. 데모데이 저녁에는 함께 회식을 하는 시간을 갖는다.     \n보통 캠퍼스로 음식을 배달시켜 먹는 편인데, 사실 밥 먹을 때는 그냥 우스갯소리하거나 조용히 밥을 먹는다 ㅋㅋㅋ 저녁밥을 어느정도 다 먹으면 Emotion Meeting이 시작된다.    \n\n보통 시작은 아코로 시작한다. 아코로 시작해서 하고 싶은 말이 있는 팀원들 순으로 말한다. \n\n그러다보면 가끔 굵직한 이야기들이 나온다. 나는 여러분이 조금만 더 솔직해도 좋다고 봐요. 나는 진심으로 솔직했어...ㅋㅋㅋㅋ\n"},{"excerpt":"LOG 발을 삐었는지 몰라도 발목이 너무 아파서 파스를 붙였다. 배운 것 궁금한 것 느낀 것","fields":{"slug":"/2023-07-19/"},"frontmatter":{"date":"2023년 07월 19일 06:07","title":"2023년 07월 19일","tags":null},"rawMarkdownBody":"## LOG\n- 발을 삐었는지 몰라도 발목이 너무 아파서 파스를 붙였다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG 오늘은 아코, 코난이 과자를 사와서 맛있게 먹었다. 고마워~ 근데 아코가 사온 감자칩? 엄청 맛있었다. 내일은 내가 사가야지 배운 것  를 17로 설정하면 github action에서 17 JVM에서 호환되는 버전으로 컴파일 해준다. 설정 안 하면 가장 최신 LTS 버전으로 컴파일 하는 듯 하다.  에 아무런 내용도 없으면 예외가 발생한다. 사용하…","fields":{"slug":"/2023-07-18/"},"frontmatter":{"date":"2023년 07월 18일 03:07","title":"2023년 07월 18일","tags":null},"rawMarkdownBody":"\n## LOG\n- 오늘은 아코, 코난이 과자를 사와서 맛있게 먹었다. 고마워~ 근데 아코가 사온 감자칩? 엄청 맛있었다. 내일은 내가 사가야지\n\n## 배운 것\n- `targetCompatability` 를 17로 설정하면 github action에서 17 JVM에서 호환되는 버전으로 컴파일 해준다.\n\t- 설정 안 하면 가장 최신 LTS 버전으로 컴파일 하는 듯 하다.\n- `data.sql` 에 아무런 내용도 없으면 예외가 발생한다. 사용하지 않으면 삭제해두자.\n- 브랜치의 merge conflict는 현재 브랜치와 병합하려는 브랜치 모두에서 코드의 동일한 부분이 변경되는 경우, git이 사용할 버전을 결정할 수 없을 때 발생한다.\n- github action을 수동으로 동작할 수 있게 하는 코드 (이 코드가 없으면 브랜치마다 github action을 수동으로 동작할 수가 없다.)\n\n```yaml\non: \n\tworkflow_dispatch:\n```\n\n- Java의 HashSet은 내부적으로 HashMap을 통해 동작하고, add 할 때의 해시값을 key 로 갖는다. 그런데 영속화 전에 entity가 set에 삽입되면 그 당시의 해시값을 저장하는데, 영속화시에 id가 변경되며, 해시값이 바뀌어서 `contains()` 메서드가 제대로 작동하지 않는다. 특히 우리 프로젝트에서는 id 기반으로 `equals()`, `hashcode()` 를 적용해두어 더 그랬다... id가 변경되면 해시 값이 변경되기 때문에!\n\t- 이 문제를 해결하기 위해서는 동일성 메서드를 재정의 하지 않거나, 영속화 후에 연관 관계를 맺어야 한다. (아니면 Set을 안 쓰는 방법도.. `List` 를 쓸 수 있다면)\n\n## 궁금한 것\n\n## 느낀 것\n- 집중력의 한계가 느껴진다...... 오늘 4시간 회의 했는데 (50분 회의 10분 휴식) 3번째 회의부터는 집중이 잘 안 되는 게 느껴졌다. 휴식을 하려면 좀 길게 해야 할 거 같다. 휴식을 할 때도 어디에 집중하고 있지 말고 잡담을 하거나 가만히 있어보자."},{"excerpt":"LOG 스플릿, 바론, 아코와 함께 코드 리뷰를 했다. 굉장히 다들 꼼꼼하게 리뷰를 남겨주어서 (본인) 시간이 오래걸렸다;; 그렇지만 뿌듯했다. 방 청소했다. 화장실 청소, 싱크대 청소, 책상 청소, 침대 청소, 바닥 청소를 했다;;; 한 5시간 정도 걸린 거 같다... 사실 그러고도 좀 남았다 ㅋㅎ 배운 것 궁금한 것 느낀 것","fields":{"slug":"/2023-07-17/"},"frontmatter":{"date":"2023년 07월 17일 07:07","title":"2023년 07월 17일","tags":null},"rawMarkdownBody":"\n## LOG\n- 스플릿, 바론, 아코와 함께 코드 리뷰를 했다. 굉장히 다들 꼼꼼하게 리뷰를 남겨주어서 (본인) 시간이 오래걸렸다;; 그렇지만 뿌듯했다.\n- 방 청소했다. 화장실 청소, 싱크대 청소, 책상 청소, 침대 청소, 바닥 청소를 했다;;; 한 5시간 정도 걸린 거 같다... 사실 그러고도 좀 남았다 ㅋㅎ\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"브랜치에서 작업한 내용을 다른 브랜치에 병합할 수 있는 방법은 다양하다. 그 중 Merge commit, Squash and Merge, Rebase and Merge 에 대해 알아보자. Merge commit Github의 기본 merge 전략이다. 코드가 변경된 시기와 위치를 포함하여 코드의 전체 기록을 유지하려는 경우에 유용하다. 비파괴 작업으로, …","fields":{"slug":"/github-merge-strategy/"},"frontmatter":{"date":"2023년 07월 15일 04:07","title":"Github merge 전략","tags":["shook","레벨3","github","우테코"]},"rawMarkdownBody":"\n브랜치에서 작업한 내용을 다른 브랜치에 병합할 수 있는 방법은 다양하다.    \n그 중 Merge commit, Squash and Merge, Rebase and Merge 에 대해 알아보자. \n\n## Merge commit\n\nGithub의 기본 merge 전략이다.   \n코드가 변경된 시기와 위치를 포함하여 코드의 전체 기록을 유지하려는 경우에 유용하다.    \n비파괴 작업으로, 모든 커밋의 기록을 그대로 유지한다. merge 작업을 포함한 모든 변경 사항에 대한 기록을 남긴다.    \n\nCommit log는 커밋을 행한 순서대로 기록되고, Merge log는 merge가 된 순서대로 기록된다.    \n즉, commit log의 순서가 merge 순서와 다를 수 있다. \n\n### 예시\n\n```\ncommit 시간 순서: A - B - AC - BD      \nA 브랜치 commit 순서: A - AC     \nB 브랜치 commit 순서: B - BD      \n```\n\nB 브랜치가 A 브랜치보다 main에 merge가 먼저 된 경우, main의 commit log는 다음과 같다.\n\n`A - B - AC - BD - B merge commit - A merge commit`\n\n### 단점\n\n여러 분기가 자주 병합되는 경우, Git history 가 복잡해질 수 있다.    \n\n## Squash and Merge\n\n합쳐지는 브랜치의 모든 커밋이 merge 대상 브랜치 (main) 의 하나의 커밋으로 결합된다.    \n스쿼시된 커밋의 커밋 메시지는 기본적으로 스쿼시된 모든 커밋의 커밋 메시지 조합이 되지만, 수동으로 변경할 수 있다.    \n\n기능 당 하나의 커밋으로 main 의 commit log를 선형적이고 깨끗하게 유지하려는 경우 (히스토리 관리가 쉽다), feature 브랜치의 개별 커밋의 세부 정보가 유지 관리에 중요하지 않은 경우에 사용하면 좋다.    \n\n### 예시\n\n```\ncommit 시간 순서: A - B - AC - BD   \nA 브랜치 commit 순서: A - AC   \nB 브랜치 commit 순서: B - BD    \n```\n\nB 브랜치가 A 브랜치보다 main에 merge가 먼저 된 경우, main의 commit log는 다음과 같다.\n\n`<main>` \n`B squashed commit(B-BD 커밋 메시지) - A squashed commit(A-AC 커밋 메시지)`\n\n### 단점\n\n자세한 커밋 기록이 사라지게 된다.    \n개별 커밋을 보존하는 것이 프로젝트 기록에 중요한 경우 Squash and Merge가 올바른 선택이 아닐 수 있다.    \n\n또한 여러 작성자가 기능에 기여한 경우, 모든 커밋을 하나로 스쿼시하면 해당 정보가 손실된다.    \n\natomic commit level로 rollback 이 불가능하다.    \n\n## Rebase and Merge\n\ncommit 순서가 아닌, merge 순서대로 기록되므로 하나의 PR에 담긴 commit message 가 다른 PR의 commit message 와 섞이지 않는다.    \n\nrebase 를 사용하므로 merge 된 이후의 로그를 보았을 때, main에서 연속적으로 작업한 것과 같은 로그를 확인할 수 있다. 따라서 언제든지 atomic commit level 로 rollback 을 수행할 수 있다.    \n\n### 예시\n\ncommit 시간 순서: A - B - AC - BD      \nA 브랜치 commit 순서: A - AC     \nB 브랜치 commit 순서: B - BD     \n\nB 브랜치가 A 브랜치보다 main에 merge가 먼저 된 경우, main의 commit log는 다음과 같다.\n\n`<main>` \nB - BD - A - AC\n\n### 단점\n\nrebase 를 사용하면 특정 커밋의 부모 커밋을 바꿔서 커밋이 새로운 시점에서 시작된 것처럼 보이게 만든다.     \n\nfeature 브랜치에서 작업 중인 다른 개발자가 작업하는 경우에도 문제가 될 수 있다. feature의 로컬 복사본이 리베이스 후 원격 레포지토리와 동기화되지 않기 때문이다.    \n로컬 브랜치와 원격 브랜치가 동일한 시점에서 시작하지 않기 때문에, Git이 local의 push를 거부하게 된다. push를 위해서는 로컬 브랜치를 원격 브랜치와 동기화하거나, force push를 수행해야 할 수도 있다.    \n\nrebase를 시작하기 전에 원격 레포지토리와 제대로 동기화가 되지 않은 경우, 커밋이 손실될 수 있다.    \n그러므로 rebase는 개인 local의 브랜치의 정리를 위해 사용하거나, 작업을 main 브랜치 또는 다른 브랜치에 merge 하기 전에 사용하는 것을 권장된다.    \n\n### 결론?\n\n상황에 따라 사용해야 할 듯 하다.    \n우리는 Github Flow 로 진행하고 있기 때문에, main 에 커밋이 다 쌓이면 지저분할 것 같아서 Squash merge 전략을 사용하고 있다.     \n\n### Squash merge 후기\n\n실제로 코드를 깔끔하게 관리할 수 있었지만, 커밋 단위 롤백이 안 되는 것은 조금 불편했다.\nmerge 전에 QA 를 꼼꼼히 해야 안전하게 merge 할 수 있다.\n\n## Conflict 해결하기\n\n프로젝트를 진행하다보면 같은 파일을 수정하는 경우가 발생할 수 있다.    \n가장 베스트는 그런 일이 일어나지 않는 것이지만, 작업 분할이 항상 완벽하게 이루어지지는 않는다.    \n그런 경우에는 다른 작업자와의 conflict를 해결해야만 한다.    \n\n어떤 방법이 있을까?\n\n### 상황 가정\n\n(여기서부터는 존댓말로 작성합니다)\n\n**실제로 있었던 일임을 밝힙니다.**\n\n체모 크루, 주모 크루와 함께 작업을 했을 때의 일입니다. 애석하게도 일정의 압박으로 각자 기능을 시작할 수 밖에 없었기에 각자 다른 시점에 개발을 시작했습니다.    \n\n'체'는 A 기능을 만들고 있었고, '주'는 B 기능을 만들고 있었습니다.     \n저는 C 기능을 개발하던 중, A와 B의 기능이 필요하다는 것을 알게 되었습니다.    \n일단 개발한 기능을 원격에 push 한 후, 체와 주의 기능 merge를 기다렸습니다.    \n\n모든 기능이 merge되고 dev를 pull 하는 순간, 무수한 conflict와 무수한 파일 add 가 생성된 것을 보고 이것은 뭔가 잘못됐다고 느꼈습니다.    \n\n제 작업 브랜치가 원격 브랜치와 동기화되지 않아, pull을 하는 순간 git이 모두 새로운 파일이라 판단한 것입니다.\n\n저는 로컬 C 브랜치에 dev를 rebase 한 후, 원격 C 브랜치에 force push 하는 방식으로 해결했는데, 다른 방법은 없을까요?\n\n### Cherry Pick\n\nA와 B가 반영된 원격 dev 브랜치에서 새로운 new_dev 브랜치를 생성한 후, 체크아웃합니다.    \n그 후, C 브랜치에서 제가 작업했던 내용을 cherry pick 합니다. (rebase와 마찬가지로 conflict는 해결해야 합니다. )    \n\n이미 원격 저장소에는 C 브랜치가 존재하지만, new_dev 브랜치를 원격에 push한 후, 'new_dev'를 main에 머지합니다.     \n\nC 브랜치가 아니라는 점이 걸리기는 하지만, force push를 하지 않는다는 점에서 장점을 갖고 있습니다.    \n\nGPT의 답변은 다음과 같았습니다.    \n\n```text\n체리 피킹은 일반적으로 한 브랜치에서 다른 브랜치로 적은 수의 커밋을 통합하는 데 사용됩니다. 더 큰 선택성과 제어가 가능하지만 커밋이 많으면 번거로울 수 있습니다.\n\n반면 리베이스는 한 브랜치의 모든 변경 사항을 다른 브랜치로 통합하려는 경우에 자주 사용됩니다. 브랜치에 일련의 커밋이 있고 선형 방식으로 메인 브랜치에 통합하려는 상황에 더 적합합니다.\n```\n\n커밋이 적은 경우에만 Cherry Pick을 사용하고, 브랜치의 모든 변경 사항을 다른 브랜치로 통합하는 경우에는 rebase가 더 적합한 듯 합니다.     \n\n역시 상황에 따라 맞게 사용하는 것이 좋아보이네요.     \n\n저희 프로젝트에서는 한 사람이 한 피쳐를 맡는 경우가 많아 force-push 를 더 많이 사용했던 것 같습니다.\n\n## 참고\n- https://inmoonlight.github.io/2021/07/11/Git-merge-strategy/\n- https://chat.openai.com/share/d8d773a5-8ccc-4366-9735-cd8fdbb89b3b"},{"excerpt":"CODEOWNERS? 매번 PR을 올릴 때마다 리뷰어를 넣어주는 게 귀찮다. 그러니 리뷰어를 자동으로 등록해주는  를 사용해보자! 등록하기 ,  중 한 곳에  파일을 생성한 후, 리뷰어를 지정한다. 우리는  하위에 생성했다. 파일은 다음과 같다. shook 레포지토리는 frontend와 backend가 레포지토리를 공유하는 형태이다. 우리는 소속된 파트의…","fields":{"slug":"/github-codeowners/"},"frontmatter":{"date":"2023년 07월 15일 04:07","title":"Github CODEOWNERS로 PR 리뷰어 자동 할당하기","tags":["shook","github","우테코","레벨3"]},"rawMarkdownBody":"\n## CODEOWNERS?\n\n매번 PR을 올릴 때마다 리뷰어를 넣어주는 게 귀찮다.    \n그러니 리뷰어를 자동으로 등록해주는 `CODEOWNERS` 를 사용해보자!\n\n### 등록하기\n\n`docs/`, `.github/` 중 한 곳에 `CODEOWNER` 파일을 생성한 후, 리뷰어를 지정한다.    \n우리는 `.github/` 하위에 생성했다.    \n\n파일은 다음과 같다.\n\n```text\n# Frontend  \n/frontend/ @Creative-Lee @ukkodeveloper @cruelladevil  \n  \n# Backend  \n/backend/ @Cyma-s @splitCoding @somsom13 @seokhwan-an\n```\n\nshook 레포지토리는 frontend와 backend가 레포지토리를 공유하는 형태이다.    \n우리는 소속된 파트의 모두의 approve를 받아야 PR을 머지할 수 있다는 규칙을 정했다.     \n따라서 `/frontend/` 하위의 모든 파일들에 대해서는 프론트엔드 크루들을 지정하고, `/backend/` 하위의 모든 파일들에 대해서는 백엔드 크루들을 지정했다.    \n\n### 사용해 본 결과 ...\n\n각 파일 하위에 변경 사항이 추가되면 자동으로 코드 리뷰어가 추가 되어 훨씬 편하게 개발할 수 있었다. 추천합니다 👍"},{"excerpt":"배운 것  에도 빈 생성자가 필요하다.","fields":{"slug":"/2023-07-14/"},"frontmatter":{"date":"2023년 07월 14일 04:07","title":"2023년 07월 14일","tags":null},"rawMarkdownBody":"\n\n\n## 배운 것\n\n- `@Embeddable` 에도 빈 생성자가 필요하다."},{"excerpt":"LOG 배운 것 2차원 배열 누적합을 계산하는 방법 궁금한 것 느낀 것 알고리즘이 풀기 싫을 때도 있는데 그게 오늘~ 다른 날이라면 10분만에 풀었는데 !!!!! 많이 봐줬다 짜식","fields":{"slug":"/2023-07-13/"},"frontmatter":{"date":"2023년 07월 13일 15:07","title":"2023년 07월 13일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n- 2차원 배열 누적합을 계산하는 방법\n\n```python\nsum_arr = [[0] * (m+1) for _ in range(n+1)] \nfor i in range(1, n+1): \n\tfor j in range(1, m+1): \n\tsum_arr[i][j] = arr[i-1][j-1] + sum_arr[i-1][j] + sum_arr[i][j-1] - sum_arr[i-1][j-1]\n```\n\n## 궁금한 것\n\n## 느낀 것\n- 알고리즘이 풀기 싫을 때도 있는데 그게 오늘~ 다른 날이라면 10분만에 풀었는데 !!!!! 많이 봐줬다 짜식"},{"excerpt":"S-HOOK의 최우선 페르소나 문제점 데모데이 이후에 고려해봤었던 '일반인' 페르소나의 needs는 우리가 충족시켜줄 수 없다. need를 만족하기 위해서는 어떤 방법이든 곡 추천을 해야 한다. 그러나 우리가 추천을 해줄 수 있는 방법은 없다. 우리가 직접적으로 추천을 해주지 않는다고 하더라도, 우리의 '간접적인' 추천은 (킬링 파트의 투표를 보고 그 음…","fields":{"slug":"/shook-persona/"},"frontmatter":{"date":"2023년 07월 12일 12:07","title":"S-HOOK 페르소나","tags":["shook","기획","레벨3"]},"rawMarkdownBody":"\n## S-HOOK의 최우선 페르소나\n\n### 문제점\n\n- 데모데이 이후에 고려해봤었던 '일반인' 페르소나의 needs는 우리가 충족시켜줄 수 없다. \n\t- need를 만족하기 위해서는 어떤 방법이든 곡 추천을 해야 한다. 그러나 우리가 추천을 해줄 수 있는 방법은 없다.\n\t- 우리가 직접적으로 추천을 해주지 않는다고 하더라도, 우리의 '간접적인' 추천은 (킬링 파트의 투표를 보고 그 음악이 좋다고 생각하든지 안 하든지 간에) 일반인 페르소나에게 pain point가 되지 않는다.\n\t- 일반인의 pain point를 해결하는 서비스는 시중에 너무나도 많다. (꼭 새로운 서비스가 아니어도 되지만, 우리만의 특별한 기능을 특별하게 꼽기 어렵다)\n\t- 일반인을 위한 기능을 제공해주기 어렵다. 듣기와 좋은 음악을 찾기 원하는 페르소나이다 보니, 일반인이 최우선 페르소나가 되는 경우 추천과 듣기에 집중된 기능을 개발해야 한다. 그러나 현실적으로 듣기가 매우 어렵고, 듣는 방법을 유튜브 링크로 한정하는 경우도 마찬가지로 일반인의 pain point를 채워줄 수 없다.\n\t- 일반인이 최우선 페르소나가 된다면 '킬링파트 듣기'가 최우선 개발 기능이 되어야 할 것 같다.\n- 팬덤을 공략하는 방법\n\t- 우리의 주변에는 팬덤이 없기 때문에 실제로 팬덤이 어떤 니즈를 갖고 있는지 알 수 없다. 우리가 팬덤을 위해 어떤 것을 제공할 수 있는가? 팬덤이 원하는 것은 어떤 것인가?\n\t- 비교할 만한 표본이 없고, 다른 서비스에서 제공하는 것들 (1위를 하면 광고를 해준다던지) 을 제공하기는 어렵다. \n\t- 이용자 수를 늘리기 위해 팬덤 측에 마케팅을 시도하는 것 자체는 좋지만, 팬덤이 페르소나이자 메인 이용자가 되어서는 안 된다고 생각한다. 우리는 팬덤의 니즈를 해결하기 어렵다. (아직 니즈가 뭔지도 잘 모르기 때문에...)\n\n### 그래서...\n\n페르소나는 보편적일 필요는 없다. 그러나 우리 주변에서 볼 수 있거나, 어딘가에서 봤거나, 들어봤어야 한다.\n\n우리는 무슨 가치를 사용자에게 전달하고 싶나?\n우리의 애플리케이션을 통해 어떤 것을 얻어 가기를 원하는가?\n왜 사용자가 우리의 서비스를 사용할 수 밖에 없을까?\n\n서비스의 사용을 구걸하지 말고, 자연스럽게 사용할 수 있도록 해야 한다.\n\n### '킬링파트를 공유하는 것'이 우리의 사용자에게 어떤 가치를 전달할 수 있을까?\n\n=> 타인에게 인정받고자 하는 욕구, 내가 추천한 노래를 다른 사람들이 좋아했을 때 기쁨을 느낀다. 내가 추천한 킬링파트를 다른 사람들이 인정할 때 (투표가 많이 달렸을 때)\n=> 내가 음잘알이다. 내가 이렇게 힙한 노래를 많이 안다.\n=> 누구나 아는 명곡보다는 나만의 명곡을 공유하는 경우가 많다.\n=> 내가 음잘알인 것을 알리고 싶다.\n\n-> 내가 추천한 노래를 다른 사람들이 들어보고 좋아했는지를 알려준다면?\n-> 킬링파트 공유자의 인정욕/과시욕을 채워줄 수 있는 기능이 필요할 것 같다. \n\n### '킬링파트를 공유받는 것'이 우리의 사용자에게 어떤 가치를 전달할 수 있을까?\n\n=> 도입부부터 들었다면 별로였을 노래가 좋은 노래라는 걸 알 수도 있다.\n=> 처음 접하는 노래인 경우 좋은 노래인지 아닌지 다른 사람들의 보편적인 좋은 부분을 통해 바로 판단할 수 있다.\n=> 만약 이전에 들어본 노래인데 별로라고 생각했던 경우 굳이 검색해서 안 찾아볼 거 같다.\n=> 이전에 들어본 노래가 인기곡에 있다면 들어볼 듯. (인터뷰에 기반한 내용)\n-> 노래를 검색해서 킬링파트를 찾아보게 하는 건 별로 좋지 않은 것 같다. 킬링파트를 공유받는 사람의 경우 주로 이전에 들어보지 않은 새로운 노래의 킬링파트를 듣는 것을 선호하지 않을까?\n-> 인기곡으로 들어와서 다른 노래로 이어지게 하는 플로우는 어려울 수도 있다. 이 사람의 취향을 알지 못하면 그냥 아무 노래나 띄워줄 수밖에 없다.\n\n이 노래가 내 취향인지 아닌지를 빠르게 파악한다. => 추천이 필요가 없다.\n\n## 3차 데모데이 페르소나\n\n### 등록과 공유를 분리한 서비스\n\n등록의 만족감보다 공유의 만족감에 초점을 맞추자.    \n등록할 때는 딱히 뭐 없다.\n회원이 등록한 파트를 공유하면 지인들이 댓글을 달아준다던지, 공감을 할 수 있다.\n등록하지 않아도 조회를 할 수 있다. (회원, 비회원 모두)\n\n취향 아카이빙 쪽 서비스가 된다. 아카이빙된 킬링파트들을 보고 다른 사람들이 공감할 수 있는.\n\n우리 서비스에서 제공하는 가치가 희석될 수 있다. (공유면 공유, 등록이면 등록, 조회면 조회가 아니고, 모든 서비스를 약간씩 서빙하는 느낌?)\n\n### 노래 순위 맞추기 서비스\n\n등록하기 전에는 킬링파트를 볼 수 없다.\n등록하고 난 후, 킬링파트를 조회할 수 있다.\n다른 사람들이 좋아하는 파트인지에 대한 정보(등록한 파트의 순위)를 제공한다.\n\n내 순위를 높이는 데에만 목표를 둘 것 같다. 내가 좋아하는 부분이 아닌 대중적인 부분을 찾는 것을 목표로 하게 될 듯하다.\n'다른 사람에게 내가 등록한 파트를 공감받는다' 라는 가치를 버려야 한다.\n비회원에게 줄 수 있는 가치가 적다.\n\n### 빠르게 노래를 듣는 서비스 (메인이 아님 -> 부가가치)\n\n우리의 서비스로부터 얻을 수 있는 부가가치로 간주한다.\n\n### 공유란?\n\n초기 공유: 킬링파트가 어디인지 알리는 거\n'특정 대상에게 공유'가 나오면서 서비스 크기가 좀 커졌다. -> 만족감이라는 키워드가 나오면서 커졌다.\n만족감을 주기 위해서 공유를 택했는데, 공유가 들어오니 공유를 위한 기능들이 추가되고 있다.\n아카이빙도 공유를 위해 등장한 것.\n노래의 킬링파트를 알려주는 것 -> 내가 좋아하는 부분을 공유하는 것도 추가 됨\n다른 사람들이 좋아하는 파트 조회 -> 내가 좋아하는 파트를 조회하는 것도 추가 됨\n\n킬링파트 등록과 조회 / 내가 좋아하는 부분 공유 => 다 담으려고 하는 중\n-> 둘은 다른 서비스다.\n\n우선순위를 정하자. 두 개를 다 가져가려면 뭐를 먼저 할 지 우선순위가 필요하다. 동시 개발은 안 됨.\n\n킬링파트로 얻는 만족감과 내가 등록한 파트에서 얻는 만족감 => 연관 관계가 없다.\n\n킬링파트 등록과 조회는 어디까지 담는 서비스?\n-> 단순히 킬링파트를 등록하고, 사람들이 와서 킬링파트를 볼 수 있는 서비스 => 이번에 조회를 하게 되면 등록과 조회를 하면 이 부분은 충족이 된다.\n\n등록과 조회를 메인으로 생각한다면 왜 등록을 할까?\n등록 과정에서 가치(만족감)를 부여해주기 위해서 공유가 등장했는데, 커지는 느낌이다.\n-> 실제로 듣는 사람들이 만드는 킬링파트\n-> 기존의 공유는 파트를 공유한 게 아니라 내가 등록한 정보를 공유할 뿐이다.\n-> 데모만 봤을 때는 페이지가 아니라 플레이할 수 있는 url을 공유한 것 아닌가? => 우리가 이 파트를 들어보라고 했지, 이 파트에 대한 정보를 준 것이 아니다. 따라서 파트에 대한 정보를 갖고 있을 필요 없다. \n\n비회원이 다 조회를 할 수 있게 만들거면, 회원은 어떤 플로우를 가질 것인가.     \n회원이 조회가 가능하다면 만족감을 가질 수 있을 것인가?\n\n회원이 등록 전에 조회를 하면 만족감을 얻을 수 없다.\n\n---\n킬링파트는 내가 좋아하는 부분이 아니라, 사람들이 좋아하는 부분이다.\n\n내가 좋아하는 부분을 공유하고 싶은 사람\n사람들이 좋아하는 부분을 알고 싶은 사람\n"},{"excerpt":"LOG 비가 많이 왔다. 비 좀 그만 왔으면 좋겠다. 오늘은 다행히 덥지는 않았는데 약간 추웠다. 반바지 입고 와서 그랬던 걸지도... 애쉬, 비버, 포이와 매드 후라이 치킨에서 저녁을 먹었다. 선릉은 맛있는 곳만 있나 ㅋㅋ 어제 갔던 곳도 맛있었는데 오늘도 맛있어서 좋았다. 점심은 라면을 먹었다. 라면에 계란을 넣으려고 계란을 부쉈(?)는데 너무 박살나…","fields":{"slug":"/2023-07-11/"},"frontmatter":{"date":"2023년 07월 11일 01:07","title":"2023년 07월 11일","tags":null},"rawMarkdownBody":"## LOG\n- 비가 많이 왔다. 비 좀 그만 왔으면 좋겠다. 오늘은 다행히 덥지는 않았는데 약간 추웠다. 반바지 입고 와서 그랬던 걸지도...\n- 애쉬, 비버, 포이와 매드 후라이 치킨에서 저녁을 먹었다. 선릉은 맛있는 곳만 있나 ㅋㅋ 어제 갔던 곳도 맛있었는데 오늘도 맛있어서 좋았다.\n- 점심은 라면을 먹었다. 라면에 계란을 넣으려고 계란을 부쉈(?)는데 너무 박살나서 계란이 용기에 흘러 내렸다.. 용기가 타지 않게 하려고 busy waiting 하면서 라면을 제조할 수 밖에 없었다. 조금 아쉽. 계란은 완전히 분해돼서 먹을 수 없었다 ㅋㅋ\n- 스플릿, 아코, 바론과 함께 도메인 설계를 했다. 각자 구상해온 도메인 클래스를 취합하고, DB 스키마도 만들었다. 오랜만에 코드 관련 이야기 하니까 너무 재밌었다. \n\n## 배운 것\n- 맥북에서 날씨 앱을 왼쪽에 열어두고 오른쪽에 다른 창을 열고 포커스를 다른 창에 맞추면 날씨 앱에 비 오던게 천천히 멈춘다 ㄷㄷ\n- 일정 추정하기 \n\t- 팀 요구사항이 있고, 기한이 존재하기 때문에 이를 충족해야 한다.\n\t- 그러나 정확한 프로젝트 일정 추정은 사실상 불가능하기 때문에, 포기하기보다는 숙달하는 것이 중요하다.\n\t- 프로젝트를 더 작은 작업으로 분해하라. 긴 추정치에는 예상 밖의 문제가 숨어든다. 작업을 더 잘게 나눌수록 예상치 못한 하위 작업이 나타날 가능성이 줄어든다.\n\t- 추정은 최상의 시나리오가 아닌 확률 분포로 생각하자. 우리가 의존하는 정보는 불완전하므로 최상의 시나리오부터 최악의 시나리오를 아우르는 결과 범위에 대한 확률 분포라고 생각해야 한다.\n\t- 구체적인 목표와 측정 가능한 마일스톤을 정의하자. 목표를 잘 정의해두면 작업 목록에서 꼭 해야 할 일과 하면 좋은 일을 구분하는 중요한 필터가 된다. 목표를 구체적으로 정의하면 명확성과 공통의 이해가 형성된다. 측정 가능한 마일스톤은 목표를 향해 제대로 가고 있는지 주기적으로 확인하는데 도움이 된다.\n\t- 작은 작업 단위와 적당한 마일스톤 기간. 처음부터 잘 할 수 없기 때문에 작은 작업 단위와 적당한 마일스톤 기간은 빠르게 실패를 할 수 있게 도와준다. 앞 마일스톤에서 경험한 것을 바탕으로 다음 마일스톤 일정을 계획한다. \n- commit 에 `#이슈-번호` 를 붙이면 이슈에 commit 이 쌓인다 ㄷㄷ by 아코\n- `@Embbedded`, `@Embeddable`\n\t- `@Embeddable` 사용할 거면 안에 사용할 값에 `@Column` 을 달아줘야 한다.\n- `@ManyToOne` 의 `fetch` 의 기본 타입은 `FetchType.EAGER` 다.\n- `@OneToMany` 의 `fetch` 의 기본 타입은 `FetchType.LAZY` 이다.\n\n## 궁금한 것\n\n## 느낀 것\n- 독성 말투를 주의하자. 습관적으로 부정적인 말을 하는 것을 경계한다. 언제나 기분이 좋을 필요는 없지만 언제나 기분이 안 좋을 이유도 없다.\n- 노력하는 것에 익숙해지자."},{"excerpt":"미니멈 프로젝트가 성공하기 위해 반드시 일어나야 하는 최소한의 일. 성실하게 작업을 수행한다면 거의 90% 확실하게 일어날 수 있는 일들. 우리가 반드시 이 고통은 해결해야 한다. 목표를 잘 설정할 수 있게 도와주는 가이드를 기능적으로 제공한다. 매 데모데이때마다 이 기능은 동작해야함. 타겟이 있어야 함 이런 일이 일어나기를 바라는 것, 어렵지만 달성 가…","fields":{"slug":"/wooteco-ux/"},"frontmatter":{"date":"2023년 07월 10일 05:07","title":"UX 특강","tags":["우테코"]},"rawMarkdownBody":"## 미니멈\n- 프로젝트가 성공하기 위해 반드시 일어나야 하는 최소한의 일. 성실하게 작업을 수행한다면 거의 90% 확실하게 일어날 수 있는 일들. 우리가 반드시 이 고통은 해결해야 한다.\n- 목표를 잘 설정할 수 있게 도와주는 가이드를 기능적으로 제공한다. 매 데모데이때마다 이 기능은 동작해야함.\n\n## 타겟이 있어야 함\n- 이런 일이 일어나기를 바라는 것, 어렵지만 달성 가능한 목표여야 함. 부지런히 노력한다면 60%이상 실현 가능성\n- 목표를 더 잘 달성할 수 있게끔, 긴박감을 줄 수 있는 타이머와 중간 회고를 도와주는 기능이 동작한다.\n\n## 에픽\n\n상상을 뛰어넘는 성공의 모습입니다. 일반적으로 모든 사람이 처음에 스스로 검열하므로 이 목표를 두 번 채워 보세요. 부끄러워하지 마세요! 그리고 이 과정에서 자신이 정말 중요하게 생각하는 것을 상상해 보는 것도 좋습니다.\n\n- 스터디를 하고 싶어 하는 많은 사람들이 공부해 서비스에 참여해서 게임 대기처럼 참여하는 플랫폼으로 만든다.\n\n비타민이어도 되는데, 비타민이면 성공 확률이 확 낮아진다.\n\n## 세 줄 요약\n\n- 우리 서비스의 핵심 기능이 비타민인가? 진통제인가? 고민해본다.\n- 2차 데모데이 이후 UX 워크숍에서 예비 사용자를 설득하기 위한 서비스 소개 글을 작성할 예정이다.\n- 진통제 같은 기능, 핵심을 잘 드러내고 고민해보는데 목표를 3단계로 정리해보면 더 또렷하게 잘 보이더라.\n- 고통을 발견하는 것까지는 쉬운데, 진통제는 어떻게 발견하지? 고통을 발견하면 그 고통을 잘 해결하는 사람이 누가 있지?\n"},{"excerpt":"LOG 저녁에 망고, 토리, 주노, 포이와 같이 족발을 먹으러 갔다. 맛집 코드에서만 보던 뽕나무쟁이에 갔는데 진짜 맛있긴 했다. 근데 불족발 너무 매웠다 ㅋㅋㅋ 김치찌개도 맛있었어서 다음에도 가고 싶다. 배운 것 궁금한 것 느낀 것","fields":{"slug":"/2023-07-10/"},"frontmatter":{"date":"2023년 07월 10일 04:07","title":"2023년 07월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 저녁에 망고, 토리, 주노, 포이와 같이 족발을 먹으러 갔다. 맛집 코드에서만 보던 뽕나무쟁이에 갔는데 진짜 맛있긴 했다. 근데 불족발 너무 매웠다 ㅋㅋㅋ 김치찌개도 맛있었어서 다음에도 가고 싶다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"LOG 드디어 못 풀어내던 LIS 알고리즘을 어느 정도 감을 잡은 것 같다. 바이토닉 수열 문제는 내 힘으로 못 풀었지만.. 그것보다 쉬운 전깃줄 문제는 5분 만에 풀어냈다! 얼마나 기억을 유지할 수 있을지... 이분탐색으로 LIS 푸는 거 이해했다고 생각했는데 또 그렇지도 않은 것 같아서 슬픔 ㅠ 배운 것 dp로 LIS 풀기 i번째보다 작은 값들을 돌면…","fields":{"slug":"/2023-07-09/"},"frontmatter":{"date":"2023년 07월 09일 10:07","title":"2023년 07월 09일","tags":null},"rawMarkdownBody":"\n## LOG\n- 드디어 못 풀어내던 LIS 알고리즘을 어느 정도 감을 잡은 것 같다. 바이토닉 수열 문제는 내 힘으로 못 풀었지만.. 그것보다 쉬운 전깃줄 문제는 5분 만에 풀어냈다! 얼마나 기억을 유지할 수 있을지... 이분탐색으로 LIS 푸는 거 이해했다고 생각했는데 또 그렇지도 않은 것 같아서 슬픔 ㅠ\n\n## 배운 것\n\n- dp로 LIS 풀기\n\n```python\ndp = [1 for _ in range(n)]  \nfor i in range(n):  \n    for j in range(i):  \n        if arr[i] > arr[j]:  \n            dp[i] = max(dp[i], dp[j] + 1)\n```\n\ni번째보다 작은 값들을 돌면서 현재 i 값보다 작은 경우 현재 dp 값, 이전 dp값 + 1 중 최댓값을 확인한 후 업데이트한다."},{"excerpt":"LOG 토스 코테를 봤다. 1,2,3,4를 건드려 봤는데 1,2번만 맞췄다. 3, 4번도 단순 구현 문제 같았는데 아직 알고리즘 능력치가 안 쌓여서 그런지 허둥댄 시간이 많았다. 내공을 길러서 허둥대지 않고 알고리즘 푸는 방법을 터득해야겠다. 밖에 있으면 끈적거려서 기분 나쁘고, 안에 오래 있으면 에어컨 때문에 너무 춥다.. 어디에 장단을 맞춰야 하는지 …","fields":{"slug":"/2023-07-08/"},"frontmatter":{"date":"2023년 07월 09일 10:07","title":"2023년 07월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 토스 코테를 봤다. 1,2,3,4를 건드려 봤는데 1,2번만 맞췄다. 3, 4번도 단순 구현 문제 같았는데 아직 알고리즘 능력치가 안 쌓여서 그런지 허둥댄 시간이 많았다. 내공을 길러서 허둥대지 않고 알고리즘 푸는 방법을 터득해야겠다.\n- 밖에 있으면 끈적거려서 기분 나쁘고, 안에 오래 있으면 에어컨 때문에 너무 춥다.. 어디에 장단을 맞춰야 하는지 모르겠다;;\n- 사시미 먹었는데 맛있었다. 나도 와사비를 먹을 수 있게 되었다. 엄마 보고 있나.."},{"excerpt":"LOG 점심으로 라면을 먹었다. 싸다김밥의 싸다는 cheap이 아니라 wrap이었다고 한다. by 바론 선호, 수민 언니, 세진과 뚝섬에서 파스타를 먹었다. 사실 그렇게 맛있진 않았다..ㅋㅋㅋ 토마토 파스타가 맛이 없기 쉽지 않은데 배운 것 repository flush를 하면 dirty checking을 확인할 수 있다.  은 '다' 쪽의 외래 키 관리…","fields":{"slug":"/2023-07-06/"},"frontmatter":{"date":"2023년 07월 06일 01:07","title":"2023년 07월 06일","tags":null},"rawMarkdownBody":"## LOG\n- 점심으로 라면을 먹었다. 싸다김밥의 싸다는 cheap이 아니라 wrap이었다고 한다. by 바론\n- 선호, 수민 언니, 세진과 뚝섬에서 파스타를 먹었다. 사실 그렇게 맛있진 않았다..ㅋㅋㅋ 토마토 파스타가 맛이 없기 쉽지 않은데\n\n## 배운 것\n\n- repository flush를 하면 dirty checking을 확인할 수 있다.\n\n- `@OneToMany(mappedBy = \"필드이름\")` 은 '다' 쪽의 외래 키 관리자를 명시해주는 것.\n- 연관 관계의 주인을 정한다는 것은 외래 키 관리자를 선택하는 것. 비즈니스 중요도로 접근하면 안 된다. 다대일, 일대다 관계에서는 항상 '다' 쪽이 외래 키를 가진다.\n- 연관 관계의 외래키 관리자가 아닌 경우, 읽기 권한만 갖는다. Station과 Line의 연관 관계를 맺고 싶은 경우, 다음과 같이 사용한다.\n\n다음은 예외가 발생하지 않는다. (Station 쓰기가 안 됨)\n\n```java\n@Test  \nvoid save() {  \n   final Line line = new Line(\"2호선\");  \n   line.addStation(new Station(\"신도림역\"));  \n   lines.save(line);  \n   lines.flush();  \n}\n```\n\n다음 방법은 스택 오버플로우가 발생할 위험이 있다.\n\n```java\n// Line.class\npublic void addStation(final Station station) {  \n   station.setLine(this);  \n   stations.add(station);  \n}\n\n// Station.class\npublic void setLine(final Line line) {  \n   this.line = line;  \n   line.getStations().add(this);  // 여기서 발생\n}\n\n// 다음처럼 바꾸면 된다.\npublic void setLine(final Line line) {\n\tthis.line = line;\n\tfinal List<Station> stations = line.getStations();\n\t\n\tif(!stations.contains(this)) {\n\t\tstations.add(this);\n\t}\n}\n```\n\n- 연관 관계 매핑을 안 하면 중간 테이블이 생긴다.\n\n```shell\nHibernate: \n    \ncreate table member_favorites (\n   member_id bigint not null,\n\tfavorites_id bigint not null\n)\n```\n\n연관 관계 매핑을 하면 '다' 쪽에 컬럼이 추가된다.\n\n```shell\ncreate table favorite (\n   id bigint generated by default as identity,\n\tmember_id bigint,\n\tprimary key (id)\n)\n\nHibernate: \n    \nalter table favorite \n   add constraint FK5w3q9ljpthkixo71hetx3ired \n   foreign key (member_id) \n   references member\n```\n\n연관 관계 공부하려면 `@JoinColumn` 파보면 좋을 듯 by 제이슨\n\n일대다 단방향 매핑보다는 다대일 양방향 매핑을 권장한다고 한다? (JPA 관점)\nbut 실무 관점에서는 일대다 단방향을 쓰는 경우도 있다.\n\n## 궁금한 점\n\n## 느낀 점\n- 아침을 먹고 가니까 좋다.\n- 로고 디자인 좀 더 깔끔하게 해봐야겠다."},{"excerpt":"LIS 길이 구하기 이분탐색 C++ Python LIS의 원소 구하기 이분탐색 참고 https://maramarathon.tistory.com/57","fields":{"slug":"/lis/"},"frontmatter":{"date":"2023년 07월 05일 13:07","title":"LIS - 가장 긴 증가하는 부분 수열","tags":["알고리즘","이분탐색","DP"]},"rawMarkdownBody":"\n## LIS 길이 구하기\n\n### 이분탐색\n\n#### C++\n\n```cpp\n#include <iostream> \n#include <vector>  \n#include <algorithm>\n\nint main() {\n\tint N = 6;   // 입력되는 수열의 길이\n\tint arr[6] = {1, 2, 4, 3, 5, 6}    // 입력되는 수열\n\tint dp[6];\n\n\tint max_length = 0;   // arr[i]가 들어갈 위치\n\n\tfor(int i = 0; i<N; i++) {\n\t\tint index = lower_bound(arr, arr + max_length, arr[i]) - arr;    // arr[i]를 넣을 수 있는 첫 번째로 나오는 크거나 같은 값의 인덱스\n\t\tdp[index] = arr[i];\n\n\t\tif(max_length == index) {  // LIS의 최대 길이가 업데이트되면 (최장 수열의 길이를 구하기 위한 배열인 dp에 값이 1개 있었는데 2개가 된 경우)\n\t\t\tmax_length++;   // 이제 다음 위치에 값이 들어가야 하므로 증가시킨다.\n\t\t}\n \t}\n \t\n\tcout << max_length;\n}\n```\n\n#### Python\n\n```python\nimport bisect\n\nx = int(input())\narr = list(map(int, input().split()))\n\ndp = [arr[0]]\n\nfor i in range(x):\n\tif arr[i] > dp[-1]:\n\t\tdp.append(arr[i])\n\t\tcontinue\n\tindex = bisect.bisect_left(dp, arr[i])\n\tdp[index] = arr[i]\n\nprint(len(dp))\n```\n\n## LIS의 원소 구하기\n\n### 이분탐색\n\n```cpp\n#include <iostream> \n#include <vector>  \n#include <algorithm>\n\nint N = 6;   // 입력되는 수열의 길이\nint arr[6] = {1, 2, 4, 3, 5, 6}    // 입력되는 수열\nint dp[6];  // LIS의 후보가 될 값들을 저장해두는 배열\nint dp_idx[6];   // dp_idx[i]: arr[i] 가 dp의 어디에 저장이 되었는지 저장한다.\n\n// dp_index: dp의 인덱스 값\n// dp_idx_index: 초기값은 길이의 최댓값, \nvoid print(int lis_index, int index) {\n\tif(lis_index < 0 || index < 0) return;\n\tif(dp_idx[index] == lis_index) { // dp에 담긴 값의 인덱스 값이 index와 같으면 출력\n\t\tprint(lis_index - 1, index - 1);\n\t\tcout << arr[index] << \" \";\n\t}\n\telse print(lis_index - 1, index);\n}\n\nint main() {\n\n\tint max_length = 0;   // arr[i]가 들어갈 위치\n\n\tfor(int i = 0; i<N; i++) {\n\t\tint index = lower_bound(arr, arr + max_length, arr[i]) - arr;    // arr[i]를 넣을 수 있는 첫 번째로 나오는 크거나 같은 값의 인덱스\n\t\tdp[index] = arr[i];\n\t\tdp_idx[i] = index;  // arr[i] 가 저장된 dp의 인덱스를 dp_idx[i]에 저장한다. \n\n\t\tif(max_length == index) {  // LIS의 최대 길이가 업데이트되면 (최장 수열의 길이를 구하기 위한 배열인 dp에 값이 1개 있었는데 2개가 된 경우)\n\t\t\tmax_length++;   // 이제 다음 위치에 값이 들어가야 하므로 증가시킨다.\n\t\t}\n \t}\n \t\n\tcout << max_length;\n\n\t// 출력은 여러 가지 방법이 있다.\n\tprint(N-1, max_length - 1);  // (1)\n\n\t// (2) -> 메모리를 많이 쓰고 시간도 더 들지만 인지 비용이 덜 든다.\n\tvector<int> result;  \n  \n\tfor (int i = N; i >= 1; i--) {  \n\t    if (dp_idx[i] == max_length - 1) {  \n\t        result.push_back(arr[i]);  \n\t        max_length--;  \n\t    }  \n\t}  \n\t  \n\tfor (int i = result.size() - 1; i >= 0; i--) {  \n\t    cout << result[i] << ' ';  \n\t}\n\n}\n```\n\n## 참고\n\n- https://maramarathon.tistory.com/57"},{"excerpt":"LOG PR 템플릿, 스프린트 기간 같은 세부 사항들을 정했다. 곧 기능 개발을 할 수 있을 것 같아서 좋다 🥹 얼른 개발하고 싶다 요즘 끝나고 프로젝트 관련해서 할 게 없다보니 알고리즘만 푸는 중이다. 배운 것  을 사용하면 매핑하는 필드의 타입에 따라 DB의 BLOB, CLOB과 매핑된다. , ,  : CLOB ,  : BLOB 테이블의 unique …","fields":{"slug":"/2023-07-05/"},"frontmatter":{"date":"2023년 07월 05일 07:07","title":"2023년 07월 05일","tags":null},"rawMarkdownBody":"\n## LOG\n- PR 템플릿, 스프린트 기간 같은 세부 사항들을 정했다. 곧 기능 개발을 할 수 있을 것 같아서 좋다 🥹 얼른 개발하고 싶다\n- 요즘 끝나고 프로젝트 관련해서 할 게 없다보니 알고리즘만 푸는 중이다.\n\n## 배운 것\n- `@Lob` 을 사용하면 매핑하는 필드의 타입에 따라 DB의 BLOB, CLOB과 매핑된다.\n\t- `String`, `char[]`, `java.sql.CLOB` : CLOB\n\t- `byte[]`, `java.sql.BLOB` : BLOB\n\n```java\n@Column(name = \"contents\")  \n@Lob  \nprivate String contents;\n```\n\n- 테이블의 unique 조건은 다음과 같이 정의한다.\n\n```java\n@Table(name = \"user\", uniqueConstraints = @UniqueConstraint(name = \"UK_a3imlf41l37utmxiquukk8ajc\", columnNames = \"user_id\"))\n@Entity  \npublic class User\n```\n\nUnique 조건의 이름을 지정하지 않으면 vendor가 생성한 값이 들어갈 수 있다.    \nJPA 2.0 부터 Unique 조건의 이름을 제공할 수 있다.     \n\n`uniqueConstraints` 속성은 배열로 여러 가지 `@UniqueConstraint` 를 가질 수 있다.    \n`columnNames` 속성은 여러 가지를 지정할 수 있다.    \n\n- 컬럼의 기본값을 설정하는 방법은 다음과 같다.\n\n```java\n@ColumnDefault(\"-1\")\nprivate int score;\n\n// 또는\n\n@Column(columnDefinition = \"integer default -1\")\nprivate int score;\n```\n\n- 준영속 상태는 다음과 같이 만들 수 있다. \n\n```java\nPerson person = new Person(\"vero\");\nPerson savedPerson = personRepository.save(person);\nentityManager.detach(savedPerson);\n```\n\n특정 엔티티만 준영속 상태로 전환한다. (준영속 상태가 되면 1차 캐시에서 빠진다)    \n준영속 엔티티는 영속성 컨텍스트가 더 이상 관리하지 않는 엔티티로, 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.    \n\n**참고** : https://www.nowwatersblog.com/jpa/ch3/3-6\n\n- `@Id` 컬럼의 이름이 id가 아니더라도 JPA가 기본적으로 제공하는 `findById` 는 사용할 수 있다.\n- JPA의 `@Temporal` 어노테이션은 `LocalDateTime` 필드에 사용할 수 없다.\n- [[lis]] 푸는 법을 드디어.. 알아냈다.\n\n## 궁금한 것\n- jpa도 프록시를 쓰나? 엔티티가 빈 생성자를 제공해야 하는 것도 그렇고, 빈 생성자가 `private` 이면 컴파일 에러가 뜨는 것도 의심스러움\n\t- 하이버네이트가 프록시 객체를 통해 지연 로딩을 구현한다.\n\t- 따라서 JPA 엔티티는 final로 정의할 수 없고, 기본 생성자는 최소 `protected` 접근 제어자를 가져야 한다. \n\t- **참고** : https://tecoble.techcourse.co.kr/post/2022-10-17-jpa-hibernate-proxy/\n- JDK 17 의 sealed class 도 JPA 엔티티로 쓸 수 없을까?\n\n## 느낀 것\n- 알고리즘 어렵다. 근데 이제는 열심히 하면 잘할 수 있을 것 같다.\n- 스타벅스 추워."},{"excerpt":"Git Branch 전략 Git Flow 에서 release를 삭제한 전략을 사용하기로 했다.  main 배포 브랜치 develop 개발 총괄 브랜치 main 에서 파생되며, 하나의 완성된 기능 개발 후 main에 반영한다. feat/issue-number issue 단위의 기능 개발 브랜치 develop 에서 파생되며, 단위 기능 개발 후 develop…","fields":{"slug":"/shook-git-branch-strategy/"},"frontmatter":{"date":"2023년 07월 05일 02:07","title":"S-HOOK Git Branch 전략","tags":["shook"]},"rawMarkdownBody":"\n## Git Branch 전략\n\nGit Flow 에서 release를 삭제한 전략을 사용하기로 했다.\n\n![[shook-git-branch-strategy.png]]\n\n- main\n\t- 배포 브랜치\n- develop\n\t- 개발 총괄 브랜치\n\t- main 에서 파생되며, 하나의 완성된 기능 개발 후 main에 반영한다.\n- feat/issue-number\n\t- issue 단위의 기능 개발 브랜치\n\t- develop 에서 파생되며, 단위 기능 개발 후 develop에 반영한다.\n- fix/issue-number\n\t- issue 단위의 버그 수정 브랜치\n\t- develop 에서 파생되며, 버그 수정 후 develop에 반영한다.\n- hotfix\n\t- main에 반영된 내용 중에 급하게 수정되어야 할 버그 수정 브랜치\n\t- main 에서 파생되며, 버그 수정 후 main에 반영한다.\n\n### 현재 release를 사용하지 않는 이유\n\n현재 개발 서버가 존재하지 않는 상황에서 유의미한 QA가 불가능하다고 생각했습니다.    \n이후 개발 서버가 필요해지고, 세팅이 완료된 후에 release 브랜치를 고려해볼 예정입니다.\n\n## 10/15,  release 는 없어졌습니다\n\nGithub Flow 를 사용하게 되면서 release 브랜치는 없어지고, feature 브랜치를 dev 서버에서 배포한 뒤 QA 후 머지하는 식으로 구현하고 있습니다."},{"excerpt":"Spotify Spotify Web API 링크","fields":{"slug":"/shook-music-api/"},"frontmatter":{"date":"2023년 07월 04일 04:07","title":"S-HOOK 음악 API 자료 조사","tags":["shook"]},"rawMarkdownBody":"\n## Spotify\n\n[Spotify Web API 링크](https://developer.spotify.com/documentation/web-api)\n\n"},{"excerpt":"기획 shook-planning shook-planning-interview shook-persona shook-service-introduce shook-second-demoday shook-third-demoday shook-copyright shook-user-inducement-plan 자료 조사 음악 API: shook-music-api 기술 G…","fields":{"slug":"/shook/"},"frontmatter":{"date":"2023년 07월 04일 04:07","title":"S-HOOK","tags":["shook","우테코","레벨3","레벨4","project"]},"rawMarkdownBody":"\n## 기획\n\n- [[shook-planning]]\n- [[shook-planning-interview]]\n- [[shook-persona]]\n- [[shook-service-introduce]]\n- [[shook-second-demoday]]\n- [[shook-third-demoday]]\n- [[shook-copyright]]\n- [[shook-user-inducement-plan]]\n\n### 자료 조사\n\n- 음악 API: [[shook-music-api]]\n\n## 기술\n\n### Github\n\n- [[github-merge-strategy]]\n- [[github-codeowners]]\n- [[github-self-hosted-runner]]\n- [[shook-git-branch-strategy]]\n\n### Spring\n\n- [[spring-profile-trouble-shooting]]\n- [[spring-xml-parsing]]\n- [[spring-external-api-call-method]]\n- [[shook-webclient-reason]]\n\n### 기타\n\n- [[shook-tech-stack]]\n- [[shook-maniadb]]\n- [[shook-load-test]]\n- [[shook-migration]]\n\n## 트러블 슈팅\n\n### 좋아요 정합성 이슈\n\n- [[shook-like-concurrency-issue]]\n- [[shook-like-issue]]\n\n### 성능 개선\n\n- [[shook-my-page-query-improve]]\n- [[inmemory-cache-develop]]\n- [[inmemory-cache-develop-reason]]\n- [[local-cache-concurrency-problem]]\n\n## 발표\n\n- [[shook-five-minute-speech]]\n- \n"},{"excerpt":"Dirty Checking 이란 Entity Manager가 변경이 발생한 엔티티를 자동 감지하여 DB에 반영하는 것이다. 이미 영속화된 엔티티들을 대상으로만 작동하여, 준영속상태이거나 비영속상태인 엔티티들은 Dirty Checking을 진행하지 않는다. 동작 방법 JPA가 엔티티를 조회할 때 해당 엔티티의 상태를 기반으로 하나의 스냅샷을 만든다. 그 후…","fields":{"slug":"/jpa-dirty-checking/"},"frontmatter":{"date":"2023년 07월 04일 02:07","title":"JPA Dirty Checking - 변경 감지","tags":["jpa"]},"rawMarkdownBody":"\n## Dirty Checking 이란\n\nEntity Manager가 변경이 발생한 엔티티를 자동 감지하여 DB에 반영하는 것이다.\n\n이미 영속화된 엔티티들을 대상으로만 작동하여, 준영속상태이거나 비영속상태인 엔티티들은 Dirty Checking을 진행하지 않는다.\n\n## 동작 방법\n\nJPA가 엔티티를 조회할 때 해당 엔티티의 상태를 기반으로 하나의 스냅샷을 만든다.    \n그 후, 트랜잭션이 종료되는 시점에 만든 스냅샷과 비교하여 변경을 감지한다.   \n변경이 감지되면 update 쿼리를 DB에 전달한다.\n\n즉, 영속화된 엔티티라면 별도로 save 메서드를 사용하지 않아도 JPA 에 의해 변경 사항이 자동으로 데이터베이스에 적용된다.\n\n### 변경된 부분만 업데이트하기\n\nDirty Checking이 이루어지는 update 쿼리는 기본적으로 모든 필드를 업데이트한다.\n\n생성되는 쿼리가 같아 부트 실행 시점에 미리 만들어 재사용 가능하고, DB 입장에서 쿼리 재사용이 가능하다.    \n그러나 필드가 많은 엔티티의 경우 모든 필드 업데이트는 부담스러울 수 있다. 데이터의 양이 많아질수록 그렇다.\n\n이런 경우에는 `@DynamicUpdate` 엔티티 최상단에 선언해주면 변경된 필드만 반영되도록 할 수 있다. \n\n```java\n@Entity\n@DynamicUpdate\npublic class Vero {\n\t...\n}\n```\n\n## 참고\n- https://jojoldu.tistory.com/415"},{"excerpt":"jpa-dirty-checking jpa-dto-projection","fields":{"slug":"/jpa/"},"frontmatter":{"date":"2023년 07월 04일 02:07","title":"JPA","tags":["jpa","spring"]},"rawMarkdownBody":"\n- [[jpa-dirty-checking]]\n- [[jpa-dto-projection]]\n"},{"excerpt":"LOG 베로위키 다시 영업합니다 구경 자주 오세요~ 어제, 그저께, 토요일까지 술을 너무 많이 마셨다 ㅋㅋ.. 술 자제해야 되는데 금요일에도 데모데이 회식이라 술 마시러 간다. 아무래도 자제하자... 백엔드 코드 스타일 컨벤션 회의를 했다. 오랜만에 코드를 보니까 좀 기뻤다 ㅋㅋㅋ 배운 것 JPA ddl-auto는 create-drop이 default 값…","fields":{"slug":"/2023-07-04/"},"frontmatter":{"date":"2023년 07월 04일 01:07","title":"2023년 07월 04일","tags":null},"rawMarkdownBody":"## LOG\n- 베로위키 다시 영업합니다 구경 자주 오세요~\n- 어제, 그저께, 토요일까지 술을 너무 많이 마셨다 ㅋㅋ.. 술 자제해야 되는데 금요일에도 데모데이 회식이라 술 마시러 간다. 아무래도 자제하자...\n- 백엔드 코드 스타일 컨벤션 회의를 했다. 오랜만에 코드를 보니까 좀 기뻤다 ㅋㅋㅋ\n\n## 배운 것\n- JPA ddl-auto는 create-drop이 default 값이다.\n- JPA Entity는 인자가 없는 생성자가 필요하다.\n- `logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE` 를 설정하면 ?에 뭐가 들어갔는지 알 수 있다. `2023-07-04 11:20:56.885 TRACE 58373 --- [    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [잠실역]`\n- `@DataJpaTest` 에는 `@Transactional` 이 붙어 있어서 rollback이 된다.\n```shell\n2023-07-04 11:24:10.786  INFO 58396 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test context [DefaultTestContext@1dd81a80 testClass = StationRepositoryTest, testInstance = subway.StationRepositoryTest@1de344a0, ...\n\nhibernate log\n\n2023-07-04 11:24:10.938  INFO 58396 --- [    Test worker] o.s.t.c.transaction.TransactionContext   : Rolled back transaction\n```\n\n- 영속성 컨텍스트: 엔티티를 영구 저장하는 환경. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 저장한다.\n\n- 영속성 컨텍스트는 동등성을 보장해준다.\n```java\n@Test  \nvoid identity() {  \n    Station station1 = stations.save(new Station(\"잠실역\"));  \n    Station station2 = stations.findById(station1.getId()).get();  \n    assertThat(station1 == station2).isTrue();  \n}\n```\n\n- 영속성 컨텍스트는 `ConcurrentHashMap` 으로 구현되어 있다.\n- 영속성 컨텍스트는 id 조회 시에 DB를 바로 조회하지 않고, 먼저 1차 캐시를 확인한 후 있으면 그대로 리턴해준다. 1차 캐시에 없는 값은 DB에서 select 후, 1차 캐시에 저장한다.\n- 엔티티의 생명 주기\n\t- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태\n\t- 영속 : 영속성 컨텍스트에 저장된 상태\n\t- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태\n\t- 삭제 : 삭제된 상태\n- `@Transactional` 에서 트랜잭션을 커밋하는 순간, 영속성 컨텍스트를 DB에 반영한다.\n- 이 경우, update query가 날아간다. 조회하기 전에 변경 사항이 있으면 update 한다. \n\n```java\n@Test  \nvoid update() {  \n\tStation station1 = stations.save(new Station(\"잠실역\"));  \n\tstation1.changeName(\"선릉역\");  \n\tStation station2 = stations.findByName(\"선릉역\");  \n\tassertThat(station2).isNotNull();\n}\n```\n\n```shell\nupdate\n\tstation \nset\n\tname=? \nwhere\n\tid=?\n```\n\n- 이 경우는 update query가 날아가지 않는다.\n\n```java\n@Test  \nvoid update() {  \n\tStation station1 = stations.save(new Station(\"잠실역\"));  \n\tstation1.changeName(\"선릉역\");  \n//        Station station2 = stations.findByName(\"선릉역\");  \n//        assertThat(station2).isNotNull();  \n}\n```\n\n- flush 는 영속성 컨텍스트가 관리하는 객체의 변화를 DB에 반영하겠다는 것. commit은 트랜잭션의 관점. \n- 해보니까 이슈, discussion 삭제 됩니다 ㅋㅋ by 주노\n\t- 원래는 권한이 없어서 안 됐던 거 같기도 하고 아니면 내가 연 이슈가 아니어서 그런 거 같기도 하고 검증 필요\n\n## 궁금한 것\n- 내 안경은 왜 계속 휘어질까\n\n## 느낀 것\n- 비가 너무 많이 와서 찝찝했다. 내일까지는 비가 올텐데 진짜 싫다;; 언제까지 여름이야...\n- 회의가 많으니까 시간은 잘 가는데 에너지 소모가 심하다.\n- 바론이 빅파이를 사와서 맛있게 먹었다. 간식 가져와 준 바론 고마워 😄"},{"excerpt":"2023-07-04 2023-07-05 2023-07-06 2023-07-08 2023-07-09 2023-07-10 2023-07-11 2023-07-13 2023-07-14 2023-07-17 2023-07-18 2023-07-19 2023-07-20 2023-07-22 2023-07-24 2023-07-25 2023-07-26 2023-07-27","fields":{"slug":"/2023-07/"},"frontmatter":{"date":"2023년 07월 04일 01:07","title":"2023년 07월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-07-04]]\n- [[2023-07-05]]\n- [[2023-07-06]]\n- [[2023-07-08]]\n- [[2023-07-09]]\n- [[2023-07-10]]\n- [[2023-07-11]]\n- [[2023-07-13]]\n- [[2023-07-14]]\n- [[2023-07-17]]\n- [[2023-07-18]]\n- [[2023-07-19]]\n- [[2023-07-20]]\n- [[2023-07-22]]\n- [[2023-07-24]]\n- [[2023-07-25]]\n- [[2023-07-26]]\n- [[2023-07-27]]\n"},{"excerpt":"LOG 배운 것 github discussion, issue는 삭제가 불가능하다...","fields":{"slug":"/2023-06-30/"},"frontmatter":{"date":"2023년 06월 30일 07:06","title":"2023년 06월 30일","tags":null},"rawMarkdownBody":"\n## LOG\n\n## 배운 것\n- github discussion, issue는 삭제가 불가능하다..."},{"excerpt":"LOG 27일 TIL을 안 써서.. ㅋㅋ 여기다가 같이 적어야겠다. 우리 팀 이름은 슉(shook)이 되었다. share-hook이라는 이름으로, 강렬한 킬링 파트를 다른 사람들과 함께 공유한다는 의미이다. 그런데 스플릿이 팀 이름 정할 때 뿌직 이라는 의견을 냈는데 모두 그 이름을 웃겨해서 ㅋㅋㅋ 비공식적 팀 이름은 뿌직이 되었다... 그렇지만 공식적인…","fields":{"slug":"/2023-06-28/"},"frontmatter":{"date":"2023년 06월 28일 12:06","title":"2023년 06월 28일","tags":null},"rawMarkdownBody":"## LOG\n27일 TIL을 안 써서.. ㅋㅋ 여기다가 같이 적어야겠다.\n- 우리 팀 이름은 슉(shook)이 되었다. share-hook이라는 이름으로, 강렬한 킬링 파트를 다른 사람들과 함께 공유한다는 의미이다. 그런데 스플릿이 팀 이름 정할 때 뿌직 이라는 의견을 냈는데 모두 그 이름을 웃겨해서 ㅋㅋㅋ 비공식적 팀 이름은 뿌직이 되었다... 그렇지만 공식적인 서비스 이름은 슉 입니다 ^_^\n- 어제 밥을 먹으면서 팀원 모두와 말을 놓았다. 도밥은 처음에 말을 놓기 힘들어했지만 금방 적응했다 ㅋㅋ 말을 놓고 나니 좀 더 대화하기 편해진 것 같아 좋았다. 2달간 거의 모든 시간을 팀원들과 함께 하게 될 것 같은데, 다들 좋은 사람들이라 좋은 팀 활동을 할 수 있을 것 같다.\n- 리사, 토미와도 커피챗을 했다. 어제 밥 먹고 나서 커피챗을 했는데, 우리 팀이 모두 초면인데도 불구하고 (나는 스플릿과 도밥은 알고 있었지만 다른 분들은 모두 초면이었다) 원래 알고 지내던 사람들 같다는 말을 들어서 기분이 좋았다.\n- 오늘은 페르소나에 대한 강의를 들어서, 인터뷰 질문들을 정하는 시간을 가졌다. 인터뷰에 응해준 하마드, 주노, 그레이 고마워~ 큰 도움이 되었습니다 😄\n- 오늘은 팀 문화를 정하는 시간도 가졌다. 도밥이 예비군을 가고, 코난, 스플릿도 근로가 있어서 큰 뼈대는 아코, 우코, 바론과 함께 정하게 되었다. 어제 오늘 회의하면서 느끼는 거지만 다들 둥글둥글하고 배려하는 말하기를 잘해서 의견 수렴이 더 잘 되는 듯한 기분이 든다.\n- FUGA 커피 드디어 마셔봤다. 맛있긴 한데, 어떤 부분에서 맛있냐고 물어보면 모르겠다 ㅋㅋㅋ\n- 나 사용설명서를 공유하는 시간을 가졌다. 예비군 간 도밥도 허들로 참여해서 모두 잘 참여할 수 있어 감사하다. 의외로 나와 비슷한 성격을 가진 팀원들이 많아서 신기했다. \n\n## 배운 것\n- 스프링 부트 3.0을 사용하려면 Java 17부터 쓸 수 있다.\n\n## 궁금한 것\n\n## 느낀 것\n- '~라고 생각하면 어떡하지?' 라고 지레짐작하지 말고, 내 의도를 충분히 설명한 다음에 말하는 게 오해가 덜하다.\n- 나 꽤나 눈을 못 마주치는 사람이었을지도... 특히 여자 크루들과 대화하면서 눈을 마주치는 게 쉽지 않다. 천천히 연습해보자(?)\n- 자세의 중요성. 바른 자세를 유지하기 위해 노력하자.\n- 데블스캠프 자료 얼른 준비해야겠다. 이번 주 토요일인데 이제 30% 만들었음..ㅋ\n"},{"excerpt":"인터뷰 주제 주노 하루에 노래를 얼마나 들으세요 ? 3시간 이상 노래를 언제 들으시나요 ? 출퇴근 시간, 개인 공부할 때 유투브로도 음악을 들으시나요 ? 유튜브 뮤직, 유튜브로만 듣는다. 유투브에 있는 플레이리스트들을 이용해 보셨나요? 예. 뭐 듣죠? 시끄러운 플레이리스트 아니면 4세대 여자 아이돌 플레이리스트 본인만의 플레이리스트가 있나요? 없다. 노래…","fields":{"slug":"/shook-planning-interview/"},"frontmatter":{"date":"2023년 06월 28일 09:06","title":"슉 인터뷰","tags":["shook","레벨3"]},"rawMarkdownBody":"\n## 인터뷰 주제\n\n### 주노\n  \n- 하루에 노래를 얼마나 들으세요 ?\n\t- 3시간 이상\n- 노래를 언제 들으시나요 ?  \n\t- 출퇴근 시간, 개인 공부할 때\n- 유투브로도 음악을 들으시나요 ?  \n\t- 유튜브 뮤직, 유튜브로만 듣는다.\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 예. \n\t- 뭐 듣죠? 시끄러운 플레이리스트 아니면 4세대 여자 아이돌 플레이리스트\n- 본인만의 플레이리스트가 있나요?  \n\t- 없다. 노래 취향이 명확하지 않다. 노래에 관심이 없다....\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 다양한 노래를 듣는다.\n\t- 유튜브 추천 알고리즘에 뜨는 거 그냥 듣는다...\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- FT 아일랜드\n\t- 옛날 한국 노래\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 멜로디, 비트\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 지루한 노래. 잔잔한 노래\n\t- 클래식은 취향이 아니다.\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 안 좋아한다. 명확하게 듣는게 없어서 탑 100 좋아한다.\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 듣는다. 취향에 민감하지 않아서\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 네. 1절까지만 듣는다. 한 절반정도\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- 예 뭐.. 언제든지.\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 유튜브 뮤직 알고리즘\n\t- 우플리 채널 -> 아 뭐.. 의향 있습니다.\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 도입부부터 1절까지. \n\n### 그레이\n\n- 하루에 노래를 얼마나 들으세요 ?  \n\t- 하루 두 시간 이상\n- 노래를 언제 들으시나요 ?  \n\t- 출퇴근할 때, 걸을 때, 공부할 때, 대화할 때 빼고\n- 유투브로도 음악을 들으시나요 ?  \n\t- 아 네. 매우 좋아한다.\n\t- 유튜브 프리미엄 사용한다. 나머지는 이제 안 쓴다.\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 물론이다.\n\t- 유튜브에서 알고리즘 추천해주는 거 듣는다.\n- 본인만의 플레이리스트가 있나요?  \n\t- 요즘은 있다.\n\t- 가수에 빠지면 가수 플리를 듣는다.\n\t- 장르는 보통 발라드, 인디 뮤직 듣는다.\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 다양한 노래를 듣는 편.\n\t- 플레이리스트 만들어 둔 거는 일정 기간 지나면 질려서 안 듣는다.\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- 발라드, 인디 뮤직\n\t- 하현상, MC the MAX, 볼빨간 사춘기\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 멜로디\n\t- 직관적으로 들었을 때 끌리는 거\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 단조로운 음율 안 좋아한다.\n\t- 시끄러운 거 안 좋아한다.\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 막 좋아하지 않는다.\n\t- 큰 이유는 없는데, 굳이 싶어서\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 무조건 100%\n\t- 사람들이 좋아 하는 노래는 이유가 있다. 한 번 들었을 때 좋은 노래보다 여러 번 들었을 때 좋은 게 많다.\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 웬만하면 듣는다. 한 곡 다 듣는다.\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- 이미 겪은 장르면 안 듣는다.\n\t- 최근에 클래식 추천 받았는데 괜찮더라.\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 지인 추천이 많다.\n\t- 유튜브 알고리즘이 추천해준다. 별로면 넘기고\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 무조건 처음부터 끝까지\n- 처음부터 끝까지 들어서 별로였던 노래가 있는데 다시 처음부터 들었을 때 괜찮았던 경우?\n\t- 있다. 한 5번은 들어야 괜찮더라.\n\n### 하마드\n\n- 하루에 노래를 얼마나 들으세요 ?  \n\t- 하루에 10곡 내외\n\t- 한 30-40분\n- 노래를 언제 들으시나요 ?  \n\t- 아침에 일어나서 머리감을 때\n\t- 출퇴근\n\t- 가끔 혼자 코딩할 때 \n- 유투브로도 음악을 들으시나요 ?  \n\t- 유튜브로만 듣는다.\n\t- 사운드클라우드도 가끔\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 웬만하면 안 한다.\n\t- 내 기호에 맞추는 걸 좋아한다.\n- 본인만의 플레이리스트가 있나요?  \n\t- 멜론 시절에는 있었는데 \n\t- 유튜브 알고리즘이 비슷한 거 찾아줘서 안 만든다.\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 웬만하면 익숙한 것\n\t- 우연한 경우에는 그거 들어보는 경우\n\t- 웬만하면 추가 잘 안 됨\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- 장르 안 가림\n\t- 힙합, 외국 R&B, 걸그룹, 외국 락 밴드\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 제일 중요한 거 멜로디\n\t- 팝송은 그래서 안 듣는다.\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 가사가 개구리면 정 떨어진다.\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 굉장히 좋아한다.\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 브아걸 아브라카다브라\n\t- 개쓰레기라고 생각했는데 전국적으로 유행해서 다시 들어보니까 괜찮았다.\n\t- 아무리 많이 들어도 설득이 안 되면 안 좋다.\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 일단 처음부터 30초 들어본다.\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- 거부감은 없지만, 좋아하는 노래가 되는 데는 장벽이 좀 높다.\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 웬만하면 유튜브 알고리즘 맨 앞에 있는 거\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 무조건 처음부터 30초\n\n### 박스터\n\n- 하루에 노래를 얼마나 들으세요 ?  \n\t- 6시간\n- 노래를 언제 들으시나요 ?  \n\t- 이동할 때, 코딩할 때\n- 유투브로도 음악을 들으시나요 ?  \n\t- 스포티파이\n\t- 컴퓨터는 유튜브\n- 유투브에 있는 플레이리스트들을 이용해 보셨나요?  \n\t- 내가 만든 거 쓴다.\n- 본인만의 플레이리스트가 있나요?  \n\t- 1개\n- ( 좋아하는 노래만 들으시나요 다양한 노래를 들어보시나요? )  \n\t- 다양한 노래\n\t- 장르를 여러 개 들어서 다양한 노래\n- 어떤 장르, 가수를 좋아하시나요?  \n\t- 장르: 락, 힙합, 클래식\n\t- 가수: 라디오헤드, 다이나믹 듀오, 라흐마니노프\n- 노래를 들을 때 어떤 것 위주로 들으시나요?  \n\t- 한국 노래면 가사\n\t- 외국 노래는 멜로디, 목소리\n- ( 노래를 별로라고 생각하는 요인이 무엇인가요? )  \n\t- 발라드는 쓰레기\n\t- 여자 보컬 별로 안 좋아함 (아이유 제외 - 목소리 좋아서)\n- 좋아하는 노래를 공유하는 것을 좋아하시나요?  \n\t- 아주 좋아한다.\n- 자신은 별로지만 사람들이 좋아하는 노래라면 다시 들어볼 의향이 있나요?  \n\t- 의향 있다.\n\t- 뉴진스 듣다보니 좋아짐.\n- ( 추천받은 노래를 들어보는 편인가요? )  \n\t- 웬만하면 듣는다.\n\t- 우플리 몇 명이 올리는 거 빼고 들음.\n\t- 그래도 발라드는 거름\n- 새로운 노래 혹은 새로운 장르를 들어볼 의향이 있나요?  \n\t- why not\n- 새로운 음악을 어떻게 접하시나요? ->지인 추천, 스트리밍, 유튜브 ...  \n\t- 우플리\n\t- 지인 추천\n\t- 스포티파이 신곡 추천 올라오면 들음\n- 음악을 처음 들을 때 어디를 들으시나요?\n\t- 처음부터 싫을 때까지"},{"excerpt":"개발 컨벤션 좋아보이는 거 모음 Issue 템플릿 버그 이슈 템플릿 피쳐 이슈 템플릿 PR 템플릿 RCA 룰 by 주노 각각의 코멘트의 접두에 R, C, A를 붙이면서 리뷰를 진행하는 방식이다.  : 적극적으로 반영을 고려해주세요  : 웬만하면 반영해주세요  : 반영해도 좋고, 넘어가도 좋습니다. 사소한 의견입니다. reviewer가 1명 이상 appro…","fields":{"slug":"/shook-planning/"},"frontmatter":{"date":"2023년 06월 27일 11:06","title":"슉 기획","tags":["shook","우테코","레벨3"]},"rawMarkdownBody":"\n## 개발 컨벤션 좋아보이는 거 모음\n\n### Issue 템플릿\n\n- 버그 이슈 템플릿\n\n```markdown\n## 🤷 버그 내용\n\n## ⚠ 버그 재현 방법\n1.\n2.\n3.\n\n## 📸 스크린샷\n\n## 👄 참고 사항\n\nby dallog\n```\n\n```markdown\n## 버그 기능\n- 페이지나 기능을 적습니다.\n\n### 버그 상황 재연\n- 어떤 상황에서 버그가 발생하는지 적습니다.\n\n### 기대 동작\n- 원래 기대하던 정상 동작에 대해 작성합니다.\n\n### 현재 동작\n- 기대하던 동작에 반해 지금 문제가 되는 동작을 작성합니다.\n\nby zzimkkong\n```\n\n```markdown\n### QA 환경 : \n\n### 현상: \n\n### 재현 과정 : \n\n### 예상되는 원인: \n\n### 스크린샷:\n\nby jujeol-jujeol\n```\n\n- 피쳐 이슈 템플릿\n\n```markdown\n## 🤷 구현할 기능\n\n## 🔨 상세 작업 내용\n\n- [ ] To-do 1\n- [ ] To-do 2\n- [ ] To-do 3\n\n## 📄 참고 사항\n\n## ⏰ 예상 소요 기간\n\nby dallog\n```\n\n```markdown\n[FE | BE] 명사형으로 작성\n### 설명\n\n### 진행상황\n- [ ] 진행사항1\n- [ ] 진행사항2\n\n### 주의사항\n\nby jujeol-jujeol\n```\n\n### PR 템플릿\n\n```markdown\n## 작업 내용\n\n## 스크린샷\n\n## 주의사항\n\nCloses #{이슈 번호}\n\nby dallog\n```\n\n```markdown\n## 구현 기능\n- 구현한 기능을 적습니다.\n\n## 논의하고 싶은 내용\n- 논의할 내용을 적습니다.\n\n## 공유하고 싶은 내용\n- 학습한 내용, 공유할 내용 등을 적습니다.\n- 위키에 작성했다면 링크 첨부, 없는 경우 삭제\n\n## 기타\n- 기타 추가할 내용이 있다면 추가합니다.\n- 없는 경우 삭제\n\nClose #이슈번호\n\nby zzimkkong\n```\n\n```markdown\n## resolve #issue number\n\n### 설명\n- 프론트의 경우 화면 작업일 때 캡쳐본 포함하기\n\n### 기타\n\nby jujeol-jujeol\n```\n\n```markdown\n[ALL/FE/BE] 작업 진행 내용 간단명료하게\n\n## 📌 관련 이슈\n<!-- 이슈 번호를 적어주세요\nclosed #issue_number를 적어주세요-->\n\n## ✨ 작업 내용\n<!-- 어떤 작업을 했는지 설명해주세요 -->\n\n## 📷 스크린샷 (선택)\n<!-- 스크린샷 필요하면 첨부해주세요 --> \n\n## 🔍 참고 사항\n<!-- PR을 리뷰할 때 참고할 사항이 있으면 적어주세요 -->\n```\n\n- RCA 룰 by 주노\n\t- 각각의 코멘트의 접두에 R, C, A를 붙이면서 리뷰를 진행하는 방식이다.\n\t- `R (Request Changes)` : 적극적으로 반영을 고려해주세요\n\t- `C (Comment)` : 웬만하면 반영해주세요\n\t- `A (Approve)` : 반영해도 좋고, 넘어가도 좋습니다. 사소한 의견입니다.\n\n- reviewer가 1명 이상 approve 하지 않았을 경우에는 merge block 하기\n\n### 코드 컨벤션\n\n- zzimkkong BE 코드 컨벤션 : https://xrabcde.notion.site/5cd0851364254f1db103607efa414a8d\n\n## Git Branch 전략\n\n- main\n\t- 실제 프로젝트 사용자들이 볼 배포 브랜치\n- develop\n\t- 개발 총괄 브랜치\n\t- main 에서 파생, 기능 개발 후 main에 반영\n\t- feat/issue-number\n\t\t- issue 단위의 기능 개발 브랜치\n\t\t- develop 에서 파생, 기능 개발 후 develop에 반영\n\t- fix/issue-number\n\t\t- issue 단위의 버그 수정 브랜치\n\t\t- develop 에서 파생, 버그 수정 후 develop에 반영\n- hotfix\n\t- main 에서 파생, 버그 수정 후 main에 반영\n\n## Commit 컨벤션\n\n- feat: 기능 개발\n- docs: 문서 관련 작업\n- refactor: 기능 변경 없이 전반적 코드 구조 변경 (Ex. 필드 이름 변경 등)\n- chore: 파일 내부가 아닌 파일 자체에 대한 변경 (Ex. 폴더 이동 / 변경, 파일 이름 변경, 파일 삭제)\n- style: 코드 컨벤션 관련 작업\n- test: 테스트 코드 관련 작업\n- fix: 버그 수정\n- design: 마크업 관련 수정\n- config: 외부 라이브러리 관련 추가 및 설정"},{"excerpt":"로컬 환경에서 로컬 프로필이 적용되지 않는 문제 로컬에서는 로컬 프로필이 적용되어야 하는데 submodule 로 지정해준 prod 프로필이 적용되는 문제가 발생했다.  PR 링크 기존에는 prod 파일에도 이런 설정이 있었다.  파일은 다음과 같았다. 이대로 실행하면, 실행되는 프로필은 prod 였다. 문제의 원인은  가 여러 개 존재하기 때문이다. ap…","fields":{"slug":"/spring-multi-profile-issue/"},"frontmatter":{"date":"2023년 06월 26일 12:06","title":"Spring의 Profile은 어떤 순서로 읽힐까?","tags":["spring","개발","matzip","trouble-shooting"]},"rawMarkdownBody":"\n## 로컬 환경에서 로컬 프로필이 적용되지 않는 문제\n\n로컬에서는 로컬 프로필이 적용되어야 하는데 submodule 로 지정해준 prod 프로필이 적용되는 문제가 발생했다.  [PR 링크](https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/158)\n\n기존에는 prod 파일에도 이런 설정이 있었다.\n\n```yaml\n# prod/application.yml\nspring:  \n  profiles:  \n    active:  \n      - prod  \n    group:  \n      prod:  \n        - web-prod  \n        - db-prod\n---\n...\n```\n\n`application.yml` 파일은 다음과 같았다.\n\n```yaml\nspring:  \n  profiles:  \n    active:  \n      - local  \n    group:  \n      local:  \n        - web-local  \n        - db-local  \n      prod:  \n        - web-prod  \n        - db-prod  \n  config:  \n    import: classpath:prod/application.yml\n---\n...\n```\n\n이대로 실행하면, 실행되는 프로필은 prod 였다.\n\n```bash\n2023-06-22 18:20:00.952  INFO 12487 --- [           main] c.woowacourse.MatzipExternalApplication  : The following 3 profiles are active: \"prod\", \"web-prod\", \"db-prod\"\n```\n\n문제의 원인은 **`active` 가 여러 개 존재하기 때문이다.**     \napplication-prod에도 `active` 설정을 해주었기 때문에 `active` 설정이 덮어 씌워진 것이다.\n\n따라서 문제 해결을 위해서는 prod의 `application.yml` 을 다음처럼 바꾸면 된다.\n\n```yaml\nspring:  \n  profiles:  \n    group:  \n      prod:  \n        - web-prod  \n        - db-prod\n---\n```\n\n### prod의 application.yml이 local의 application.yml 보다 늦게 읽히는 걸까?\n\n여기까지 문제는 해결됐는데, 왜 prod가 local보다 늦게 실행되는지 궁금했다.     \n스프링이 local을 먼저 읽고, prod를 읽기 때문에 덮어 씌워지는 건가? 해서 테스트를 해보았다.     \n\nprod가 나중에 읽혀진다면, 스프링이 실행되고 나서 정해진 설정은 prod의 필드 값이어야 한다.     \n그러나 확인해보니 local 의 필드 값이 저장되어 있었다.    \n대체 어떻게 된 일일까?\n\n결론적으로는 `spring.config.import` 를 할 때 파일을 가져오는 방식 때문에 그렇다.     \n`spring.config.import` 를 하게 되면 해당 경로에 있는 yml 파일을 아래에 추가한다.     \n주의해야 하는 것은 맨 위의 디폴트 설정값 이후에 바로 추가된다는 것이다.     \n즉, 다음과 같다.\n\n```yaml\nspring:  \n  profiles:  \n    active:  \n      - local  \n    group:  \n      local:  \n        - web-local  \n        - db-local  \n      prod:  \n        - web-prod  \n        - db-prod  \n  config:  \n    import: classpath:prod/application.yml\n---\nspring:  \n  profiles:  \n    active:  \n      - prod  \n    group:  \n      prod:  \n        - web-prod  \n        - db-prod\n---\n...\n```\n\n이런 식으로 값이 추가 되기 때문에, 처음의 문제 상황에서는 `active` 만 덮어씌워지고, 나머지 설정들은 local 값이 된 것이다.     \nyaml 파일은 위에서부터 아래로 읽기 때문에, 똑같은 설정 값을 갖는 필드는 그냥 값이 덮어 씌워지게 된다.    \n\n### 결론\n\n`spring.config.import` 는 파일 맨 끝에 내용을 추가하는 게 아니라는 것을 알게 되었다.\n\n### 참고\n- https://bbbicb.tistory.com/53\n- https://jaime-note.tistory.com/371"},{"excerpt":"LOG 동생이 입대했다. 전날에 같이 술 마신 것 때문에 조금 속이 안 좋았다..ㅋㅋ 점심은 동생이 먹고 싶어했던 육회 비빔밥을 먹으러 익산에 갔다. 비빔밥 집인데 사람이 굉장히 많길래 뭘까 했는데 백종원의 3대천왕에 나왔던 곳이었다. 꽤나 맛있었다. 훈련소에 들어가기 전에는 엄청 심란해했다. 하필 비가 많이 와서 불쾌한 기분으로 ㅋㅋㅋ 논산에 갔다. 입…","fields":{"slug":"/2023-06-26/"},"frontmatter":{"date":"2023년 06월 26일 07:06","title":"2023년 06월 26일","tags":null},"rawMarkdownBody":"\n## LOG\n- 동생이 입대했다. 전날에 같이 술 마신 것 때문에 조금 속이 안 좋았다..ㅋㅋ 점심은 동생이 먹고 싶어했던 육회 비빔밥을 먹으러 익산에 갔다. 비빔밥 집인데 사람이 굉장히 많길래 뭘까 했는데 백종원의 3대천왕에 나왔던 곳이었다. 꽤나 맛있었다. 훈련소에 들어가기 전에는 엄청 심란해했다. 하필 비가 많이 와서 불쾌한 기분으로 ㅋㅋㅋ 논산에 갔다. 입소식은 20분 만에 끝나서 논산역에 40분이나 빠르게 도착했다.\n- 집에 가면 과일을 많이 먹는다. 블루베리, 복숭아, 자두, 살구, 수박... 뭔가 많이 먹고 왔다.\n- Matzip 피쳐 개발을 완료했다. 이번 방학은 내내 맛집만 한 것 같다.\n- 방학 때 원래는 운영체제 공부를 하려고 했는데, 운영체제 공부보다는 알고리즘을 더 많이 했다. 많이 안 한 것 같으면서도, 많이 한 것 같기도 하다.\n\n## 배운 것\n- `git push --force-with-lease` : force push의 대상이 되는 브랜치에 지금까지 변화가 있었는지 확인하고, 변화가 있다면 강제 푸시를 못하도록 거부한다. 즉, 다른 사람이 해당 브랜치를 변경했다면 강제 푸시를 할 수 없고, 다른 사람이 브랜치를 변경하지 않은 경우에만 강제 푸시가 가능하게 한다.\n\t- 참고 : https://velog.io/@rawoon/-force-%EB%8A%94-%EC%9C%84%ED%97%98%ED%95%98%EB%8B%88-git%EC%9D%98-force-with-lease-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90\n- github PR 내용에 `close #{이슈번호}`  라고 치면 PR 닫힐 때 이슈도 같이 닫힌다. by 체인저\n\n## 궁금한 것\n\n## 느낀 것\n- 동생까지 군대에 갔으니 엄마가 외로워하실 것 같다. 사실 다른 건 크게 걱정되지 않았는데 그게 걱정됐다. 집에 붙어 있는 사람이 없어졌으니 고양이와 더 열심히 지내시지 않을까...\n- 내가 보기엔 걱정되는 일을 별 것 아닌 것처럼 말하는 것보다, 솔직하게 걱정하는 게 더 보기 좋다.\n- 어제 동생과 같이 이야기하기를 잘했다. 평소에 생각하고 있던 말을 솔직하게 하는 것도 기분이 좋았고, 최근에는 알지 못했던 근황과 이전의 사건에서 느꼈던 점을 물어볼 수 있어서 좋았다. 앞으로도 하고 싶은 걸 생각만 하지 말고 실천하는 연습을 해야겠다.\n- 아무리 생각해도 감정에 솔직한 건 좋다. 좋은 건 좋다고, 싫은 건 싫다고, 걱정되는 건 걱정된다고. 그렇지만 아직 싫은 걸 싫다고 말하는 건 조금 어렵다.\n- 내일은 잠실에 간다. 망고를 제외한 온보딩 조원들을 2달간 ㅠㅠ 못 본다는 사실이 슬프다. 어째서 다들 선릉인거야 😭 2월부터 대부분의 시간을 함께 했던 친한 사람들과도 헤어지게 되어 눈물 한 바가지... 그렇지만 새롭게 만나는 사람들과도 즐겁게 지내보자 🥺"},{"excerpt":"첫 회의 때 의논하면 좋아 보이는 것들 기능 어느 정도 구체화 원활한 소통을 위해 말 놓기 제안 코드 컨벤션 같은 거 통일? -> 근데 이건 첫 회의 때 안 해도 될 것 같음 프로젝트 개발 지향점 꼭 해보고 싶은 거라든지 지양했으면 하는 것이라든지 고도화 초점 vs 기능을 여러 개 만드는 것에 초점 프로젝트 기획 지향점 각자 지켜줬으면 하는 규칙들? 사용…","fields":{"slug":"/level3-project/"},"frontmatter":{"date":"2023년 06월 25일 07:06","title":"레벨 3 프로젝트","tags":["우테코","레벨3","프로젝트"]},"rawMarkdownBody":"\n## 첫 회의 때 의논하면 좋아 보이는 것들\n\n- 기능 어느 정도 구체화\n- 원활한 소통을 위해 말 놓기 제안\n- 코드 컨벤션 같은 거 통일? -> 근데 이건 첫 회의 때 안 해도 될 것 같음\n- 프로젝트 개발 지향점\n\t- 꼭 해보고 싶은 거라든지\n\t- 지양했으면 하는 것이라든지\n\t- 고도화 초점 vs 기능을 여러 개 만드는 것에 초점\n- 프로젝트 기획 지향점\n- 각자 지켜줬으면 하는 규칙들?\n- 사용할 tool 정리하기\n\t- 깃허브 프로젝트\n\t- 노션\n\t- 지라\n\t- 슬랙\n- 팀이 중점으로 둘 가치? (팀 문화 형성할 때 해도 될 거 같기도 하고)\n- 데일리 미팅 언제\n- 팀 명 / 서비스 명\n- 기술 스택\n\n## 첫 회의\n\n- 음악에도 썸네일을 붙여준다.\n- 제일 유명한 부분을 먼저 들어보고, 별로면 안 들어보고.\n- 주된 목적\n\t- 유저가 다 들어보기에는 피곤하니까 사람들이 좋다고 하는 부분을 먼저 들어보자.\n\t- 내 취향에 맞는 노래를 빠르게 선택하고 싶다.\n- 궁금증\n\t- 아이돌 음악은 유튜브에 킬링 파트가 많이 올라와 있다.\n\t- 영상이 아닌 음악에 한해서만 하는 걸로\n\t- 구간은 애매할 수 있다. -> 여기부터 들어봐 느낌?\n\t- 가장 많이 투표했던 노래들을 노출시킨다. \n\t- 좋은 부분의 시작 지점을 선택해서 여기서부터 들어라.\n\t- 음원은 가지고 있을 필요 없지만, 노래 리스트는 필요하다.\n\t\t- 노래 리스트 선정 방법도 중요할 듯\n\t\t- 유튜브 영상 링크로 연결되는 느낌으로\n"},{"excerpt":"어떤 이미지 링크는 다운로드가 된다 동일한 S3 버킷으로 연결되는 cloudfront 링크로 이미지를 조회했을 때, 어떤 이미지 링크는 브라우저의 창으로 이미지가 보여지는 반면 어떤 이미지는 이미지 창이 열리지 않고 다운로드가 됐다. 어떤 차이였을까? MIME 이란? MIME (Multipurpose Internet Mail Extensions) 유형은 …","fields":{"slug":"/mime/"},"frontmatter":{"date":"2023년 06월 22일 07:06","title":"MIME Type 알아보기 - 이미지 링크로 들어갔을 때 다운로드가 된다면?","tags":["matzip","개발","aws","trouble-shooting"]},"rawMarkdownBody":"\n## 어떤 이미지 링크는 다운로드가 된다\n\n동일한 S3 버킷으로 연결되는 cloudfront 링크로 이미지를 조회했을 때, 어떤 이미지 링크는 브라우저의 창으로 이미지가 보여지는 반면 어떤 이미지는 이미지 창이 열리지 않고 다운로드가 됐다.\n\n어떤 차이였을까?\n\n## MIME 이란?\n\n> MIME (Multipurpose Internet Mail Extensions) 유형은 인터넷에서 데이터를 전송하고 식별하기 위해 사용되는 표준화된 방법입니다. - GPT 선생\n\nMIME(마임이라고 읽는다)은 일종의 인코딩 방식이다. 이메일 시스템에서 파일 첨부를 위해 개발되었으나, 웹을 통해 여러 형태의 파일을 전달하는데 널리 사용되고 있다.\n\nMIME으로 인코딩한 파일은 'content-type' 정보를 파일의 앞 부분에 담고 있다. \n\nMIME 유형은 두 부분으로 구성된다.    \n첫 번째 부분은 주 유형 (Primary Type) 이다. Ex. `text`, `image`, `application` 등     \n두 번째 부분은 부 유형 (Subtype) 이다. Ex. `plain`, `jpeg`, `pdf` 등    \n두 부분은 `/` 로 구분된다.\n\n다음은 몇 가지 예시이다.\n\n`text/plain`    \n`image/jpeg`     \n`application/pdf`     \n\n파이썬으로 MIME 으로 인코딩한 파일의 바이너리 코드를 열어보면 파일의 시작 부분에 확장자가 명시되어 있다.    \n\n```text\nb'\\x89PNG\\r\\n\\x1a ...\n```\n\n이처럼 PNG 이미지 파일의 바이너리 코드에는 파일의 매직 넘버인 PNG가 들어있다.     \n\n```python\nwith open('image.png', 'rb') as file:  \n    byte_code = file.read()  \n  \nprint(byte_code)\n```\n\n바이너리 코드는 위의 파이썬 코드로 확인할 수 있다.\n\n## S3의 어떤 설정 때문이었을까?\n\n확인해보니, 업로드된 이미지의 `Content-Type` 이  `application/octet-stream` 으로 설정되어 있었다.\n\n(업로드된 파일의 메타데이터 편집에 들어가면 `Content-Type` 을 확인할 수 있다)\n\n![[octet-mime-type.png]]\n\n`application/octet-stream` 은 이진 파일을 위한 기본값이다.     \n8-bit 바이너리 배열을 의미하며, http나 email 상에서 application 이 지정되지 않았거나 형식을 모를 때 사용한다.     \n즉, 브라우저는 `octet-stream` 으로 MIME 유형이 지정된 경우, 바이너리 데이터로만 다운로드가 가능하다.   \n\n기존에 잘 열렸던 이미지의 `Content-Type` 을 확인해보자.    \n\n![[image-mime-type.png]]\n\n`Content-Type` 이 `image/png` 로 잘 설정되어 있는 것을 볼 수 있다.    \n\n## 브라우저에서 이미지 열기로 바꿔보자\n\n```java\n@Transactional\npublic ImageUploadResponse uploadImage(final MultipartFile file) {\n\tString extension = validateExtension(file);\n\tPutObjectRequest request = createRequest(file, extension);\n\ttry {\n\t\ts3Client.putObject(request, RequestBody.fromBytes(file.getBytes()));\n\t} catch (IOException e) {\n\t\tthrow new UploadFailedException();\n\t}\n\treturn new ImageUploadResponse(\"aaa\");\n}\n\nprivate PutObjectRequest createRequest(final MultipartFile file, final String extension) {\n\tString uuid = UUID.randomUUID().toString();\n\tString key = uuid + EXTENSION_DELIMITER + extension;\n\treturn PutObjectRequest.builder()\n\t\t\t.bucket(bucketName)\n\t\t\t.key(key)\n\t\t\t.contentLength(file.getSize())\n\t\t\t.build();\n}\n```\n\n기존 코드는 다음과 같다. \n\n`contentType` 을 지정해주지 않았기 때문에 자동으로 `application/octet-stream` 으로 저장되었다.     \n따라서 `contentType` 을 설정해주면 된다.\n\n```java\nreturn PutObjectRequest.builder()\n\t\t\t.bucket(bucketName)\n\t\t\t.key(key)\n\t\t\t.contentLength(file.getSize())\n\t\t\t.contentType(file.getContentType())\n\t\t\t.build();\n```\n\n이렇게 바꿔주면 `application/octet-stream` 이 아닌 파일의 `Content-Type` 으로 설정되기 때문에 브라우저가 이미지로 인식한다.     \n\n"},{"excerpt":"개요 Matzip 다른 팀원들이 AWS Management Console에 접근하게 하기 위해 관리 계정과는 다른 사용자가 필요했다. 지금은 읽기 권한만 가능하도록! 원래는 IAM 사용자를 생성하려 했는데, 이번에 IAM 자격 증명 센터가 생겼다고 해서 (권장하는 방법이래서) 한 번 사용해봤다. IAM 자격 증명 센터는 하나의 리전에만 구성할 수 있으니,…","fields":{"slug":"/matzip-aws-iam/"},"frontmatter":{"date":"2023년 06월 17일 05:06","title":"AWS IAM Identity Center 사용하기","tags":["aws","matzip"]},"rawMarkdownBody":"\n## 개요\n\nMatzip 다른 팀원들이 AWS Management Console에 접근하게 하기 위해 관리 계정과는 다른 사용자가 필요했다. 지금은 읽기 권한만 가능하도록!\n\n원래는 IAM 사용자를 생성하려 했는데, 이번에 IAM 자격 증명 센터가 생겼다고 해서 (권장하는 방법이래서) 한 번 사용해봤다.\n\nIAM 자격 증명 센터는 하나의 리전에만 구성할 수 있으니, 원래 사용하는 리전인 Asia Pacific Seoul에 구성해주었다.\n\n## 그룹 생성하기\n\n관리자 그룹과 개발자 그룹으로 분리했다. (admin, dev)\n\n그룹은 아무 조건 없이 그냥 만들 수 있다. 그룹 이름은 변경할 수 없다.\n\n## 사용자 생성하기\n\n사용자 이름, 이메일 주소, 이름, 성, 표시 이름을 입력한다.\n\n사용자 이름은 **반드시 그룹 이름과 달라야 한다**. 그룹 이름과 같으면 에러가 발생한다.\n모든 정보를 입력했다면 그룹에 할당해준다.\n\n이 과정까지 마치면 단 한 번 볼 수 있는 AWS 액세스 포털 URL, 사용자 이름, 암호가 나온다. 복사해주자.\n\n## 권한 세트 생성\n\n여기까지 수행하면 아무런 권한이 설정되어 있지 않기 때문에 AWS 액세스 포털 링크에 들어가도 아무것도 할 수 없다. 그러므로 권한 세트를 생성한 후, 그룹에 등록해주어야 한다.\n\n관리자는 모든 권한, 개발자는 읽기 권한만 줄 것이라 `사전 정의된 권한 세트` 를 사용했다.    \n잘 읽어보면 이것저것 있으니 원하는 권한을 선택하자.    \n더 자세하게 하고 싶으면 사용자 지정 권한 세트를 만들면 된다.\n\n## 권한 세트 할당\n\n사용자 및 그룹 할당에서 계정을 선택해준다.\n\n권한을 설정하고 싶은 그룹을 선택하고, 주고 싶은 권한 세트를 선택하면 된다.\n\n이 과정까지 하면 사용자 추가가 완료된다.\n개발 계정으로 로그인 하면 다음과 같은 화면이 나오는데, Management console로 들어가면 AWS를 사용할 수 있다.\n\n![[aws-iam-management-console.png]]"},{"excerpt":"S3 버킷 생성 설정 모든 퍼블릭 액세스 차단 버킷 정책은 다음과 같이 설정했다. 버전 관리 설정 X CloudFront 생성 원본 도메인에 연결하고자 하는 S3를 선택한다. 원본 액세스는 원본 액세스 제어 설정을 선택한다. (OAC) 많이 소개하는 OAI는 레거시가 되어 사용하지 않는 것을 권장한다고 한다. 제어 설정을 생성하여  을 선택하고, 원본 유…","fields":{"slug":"/matzip-aws-s3-cloudfront/"},"frontmatter":{"date":"2023년 06월 17일 05:06","title":"S3와 CloudFront 연동하기","tags":["aws","matzip"]},"rawMarkdownBody":"\n## S3 버킷 생성\n\n### 설정\n\n- 모든 퍼블릭 액세스 차단\n\n버킷 정책은 다음과 같이 설정했다.\n\n```json\n{\n    \"Version\": \"2008-10-17\",\n    \"Id\": \"PolicyForCloudFrontPrivateContent\",\n    \"Statement\": [\n        {\n            \"Sid\": \"AllowCloudFrontServicePrincipal\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": \"cloudfront.amazonaws.com\"\n            },\n            \"Action\": \"s3:GetObject\",\n            \"Resource\": \"arn:aws:s3:::{버킷 이름}/*\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"AWS:SourceArn\": \"arn:aws:cloudfront::{숫자로 된 계정 id}:distribution/{cloudfront id}\"\n                }\n            }\n        }\n    ]\n}\n```\n\n- 버전 관리 설정 X\n\n## CloudFront 생성\n\n원본 도메인에 연결하고자 하는 S3를 선택한다.\n\n원본 액세스는 원본 액세스 제어 설정을 선택한다. (OAC)     \n많이 소개하는 OAI는 레거시가 되어 사용하지 않는 것을 권장한다고 한다.    \n제어 설정을 생성하여 `서명 요청 (권장)` 을 선택하고, 원본 유형은 S3를 선택한다.     \n이 설정 후에는 S3의 버킷 정책을 업데이트해야 한다. 복사할 수 있는 버튼이 생기니 복사해서 그대로 갖다 붙이면 된다. \n\n웹 애플리케이션 방화벽은 비활성화했다.\n설정에서는 `모든 엣지 로케이션에서 사용` 을 선택한다.    \n\n만약 커스텀 도메인이 존재한다면 Route53에 등록된 도메인을 등록하면 된다."},{"excerpt":"VPC 생성 + NAT EC2로 구축하기 + Bastion 세팅하기\nS3와 Cloudfront 연동하기\nIdentity Center로 IAM 사용자 생성하기","fields":{"slug":"/matzip-aws/"},"frontmatter":{"date":"2023년 06월 17일 05:06","title":"matzip aws 설정기","tags":["matzip","aws","네트워크"]},"rawMarkdownBody":"\n[[matzip-vpc-setting|VPC 생성 + NAT EC2로 구축하기 + Bastion 세팅하기]]\n[[matzip-aws-s3-cloudfront|S3와 Cloudfront 연동하기]]\n[[matzip-aws-iam|Identity Center로 IAM 사용자 생성하기]]"},{"excerpt":"NAT이란? IP 패킷의 TCP / UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다. 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위해 사용된다. IPv4의 주소 부족 문제를 해결하기 위한 방법으로써 고려되었다. 인터넷이 연동되는 기…","fields":{"slug":"/nat/"},"frontmatter":{"date":"2023년 06월 12일 06:06","title":"Network Address Translation","tags":["네트워크"]},"rawMarkdownBody":"\n## NAT이란?\n\nIP 패킷의 TCP / UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다.\n\n사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위해 사용된다.    \nIPv4의 주소 부족 문제를 해결하기 위한 방법으로써 고려되었다.    \n인터넷이 연동되는 기기가 많아지면서 IP 주소가 전세계적으로 유일하게 할당 되는 것은 불가능해졌다.   \n\n주로 사설 네트워크 주소를 사용하는 망에서 외부의 공인망과의 통신을 위해 네트워크 주소를 반환하는 것이다.   \n즉, 내부 망에서는 사설 IP 주소를 사용하여 통신을 하고, 외부망과 통신 시에는 NAT 을 거쳐 공인 IP 주소로 자동 변환합니다.\n\n### 장단점\n\n#### 장점\n1. 인터넷의 공인 IP 주소를 절약할 수 있다.\n\t- NAT을 사용하면 사설 IP 주소를 공유하면서 이를 공인 IP 주소와 상호 변환할 수 있도록 하여 공인 IP 주소를 다수가 함께 사용할 수 있게 한다.\n2. 인터넷이란 공공망과 연결되는 사용자들의 고유한 사설망을 침입자들로부터 보호할 수 있다.\n\t- 인터넷과 사설망 사이에 방화벽을 설치하여 외부 공격으로부터 사용자의 통신망을 보호하는 기본 수단으로 활용할 수 있다.\n\t- 인터넷 망과 연결하는 장비인 라우터에 NAT을 설정하는 경우, 라우터는 자신에게 할당된 공인 IP 주소만 외부로 알려지게 하고, 내부에서는 사설 IP 주소만 사용하도록 하여 필요 할 때 이를 서로 변환시켜 준다. 따라서 외부 침입자가 공격하기 위해서는 사설망의 내부 사설 IP 주소를 알아야 하므로 공격이 불가능하다.\n\n#### 단점\n- end-to-end 추적이 어렵다. 여러 개의 NAT 라우터에 의해 multiple NAT가 적용되었을 경우, 경로 추적이 더욱 어렵다. 이는 해커가 대상 경로를 추적하기 어렵게 만들어서 좀 더 보안성 있는 연결을 할 수 있게 한다는 관점에서도 볼 수 있다.\n- NAT 라우터를 거치는 모든 패킷을 스캔하므로 switching path delay가 커지게 된다.\n\n### 참고\n- https://jwprogramming.tistory.com/30\n- https://5kyc1ad.tistory.com/254\n"},{"excerpt":"CIDR란 클래스 없는 도메인 간 라우팅 기법 (Classless Inter-Domain Routing) 각 네트워크 대역을 구분 짓고, 구분된 네트워크간 통신을 위한 주소 체계이다.\n서브넷팅 뿐만 아니라 서브넷을 합치는 슈퍼네팅 역시 CIDR의 일환이다. IPv4 주소는 4개의 옥텟으로 이루어져 있고, 하나의 옥텟은 8비트로 이루어져 있다.\n즉, 사이더…","fields":{"slug":"/cidr/"},"frontmatter":{"date":"2023년 06월 12일 05:06","title":"CIDR","tags":["네트워크"]},"rawMarkdownBody":"\n## CIDR란\n\n클래스 없는 도메인 간 라우팅 기법 (Classless Inter-Domain Routing)\n\n각 네트워크 대역을 구분 짓고, 구분된 네트워크간 통신을 위한 주소 체계이다.\n서브넷팅 뿐만 아니라 서브넷을 합치는 슈퍼네팅 역시 CIDR의 일환이다.\n\nIPv4 주소는 4개의 옥텟으로 이루어져 있고, 하나의 옥텟은 8비트로 이루어져 있다. \n즉, 사이더는 0~32까지 총 32비트까지 사용가능하다.\n\n`143.7.65.203/16` 인 경우, `143.7.0.0` ~ `143.7.255.255` 를 사용할 수 있게 된다.\n\n### 장점\n\n- IP의 범위를 한 줄로 표기할 수 있다.\n- CIDR 숫자를 필요에 따라 더 쓰거나, 적게 사용해서 IP를 적절하게 할당할 수 있다.\n\n## AWS의 서브넷팅\n\nAWS에서는 자체 클라우드에서 설정해서 사용하고 있는 IP가 있기 때문에 총 5개를 제외해야 한다.\n\n`10.0.0.0` : 네트워크 주소\n`10.0.0.1` : AWS에서 VPC 라우터 용으로 예약 (Default Gateway)\n`10.0.0.2` : DNS 서버 주소\n`10.0.0.3` : AWS에서 앞으로 사용하려고 예약한 주소\n`10.0.0.255` : 네트워크 브로드캐스트 주소\n\n즉, AWS에 `192.168.0.0/24` 에서 총 사용가능한 호스트 개수는 256 - 5 = 251 이다.\n\n\n"},{"excerpt":"방학 때 진행할 피쳐 기획 가장 많은 투표를 받았던 기능 기능 추가:  -> 1 순위 기능 개선:  -> 조금씩만 기능 추가하는 식으로 사용자 별 평균 별점 표시 -> 최대한 빨리 구현 홈페이지 개선 애슐리의 피그마 디자인 적용하기 slack 에 디자인 반영해도 되는지 여쭤보기 마이페이지 추가","fields":{"slug":"/matzip-summer-vacation-meeting/"},"frontmatter":{"date":"2023년 06월 12일 02:06","title":"matzip 여름 방학 기획","tags":["matzip"]},"rawMarkdownBody":"\n## 방학 때 진행할 피쳐 기획\n\n- 가장 많은 투표를 받았던 기능  \n\t- 기능 추가: `마이페이지 추가` -> 1 순위\n\t- 기능 개선: `홈페이지 개선` -> 조금씩만 기능 추가하는 식으로\n- 사용자 별 평균 별점 표시 -> 최대한 빨리 구현\n\n## 홈페이지 개선\n\n- 애슐리의 피그마 디자인 적용하기\n\t- slack 에 디자인 반영해도 되는지 여쭤보기\n\n## 마이페이지 추가\n"},{"excerpt":"VPC란 Virtual Private Cloud : 가상 프라이빗 클라우드 (논리적 네트워크) 클라우드 컴퓨팅 환경에서 네트워킹을 구성하는 데 사용되는 가상 네트워크이다. 사용자가 정의한 IP 주소 범위에서 작동하며, 사용자는 서브넷, 라우팅 테이블, 네트워크 게이트웨이 등의 구성 요소를 사용하여 VPC를 세부적으로 관리할 수 있다. 장점 다른 VPC와 …","fields":{"slug":"/vpc/"},"frontmatter":{"date":"2023년 06월 11일 08:06","title":"VPC","tags":["네트워크","aws"]},"rawMarkdownBody":"\n## VPC란\n\nVirtual Private Cloud : 가상 프라이빗 클라우드 (논리적 네트워크)\n\n클라우드 컴퓨팅 환경에서 네트워킹을 구성하는 데 사용되는 가상 네트워크이다.   \n사용자가 정의한 IP 주소 범위에서 작동하며, 사용자는 서브넷, 라우팅 테이블, 네트워크 게이트웨이 등의 구성 요소를 사용하여 VPC를 세부적으로 관리할 수 있다. \n\n### 장점\n\n1. 다른 VPC와 완전히 분리된 환경을 제공하여 보안과 개인정보 보호를 강화할 수 있다.\n2. 사용자는 VPC 내에서 사용할 IP 주소 범위를 정의할 수 있다. 네트워크 주소 공간을 효율적으로 관리할 수 있다.\n3. VPC 내에서 서브넷을 생성하여 리소스를 그룹화하고, 라우팅 테이블을 사용하여 트래픽을 관리할 수 있다. 네트워크 트래픽을 효율적으로 분배하고 제어할 수 있다.\n\n\n### 참조\n- https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/what-is-amazon-vpc.html"},{"excerpt":"관련 글: ori-06-08 공부한 내용 VPC CIDR NAT 진행 사항 private 서브넷 2개, public 서브넷 2개 NAT 설정 X 가용성을 위해 가용영역 A, C에 저장  NAT 게이트 웨이 설정 public subnet에 NAT 게이트웨이 설정을 해줬다. private subnet의 라우팅 테이블에  을 nat에 연결해주었다. 실험해보지는…","fields":{"slug":"/matzip-vpc-setting/"},"frontmatter":{"date":"2023년 06월 11일 08:06","title":"matzip vpc setting","tags":["matzip","인프라","aws","네트워크"]},"rawMarkdownBody":"\n관련 글: [[ori-06-08]]\n\n## 공부한 내용\n- [[vpc|VPC]]\n- [[cidr|CIDR]]\n- [[nat|NAT]]\n\n## 진행 사항\n\n- private 서브넷 2개, public 서브넷 2개\n- NAT 설정 X\n- 가용성을 위해 가용영역 A, C에 저장\n\n![[vpc-setting.png]]\n\n### NAT 게이트 웨이 설정\n\npublic subnet에 NAT 게이트웨이 설정을 해줬다.     \n\nprivate subnet의 라우팅 테이블에 `0.0.0.0/0` 을 nat에 연결해주었다.     \n실험해보지는 않았지만 아마도 이렇게 하면 외부 인터넷 연결이 NAT으로 연결되지 않을까 싶다.    \nNAT에 연결되면 라우터를 통해 사설 IP 주소로 값이 변경되어서 내부 사설망으로 연결 된다.\n\n-> 근데 NAT 게이트 웨이는 너무 값이 비싸서 쓸 수 없다... 그래서 EC2로 NAT 게이트 웨이를 직접 만들게 되었다. \n\n### EC2 게이트 웨이 설정\n\n[이 글](https://cloudest.oopy.io/posting/007) 을 참고했다.\n\n`matzip-nat-gateway-c-prod` 으로 이름을 설정했다.\n\nNAT 이미지는 다음의 이미지를 사용했다. 꽤 최신이라.. 잘 찾아보니 6월 것도 있었다.\n\n![[nat-image.png]]\n\n인스턴스 유형은 t2.micro로 설정했다. \n\n키 페어는 새로 생성했다. `nat-gatewat-keypair.pem`\n\n네트워크 설정에서 vpc는 새롭게 만든 vpc를 설정해주고, 서브넷은 해당 가용 영역(여기서는 c)의 public subnet을 적용해주었다.   \n보안 그룹 설정에서 새로운 보안 그룹을 만들어 주었다.   \nssh 연결은 기본 설정대로 두고, 모든 트래픽으로 private subnet 의 ip를 설정해주었다.    \n퍼블릭 IP 자동 할당도 필요하다.    \n\n스토리지 볼륨에서 볼륨 유형을 `gp2` 로, 암호화됨으로 변경해주었다.    \nKMS 키는 기본값을 사용했다.\n\n고급 세부 정보에서는 최대 절전 중지 방식을 `활성화` 로 설정했다.    \n추가로 종료 방지는 `활성화` 해주었다.    \n용량 예약은 `열기` 로 변경했다.      \n\n다 설정해주고 나서 `네트워킹 -> 소스 / 대상 확인 변경` 을 중지한다.    \n\n![[source-object-check-change.png]]\n\n생성된 NAT 모두에 탄력적 IP를 설정해 주었다.    \n\nNAT을 설정한 후에는 private subnet으로 가서 라우팅 테이블을 수정해주어야 한다.    \n`0.0.0.0/0` 에서 만든 NAT 인스턴스로 연결되게 해주면 완료.    \n\n### Bastion 설정\n일반 EC2처럼 만들되, 아까 만들어 둔 VPC와 public subnet (가용영역 A) 에서 생성한다.\n퍼블릭 아이피는 할당한다. 외부에서 접근할 수 있어야 하기 때문에? (SSH 연결 가능하게)\n\n> 가용 영역 별로 Bastion을 만드는 방식이 맞을까요?\n\n굳이 가용 영역 별로 Bastion을 만들 필요는 없다.    \n가용성은 서비스가 동작할 때의 안정성을 뜻하는 것이고, 접속과는 관련 없다.\n\nprivate subnet 보안 그룹에서 bastion 보안 그룹을 SSH 22로 열어두면 private subnet의 인스턴스에 bastion으로 접근 가능하다.\n\n- 참고: https://err-bzz.oopy.io/f5616e26-79ca-4167-b2eb-140de69b9b54"},{"excerpt":"인프라 matzip-aws PR 링크 백엔드 PR 링크 submodule 적용기 로컬용 yml 파일 추가: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/142 submodule 적용: https://github.com/The-Fellowship-of-the-matzip/mat.zip…","fields":{"slug":"/matzip-feature-develop/"},"frontmatter":{"date":"2023년 06월 11일 08:06","title":"matzip 피쳐 개발","tags":["matzip","우테코"]},"rawMarkdownBody":"## 인프라\n- [[matzip-aws]]\n\n### PR 링크\n\n\n## 백엔드\n\n### PR 링크\n- submodule 적용기\n\t- 로컬용 yml 파일 추가: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/142\n\t- submodule 적용: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/154\n\t- 로컬에서 local 프로필이 적용되지 않는 이슈 해결: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/158\n- 내 리뷰 조회 + 내 정보 조회 API 개발: https://github.com/The-Fellowship-of-the-matzip/mat.zip-back/pull/173\n"},{"excerpt":"우테코 미션 2레벨, 3레벨, 4레벨 ec2를 그냥 제공해준다. 클라우드 환경을 구축하는 일이 없다. ec2를 구축하는 일이 없다. vpc도 그냥 시키는 대로... ec2를 사용하는 것은 쓴다고 하기 좀 애매하다. vpc를 실제로 세팅하고, 내부 인스턴스들을 관리를 직접 해보는 것이 중요하다. 네트워크를 학습하는데 도움이 된다. (vpc, subnet m…","fields":{"slug":"/ori-06-08/"},"frontmatter":{"date":"2023년 06월 08일 11:06","title":"오리와 페어 6/8","tags":["matzip","우테코"]},"rawMarkdownBody":"\n## 우테코 미션\n- 2레벨, 3레벨, 4레벨\n\t- ec2를 그냥 제공해준다.\n\t- 클라우드 환경을 구축하는 일이 없다. ec2를 구축하는 일이 없다. vpc도 그냥 시키는 대로...\n\t- ec2를 사용하는 것은 쓴다고 하기 좀 애매하다.\n\t- vpc를 실제로 세팅하고, 내부 인스턴스들을 관리를 직접 해보는 것이 중요하다.\n\t- 네트워크를 학습하는데 도움이 된다. (vpc, subnet mask, bastin, ...)\n\t- 그러니 그냥 제공받는 거 쓰지 말고 vpc 세팅을 한 번 해보자!\n- 물론 데브옵스를 할 건 아니지만 vpc endpoint는 직접 구축해 보는 게 좋다.\n\n- 참고 링크 : https://tech.cloud.nongshim.co.kr/2023/03/16/%ec%86%8c%ea%b0%9c-vpc-endpoint%eb%9e%80/\n## matzip 환경\n- 환경은 총 3개가 될 것이다. (또는 운영+모니터링, 베타 2개)\n\t- 운영이 실제 띄워지는 환경\n\t- 베타가 띄워지는 환경\n\t\t- develop, staging 환경\n\t\t- 우테코에서 미션할 때는 로컬에서 개발하고 테스트 한 후에 운영에 배포한다. 그러나 운영이나 로컬이나 비슷한 환경을 맞춰도 100% 된다는 보장이 없다.\n\t\t- 최대한 운영에 비슷한 환경 -> 베타에 먼저 배포하고 QA를 실행하고 운영에 배포하는 경우가 많다.\n\t- 모니터링 환경: 그라파나 (모니터링 데이터를 UI로 가시화 하는 것) -> 운영으로 합쳐질 수도 있다.\n\t\t- CPU, Memory 수치를 보면서 ec2에 과부하가 오는지 아닌지를 파악하기 위함. \n\t\t- 요청수를 보면서 트래픽이 얼마나 들어오는지를 파악하기 위함.\n\n### 해야 할 것\n- VPC 세팅 `CIDER: 10.0.0.0/16` (관습적으로 이렇게 쓴다는데 이유도 알아보자 -> reserved ip 피해서?)\n- public subnet, private subnet을 구성해야 한다. subnet은 2개로 구성해야 한다. (public도 가용영역마다 2개씩 - 2a, 2c에 하나씩 이런 식으로)\n\t- 운영 환경에 대한 라우팅 테이블(rt) 을 구축한다(지정한다).\n\t\t- 하나의 vpc 환경이 있을 때 subnet mask를 운영 환경으로 잡고 여기에 대한 라우팅 테이블을 설정한다.\n\t- (후순위) 베타 환경에 대한 라우팅 테이블(rt) 을 구축한다(지정한다).\n- ec2, s3, rds의 주소는 모두 private으로 한다.\n\t- db를 private으로 막는 이유는 직접 접근을 못하게 하기 위함.\n\t- application도 직접 접근을 막아야 한다.\n\t- 외부의 요청을 받아야 한다. -> Internet Gateway (IGW)를 사용할 것\n\t- IGW(public) -> Routing table(public) -> ec2(private)\n- 운영과 베타의 vpc를 다르게 둘 것인가에 대한 고민\n\t- 베타는 막쓰는 서버이고, 운영은 중요한 정보가 있기 때문에 베타에서 운영을 접근할 수 있게 해서는 안 된다.\n\t- 같이 두면 편하다. -> 모니터링 환경이 있는데, peering을 해야 한다.\n\t- 모니터링 환경도 vpc를 다르게 둔다고 했을 때, 모니터링(vpc3)이 운영(vpc1)과 베타(vpc2)에 접근하려면 vpc peering을 해야 한다.\n\t- 귀찮을 수도 있으니, 이점을 고려하여 다르게 둘지 같게 둘지를 판단해서 작업하자.\n\t- 물론 우테코는 하나의 vpc 안에서 작업한다.\n- subnet의 고민? subnet을 분리할 지에 대한 고민?\n=> 일단은 운영 vpc만 세팅을 하고 -> 다 하고 시간이 남으면 베타를 vpc 세팅을 똑같이 해보자. (해본 사람과 안 해본 사람이랑 페어하면서 서로 도우면서~)\n\n### 리전\n나라에 세워져 있는 AWS 큰 그림?\n서울 리전을 사용할 것.\n\n### 가용 영역\n리전 안에 여러 개가 존재한다. 서울은 4개\n데이터 센터라고 보면 된다. 실제로 데이터가 저장되는 곳은 실물로 있어야 한다.\n기본 서브넷에 가용 영역이 주어져 있다.\n\naws 데이터 센터가 아마 a-b, c-d가 같은 데이터 센터에 있을 거라서 a, c 이런 식으로 만드는 게 국룰이라고 한다. (추가로 알아보자)\n\n### vpc 워크플로\n\n- 오리가 줌에서 보여주신 사진\n\n![[vpc-workflow.png]]\n\n### 요약\n- vpc 세팅\n\t- 가용 영역은 2개를 사용한다. (a, c)\n\t- a, c가 서로 다른 데이터 센터에 위치할 듯 (검색해보기)\n- subnet 세팅 (가용 영역 - a: public1 + private1 + private 2 / 가용 영역 - b: public1 + private1 + private 2)\n\t- private 서브넷 개수?\n- rt 세팅\n- IGW 세팅\n- NAT 세팅 (일단 NAT가 뭔지부터 알아보자)\n\t- aws 에서 제공해주는 것 말고 NAT 인스턴스를 하나를 만드는 것 고려. vpc에서 인스턴스 하나 만들어서 해보기.\n\t- 너무 빡세면 ㅌㅌ\n\t- private을 다 막을 건데 private 인스턴스들이 java를 다운 받아야 하는데 막혀있어서 다운을 못한다. 그래서 NAT가 필요하다.\n- ec2 세팅 (안 해도 된다)\n\n++ '초보자를 위한 AWS 웹구축' 참고해 보기~\n\n**다음 공유 시간: 13일까지. 운영 vpc 세팅 완료 목표 !!**"},{"excerpt":"답할 수 있어야 하는 것들 운영체제에서 제공하는 서비스 시스템 콜을 사용하는 방법 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략 비교 / 대조 운영체제 부팅 프로세스 운영체제 성능 모니터링 도구 운영체제 서비스 사용자에게 도움을 주는 사용자 인터페이스 UI GUI 터치 스크린 인터페이스 CLI (명령어 라인 인터페이스) 프로그램 수행 : 시…","fields":{"slug":"/os-ch2/"},"frontmatter":{"date":"2023년 06월 08일 08:06","title":"운영체제 2장-운영체제 구조","tags":["운영체제","공룡책"]},"rawMarkdownBody":"\n## 답할 수 있어야 하는 것들\n\n- 운영체제에서 제공하는 서비스\n- 시스템 콜을 사용하는 방법\n- 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략 비교 / 대조\n- 운영체제 부팅 프로세스\n- 운영체제 성능 모니터링 도구\n\n## 운영체제 서비스\n\n### 사용자에게 도움을 주는\n\n- 사용자 인터페이스\n\t- UI\n\t\t- GUI\n\t\t- 터치 스크린 인터페이스\n\t- CLI (명령어 라인 인터페이스)\n- 프로그램 수행 : 시스템은 프로그램을 메모리에 적재해 실행하 ㄹ수 있고, 끝낼 수 있어야 한다.\n- 입출력 연산 : 수행되는 프로그램은 입출력을 요구할 수 있다. 입출력 수행의 수단을 제공해야 한다.\n- 파일 시스템 조작 : 개인의 선택 / 특정 특성 / 성능을 제공하기 위해 다양한 파일 시스템을 제공해야 한다.\n- 통신 : 한 프로세스가 다른 프로세스와 정보를 교환해야 할 필요가 있다. 통신은 공유 메모리 / 메시지 전달 기법을 사용하여 구현될 수 있다.\n- 오류 탐지 : 모든 가능한 오류를 항상 의식하고 있어야 한다. 올바르고 일관성 있는 계산을 보장하기 위해 각 유형의 오류에 대해 적당한 조처를 해야 한다.\n\n### 시스템 자체의 효율적인 동작을 보장하기 위한\n\n- 자원 할당 : 다수의 프로세스나 다수의 작업이 동시에 실행 될 때, 각각에 자원을 할당해 주어야 한다.\n- 기록 작성 (logging) : 어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지를 추적할 수 있다.\n- 보호 (protection) 와 보안 (security) : 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 한다. 보안은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록한다.\n\n## 사용자와 운영체제 인터페이스\n\n**사용자가 운영체제와 접촉하는 방식**\n\n- 명령 인터프리터를 통해 운영체제와 접촉하는 것\n- 그래픽 기반 사용자 인터페이스를 통해 운영체제와 접촉하는 것\n\n### 명령 인터프리터\n\n가장 중요한 기능은 사용자가 지정한 명령을 가져와서 수행하는 것이다.   \n\n명령어들이 구현되는 방식은 두 가지 일반적인 방법이 있다.\n\n1. 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우 : 제공될 수 있는 명령의 수가 명령 인터프리터의 크기를 결정한다.\n2. 시스템 프로그램에 의해 대부분의 명령을 구현하는 경우 : 명령 인터프리터는 전혀 명령을 알지 못하고, 단지 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용한다.\n\t- 프로그래머가 적합한 프로그램 로직을 가진 새로운 파일을 생성하여 새로운 명령을 쉽게 추가할 수 있다.\n\t- 명령 인터프리터 프로그램이 아주 작아질 수 있고, 명령을 추가하기 위해 변경될 필요가 없다.\n\n### 그래픽 기반 사용자 인터페이스\n\n사용자가 직접 명령어를 입력하는 것이 아닌, 데스크톱이라고 특정지어지는 마우스를 기반으로 한 윈도 메뉴 시스템을 사용한다.\n\n### 터치스크린 인터페이스\n\n터치스크린에서 손가락을 누르거나 스와이프 하는 등의 제스처로 상호 작용한다.\n\n## 시스템 콜\n\n운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.   \n이러한 호출은 일반적으로 C와 C++ 언어로 작성된 함수 형태로 제공된다.\n\n### 응용 프로그래밍 인터페이스\n\n대부분의 응용 개발자들은 응용 프로그래밍 인터페이스 (API) 에 따라 프로그램을 설계한다.\n\nAPI는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.\n\n#### 응용 프로그래머가 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍하는 것은 선호하는 이유\n\n먼저 프로그램 호환성과 관련이 있다.    \nAPI 를 사용하는 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일 되고 실행된다는 것을 기대할 수 있다.     \n\n또한 실제 시스템 콜은 좀 더 자세한 명세가 필요하고 프로그램 상에서 작업하기가 API보다 더 어렵다.\n\n그럼에도 API를 호출하는 것과 시스템 콜을 호출하는 것은 강한 상관 관계가 존재한다.    \n대부분의 POSIX, Windows API 는 운영체제가 제공하는 고유의 시스템 콜과 유사하다.\n\n#### 실행 시간 환경 (RunTimeEnvironment, RTE)\n\n컴파일러 또는 인터프리터를 포함한 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트 웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어이다.    \n\n운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 `시스템 콜 인터페이스` 를 제공한다.    \nAPI 함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다.    \n\n호출자는 시스템 콜의 구현과 실행 중 어떤 작업을 하는지 알 필요가 없다.    \n단지 API를 준수하고 결과로 운영체제가 어떤 행동을 할 것인지만 이해하면 된다.     \n\n---\n\n시스템 콜은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다.    \n필요한 정보의 유형과 양은 특정 운영체제와 호출에 따라 다양하다.     \n\n#### 운영체제에 매개변수를 전달하기 위한 방법\n\n1. 매개변수를 레지스터 내에 전달하는 것\n\t- 레지스터보다 더 많은 매개변수가 존재할 수도 있다 -> 매개변수를 테이블, 블록에 저장하기\n2. 매개변수가 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달되는 것\n\t- 리눅스에서는 5개 이하의 매개변수가 있으면 레지스터가 사용되고, 매개변수 개수가 5개를 넘으면 블록 방법을 사용한다.\n\t- 매개변수는 프로그램에 의해 스택에 넣어질 수 있고, 운영체제에 의해 꺼내진다.\n\n### 시스템 콜의 유형\n\n- 프로세스 제어\n- 파일 조작\n- 장치 조작\n- 정보 유지 보수\n- 통신 / 보호\n\n#### 프로세스 제어\n\n실행 중인 프로그램은 수행을 정상적으로 `end()` / 비정상적으로 `abort()` 멈출 수 있어야 한다.    \n정상이거나 비정상인 상황에서, 운영체제는 명령 인터프리터로 제어를 전달해야 한다.    \n\n---\n\n한 프로그램을 실행하고 있는 프로세스가 다른 프로그램을 적재 `load()` 하고 실행 `execute()` 하기를 원할 수도 있다.     \n해당 기능은 명령 인터프리터가 사용자 명령 또는 마우스 클릭을 통해 지시된 프로그램을 실행하는 것을 허용한다.\n\n그렇다면 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 줄까?     \n기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련이 있다.     \n\n새로운 프로그램이 종료될 때 제어가 기존 프로그램으로 돌아간다면, 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다.    \n즉, 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이다. 이를 위한 시스템 콜이 존재한다. (`create_process()`)\n\n새로운 잡(job)이나 프로세스, 혹은 잡들이나 프로세스들의 집합을 생성한다면, 실행을 제어할 수 있어야 한다.    \n잡의 우선순위, 최대 허용 실행 시간 등을 포함하여 잡 혹은 프로세스의 속성들을 결정하고 재설정 (reset) 할 수 있는 능력이 필요하다. (`get_process_attributes()`, `set_process_attributes()`)\n또한 새로 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다. (`terminate_process()`)\n\n새로운 프로세스를 생성한 후에는, 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다.\n- `wait_time()` : 일정 시간만큼 기다리기 \n- `wait_event()` : 특정 이벤트가 일어날 때까지 기다리기\n\t- `signal_event()` : 프로세스들은 이벤트가 일어나면 신호를 보내야 한다.\n\n---\n둘 이상의 프로세스들은 빈번하게 데이터를 공유하기 때문에, 공유 데이터를 잠글 수 있는 시스템 콜을 제공한다.   \n그러면 잠금이 해제될 때까지 어느 프로세스도 데이터에 접근할 수 없게 된다.    \n`acquire_lock()`, `release_lock()` 시스템 콜을 제공한다.\n\n---\n**단일 태스킹 시스템 - Arduino**\n\n표준 Arduino 플랫폼은 운영체제를 제공하지 않고, 부트 로더라 불리는 작은 소프트웨어가 프로그램을 Arduino의 특정 영역으로 적재한다.    \n한순간에 하나의 프로그램만 메모리에 존재할 수 있으므로, 단일 태스킹 시스템으로 간주된다. 즉, 다른 프로그램이 적재되면 기존 프로그램을 대체하게 된다.    \n\n**다중 태스킹 시스템 -FreeBSD**\n\n사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램으 수행한다.\n\n새로운 프로세스를 시작하기 위해 셸은 `fork()` 시스템 콜을 실행한다.    \n선택된 프로그램이 `exec()` 시스템 콜을 통해 메모리에 적재되고, 프로그램이 수행된다.     \n\n셸은 프로세스가 종료하기를 기다리거나 '백그라운드' 에서 프로세스를 수행한다.    \n백그라운드에서 프로세스를 수행하는 경우, 셸은 바로 다음 명령이 입력되기를 기다린다.    \n백그라운드에서 프로세스가 수행될 때, 프로세스는 셸이 사용하고 있는 자원인 키보드로부터 직접 입력을 받을 수 없다.     \n그러나 사용자는 셸에게 입력을 제외한 다른 요청은 자유롭게 할 수 있다.    \n\n프로세스가 종료되면 `exit()` 시스템 콜을 수행하며, 0이나 오류 코드를 돌려준다.     \n\n#### 파일 관리\n\n파일을 생성 `create()` 하고 삭제 `delete()` 할 수 있어야 한다. 파일의 이름이나 파일 속성의 일부가 필요하다.    \n파일이 생성되면 그것을 열고 `open()` 사용해야 한다.    \n또한 읽고 `read()` , 쓰고 `write()`, 위치 변경 `reposition()` (되감기 `rewind()` 나 파일 끝으로 건너뛰기) 할 수 있다.    \n마지막으로 파일을 더 이상 사용하지 않음을 나타내는 파일 닫기 `close()` 가 필요하다. \n\n파일이나 디렉터리에 대해 여러 속성의 값을 결정할 수 있어야 하고, 재설정 `reset()` 할 수 있어야 한다.    \n파일 속성은 파일 이름, 파일 유형, 보호 코드, 회계 정보 등을 포함한다.    \n이를 위해서는 최소한 파일 속성 획득 `get_file_attribute()` 과 파일 속성 설정 `set_file_attribute()` 의 두 시스템 콜이 필요하다.    \n몇몇 운영체제는 파일 이동 `move()` 와 복사 `copy()` 같은 더 많은 시스템 콜을 제공한다.    \n\n#### 장치 관리 \n\n프로세스는 작업을 계속 수행하기 위해 추가 자원(주 기억장치, 디스크 드라이브, 파일에의 접근)이 필요할 수 있다.    \n자원들을 사용할 수 있다면, 자원이 주어지고 제어가 사용자 프로그램으로 복귀될 수 있다.    \n그렇지 않으면, 프로그램은 충분한 자원이 사용 가능하게 될 때까지 기다려야 한다.    \n\n다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 장치를 요청 `request()` 하는 것을 요구한다.    \n장치의 사용이 끝나면 반드시 방출 `release()` 해야 한다.     \n이런 기능은 파일의 열기, 닫기 시스템 콜과 비슷하다.     \n\n다른 운영체제들은 장치에 대해 통제되지 않은 접근을 허용하기도 한다.    \n\n일단 장치를 요청하고 할당받게 되면, 파일과 마찬가지로 `read()` , `write()` , `reposition()` 할 수 있다.    \n입출력 장치와 파일 간에는 유사성이 매우 많기 때문에, 많은 운영체제가 이 둘을 통합된 파일 - 장치 구조로 결합하였다. \n\n#### 정보 유지 관리\n\n많은 시스템이 메모리를 `dump()` 하기 위한 시스템 콜을 제공한다. 이는 디버깅에 유용하다. \n\n많은 운영체제는 프로그램의 time profㅌ을 제공한다.    \ntime profile은 프로그램이 특정 위치, 혹은 위치의 집합에서 수행한 시간의 양을 나타낸다.    \n\n운영체제는 현재 운영되고 있는 모든 프로세스에 관한 정보를 가지고 있으며, 이런 정보에 접근하기 위한 시스템 콜도 있다.    \n일반적으로, 그 프로세스 정보를 획득하고 설정하기 위한 `get_process_attributes()` 와 `set_process_attributes()` 가 있다.    \n\n#### 통신\n\n통신 모델에는 메시지 전달과 공유 메모리의 두 가지 일반적인 모델이 있다.    \n\n- 메시지 전달 모델\n통신하는 두 프로세스가 정보를 교환하기 위해 서로 메시지를 주고 받는다.    \n메시지는 두 프로세스 사이에 직접 교환되거나 우편함을 통해 간접적으로 교환될 수 있다.     \n통신이 이루어지기 전에 연결이 반드시 열려야 한다.    \n\n상대 통신자가 동일한 CPU에 있는 프로세스이든지 통신 네트워크에 의해 연결된 다른 컴퓨터에 있는 프로세스이든지 간에 그 이름을 반드시 알고 있어야 한다.    \n\n네트워크의 각 컴퓨터는 호스트 이름을 가지며, 각 컴퓨터는 이들 이름으로 일반적으로 알려져 있다.    \n각 프로세스는 프로세스 이름을 가지고 있으며, 이 이름은 운영체제에 의해 동등한 식별자로 변환되고, 식별자는 운영체제가 그 프로세스를 가리키는 데 사용할 수 있다.    \n\n호스트 이름과 프로세스 이름은 각각 `get_hostid()` 와 `get_processid()` 시스템 콜이 변환을 수행한다.    \n이 식별자는 시스템의 통신 모델에 따라 파일 시스템의 open, close 호출에 전달되거나, 특정 `open_connection()` 과 `close_connection()` 시스템 콜에 전달된다.    \n\n수신 프로세스는 통상 통신이 일어날 수 있도록 `accept_connection()` 호출에 permission을 제공한다.     \n연결을 받아들일 프로세스들의 대부분은 특수 목적의 daemon 이다.     \n`wait_for_connection()` 호출을 수행하고, 연결이 이루어질 때 깨어난다.     \n클라이언트로 알려진 통신의 출발지와 서버로 알려진 수신 daemon은 `read_message()` 와 `write_message()` 시스템 콜에 의해 메시지들을 교환한다.    \n\n`close_connection()` 호출은 통신을 종료한다.    \n\n- 공유 메모리 모델\n프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared_memory_create()` 와 `shared_memory_attach()` 시스템 콜을 사용한다.    \n이때 프로세스는 동일한 위치에 동시에 쓰지 않도록 보장할 책임을 진다.    \n\n또한 프로세스 모델의 변형으로 디폴트로 메모리를 공유하는 스레드도 있다.    \n\n---\n두 방법은 운영체제에서 보편적이며, 시스템 대부분은 둘 다 구현한다.    \n\n메시지 전달은 피해야 할 충돌이 없기 때문에 소량의 데이터 교환 시에 유용하다. 또한 컴퓨터 간의 통신을 위해 메모리 공유보다 구현하기 쉽다.    \n\n공유 메모리는 한 컴퓨터 안에서는 메모리 전송 속도로 수행할 수 있으므로, 최대 속도와 편리한 통신을 허용한다.    \n그러나 보호와 동기화 부분에서 여러 문제점을 가지고 있다.   \n\n#### 보호\n\n컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다.     \n- `set_permision()` 과 `get_permission()` : 파일, 디스크와 같은 자원의 허가 권한을 설정하는 데 이용된다. \n- `allow_user()` 와 `deny_user()` : 특정 사용자가 지정된 자원에 대해 접근이 허가 / 불허되었는지를 명시한다.   \n\n## 시스템 서비스\n\n시스템 서비스는 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.    \n몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며, 나머지는 훨씬 더 복잡하다.\n\n다음과 같은 범주로 분류할 수 있다.    \n\n- 파일 관리 : 파일과 디렉터리를 생성 / 삭제 / 복사 / 이름 변경 / 인쇄 / 열거 / 조작 한다. \n- 상태 정보\n- 파일 변경 : 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 text editor를 사용할 수 있다. \n- 프로그래밍 언어 지원\n- 프로그램 적재와 수행 : 프로그램이 어셈블되거나 컴파일된 후, 수행되려면 반드시 메모리에 적재(load) 되어야 한다. absolute loader, relocatable loader, linkage editor, overlay loader 등을 제공할 수 있고, 고급어나 기계어를 위한 디버깅 시스템도 필요하다. \n- 통신 : 프로세스, 사용자, 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공한다.\n- 백그라운드 시스템 : 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 갖는다. 항상 실행되는 시스템 프로그램 프로세서는 서비스, 서브시스템, 또는 daemon으로 알려져 있다. \n\n## 링커와 로더\n\n일반적으로 프로그램은 디스크에 이진 실행 파일로 존재한다. `.out` ,`.exe` 등    \nCPU에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 한다.    \n\n- `재배치 가능 오브젝트 파일` : 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일. 소스파일이 컴파일 되면 재배치 가능 오브젝트 파일이 된다. \n- `링커` : 재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합한다. 다른 오브젝트 파일 또는 라이브러리가 포함될 수 있다. \n- `로더` : 이진 실행 파일을 메모리에 적재한다. 이 과정까지 지나면 CPU 코어에서 실행할 수 있는 상태가 된다. \n- `재배치` : 링크 및 로드와 관련된 활동이다. 프로그램 부분에 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조장하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다. \n\n## 응용 프로그램이 운영체제마다 다른 이유\n\n각 운영체제는 고유한 시스템 콜 집합을 제공한다.    \n시스템 콜은 어느 정도 같더라도 다른 장벽으로 인해 응용 프로그램을 다른 운영체제에서 실행하기 어렵다.    \n\n### 응용 프로그램이 여러 운영체제에서 실행할 수 있게 하는 방법\n\n1. 응용 프로그램은 운영체제마다 인터프리터가 제공되는 인터프리터 언어로 작성될 수 있다. 단, 인터프리터는 기계어 코드로 구성된 프로그램에 비해 성능이 떨어지고, 각 운영체제 기능의 일부만 제공하므로 관련 응용 프로그램의 기능도 제한될 수 있다.  (Python, Ruby)\n2. 응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다. (Java) 인터프리터 시스템과 유사한 단점을 가진다.\n3. 응용 프로그램 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API 를 사용할 수 있다. 이식은 많은 시간이 소요될 수 있고, 많은 시험과 디버깅을 거쳐서 응용 프로그램의 새 버전마다 수행되어야 한다.\n\n일반적으로 응용 프로그램의 이동성이 부족한 데에는 여러 원인이 있기 때문에 여전히 크로스 플랫폼 응용 프로그램을 개발하는 것이 어렵다. \n\n그 추가 원인\n- 각 운영체제는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있다.\n- CPU 는 다양한 명령어 집합을 가지며 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있다.\n- 운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 열기와 같은 다양한 활동을 요청할 수 있는 시스템 콜을 제공한다.\n\n### ABI\n\n아키텍처 수준에서 이진 코드의 여러 구성요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있는 방법을 정의하는 데 ABI (application binary interface) 가 사용된다. \n\n주소 길이, 시스템 콜에 매개변수를 전달하는 방법, 런타임 스택 구성, 시스템 라이브러리의 이진 형식 및 데이터 유형의 크기 등 하위 수준의 세부 정보를 명시한다.\n\n일반적으로 ABI 는 특정 아키텍처에 대해 명시되므로, 아키텍처 수준의 API 라고 할 수 있다.    \n특정 아키텍처에서 실행되는 특정 운영체제에 대해 ABI 가 정의되어 있기 때문에, 플랫폼 간 호환성을 거의 제공하지 않는다.\n\n## 운영체제 설계 및 구현\n\n### 설계 목표\n\n시스템을 설계할 때의 첫 번째 문제점은 시스템의 목표와 명세를 정의하는 일이다.      \n요구 조건들은 근본적으로 '사용자 목적' 과 '시스템 목적' 으로 나눌 수 있다. \n\n### 기법과 정책\n\n한 가지 중요한 원칙은 기법으로부터 정책을 분리하는 것이다.      \n\n기법은 어떤 일을 '어떻게' 할 것인가를 결정하는 것이다.     \n정책은 '무엇을' 할 것인가를 결정하는 것이다.     \n\n정책과 기법의 분리는 융통성을 위해 아주 중요하다.     \n여러 정책에서 사용되기에 충분한 융통성 있는 일반적인 기법이 바람직한 경우가 많다.     \n\n### 구현\n\n운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이므로, 구현 방법에 대해 일반적으로 말하는 것은 어렵다.     \n대부분의 운영체제는 C, C++ 같은 고급 언어로 작성되며, 극히 일부의 시스템만이 어셈블리 언어로 작성된다.     \n\n## 운영체제 구조\n\n### 모놀리식 구조\n\n운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것, 즉 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것이다.     \n\n최초의 UNIX 운영체제는 커널과 시스템 프로그램 두 부분으로 구성된다.    \n커널은 여러 인터페이스와 장치 드라이버로 다시 분리된다.     \n커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리, 다른 운영체제 기능을 제공한다.\n\n모놀리식 커널은 단순하지만, 구현과 확장이 어렵다.   \n그러나 성능 면에서는 뚜렷한 이점이 있다. 시스템 콜 인터페이스는 오버헤드가 거의 없고, 커널 안에서의 통신 속도가 빠르다.     \n\n### 계층적 접근\n\n모놀리식 접근법은 시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 줄 수 있으므로, 밀접하게 결합된 시스템이라고 불린다.     \n\n그 대안으로 느슨하게 결합된 시스템이 등장했다.     \n기능이 특정 기능 및 한정된 기능을 가진 개별적이고 작은 구성요소로 나뉜다.    \n한 구성요소의 변경이 해당 구성요소에만 영향을 미치고 다른 구성 요소에는 영향을 미치지 않아 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있다.     \n\n시스템은 다양한 방식으로 '모듈화' 될 수 있다.    \n그 중 계층적 접근 방식에서는 운영체제가 여러 layer로 나누어진다.     \n\n계층적 접근 방식의 장점은 구현과 디버깅이 간단하다는 것이다.     \nlayer 들은 자신의 하위층들의 서비스와 기능만을 사용하도록 요구된다.     \n\n계층화된 시스템은 컴퓨터 네트워크 (TCP / IP) 및 웹 응용 프로그램에서 성공적으로 사용됐다.     \n그럼에도 순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적다.     \n\n각 계층의 기능을 적절히 정의해야 하는 문제, 여러 계층을 통과하는 오버헤드로 인한 전반적인 성능 문제가 원인이다.     \n\n### 마이크로 커널\n\n마이크로 커널 접근 방식은 모든 중요치 않은 구성 요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다.     \n통상적으로 마이크로커널은 통신 설비 외에 추가적으로 최소한의 프로세스와 메모리 관리를 제공한다.     \n\n마이크로커널의 주 기능은 클라이언트 프로그램과 역시 사용자 공간에서 수행되는 다양한 서비스 간의 통신을 제공하는 것이다.    \n클라이언트 프로그램과 서비스는 결코 직접 상호작용하지 않고, 마이크로커널과 메시지를 교환함으로써 간접적으로 상호작용한다.    \n\n장점은 운영체제의 확장이 쉽다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되므로, 커널을 변경할 필요가 없다.     \n마이크로커널은 서비스 대부분이 커널이 아닌 사용자 프로세스로 수행되기 때문에 높은 보안성과 신뢰성을 제공한다. 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다.\n\nEx. macOS 및 iOS 운영체제의 커널 구성요소인 `Darwin`, `QNX`\n\n그러나 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다. 두 개의 사용자 수준 서비스가 통신해야 하는 경우, 별도의 주소 공간에 서비스가 존재하기 때문에 메시지가 복사되어야 한다.     \n또한 메시지를 교환하기 위해 한 프로세스에서 다른 프로세스로 전환되어야 할 수도 있다.     \n\n### 모듈\n\n적재가능 커널 모듈 (loadable kernel mkodules, LKM) 기법이 최근 기술 중 최선책이다.\n커널은 핵심적인 구성요소의 집합을 가지고 있고, 부팅 때 혹은 실행 중에 부가적인 서비스들을 모듈을 통해 링크할 수 있다. 이런 유형의 설계가 현대 UNIX를 구현하는 일반적인 추세이다.\n\n설계의 주안점은 커널은 핵심 서비스를 제공하고, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다.  \n새로운 기능을 직접 커널에 추가하는 방식은 수정 사항이 생길 때마다 커널을 다시 컴파일 해야 한다는 단점이 있다.\n\n커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서는 계층 구조를 닮았지만, 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하다. \n중심 모듈은 단지 핵심 기능만 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과 유사하나, 통신을 위해 메시지 전달을 호출할 필요가 없기 때문에 더 효율적이다. \n\n### 하이브리드 시스템\n\n엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않는다. 보통 다양한 구조를 결합하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성된다.\n\n"},{"excerpt":"","fields":{"slug":"/operating-system-concepts/"},"frontmatter":{"date":"2023년 06월 08일 07:06","title":"운영체제","tags":["CS","운영체제","공룡책"]},"rawMarkdownBody":"\n"},{"excerpt":"LOG 레벨 인터뷰가 있었다. 이번에도 제이슨조~ 같은 조는 그레이, 제리, 제나, 로건, 코코닥, 제이미, 주디, 무민이었다. 이번에는 좀 더 범위가 넓은 질문이 나올 것 같아서 어려워했던 Filter, Interceptor, transactional, bean에 대해 중점적으로 공부했는데 정작 나온 질문은 레이어드 아키텍처였어서 ㅋㅋㅋ 조금 아쉽긴 했…","fields":{"slug":"/2023-06-07/"},"frontmatter":{"date":"2023년 06월 07일 13:06","title":"2023년 06월 07일","tags":null},"rawMarkdownBody":"## LOG\n\n- 레벨 인터뷰가 있었다. 이번에도 제이슨조~ 같은 조는 그레이, 제리, 제나, 로건, 코코닥, 제이미, 주디, 무민이었다. 이번에는 좀 더 범위가 넓은 질문이 나올 것 같아서 어려워했던 Filter, Interceptor, transactional, bean에 대해 중점적으로 공부했는데 정작 나온 질문은 레이어드 아키텍처였어서 ㅋㅋㅋ 조금 아쉽긴 했지만 재밌었다. 레벨 인터뷰하면서 나도 생각 정리가 어느 정도 된 것 같아 좋았다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"ApplicationContext 언제 실행되나? 장바구니 미션의  을 실행해보자.   의  이 실행된다. 계속 타고 들어가면  의  메서드가 실행된다. 곧 지울 내용 BootStrapContext 생성  내부로 들어가보자. 는 를 생성하기 전에 를 생성하는 메서드이다.  란 애플리케이션 컨텍스트가 준비될 때까지 환경 변수를 관리하는 Spring의 Env…","fields":{"slug":"/application-context/"},"frontmatter":{"date":"2023년 06월 06일 07:06","title":"ApplicationContext 찍먹하기","tags":["spring","개발","스터디","학습로그"]},"rawMarkdownBody":"\n## ApplicationContext\n\n### 언제 실행되나?\n\n```java\n@SpringBootApplication  \npublic class JwpCartApplication {  \n    public static void main(String[] args) {  \n        SpringApplication.run(JwpCartApplication.class, args);  \n    }   \n}\n```\n\n장바구니 미션의 `SpringApplication.run` 을 실행해보자.\n\n![[spring-application-context-run.png]]\n\n`SpringApplication` 의 `run` 이 실행된다.\n\n계속 타고 들어가면 `SpringApplication` 의 `run` 메서드가 실행된다.\n\n```java\npublic ConfigurableApplicationContext run(String... args) {  \n\n   long startTime = System.nanoTime();\n\n// BootStrapContext 생성\n   DefaultBootstrapContext bootstrapContext = createBootstrapContext();  \n   ConfigurableApplicationContext context = null;  \n\n// Java AWT Headless Property 설정\n   configureHeadlessProperty();  \n\n// 스프링 애플리케이션 리스너 조회 및 starting 처리\n   SpringApplicationRunListeners listeners = getRunListeners(args);  \n   listeners.starting(bootstrapContext, this.mainApplicationClass);  \n   \n   try {  \n\n\t// Arguments 래핑 및 Environment 준비\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);  \n      ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);  \n\n\t// IgnoreBeanInfo 설정\n      configureIgnoreBeanInfo(environment);  \n\n\t// 배너 출력\n      Banner printedBanner = printBanner(environment);  \n\n\t// 애플리케이션 컨텍스트 생성\n      context = createApplicationContext();  \n      context.setApplicationStartup(this.applicationStartup);  \n\n\t// Context 준비 단계\n      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);  \n\n\t// Context Refresh 단계\n      refreshContext(context);  \n\n\t// Context Refresh 후처리 단계\n      afterRefresh(context, applicationArguments);  \n\n\t// 실행 시간 출력 및 리스너 started 처리\n      Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);  \n      if (this.logStartupInfo) {  \n         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);  \n      }  \n      listeners.started(context, timeTakenToStartup);  \n\n\t// Runners 실행\n      callRunners(context, applicationArguments);  \n   }  \n   catch (Throwable ex) {  \n      handleRunFailure(context, ex, listeners);  \n      throw new IllegalStateException(ex);  \n   }  \n   ...\n   return context;  \n}\n```\n\n## 곧 지울 내용\n---\n\n### BootStrapContext 생성\n\n`createBootstrapContext()` 내부로 들어가보자.\n\n`createBootstrapContext()`는 `ApplicationContext`를 생성하기 전에 `BootstrapContext`를 생성하는 메서드이다. `BootstrapContext` 란 애플리케이션 컨텍스트가 준비될 때까지 환경 변수를 관리하는 Spring의 Environment 객체를 후처리하기 위한 임시 컨텍스트이다. \n\nSpring Boot는 다양한 환경에서 애플리케이션을 실행할 수 있으므로, `createBootstrapContext()` 는 애플리케이션을 실행할 환경과 관련된 `BootstrapContext`를 생성한다. \n\n```java\nprivate DefaultBootstrapContext createBootstrapContext() {  \n   DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();  \n   this.bootstrapRegistryInitializers.forEach((initializer) -> initializer.initialize(bootstrapContext));  \n   return bootstrapContext;  \n}\n```\n\n`initializers` 리스트를 초기화하고, 해당 리스트의 요소들에 대해 `initialize()` 메서드를 호출하여 `BootstrapContext`를 초기화한다.\n\n### Java AWT Headless Property 설정\n\nJava AWT Headless Property란 디스플레이 장치가 없는 서버 환경에서 UI 클래스를 사용할 수 있도록 하는 옵션이다.\n`java.awt.headless` 를 true로 설정하거나, 서버 시작 스크립트의 `JAVA_OPTS` 환경 변수에 `-D java.awt.headless=true` 를 설정하는 방법 등이 있다.\n\n```java\nprivate void configureHeadlessProperty() {  \n   System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,  \n         System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));  \n}\n```\n\n이 부분은 (잘 모르겠으니) 자세히 다루지 않고 넘어가겠다.\n\n---\n\n### 애플리케이션 컨텍스트 생성\n\n`createApplicationContext` 는 내부적으로 `ApplicationContextInitializer` 객체들의 `initialize()` 메서드를 호출하여 `ApplicationContext` 의 초기화 작업을 수행한다. \n\n```java\nprotected ConfigurableApplicationContext createApplicationContext() {  \n   return this.applicationContextFactory.create(this.webApplicationType);  \n}\n```\n\n코드를 보면 `ApplicationContextFactory` 팩토리 클래스에게 생성을 위임하는 것을 볼 수 있다.\n애플리케이션 컨텍스트 생성 시에는 `webApplicationType` 이 사용된다.\n\n우리의 애플리케이션은 SERVLET 기반으로 실행되기 때문에, 환경 또한 `ApplicationServletEnvironment` 로 설정되어 있다.\n\n내부는 다음과 같다.\n\n![[spring-application-context-getFactories.png]]\n\n디버깅을 해보면 `create()`로 부터 생성되는 `ConfigurableApplicationContext`는 `AnnotationConfigServletWebServerApplicationContext`인 것을 확인할 수 있다.\n\nSpring이 제공하는 ApplicationContext 구현 클래스에는 여러 가지 종류가 있다.\nSpring Application은 사용자 대신 `ApplicationContext` 의 적절한 타입을 생성하게 된다.\n\n`WebApplicationType` 은 다음과 같이 정해진다.\n\n- Spring MVC가 존재 -> `AnnotaionConfigServletWebServerApplicationContext` 사용\n- Spring MVC가 존재하지 않고, Spring WebFlux가 존재하면 `AnnotationConfigReactiveWebServerApplicationContext` 사용\n- 그 외에는 `AnnotationConfigApplicationContext` 사용\n\n### 잠깐, AnnotationConfigServletWebServerApplicationContext는 뭘까\n\n> ServletWebServerApplicationContext that accepts annotated classes as input - in particular @Configuration -annotated classes, but also plain @Component classes and JSR-330 compliant classes using javax.inject annotations. Allows for registering classes one by one (specifying class names as config location) as well as for classpath scanning (specifying base packages as config location). \n> \n> Note: In case of multiple @Configuration classes, later @Bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions through an extra Configuration class.\n\n`AnnotationConfigServletWebServerApplicationContext` 는 우리가 Spring 애플리케이션을 사용할 때 실행되는 웹 `ApplicationContext` 중의 하나이다. \nJava Config를 사용하여 웹 애플리케이션을 설정하기 위해 사용된다.\n\n입력으로 `@Configuration` 어노테이션, `@Component` 어노테이션, javax.inject 어노테이션을 사용하는 JSR-330 compilant 클래스들을 받는다. 클래스 이름을 설정 위치로 특정하여 클래스들을 등록하고, base 패키지들을 설정 위치로 특정하여 classpath scanning을 한다.\n\n`@Configuration` 클래스들이 여러 개 있는 경우, 이후의 `@Bean` 정의들은 더 먼저 로드된 파일에서 정의된 bean을 오버라이딩 한다. 이는 특정 bean 정의를 추가 configuration 클래스를 통해 일부러 오버라이딩하기 위해 사용될 수 있다.\n\n`GenericWebApplicationContext` 의 서브 클래스이며, 서브 클래스 자체는 `GenericApplicationContext` 의 서브 클래스이다. \n웹 애플리케이션 중에서도 특히 서블릿 컨테이너 내부에서 실행되는 애플리케이션에 사용할 수 있는 Spring ApplicationContext를 생성하는데 사용된다.\n\n### Context 준비 단계\n\nContext가 생성된 후에 해주어야 하는 후처리 작업들과 bean을 등록하는 refresh 단계를 위한 전처리 작업을 수행한다.\n\n```java\nprivate void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,  \n      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,  \n      ApplicationArguments applicationArguments, Banner printedBanner) {  \n\t\n   // Environment를 애플리케이션 컨텍스트에 설정한다. \n   context.setEnvironment(environment);  \n   postProcessApplicationContext(context);  \n\n   // Initializer initialize 해주기\n   applyInitializers(context);  \n   listeners.contextPrepared(context);  \n   \n   // BootstrapContext 종료\n   bootstrapContext.close(context);  \n   if (this.logStartupInfo) {  \n      logStartupInfo(context.getParent() == null);  \n      logStartupProfileInfo(context);  \n   }  \n   \n   // Add boot specific singleton beans  \n   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();  \n   beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);  \n   if (printedBanner != null) {  \n      beanFactory.registerSingleton(\"springBootBanner\", printedBanner);  \n   }  \n   if (beanFactory instanceof AbstractAutowireCapableBeanFactory) {  \n      ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(this.allowCircularReferences);  \n      if (beanFactory instanceof DefaultListableBeanFactory) {  \n         ((DefaultListableBeanFactory) beanFactory)  \n            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);  \n      }  \n   }   if (this.lazyInitialization) {  \n      context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());  \n   }  \n   context.addBeanFactoryPostProcessor(new PropertySourceOrderingBeanFactoryPostProcessor(context));  \n   \n   // Load the sources  \n   Set<Object> sources = getAllSources();  \n   Assert.notEmpty(sources, \"Sources must not be empty\");  \n   load(context, sources.toArray(new Object[0]));  \n   listeners.contextLoaded(context);  \n}\n```\n\n`applyInitializer` 에서는 SpringApplication에 등록된 `ApplicationContextInitializer` 를 가져온다. 가져온 `ApplicationContextInitializer` 리스트를 반복하여 각각의 `ApplicationContextInitializer` 의 `initialize()` 를 호출한다.\n\n사용자가 추가한 설정을 적용하여, `ApplicationContext` 가 정상적으로 구동될 수 있도록 한다.\n\n![[initializer.png]]\n\n애플리케이션 컨텍스트가 생성되고, initializer들의 initialize까지 진행되면 `BootstrapContext`가 불필요하므로 `BootstrapContext` 를 종료해준다.\n\n- `DefaultSingletonoBeanRegistry` 의  `registerSingleton()`\n\n```java\n@Override  \npublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {  \n   Assert.notNull(beanName, \"Bean name must not be null\");  \n   Assert.notNull(singletonObject, \"Singleton object must not be null\");  \n   synchronized (this.singletonObjects) {  \n      Object oldObject = this.singletonObjects.get(beanName);  \n      if (oldObject != null) {  \n         throw new IllegalStateException(\"Could not register object [\" + singletonObject +  \n               \"] under bean name '\" + beanName + \"': there is already object [\" + oldObject + \"] bound\");  \n      }  \n      addSingleton(beanName, singletonObject);  \n   }  \n}\n```\n\nbean의 이름과 인스턴스를 인자로 받아 bean의 이름으로 싱글톤 레지스트리에 bean의 인스턴스를 등록한다. \n\n동일한 이름의 bean이 이미 등록되어 있으면, 덮어쓰지 않고 예외를 발생시켜 bean의 중복 등록을 방지한다. \n(`SpringApplicationBuilder` 나 `properties` 를 통해 해당 옵션을 변경할 수는 있지만 가급적 기본값을 사용하는 것이 좋다. 중복된 bean이 등록되는 경우 IoC 컨테이너에서 어떤 bean을 사용해야 할 지 결정할 수 없어 예기치 못한 동작을 일으킬 수 있다.)\n\n### Context Refresh 단계\n\n싱글톤 빈으로 등록할 클래스들을 찾아서 생성하고, 후처리하는 단계이다.\n`refresh` 를 거치면 모든 객체들이 싱글톤으로 인스턴스화 되는데, 에러가 발생하면 모든 bean을 제거한다.\n\n즉, `refresh()` 를 거쳤을 때 싱글톤으로 모두 인스턴스화 되던지, 아예 인스턴스화 되지 않아야 한다.\n\n- `AbstractApplicationContext`: `refresh()` \n\n```java\n@Override  \npublic void refresh() throws BeansException, IllegalStateException {  \n   synchronized (this.startupShutdownMonitor) {  \n      StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\");  \n  \n      // Prepare this context for refreshing.  \n      // Refresh를 위해 context 준비하기 \n      prepareRefresh();  \n  \n      // Tell the subclass to refresh the internal bean factory.  \n      // 내부 Bean Factory 준비하기\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  \n  \n      // Prepare the bean factory for use in this context.  \n      // 해당 context에서 사용하기 위한 Bean Factory 준비하기\n      prepareBeanFactory(beanFactory);  \n  \n      try {  \n         // Allows post-processing of the bean factory in context subclasses.  \n         // Bean Factory의 후처리 진행\n         postProcessBeanFactory(beanFactory);  \n  \n         StartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\");  \n         \n         // Invoke factory processors registered as beans in the context.  \n         // Context에 bean으로 등록되는 Factory processor 실행 (BeanFactoryPostProcessor 실행)\n         invokeBeanFactoryPostProcessors(beanFactory);  \n  \n         // Register bean processors that intercept bean creation.  \n         // Bean 생성을 가로채는 Bean Processor 등록 (BeanPostProcessor 등록)\n         registerBeanPostProcessors(beanFactory);  \n         beanPostProcess.end();  \n  \n         // Initialize message source for this context.  \n         // messageSource 및 Event Multicaster 초기화\n         initMessageSource();  \n  \n         // Initialize event multicaster for this context.  \n         initApplicationEventMulticaster();  \n  \n         // Initialize other special beans in specific context subclasses.  \n         // 웹 서버 생성\n         onRefresh();  \n  \n         // Check for listener beans and register them.  \n         // listener 빈들을 조회 및 등록\n         registerListeners();  \n  \n         // Instantiate all remaining (non-lazy-init) singletons.  \n         // 빈 인스턴스화 및 후처리\n         finishBeanFactoryInitialization(beanFactory);  \n  \n         // Last step: publish corresponding event.  \n         finishRefresh();  \n      }  \n  \n      catch (BeansException ex) {  \n         if (logger.isWarnEnabled()) {  \n            logger.warn(\"Exception encountered during context initialization - \" +  \n                  \"cancelling refresh attempt: \" + ex);  \n         }  \n  \n         // Destroy already created singletons to avoid dangling resources.  \n         destroyBeans();  \n  \n         // Reset 'active' flag.  \n         cancelRefresh(ex);  \n  \n         // Propagate exception to caller.  \n         throw ex;  \n      }  \n  \n      finally {  \n         // Reset common introspection caches in Spring's core, since we  \n         // might not ever need metadata for singleton beans anymore...         resetCommonCaches();  \n         contextRefresh.end();  \n      }  \n   }}\n```\n\n`DefaultListableBeanFactory` bean 팩토리를 생성한다.\n\n`prepareBeanFactory()` 에서 의존성 주입을 무시할 인터페이스들을 등록한다.\n\n```java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {  \n   // Tell the internal bean factory to use the context's class loader etc.  \n   beanFactory.setBeanClassLoader(getClassLoader());  \n   if (!shouldIgnoreSpel) {  \n      beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));  \n   }  \n   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));  \n  \n   // Configure the bean factory with context callbacks.  \n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));  \n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);  \n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);  \n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);  \n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);  \n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);  \n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);  \n   beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);  \n  \n   // BeanFactory interface not registered as resolvable type in a plain factory.  \n   // MessageSource registered (and found for autowiring) as a bean.   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);  \n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);  \n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);  \n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);  \n  \n   // Register early post-processor for detecting inner beans as ApplicationListeners.  \n   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));  \n  \n   // Detect a LoadTimeWeaver and prepare for weaving, if found.  \n   if (!NativeDetector.inNativeImage() && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {  \n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));  \n      // Set a temporary ClassLoader for type matching.  \n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));  \n   }  \n  \n   // Register default environment beans.  \n   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {  \n      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());  \n   }  \n   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {  \n      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());  \n   }  \n   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {  \n      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());  \n   }  \n   if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) {  \n      beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());  \n   }  \n}\n```\n\n`postProcessBeanFactory()` 에서 beanPostProcessor를 등록하고, bean 팩토리에 `WebApplicationContext`와 관련된 스코프를 등록한다. \n\n```java\n@Override  \nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {  \n   beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));  \n   beanFactory.ignoreDependencyInterface(ServletContextAware.class);  \n   registerWebApplicationScopes();  \n}\n```\n\n`invokeBeanFactoryPostProcessors()`는 ConfigClass의 bean 정의와 기타 bean 정의를 로딩한다.\n\n`registerBeanPostProcessors()` 는 bean 생성을 가로채는 bean 프로세서들을 등록한다.\n\n`initMessageSource()`, `initApplicationEventMulticaster()`에서 message source와 multicaster의 bean을 등록한다.\n\n`onRefresh()` 에서는 `WebServerFactory`를 통해 `Tomcat Server` 객체를 만들고 설정 값들을 세팅한다.\n\n`registerListeners()` 는 `EventMultiCaster` 에 리스너를 등록한다.\n\n`finishBeanFactoryInitialization()` 에서는 bean 팩토리의 설정과 정의들을 프리징하고, 남은 싱글톤 빈들을 모두 인스턴스로 등록한다.\n\n마지막으로 `finishRefresh()` 는 마지막 이벤트를 발행하고, 등록되어 있는 이벤트 리스너를 별도 스레드로 실행한다. 이후 Tomcat Server를 시작한다.\n\nrefresh의 자세한 동작 과정은 다음 포스팅을 기대해주세요~\n\n## 정리\n애플리케이션에 대한 Configuration을 제공하는 인터페이스이다. Bean Factory를 상속받아 확장되었다.\n`@Configuration` 이 붙은 클래스들을 설정 정보로 등록해두고, `@Bean` 이 붙은 메서드의 이름으로 bean 목록을 생성한다.\n클라이언트가 해당 bean을 요청하면 bean 목록에서 요청한 이름이 있는지 찾고, 있으면 해당 bean 생성 메서드를 호출하여 객체를 생성하고 돌려준다.\n\n## 추가할 내용\n- bean 후처리\n- BeanDefinition이 어디서 초기화 되는가? -> [[bean]] 에 추가했습니다.\n- getBean 알아보기\n\n## 참고 자료\n- https://www.baeldung.com/spring-beanfactory-vs-applicationcontext\n- [망규형 블로그 - Application Run](https://mangkyu.tistory.com/213)\n- [망규형 블로그 - refresh](https://mangkyu.tistory.com/214)\n- https://pplenty.tistory.com/6"},{"excerpt":"Prototype Bean과 Singleton Bean을 섞어서 사용하는 경우 Prototype Bean 내부에서 Singleton Bean을 참조하는 경우 프로토타입 빈에서 싱글톤 빈을 사용하는 경우는 아무런 문제가 발생하지 않는다.\n프로토타입 빈 인스턴스는 계속해서 생성되지만, 주입받는 싱글톤 빈은 계속 동일한 하나의 인스턴스이다. Singleton …","fields":{"slug":"/bean-scope/"},"frontmatter":{"date":"2023년 06월 06일 06:06","title":"Spring Bean Scope","tags":["Spring","개발"]},"rawMarkdownBody":"\n## Prototype Bean과 Singleton Bean을 섞어서 사용하는 경우\n\n### Prototype Bean 내부에서 Singleton Bean을 참조하는 경우 \n\n프로토타입 빈에서 싱글톤 빈을 사용하는 경우는 아무런 문제가 발생하지 않는다.\n프로토타입 빈 인스턴스는 계속해서 생성되지만, 주입받는 싱글톤 빈은 계속 동일한 하나의 인스턴스이다. \n\n### Singleton Bean 내부에서 Prototype Bean을 참조하는 경우\n\n싱글톤 빈 내부의 프로토타입 빈은 주입되고 나서 인스턴스가 새로 생성되지 않는다. (프로토타입 빈임에도 불구하고)\n\n#### 해결 방법\n\n1. ProxyMode 설정\n\n객체의 해시코드를 확인하기 위한 코드를 작성한다.\n\n```java\n@SpringBootApplication  \npublic class DemoApplication implements CommandLineRunner {  \n  \n    public static void main(String args[]) {  \n        SpringApplication.run(DemoApplication.class, args);  \n    }  \n  \n    @Autowired  \n    ApplicationContext applicationContext;  \n  \n    @Override  \n    public void run(String... strings) throws Exception {  \n        System.out.println(applicationContext.getBean(Single.class));  \n        System.out.println(applicationContext.getBean(Single.class));  \n        System.out.println(applicationContext.getBean(Single.class));  \n  \n        System.out.println();  \n  \n        System.out.println(applicationContext.getBean(Proto.class));  \n        System.out.println(applicationContext.getBean(Proto.class));  \n        System.out.println(applicationContext.getBean(Proto.class));  \n        System.out.println(applicationContext.getBean(Proto.class));  \n  \n        System.out.println();  \n  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n        System.out.println(applicationContext.getBean(Single.class).getProto());  \n    }  \n}\n```\n\n프로토타입 빈에 proxymode를 설정한다.\n\n```java\n@Component  \n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)  \npublic class Proto {  \n}\n```\n\n```java\n@Component  \npublic class Single {  \n    private final Proto proto;  \n  \n    public Single(final Proto proto) {  \n        this.proto = proto;  \n    }  \n  \n    public Proto getProto() {  \n        return proto;  \n    }  \n}\n```\n\n결과는 다음과 같다. 싱글톤 빈에서도 프로토타입 빈이 계속해서 생성되는 것을 볼 수 있다.\n\n```shell\nhello.Single@7a9ceddf\nhello.Single@7a9ceddf\nhello.Single@7a9ceddf\n\nhello.Proto@4c6a4ffd\nhello.Proto@3aed69dd\nhello.Proto@3f1a9a53\nhello.Proto@1ca3d25b\n\nhello.Proto@2287395\nhello.Proto@535a518c\nhello.Proto@38f981b6\nhello.Proto@3a4aadf8\nhello.Proto@7bbfc5ff\n```\n\n2. `ObjectProvider` 사용하기\n\n싱글톤 빈의 필드로  `ObjectProvider` 를 추가한다.\n\n```java\n@Component  \npublic class Single {  \n    @Autowired  \n    private ObjectProvider<Proto> objectProvider;  \n  \n    public Proto getProto() {  \n        return objectProvider.getIfAvailable();  \n    }  \n}\n```\n\n```shell\nhello.Single@1d98daa0\nhello.Single@1d98daa0\nhello.Single@1d98daa0\n\nhello.Proto@54336976\nhello.Proto@f25f48a\nhello.Proto@3b7c80c6\nhello.Proto@3b2e5c0d\n\nhello.Proto@79eeff87\nhello.Proto@8bd076a\nhello.Proto@1378eea2\nhello.Proto@66522ead\nhello.Proto@e91b4f4\n```\n\n동일한 동작을 하지만, 자바 객체가 POJO 스타일에서 벗어나게 된다.\n\n"},{"excerpt":"LOG 배운 것  Service를 지정하고,  어노테이션이 '인터페이스' 객체에 지정되어 있는 경우, 인터페이스 객체는 구현체가 아닌 인터페이스 객체가 생성되어 주입된다. 어차피 mock 객체이기 때문에 mockito에서 구현체를 사용하지 않고 인터페이스를 그대로 사용하는 듯 하다. 을 사용할 때, 비교하는 객체가 다른 클래스더라도 내부 필드 이름이 같으…","fields":{"slug":"/2023-06-06/"},"frontmatter":{"date":"2023년 06월 06일 05:06","title":"2023년 06월 06일","tags":null},"rawMarkdownBody":"## LOG\n\n## 배운 것\n\n- `@InjectMocks` Service를 지정하고, `@Mock` 어노테이션이 '인터페이스' 객체에 지정되어 있는 경우, 인터페이스 객체는 구현체가 아닌 인터페이스 객체가 생성되어 주입된다. 어차피 mock 객체이기 때문에 mockito에서 구현체를 사용하지 않고 인터페이스를 그대로 사용하는 듯 하다.\n- `usingRecursiveComparison()`을 사용할 때, 비교하는 객체가 다른 클래스더라도 내부 필드 이름이 같으면 그대로 비교가 된다 ㄷㄷ 필드 타입과 이름만 같으면 비교 가능하다.\n- mocking된 객체의 경우 따로 행동을 지정해주지 않으면 자동으로 기본값을 리턴한다. (void는 안 써줘도 무방)\n\n## 궁금한 것\n\n## 느낀 것\n"},{"excerpt":"Interceptor란? Controller의 Handler를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터 컨트롤러에 들어오는 요청  와 응답하는  를 가로채는 역할을 한다.\n 은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하고,  을 돌려준다. 왜 써야 할까? 기존 컨트롤러의 로직을 수정하지 않고 사전, 사후에 제어가 …","fields":{"slug":"/interceptor/"},"frontmatter":{"date":"2023년 06월 06일 02:06","title":"Interceptor","tags":null},"rawMarkdownBody":"\n## Interceptor란?\n\nController의 Handler를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터\n\n컨트롤러에 들어오는 요청 `HttpRequest` 와 응답하는 `HttpResponse` 를 가로채는 역할을 한다.\n`DispatcherServlet` 은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하고, `HandlerExecutionChain` 을 돌려준다.\n\n## 왜 써야 할까?\n\n기존 컨트롤러의 로직을 수정하지 않고 사전, 사후에 제어가 가능하다.\n\nEx. 세션 인증\n요청을 받아들이기 전에 세션에 로그인한 사용자가 있는지 확인해보고, 없다면 로그인 페이지로 리다이렉트할 수 있다. 인터셉터가 없다면 모든 컨트롤러마다 해당 로직이 필요하다.\n\n## Interceptor 메서드\n\n```java\npublic interface HandlerInterceptor { \n\tdefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { \n\t\treturn true; \n\t} \n\t\n\tdefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception \n\t{ } \n\t\n\tdefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { } \n}\n```\n\n- `preHandle` : 컨트롤러가 호출되기 전에 실행된다. 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가할 때 사용한다. 반환값이 true이면 다음 단계로 진행되고, false 라면 작업을 중단하여 이후의 인터셉터나 컨트롤러로 진행되지 않는다.\n- `postHandle` : 컨트롤러 호출 후에 실행된다. 컨트롤러 작업 이후에 처리해야 하는 후처리 작업이 있을 때 사용한다. 컨트롤러 하위 계층에서 작업을 진행하다가 중간에 예외 발생 시 호출되지 않는다.\n- `afterCompletion` : 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다. 요청 처리 중에 사용한 리소스를 반환할 때 사용하기 좋다. 컨트롤러 하위 계층에서 작업을 진행하다가 예외가 발생하더라도 반드시 호출된다.\n\n## Filter와의 비교\n\n더 자세한 내용은 [[filter]] 확인\n\n### 공통점\n\n특정 URI에 접근할 때 제어하는 용도로 사용된다.\n\n### 차이점\n\n**영역의 차이**\nFilter는 동일한 웹 애플리케이션의 영역 내에서 필요한 자원들을 활용한다. 웹 애플리케이션 내에서 동작하므로 스프링에 Context를 접근하기 어렵다고 하나, 요즘에는 필터에서도 스프링 설정 정보에 접근할 수 있다.\n\nInterceptor는 스프링에서 관리되어 스프링의 모든 객체에 접근이 가능하다.\n\n**스프링의 예외 처리 차이**\nFilter에서 예외가 던져지면 에러가 처리되지 않고 서블릿까지 전달된다. \nFilter는 주로 `doFilter()` 주변을 try-catch 로 감싸서 그 시점에서 발생한 예외를 바로 핸들링한다.\n\nInterceptor는 `@ControllerAdvice` 와 `@ExceptionHandler` 를 사용하여 예외 처리가 가능하다.\n\n**호출 시점의 차이**\nFilter는 `DispatcherServlet` 이 실행되기 전, Interceptor는 `DispatcherServlet` 이 실행되며 호출된다.\n\n**Request/Response 객체 조작 가능 여부**\nFilter가 다음 필터를 호출하기 위해서는 필터 체이닝을 해주어야 하는데, 이때 Request/Response 객체를 넘겨주므로 원하는 Request, Response 객체를 넘겨줄 수 있다.\n\nInterceptor는 boolean만 반환할 수 있으므로 다음 Interceptor로 Request/Response 객체를 넘겨줄 수 없다.\n\n## ArgumentResolver와의 비교\n\n### ArgumentResolver란?\n\n어떤 요청이 컨트롤러에 들어왔을 때, 요청에 들어온 값으로부터 원하는 객체를 생성하는 일을 `ArgumentResolver` 가 간접적으로 수행해줄 수 있다.\n\nEx. 사용자가 로그인되어 있을 때, 올바른 사용자인지 검증하는 경우\n유효한 인증 정보를 갖고 있는지 확인하고, Member로 만들어주는 작업이 필요한 경우를 생각해보자.\n검증 코드가 Controller 에 존재할 때는 모든 메서드에 같은 코드가 중복되고, Controller의 책임이 증가한다.\n\n### ArgumentResolver 사용\n\n`HandlerMethodArgumentResolver` 를 구현하여 사용할 수 있다.\n\n다음과 같은 메서드를 구현해야 한다.\n\n```java\nboolean supportsParameter(MethodParameter parameter);\n\n@Nullable\nObject resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;\n```\n\n- `supportsParameter` : 핸들러의 특정 파라미터를 지원하는지 여부를 판단하기 위한 메서드. 어떤 파라미터에 대해 작업을 수행할 것인지를 정의하는 곳\n- `resolveArgument` : 해당 파라미터에 대한 실질적인 로직을 처리하는 곳. parameter에 전달할 객체에 대한 조작을 진행한 후, 해당 객체를 리턴한다.\n\n구현한 `HandlerMethodArgumentResolver` 는 `WebMvcConfigurer` 를 구현한 `@Configuration` 클래스에 `addArgumentResolvers` 를 통해 등록해주어야 한다.\n\n### Interceptor와 차이점\n\nArgumentResolver는 Interceptor 이후에 동작하고, 어떤 요청이 컨트롤러에 들어왔을 때, 요청에 들어온 값으로부터 원하는 객체를 반환한다.\n\n그러나 인터셉터는 실제 컨트롤러가 실행되기 전에 요청을 가로채고, 특정 객체를 반환할 수 없다.\n\n## 용도\n클라이언트 요청과 관련된 전역적으로 처리해야 하는 작업을 처리할 수 있다.\n`HttpServletResponse`, `HttpServletRequest` 객체 자체를 바꿔치기 할 수는 없지만, 내부 값은 조작 가능하다.\n\n다음과 같은 경우에 사용하는 것을 권장한다.\n\n- 인증/인가와 같은 공통 작업 : 클라이언트 요청과 관련된 작업들을 컨트롤러로 넘어가기 전에 검사할 수 있다.\n- Controller로 넘겨주는 정보 가공: 전달받는 Request, Response 객체를 가공하여 컨트롤러에 전달할 수 있다. \n- API 호출에 대한 로깅: 클라이언트의 정보를 기록한다."},{"excerpt":"Filter란?  처리 전 후에 동작하여 사용자의 요청이나 응답의 최전방에 존재한다. Java Servlet에서 제공된다.\n요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 부가 작업을 처리할 수 있는 기능을 제공한다. 스프링 빈으로 등록될 수 있다. Filter의 메서드 Filter 인터페이스를 구현해야 필터를 추가할 수 있다.  : 필터가 웹 …","fields":{"slug":"/filter/"},"frontmatter":{"date":"2023년 06월 06일 02:06","title":"Filter","tags":null},"rawMarkdownBody":"\n## Filter란?\n\n`DispatcherServlet` 처리 전 후에 동작하여 사용자의 요청이나 응답의 최전방에 존재한다. Java Servlet에서 제공된다.\n요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 부가 작업을 처리할 수 있는 기능을 제공한다.\n\n스프링 빈으로 등록될 수 있다.\n\n## Filter의 메서드\n\nFilter 인터페이스를 구현해야 필터를 추가할 수 있다.\n\n```java\n public interface Filter {  \n  \n    public default void init(FilterConfig filterConfig) throws ServletException {}  \n  \n    public void doFilter(ServletRequest request, ServletResponse response,  \n            FilterChain chain) throws IOException, ServletException;  \n  \n    public default void destroy() {}  \n}\n```\n\n`init()` : 필터가 웹 컨테이너에 생성될 때 실행된다.\n`doFilter()` : Request, Response가 필터를 거칠 때 수행되는 메서드로, 체인을 따라 다음에 존재하는 필터로 이동한다. url 패턴에 맞는 모든 HTTP 요청이 `DispatcherServlet` 으로 전달되기 전에 웹 컨테이너에 의해 실행된다.\n`destroy()` : 필터가 소멸될 때 실행된다.\n\n## 용도\n요청 파라미터 자체의 검증 및 처리를 담당한다.\n\n- 보안 관련 공통 작업: 필터는 웹 컨테이너에서 동작하므로 보안 검사를 통해 올바른 요청이 아닌 경우 차단할 수 있다. 스프링 컨테이너까지 요청이 전달되지 않고 차단되므로 안정성을 높일 수 있다.\n- 모든 요청에 대한 로깅\n- 이미지 / 데이터 압축 및 문자열 인코딩: 웹 애플리케이션에서 전반적으로 사용되는 기능을 구현한다.\n\n## 참고\n- https://mangkyu.tistory.com/173\n- https://steady-coding.tistory.com/601"},{"excerpt":"공부를 한다. 공부 왜 레벨3는 사실상 프로젝트 기간. 공부를 얼마나 많이 할 수 있을까?\n다른 공부를 레벨5 때 시작한다면? 나는 레벨 5 때 무슨 공부를 할까?\n바뀌지 않는 것: 나는 우테코를 수료하고 학교로 돌아가서 졸업을 한다. 우형 / 다른 회사에 취업했을 때 -> 4-1은 그냥 어떻게든 졸업한다.\n데이터베이스, 네트워크, 캡스톤 -> 9학점\n멀…","fields":{"slug":"/vacation-plan/"},"frontmatter":{"date":"2023년 06월 04일 05:06","title":"방학 계획","tags":null},"rawMarkdownBody":"\n공부를 한다.\n\n# 공부\n\n## 왜\n\n레벨3는 사실상 프로젝트 기간. 공부를 얼마나 많이 할 수 있을까?\n다른 공부를 레벨5 때 시작한다면? 나는 레벨 5 때 무슨 공부를 할까?\n바뀌지 않는 것: 나는 우테코를 수료하고 학교로 돌아가서 졸업을 한다.\n\n- 우형 / 다른 회사에 취업했을 때 -> 4-1은 그냥 어떻게든 졸업한다.\n\t데이터베이스, 네트워크, 캡스톤 -> 9학점\n\t멀티코어 컴퓨팅, 오픈소스SW프로젝트, 컴퓨터시스템및어셈블리언어, 무언가 하나 -> 21학점\n\n- 취업하지 못했을 때 -> 굳이 한 학기에 졸업할 필요 없다.\n\t- 1학기 \n\t\t- 데이터베이스, 네트워크, 캡스톤, 멀티코어 컴퓨팅, 오픈소스SW프로젝트, 컴퓨터시스템및어셈블리언어 -> 18학점\n\t- 2학기 \n\t\t- 설계패턴 -> 3학점\n\n**이론**\n취업을 위한 공부 -> 알고리즘, CS\n프로젝트를 위한 공부 -> 어느 정도의 CS, 네트워크, 데이터베이스\n\n=> 언젠가는 해야 하는 공부. 브라운이 CS는 슬슬 시작하라고 하기도 했음.\n알고리즘은 해두면 언제나 좋은. 단기간 연습이 필요하다. 그러나 우테코 수료하기 전의 프로젝트에서는 기본적인 것 빼고 필요 없다.\nCS는 기초 지식이기 때문에 예외를 만났을 때 왜 이런지 어느 정도 파악할 수 있는 지식이 된다. 취업에 중요한 공부 중에 하나. 그렇지만 프로젝트할 때 직접적으로 도움이 되지는 않는다.\n데이터베이스는 프로젝트 때 JPA 쓸 거라서 한다면 쿼리 공부보다는 좀 더 이론적인 공부에 치중할 듯. 가장 우선순위가 낮다.\n네트워크는 취업 공부할 때도 필요하다. 프로젝트에서도 좀 더 중요하게 다뤄질 것 같다. 인프라 쪽 문제 발생했을 때 해결하기 좋을 듯. 그러나 취업 공부에서는 상대적으로 CS나 알고리즘보다 우선순위가 낮다.\n\n**기술**\n기술 자체에 대한 공부 -> Spring, JPA(오찌가 깊게 파지는 말라고 했으니까 기능 습득 위주), Docker, Jenkins ...\n\n=> 프로젝트에 쓸 기술은 어떻게 공부하면 좋을까? 그냥 무작정 시작할 수도 있고, 책을 읽을 수도 있고\n무작정 시작하는 것은 별로 좋지는 않은 것 같다. 크게 기억에 남는 것도 없고, 제대로 배우기보다는 지식 겉핥기로 끝나는 경우가 많았다.\n기술을 먼저 생각하고 프로젝트를 진행하는 것은 옳은가? 부족한 상황에서 develop 해가는 것이 맞나?\n필요성을 느끼고 기술을 도입하는 것이 더 좋은 듯.\n기술은 도구일 뿐 기술을 위해 뭔가를 시작해서는 안 된다.\n\n## 무엇을\n- 알고리즘\n- CS\n\n## 언제\n\n### CS\n#### 학기 중\n- 평일 하루 2시간 -> 프로젝트 시작하고 정해보기\n- 일요일 2-6시\n\n#### 방학\n- 화 목 2시간씩 (오후 7-9시)\n- 일요일 2-6시\n\n###  알고리즘\n- 월수금에 알고리즘 풀이 (2-4시)\n- 일주일에 총 2문제\n\n## 어떻게\n\n### CS\n- 책으로 공부하기 -> 아마도 공룡책?\n\n### 알고리즘\n- 과외 진도를 따라가면서 관련 문제 풀이\n- 모르는 문제 유형 정리\n\n# matzip 피쳐 개발\n\n하고 싶은 것: matzip 서버 CD & 무중단 배포"},{"excerpt":"공부한 것 목록 transactional bean bean-scope bean-candidate interceptor ioc-container-and-di filter 질문 목록 이번 미션에서 사용자 인증을 ArgumentResolver에서 수행했는지, Interceptor를 사용했는지: 미션에서는 ArgumentResolver에서 수행했다. 그러나 나중…","fields":{"slug":"/level2-level-log/"},"frontmatter":{"date":"2023년 06월 04일 05:06","title":"레벨2 레벨로그","tags":["우테코","레벨2","레벨로그"]},"rawMarkdownBody":"## 공부한 것 목록\n\n- [[transactional]]\n- [[bean]]\n- [[bean-scope]]\n- [[bean-candidate]]\n- [[interceptor]]\n- [[ioc-container-and-di]]\n- [[filter]]\n\n## 질문 목록\n\n- **이번 미션에서 사용자 인증을 ArgumentResolver에서 수행했는지, Interceptor를 사용했는지**: 미션에서는 ArgumentResolver에서 수행했다. 그러나 나중에는 Interceptor에서 인증 로직을 수행할 것 같습니다.\n\t- **이유?** \n\t- ArgumentResolver의 경우: **ArgumentResolver는 단순하게 값을 받아서 객체로 만드는 역할만 수행해야 한다는 의견도 있는데, 이런 경우는 어떻게 생각하시나요?**\n\t- Interceptor의 경우: **Interceptor에서는 true, false만 리턴할 수 있고 Request 조작만 가능하기 때문에 한 번에 객체를 만들어 주기 위해서는 ArgumentResolver가 더 낫다는 의견도 있었는데 어떻게 생각하시나요?**\n- **DI의 장점과 단점에 대해 설명해주세요.**\n\t- 장점: 클래스 사이의 결합도를 낮추어서 테스트하기 용이하고 리팩토링이 쉽다. 구현체가 변경되는 상황에서 객체 변경의 유연성을 가져갈 수 있다.\n\t- 단점: 의존성 주입이 여기저기에 흩어져 있으면 연관 관계를 파악하기 어려울 수 있다는 단점. 따라서 작은 프로젝트에서는 의존성 주입을 사용하지 않아도 될 것 같다.\n- **`@Transactional(readOnly = true)` 를 사용해 보신 적 있나요?**\n\t- **왜 쓰셨죠?** : 동료 개발자의 가독성 측면, CUD에 사용하는 경우에 예외 처리를 위해 사용했다.\n\t- **아예 안 쓰는 것과 어떤 차이가 있나요? 가독성 제외하고** : DB가 Read lock을 지원하는 경우에는 데이터 스냅샷으로만 조회를 해오기 때문에 데이터 일관성이 유지되고, mysql의 경우 transaction id를 부여하지 않기 때문에 오버헤드가 사라진다는 장점이 있습니다.\n- **bean scope에 대해 설명해주세요.**\n\t- **singleton bean 내부에서 prototype bean을 참조하는 경우 발생하는 문제와 해결 방법**\n- **java bean에 대해 설명해주세요.**\n\t- 특정 형태를 만족하는 클래스를 의미한다. 디폴트 생성자가 있고, 모든 필드는 private으로 getter, setter가 있어야 한다.\n- **bean 등록 시에 `@Configuration` 과 `@Component` 설정 방식을 정하는 기준이 있는지?**\n\t- 외부 라이브러리를 사용하거나 특정 의존성을 주입해주어야 할 때는 `@Configuration` 을 사용하고, 그 외의 일반 bean 설정은 `@Component` 를 사용한다.\n- **bean lifecycle이란?** : bean이 생성되고 소멸되는 주기를 의미한다. 스프링 컨테이너가 생성되고, bean이 생성된 후, 의존관계가 주입된다. 그 후 초기화 콜백이 실행되고, bean이 사용된다. 이후 bean의 소멸 콜백이 호출되고, 스프링 컨테이너가 종료되는 방식의 라이프 사이클을 갖는다.\n- **의존 관계 주입 방법 세 가지와 어떤 것이 왜 좋은지?**\n- **컨트롤러 단위 테스트와 서비스 단위 테스트 작성 하시는지? 그 이유?** : 컨트롤러 단위 테스트는 진행하지 않고, 서비스 단위 테스트는 진행하는 편입니다. \n\t- **컨트롤러 단위 테스트 / 서비스 단위 테스트에서는 어떤 어노테이션을 사용하시는지?**\n\t- **컨트롤러 단위 테스트를 했는데 통합 테스트도 써야 할까요?**\n- **같은 타입의 bean이 여러 개 존재한다면 어떤 문제가 발생하나요?**\n\t- **해당 문제를 해결하는 방법**\n- **repository와 dao 분리하셨는지**\n\t- 분리했다면 어떤 이유로\n\t- 분리하지 않았다면 분리한 것에 비해 어떤 장점이 있었는지\n- **domain과 entity 분리했는지**\n- **repository 는 도메인 레이어인가, 영속성 레이어인가? 그렇게 생각하는 이유는?**\n\t- 도메인 레이어이다. 도메인을 가지고 레파지터리와 소통하기 때문이다. 해당 도메인을 가지고 영속성 레이어를 호출하는 보다 상위의 클래스라고 생각한다.\n- **쿼리를 여러 번 날리는 것과 조인을 여러 번 하는 것 중 어떤 것을 선호하는가? 이유는?**\n\t- **반대 방법의 장점은 어떤 것이 있을까요?**\n- **Spring 컨테이너에게 객체의 라이프 사이클을 맡기는 것의 장단점?**\n\t- 객체의 생성부터 소멸까지 Spring이 관리하게 함으로써 개발자가 비즈니스 부분에만 집중할 수 있다는 장점이 있다.\n\t- 상태를 갖는 객체의 경우에는 bean으로 등록하지 않는다고 했을 때: 상태를 가져도 bean으로 만들 수 있다면 bean으로 만드실 건가요? 실제로 prototype 빈은 싱글톤이 아니고 조회할 때마다 새로 생성되는 빈이라 상태를 가질 수 있습니다.\n- **mocking과 stubing의 차이점? 왜 쓰는지?**\n\t- **테스트 더블 중에서 어떤 것을 더 선호하는지? (상황별)**\n- **협업 미션에서 프론트엔드로 필요하지 않은 정보도 모두 내려주는 것 vs 필요한 정보만 선별해서 내려주는 것 중 어떤 것이 좋다고 생각하시나요?**\n- **숨겨야 하는 애플리케이션 속성은 어떻게 처리하셨나요? 서브 모듈 / external properties 도 있는데 어떤 장점 때문에 그 방법을 선택하셨는지**\n- **FK 는 필요할까요? 이유**\n\t- mysql 에서는 FK 가 걸려 있으면 lock 전파가 발생하기 때문에 FK 를 사용할 때 주의해야 한다. 따라서 FK 는 따로 쓰지 않는 것이 좋다고 생각한다.\n- **테이블 사이에 FK 가 걸려있어도 값을 검증해야 할까요?**\n\t- 해야 한다. 도메인 로직에서 값을 검증하는 부분이 보이지 않는다. 또한 DB의 예외가 위쪽 계층으로 침범한다고 생각해서 값을 미리 Repository 단에서 검증하는 것이 좋다고 생각한다.\n\t- 할 필요 없다: **FK가 걸려 있으면 존재하지 않는 데이터를 FK로 해서 DB에서 쿼리를 보낼 때 예외가 발생한다. 그래도 해야 하나?**\n\t- 할 필요가 있다: **계속 동일한 코드가 중복해서 들어가게 되어서 가독성 측면에서는 좋지 않은 것 같은데, 그 부분은 어떻게 생각하시나요?** -> 그 부분이 트레이드 오프라고 생각한다. 계속해서 동일한 로직이 실행되고 있지만, 꼭 필요한 로직이라면 중복해서 들어가 있어도 괜찮다고 생각한다.\n- **도메인에 ID가 있어도 될까요?**\n\t- 있으면 안 된다: 객체 내부의 필드 값을 모두 비교해야 같은 데이터가 될 수 있는 도메인이 있다고 했을 때, 아이디로 식별하게 되면 훨씬 동등성을 비교하기 쉬울 수 있다는 의견에 대해서는 어떻게 생각하시나요?\n\t- 있어도 된다: 어떤 이점이 있었는가?\n- **클라이언트에서 조회하고 싶은 id를 전송했는데, 서버에서 해당 id에 맞는 데이터가 없다고 가정할 때 어떤 HttpStatus 코드를 내려주시나요? 이유는?**\n\t- 404 코드를 내려주었다. 404 자체가 리소스가 존재하지 않는다는 의미이기 때문에, 서버에서 해당 자원을 찾을 수 없다는 식으로 해석했다. \n\t- 해당 id가 포맷에 맞기 때문에 (id=4인 경우 포맷은 맞으나 서버 내부에서 못 찾는 것) 서버로 전달이 된 것이라고 생각해서 401은 적합하지 않다고 생각했다.\n- **interceptor와 argumentresolver의 패키지 위치는 어디가 적합하다고 생각하시는지?**\n- **httpstatus 403과 401의 차이점이 뭐라고 생각하시나요?**\n\t- **403을 사용해보신 적 있으신지, 왜 사용하셨는지?**\n- **truncate.sql 사용하시나요?**\n\t- 사용하신다면: **DROP을 선호하시는지, TRUNCATE를 선호하시는지?**\n\t- **테스트 격리를 위해 어떤 방법을 사용하시나요?**\n\n### 주디 피드백\n- FK를 사용하면 어떤 부분에서 무결성이 보장되는가?\n- FK를 사용하지 않는다면 무결성은 어떻게 최대한 지킬 수 있을까요?\n\n#### 학습 측면\n- 많이 고민해보신 것 같은 부분이 좋았습니다. 적절한 학습 예시와 함께 말해주신 점이 좋았습니다.\n\n#### 말하기 측면\n- 눈을 마주치면서 답변하고, 제스처를 적절하게 사용하여 답변에 좀 더 몰입할 수 있었습니다.\n- 말의 속도가 차분하고 목소리도 떨리지 않아서 좋았습니다.\n- 경험을 말하다보니 조금 장황해지는 경향이 있는 것 같습니다.\n- 결론과 이전의 답변이 조금은 상반된 경우가 있는 것 같습니다.\n\n### 코코닥 피드백\n\n#### 학습 측면\n- 주장에 대한 반대 의견도 함께 이야기 해주는 것이 좋았습니다. 깊게 공부해본 것 같은 느낌을 주었습니다.\n- 주장에 대한 자기 주관이 드러나는 것이 좋았습니다.\n- 주장과 근거가 함께 주어지고, 제공되는 근거가 신뢰도 있었습니다.\n\n#### 말하기 측면\n- 안정감을 주는 목소리로 차분하게 말해서 좋았습니다.\n- 손을 만지거나 다른 쪽을 바라볼 때가 있어서 그 부분은 신경써주시면 좋을 것 같다.\n\n### 제이미 피드백\n\n#### 학습 측면\n- 답변에서 필요한 답변을 하면서도 답변과 연결되는 개념을 함께 말해주어서 제이미가 많이 공부했다는 느낌이 들었습니다.\n- 미션에서 느꼈던 점, 왜 그렇게 했는지를 미션과 연관지어 이야기해 주신 부분이 좋았습니다.\n- 이전 질문에서 답변이 이어지는 느낌이 좋았습니다.\n\n#### 말하기 측면\n- 이해가 안 되는 부분은 다시 한 번 물어보는 부분이 좋았습니다.\n- 어떤 질문을 해도 되게 쉽게 답변해 주셔서 대단했습니다.\n- 조금 말의 호흡이 길게 느껴지는 부분이 있었습니다. 중간에 말을 끊어주고 말하면 문장의 핵심을 더 잘 파악할 수 있을 것 같습니다.\n- 답변에서 비슷한 의미의 말이 반복되는 느낌이 들었습니다.\n\n### 무민 피드백\n- DI에 대한 내용\n- interceptor, filter?\n\n#### 학습 측면\n- 해결 방법에 대한 경험, 경험에서의 고민이 답변에서 드러나서 좋았습니다.\n- 주장에 대한 근거가 주관으로 드러나서 좋았습니다. \n\n#### 말하기 측면\n- 답변하기 어려운 질문에도 천천히 잘 답변했습니다.\n- 질문에 관한 답변이 아닌 다른 답변을 할 때가 있어서 조금 아쉬웠습니다.\n- 생각할 때는 무의식적으로 하늘을 보는 습관이 있는 것 같습니다. 시선 처리를 좀 더 신경 써주시면 답변에 집중하고 있다고 보일 거 같습니다."},{"excerpt":"LOG 날씨가 매우 좋았는데, 동시에 더웠다... 집에서 에어컨 틀고 누워있으니 기분이 진짜 좋았다. 오랜만에 집에서 김치찌개 해먹었는데 역시 맛있었다. 미루던 집안일도 해결한 오늘의 점수 :100: 배운 것 헤나가 말하기를 sql 버전에 따라 alias 문제가 발생할 수 있다고 한다. 궁금했던 bad sql grammar 문제가 대충 해결 된 것 같다.…","fields":{"slug":"/2023-06-03/"},"frontmatter":{"date":"2023년 06월 03일 14:06","title":"2023년 06월 03일","tags":null},"rawMarkdownBody":"## LOG\n- 날씨가 매우 좋았는데, 동시에 더웠다... 집에서 에어컨 틀고 누워있으니 기분이 진짜 좋았다. 오랜만에 집에서 김치찌개 해먹었는데 역시 맛있었다. 미루던 집안일도 해결한 오늘의 점수 :100:\n\n## 배운 것\n- 헤나가 말하기를 sql 버전에 따라 alias 문제가 발생할 수 있다고 한다. 궁금했던 bad sql grammar 문제가 대충 해결 된 것 같다...\n- swagger의 springfox와 springdoc 중에서 springdoc이 최근에 활발하게 업데이트도 되고 있고, 좀 더 사용하기 쉽다고 한다.\n- DB 유저의 비밀번호를 설정해두지 않아서 (근데 왜 안 돼 있지 ㅋㅋㅋ) 접근 에러가 떴었다. by 다즐\n- webflux는 논블록킹 \n\n## 궁금한 것\n\n## 느낀 것\n- 방학 때 무엇을 위해 공부해야 할까? 취업일까, 아니면 공부일까. CS, 알고리즘, 네트워크, 해야 할 건 많은데 시간은 한정되어 있다. 더 이상 늦기 전에 목표를 세워보는 게 좋을 것 같다.\n- 뭐든 할 때 컨텍스트 스위칭이 잦다. 방금 TIL 쓰다가도 PR 보러 갔다가 슬랙 봤다가 갑자기 계획 고민하다가 카톡 보다가 matzip 코드 봤다가 난리도 아니네 ㅋㅋㅋㅋ....... 좀 하나에 집중할 수 있는 방법은 없을까... 항상 양털 깎다가 진짜 뭐하고 있었는지 까먹는다.\n"},{"excerpt":"LOG 드디어 기능을 다 구현했다. 이제 배포만 하면 됐는데 어째서인지 아직도 mysql 이 연동이 안 돼서 해결을 못했다... 그런 줄 알았는데 즐선생님이 해결해주셨다 🙇‍♀️ 이유는 내일 듣기로 했으니 매우 궁금한 상태로 내일을 기다려 보자 길을 걷다가 커다란 바퀴벌레를 만났지만 놀라서 그런지 다행히도 밟지 않았다 ... 나에게도 그 친구에게도 다행인 일이…","fields":{"slug":"/2023-06-01/"},"frontmatter":{"date":"2023년 06월 01일 04:06","title":"2023년 06월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 드디어 기능을 다 구현했다. 이제 배포만 하면 됐는데 어째서인지 아직도 mysql 이 연동이 안 돼서 해결을 못했다... 그런 줄 알았는데 즐선생님이 해결해주셨다 🙇‍♀️ 이유는 내일 듣기로 했으니 매우 궁금한 상태로 내일을 기다려 보자\n- 길을 걷다가 커다란 바퀴벌레를 만났지만 놀라서 그런지 다행히도 밟지 않았다 ... 나에게도 그 친구에게도 다행인 일이다.\n- 내일은 선릉으로 이동해서 도밥, 아이크와 점심을 먹고 잠시 회의를 하다 회고를 할 예정이다. 선릉에 주말에만 가봤는데 평소의 선릉은 어떨지 좀 궁금하긴 하다.\n\n## 배운 것\n- table을 삭제할 때는 `DROP TABLE 테이블_이름` 을 쓴다.\n- `GRANT ALL PRIVILEGES ON *.* TO '유저이름'@'유저호스트주소' WITH GRANT OPTION`\n\t- 모든 데이터베이스의 권한을 부여하고, 다른 유저에게 권한을 수여할 수 있는 권한도 제공한다.\n- user를 삭제할 때에는 `DROP user '유저이름'@'유저호스트'` 를 사용한다.\n- user를 생성할 때에는 `CREATE user '유저이름'@'유저호스트주소' IDENTIFIED BY '비밀번호'` 를 사용한다.\n- 권한을 변경하고 나서는 `FLUSH PRIVILEGES` 로 변경 사항을 반영한다.\n- user의 권한을 확인할 때에는 `SHOW GRANTS FOR 유저이름@유저호스트` 를 사용한다.\n- `UPDATE user SET plugin='mysql_native_password' WHERE user='유저이름' and host='유저호스트주소'`\n\t- user의 plugin을 mysql_native_password로 변경한다.\n\n## 궁금한 것\n- root인데도 권한을 줄 수 없는 문제가 있었다. 왜일까?\n```shell\nERROR 1410 (42000): You are not allowed to create a user with GRANT\n```\n\n인터넷에서는 'root'@'%' 로 유저를 생성하고 다시 시도해 보라고 했는데, 나는 그것도 안 됐다... 뭘까\n\n## 느낀 것\n- 요즘 너무 더워서 바깥에 있을 때는 확실하게 생산성이 저하된다. 가끔 잠실 캠 바깥으로 안 나가고 싶다는 생각도 한다 ㅋㅋㅋ 온도.. 습도.... 완벽해\n- 도밥과 아이크가 궁금한 부분이나 잘 이해가 안 되는 부분이 슬랙을 하면서 느껴질 때 바로 허들/줌 요청하는 게 좋았다. 확실히 글로 전달하는 것보다는 말로 설명하는 게 더 좋은데, 말로 하면 내 비언어적 표현도 전달 되어서 그렇다. 내 의도도 잘 전해지고, 의미도 명확하다. 명확한 요청과 피드백이 확실히 중요하구나."},{"excerpt":"2023-06-01 2023-06-03 2023-06-06 2023-06-07 2023-06-26 2023-06-28 2023-06-30","fields":{"slug":"/2023-06/"},"frontmatter":{"date":"2023년 06월 01일 04:06","title":"2023년 06월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-06-01]]\n- [[2023-06-03]]\n- [[2023-06-06]]\n- [[2023-06-07]]\n- [[2023-06-26]]\n- [[2023-06-28]]\n- [[2023-06-30]]\n"},{"excerpt":"LOG 오늘은 포이와 토리가 선릉에 가고 망고도 프론트엔드 분들이랑 같이 먹는다고 해서 레벨3 망토포 없이 혼자 떨어진 베로 체험했다... ㅋㅋㅋㅋ 점심은 헙크 다즐이랑 먹었는데 갑자기 나온 MBTI 질문이 재밌었다. 갑자기 궁금한데 F들은 '오늘 힘들다' 라는 말을 들었을 때 '뭐가 힘들어?' 라는 말이 안 나오는건가...? 어째서 상대방이 뭐가 힘든지…","fields":{"slug":"/2023-05-30/"},"frontmatter":{"date":"2023년 05월 30일 15:05","title":"2023년 05월 30일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘은 포이와 토리가 선릉에 가고 망고도 프론트엔드 분들이랑 같이 먹는다고 해서 레벨3 망토포 없이 혼자 떨어진 베로 체험했다... ㅋㅋㅋㅋ 점심은 헙크 다즐이랑 먹었는데 갑자기 나온 MBTI 질문이 재밌었다. 갑자기 궁금한데 F들은 '오늘 힘들다' 라는 말을 들었을 때 '뭐가 힘들어?' 라는 말이 안 나오는건가...? 어째서 상대방이 뭐가 힘든지가 궁금하지 않은거야 서운하네요\n- 오찌, 주드와 페어 프로그래밍 했다. Jpa 사용해서 사용자가 단 리뷰에 지금까지 사용자가 달아온 리뷰 개수를 표시해주는 기능을 추가했다. 원래는 두 가지 구현하려고 했는데 구현한 기능이 머지되어야 추가할 수 있는 기능이라 오찌가 JPA 온보딩을 마저 진행해주셨다. 대충 알고 있던 N+1 문제에 대해 좀 더 자세히 알 수 있는 기회였다.\n- 오랜만에 노래방에 갔다 왔다. 그렇게 잘 불러지는 날은 아니었지만 신나는 노래를 부르니까 기분이 정말 좋았다. 요즘 루시 노래를 많이 듣는데 노래 부르니까 더 좋았다.\n\n## 배운 것\n- 오늘은 오찌, 주드와 페어를 했다 -> [[ohzzi-05-30|5월 30일 오찌와 페어]]\n\n## 궁금한 것\n\n## 느낀 것\n- 요즘 계속 반복되는 코드를 쓰다 보니 좀 귀찮은 때가 있는 것 같다. 오늘도 의욕이 별로 생기지 않아서 누누, 필립, 주노랑 이야기 했다. 남이 어떻게 코드 짰는지가 좀 더 궁금하다.\n- 오늘 생각해낸 아이디어 꽤나 괜찮아서 만약 주제 선택 안 되더라도 사이드 프로젝트로 진행해보고 싶은 주제다. \n![[service_proposal.png]]"},{"excerpt":"registerEvent() 이벤트를 발행한다 -> eventListener가 이벤트를 받아서 동작을 수행한다. 왜 이벤트를 썼는가? 락 관련해서 문제가 생길 수 있다. 관계 설명  은 다대일 관계를 나타낸다.\n즉, 리뷰가 N개고 멤버가 1개이다. 양방향으로 작성해줄 수도 있다. -> 양방향으로 작성하는 것이 필요한가? (상황에 따라 다르다. by 오찌)…","fields":{"slug":"/ohzzi-05-30/"},"frontmatter":{"date":"2023년 05월 30일 11:05","title":"5월 30일 오찌와 페어","tags":["matzip","페어"]},"rawMarkdownBody":"\n## `@Query`\n\n```java\n@Query(\n\tvalue = \"select count(r) from Review r where (r.member = :member)\"\n)\nLong countByMember(Member member) {\n\t\n}\n```\n\n## registerEvent()\n\n이벤트를 발행한다 -> eventListener가 이벤트를 받아서 동작을 수행한다.\n\n왜 이벤트를 썼는가? 락 관련해서 문제가 생길 수 있다.\n\n## 관계 설명\n\n`@ManyToOne` 은 다대일 관계를 나타낸다.\n즉, 리뷰가 N개고 멤버가 1개이다. \n\n양방향으로 작성해줄 수도 있다. -> 양방향으로 작성하는 것이 필요한가? (상황에 따라 다르다. by 오찌)\n\n양방향은 설정을 안 하면 기본적으로 LAZY로 설정된다 -> 쿼리가 엄청나게 많이 터진다.\nex. 10개의 리뷰 조회할 때 LAZY로 설정해두면 나중에 member를 get할 때 멤버 조회 쿼리가 10번 더 나간다. -> N+1 문제 발생 -> fetch join을 쓰거나 EntityGraph를 쓰자.\n\n확실하게 연관 관계를 사용하는 경우에는 FETCH를 사용하면 좋다.\n\n## Fetch\n\n`fetch = FetchType.LAZY` 로 작성하면 실제로 해당 객체를 가져올 때에는 연관관계를 갖는 객체가 들어있지 않고 가짜객체 (proxy) 가 존재한다. \n\n```java\n@JoinColumn(name = \"member_id\", nullable = false)\n@ManyToOne(fetch = FetchType.LAZY)\nprivate Member member;  // 가짜 객체가 존재.\n```\n\n```sql\nselect * from review r where id = 1;\nselect * from member m where m.id = r.member_id;\n```\n\nmember에 대한 접근이 생길 때만 실제로 쿼리를 가져온다.\n\n만약 review가 필요한데, member는 필요하지 않은 경우에는 낭비가 될 수 있다.\n또한 member 테이블 자체가 크면 조인할 때 비용이 많이 든다.\n\n> **LAZY를 기본으로 두고, 필요한 경우만 EAGER로 쓰는 것 추천**"},{"excerpt":"Spring Data JPA Entity 생성하기 보통은 도메인과 엔티티를 일치시키는 편이다.  어노테이션을 사용하여 도메인 객체를 엔티티로 만든다. 영속성 컨텍스트 엔티티를 영구히 저장할 수 있는 환경.\n 를 통해 관리되는데, 우리는 Spring Data JPA 를 사용하므로 를 직접 사용할 필요는 없고,  구현체 내부에서 자동으로 사용된다. 1차 캐시…","fields":{"slug":"/matzip-jpa/"},"frontmatter":{"date":"2023년 05월 30일 10:05","title":"matzip JPA","tags":["matzip","jpa"]},"rawMarkdownBody":"\n## Spring Data JPA\n\n```java\n// 그냥 JPA만 쓸 경우\npublic class MemberRepository {\n    @PersistenceContext\n    private final EntityManager em;\n\n    // 생성자\n    ...\n\n    public Member save(Member member) {\n        em.persist(member);\n    }\n}\n\n// Spring Data Jpa\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n    Member save(Member member);\n}\n```\n\n## Entity 생성하기\n\n보통은 도메인과 엔티티를 일치시키는 편이다.\n\n`@Entity` 어노테이션을 사용하여 도메인 객체를 엔티티로 만든다.\n\n\n## 영속성 컨텍스트\n\n엔티티를 영구히 저장할 수 있는 환경.\n`EntityManager` 를 통해 관리되는데, 우리는 Spring Data JPA 를 사용하므로 `EntityManager`를 직접 사용할 필요는 없고, `JpaRepository` 구현체 내부에서 자동으로 사용된다.\n\n### 1차 캐시\n`JpaRepository` 를 통해 엔티티를 `save` 하면 영속성 컨텍스트에 엔티티가 담기게 된다.\n엔티티를 조회할 때 영속성 컨텍스트를 통해 꺼내오게 되는데, 이때 객체의 `동일성` 을 보장해줄 수 있다.\n\n```java\nLong id = memberRepository.save(오찌).getId();\n\nMember 오찌1 = memberRepository.findById(id).get();\nMember 오찌2 = memberRepository.findById(id).get();\n\n오찌1 == 오찌2\n```\n\n영속성 컨텍스트는 조회 시 영속성 컨텍스트에 있는 데이터를 반환해주기 때문에 다른 변수에 담겨있지만 '주소값' 까지 동일한 객체이다.\n\n영속성 컨텍스트는 기본적으로 트랜잭션 범위에서 작동한다. 즉, 다른 트랜잭션에서 조회하게 되면 다른 객체가 된다.\n\n## JpaRepository\n\nsave, findById, findAll, delete, deleteById 메서드들을 기본으로 제공한다."},{"excerpt":"LOG 팀호완에서 인생 첫 딤섬을 먹었다. 맛있었는데 양이 많았다. 완탕 비빔면, 무슨바오?, 히가우, 또 뭐야 부채교 (데친 시금치와 새우가.. we were together~) 를 먹었다. 그 중에서는 무슨바오가 제일 맛있었던 거 같다. 북 앤 레스트에 가서 공부했다. 12시 반에 가서 7시 40분에 나왔는데 욕창 생길 거 같았다 ㅋㅋㅋㅋㅋ 역시 욕창…","fields":{"slug":"/2023-05-29/"},"frontmatter":{"date":"2023년 05월 29일 13:05","title":"2023년 05월 29일","tags":null},"rawMarkdownBody":"\n## LOG\n- 팀호완에서 인생 첫 딤섬을 먹었다. 맛있었는데 양이 많았다. 완탕 비빔면, 무슨바오?, 히가우, 또 뭐야 부채교 (데친 시금치와 새우가.. we were together~) 를 먹었다. 그 중에서는 무슨바오가 제일 맛있었던 거 같다. \n- 북 앤 레스트에 가서 공부했다. 12시 반에 가서 7시 40분에 나왔는데 욕창 생길 거 같았다 ㅋㅋㅋㅋㅋ 역시 욕창이 생기지 않으려면 뒤집기를 잘해야 한다. 신생아를 본받자 응애 ‼️ 리팩토링 좀 하다가 오늘따라 너무 재미없어서 회고 댓글도 쓰고 글도 좀 썼다. 굉장히 생산적인 하루였다. (요즘 굉장히라는 말을 굉장히 많이 쓴다.)\n- 순살치킨 떡볶이 + 오징어 튀김을 먹었다. 진짜 오랜만에 떡볶이를 먹었는데 맛있었다~ \n\n## 배운 것\n- bean에 대해 공부했다 + bean definition -> [[bean|Spring Bean]]\n\n## 궁금한 것\n- bad sql grammar 문제는 아직 해결되지 않았다... 리만 가설과 bad sql grammar 문제, 과연 어떤 문제가 명쾌한 해답으로 신속하게 해결될 수 있을지 기대 만발.\n\n## 느낀 것\n- 말하고 싶은 게 많은데 여백이 너무 좁아 여기에 쓰지 않는다. "},{"excerpt":"선언적 트랜잭션이란 트랜잭션의 동작을 명시적으로 정의하지 않고, 선언적인 방식으로 트랜잭션을 처리하는 개념이다. 주로 프레임워크나 라이브러리 수준에서 정의된다. 개발자가 명시적으로 트랜잭션을 관리하는 대신, 프레임워크에게 책임을 위임하여 간단한 설정이나 어노테이션으로 트랜잭션을 선언하고 처리한다.  이란 Spring의 선언적 트랜잭션 방식 중 하나이다. …","fields":{"slug":"/transactional/"},"frontmatter":{"date":"2023년 05월 29일 10:05","title":"Transactional","tags":["spring"]},"rawMarkdownBody":"\n## 선언적 트랜잭션이란\n\n트랜잭션의 동작을 명시적으로 정의하지 않고, 선언적인 방식으로 트랜잭션을 처리하는 개념이다. 주로 프레임워크나 라이브러리 수준에서 정의된다.\n\n개발자가 명시적으로 트랜잭션을 관리하는 대신, 프레임워크에게 책임을 위임하여 간단한 설정이나 어노테이션으로 트랜잭션을 선언하고 처리한다. \n\n## `@Transactional` 이란\n\nSpring의 선언적 트랜잭션 방식 중 하나이다. \n\n트랜잭션을 적용하고자 하는 클래스나 메서드 위에 `@Transactional` 을 선언하면 트랜잭션 기능이 적용된 프록시 객체가 생성되고, `@Transactional` 이 포함된 메서드가 호출되는 경우 `PlatformTransactionManager` 를 사용하여 트랜잭션을 시작한다.\n\n### propagation 옵션\n\n트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할 지 결정하는 것을 트랜잭션의 전파 설정이라고 한다.\n\n#### 물리 트랜잭션 vs 논리 트랜잭션\n\n1개의 트랜잭션을 사용한다는 것은 하나의 Connection 객체를 사용한다는 것이다. \n트랜잭션이 실제 데이터베이스의 트랜잭션을 사용한다는 점에서 **물리 트랜잭션**이라고 한다. \n커넥션을 통해 커밋/롤백하는 단위이다.\n\n전파 속성에 따라 외부 트랜잭션과 내부 트랜잭션이 동일한 트랜잭션을 사용할 수도 있다.\n스프링에서는 실제 데이터베이스 트랜잭션과 스프링이 처리하는 트랜잭션을 구분하기 위해 **논리 트랜잭션**이라는 개념이 등장했다.\n\n트랜잭션 전파 없이 1개의 트랜잭션만 사용되면 물리 트랜잭션만 존재하고, 트랜잭션 전파가 사용될 때 논리 트랜잭션 개념이 사용된다. \n\n#### 종류\n\n- `REQUIRED`\n\t- 기본값. 부모 트랜잭션이 존재하는 경우 참여하고, 존재하지 않는 경우 트랜잭션을 새롭게 생성한다.\n\t- 자식에서 발생한 예외는 부모 트랜잭션도 롤백시킨다.\n\t- 부모 트랜잭션이 커밋되면 자식의 모든 변경사항도 함께 커밋된다.\n- `SUPPORTS`\n\t- 부모 트랜잭션이 존재하는 경우 참여하고, 없는 경우 non-transactional 상태로 실행한다.\n\t- 자식에서 발생한 예외는 부모 트랜잭션도 롤백시킨다.\n\t- 부모 트랜잭션이 커밋되면 자식의 모든 변경사항도 함께 커밋된다.\n- `MANDATORY`\n\t- 부모 트랜잭션이 있으면 참여하고, 없는 경우 예외를 발생시킨다.\n\t- 자식에서 발생한 예외는 부모 트랜잭션도 롤백시킨다.\n\t- 부모 트랜잭션이 커밋되면 자식의 모든 변경사항도 함께 커밋된다.\n- `REQUIRES_NEW`\n\t- 부모 트랜잭션은 일시 중단되고, 자식은 새로운 트랜잭션을 생성한다. \n\t- 부모/자식 트랜잭션의 롤백 여부는 서로 영향을 주지 않는다. 즉, 자식 트랜잭션의 롤백은 부모 트랜잭션에 영향을 주지 않는다.\n\t- 내부 트랜잭션이 롤백되는 경우는 실제 Connection에 롤백을 호출하는 경우이므로 트랜잭션이 종료된다.\n\t- 자식 트랜잭션은 부모 트랜잭션과 독립적으로 커밋되거나 롤백된다.\n- `NOT_SUPPORTED` \n\t- non-transactional 상태로 실행하며, 부모 트랜잭션이 존재하는 경우 일시 정지 시킨다.\n\t- 부모 트랜잭션의 커밋은 자식의 동작에 영향을 주지 않는다.\n- `NEVER` \n\t- non-transactional 상태로 실행하며, 부모 트랜잭션이 존재하는 경우 예외를 발생시킨다.\n\t- 부모 트랜잭션의 커밋은 자식의 동작에 영향을 주지 않는다.\n- `NESTED`\n\t- 부모 트랜잭션과는 별개의 중첩된 트랜잭션을 만든다. \n\t- 부모 트랜잭션이 없는 경우에는 새로운 트랜잭션을 생성한다.\n\t- 부모 트랜잭션이 커밋된 경우 -> 자식 트랜잭션의 변경 사항은 아직 데이터베이스에 확정되지 않는다. 자식 트랜잭션은 별도로 커밋되거나 롤백되어야 한다.\n\t- 부모 트랜잭션이 롤백된 경우 -> 자식 트랜잭션도 롤백된다.\n\t- 자식 트랜잭션이 커밋된 경우 -> 부모 트랜잭션은 커밋되지 않는다.\n\t- 자식 트랜잭션이 롤백된 경우 -> 자식 트랜잭션만 롤백되며 부모 트랜잭션은 롤백되지 않는다.\n\t- `NESTED` 트랜잭션은 데이터베이스의 세이브포인트 메커니즘을 사용하여 중첩된 트랜잭션의 시작 지점을 표시한다. 롤백 발생 시, 해당 세이브포인트까지만 롤백된다. 즉, `NESTED` 트랜잭션을 사용하려면 데이터베이스와 JDBC 드라이버가 세이브포인트를 지원해야 한다. \n\n**참고**\n- https://hwannny.tistory.com/98\n\n### readOnly 옵션\n\n기본적으로는 false로 설정되어 있다.\n\n**true로 설정하는 경우**: 데이터에 대해 Lock을 적용할 필요가 없고, 접근할 수 있는 데이터(스냅샷, 튜플 등)가 변경되지 않기 때문에 일관적인 데이터를 읽어오고 제공할 수 있다.\n\n조회 작업만 수행한다는 것을 명시적으로 나타낼 수 있다.\n\n#### MySQL에서의 readOnly\n\nSELECT 문에 대해서만 기능을 지원하고, Transaction ID 설정에 대한 오버헤드를 해결할 수 있다. (MVCC) \n즉, Read Only 트랜잭션에 대해서는 Transaction ID가 부여되지 않는다.\n\n별도의 스냅샷을 통해 데이터를 조회하기 때문에 데이터 일관성을 보장할 수 있다. \n데이터 변경과 같이 조회가 아닌 작업을 하는 경우 에러를 발생시킨다.\n\n- 스냅샷 : 데이터 수정 요청이 전달되었을 때, 변경되는 데이터를 따로 저장해두는 것.\n\n### isolation 옵션\n\n- `DEFAULT`: 기본적으로 `DEFAULT` 옵션이 적용되어 있다. 사용하는 DB의 기본 격리 수준을 따른다.\n- `READ_UNCOMMITTED` : 커밋되지 않은 데이터를 다른 트랜잭션에서 접근 가능하다.\n- `READ_COMMITTED` : 매 조회가 이루어질 때마다 새로운 스냅샷을 뜨기 때문에 다른 트랜잭션이 커밋하면 (변경 사항이 존재하면) 변경된 데이터를 볼 수 있다. 즉, B 트랜잭션이 끝나기 전에 A 트랜잭션에 의해 데이터가 변경되면 다시 조회할 때 변경된 데이터를 읽게 된다.\n- `REPEATABLE__READ` : 조회한 데이터에 대해 Shared Lock이 걸려서 다른 트랜잭션이 새로운 데이터를 추가할 수 있다. A 트랜잭션이 시작하고 처음 조회한 데이터의 스냅샷을 저장하고, 이후에 동일한 쿼리를 호출하면 해당 스냅샷에서 데이터를 가져온다. 즉, B 트랜잭션이 새로 커밋해도 (변경 사항이 있어도) A 트랜잭션이 조회하는 데이터는 변하지 않는다.\n- `SERIALIZED` : 읽기 작업에도 락을 걸어 여러 트랜잭션이 동시에 같은 데이터에 접근할 수 없다. 가장 안전하지만 성능 저하가 크기 때문에 자주 사용되지 않는다.\n\n### ProxyMode\n\n프록시를 생성하는 방식을 제어하는데 사용되는 옵션이다. \n\n1. ProxyMode.DEFAULT\n\t- 스프링이 프록시 모드를 결정한다.\n\t- 인터페이스를 구현하고 있는 경우에는 ProxyMode.PROXY를, 구현하지 않는 경우에는 ProxyMode.TARGET_CLASS를 사용한다.\n2. ProxyMode.PROXY\n\t- JDK 기반의 다이나믹 프록시를 생성한다.\n\t- 대상 객체가 인터페이스를 구현하고 있어야 한다.\n\t- 대상 객체의 인터페이스 메서드 호출 시 프록시를 거쳐 AOP 동작을 호출한다.\n3. ProxyMode.ASPECTJ\n\t- AspectJ를 사용하여 프록시를 생성한다.\n\t- 인터페이스를 구현하고 있지 않아도 된다.\n\t- 컴파일 타임에 AspectJ \n\n**갑자기 무슨 인터페이스라는 말인가...**\n\n> 스프링 AOP에서 ProxyMode.PROXY를 사용하는 경우, 대상 객체는 인터페이스를 구현하고 있어야 합니다. 이는 JDK 다이나믹 프록시를 사용하여 프록시 객체를 생성하기 때문입니다. 다이나믹 프록시는 인터페이스의 구현을 바탕으로 프록시 객체를 생성하므로, 대상 객체가 인터페이스를 구현하지 않으면 프록시를 생성할 수 없습니다. **by G-선생**\n"},{"excerpt":"Java Bean? 스윙에서 독립적인 GUI 컴포넌트의 개발을 용이하게 하기 위해 고안되었다.\n특정 형태의 클래스를 가리키는 뜻으로 사용된다. 다음의 조건을 만족해야 한다.  을 구현하여 직렬화가 가능해야 한다. public 기본 생성자를 가져야 한다. getter, setter를 가져야 한다. 모든 필드는 private으로 getter, setter를 …","fields":{"slug":"/bean/"},"frontmatter":{"date":"2023년 05월 29일 09:05","title":"Spring Bean","tags":["spring","개발"]},"rawMarkdownBody":"\n## Java Bean?\n\n스윙에서 독립적인 GUI 컴포넌트의 개발을 용이하게 하기 위해 고안되었다.\n특정 형태의 클래스를 가리키는 뜻으로 사용된다.\n\n다음의 조건을 만족해야 한다.\n- `Serializable` 을 구현하여 직렬화가 가능해야 한다.\n- public 기본 생성자를 가져야 한다.\n- getter, setter를 가져야 한다.\n- 모든 필드는 private으로 getter, setter를 통해 접근 가능해야 한다.\n\n## Spring Bean?\n\nSpring Container가 관리하는 객체이다. \nSpring Application의 기본 구성 요소이자, 다른 bean과 함께 연결하여 애플리케이션의 기능을 생성할 수 있는 재사용 가능한 구성 요소이다.\n\nXML, Java 어노테이션, `@Configuration` 같은 설정 클래스를 통해 정의된다.\n\n## 관련 문서\n\n- [[bean-scope]]\n- [[bean-candidate]]\n- [[mock-vs-mockbean]]\n\n### Spring Container에게 객체 생성과 관리를 위임하는 것의 장단점\n\n#### 장점\n- 의존성 주입을 사용하여 객체 사이의 결합도를 낮춘다. (클래스 내부에서 클래스 의존 관계를 설정하는 것이 아니라 스프링 프레임워크에서 자동으로 주입해주므로)\n- 객체의 생성, 초기화, 소멸 작업을 스프링 컨테이너가 담당하여 개발자는 비즈니스 로직에 좀 더 집중할 수 있다. \n- 다양한 bean 스코프에 따라 객체의 생명 주기, 스코프를 관리할 수 있다.\n- 애플리케이션의 객체 생성과 관리에 필요한 정보를 별도의 설정 파일 또는 클래스로 분리할 수 있다. 이를 통해 코드의 유연성과 재사용성을 높일 수 있다.\n\t- XML 설정 방식, Java 어노테이션, `@Configuration` 설정 클래스\n\n#### 단점\n- 객체 생성과 관리, 의존성 주입 등을 컨테이너가 담당하여 런타임에 약간의 오버헤드가 발생할 수 있다. (그러나 보통 이런 오버헤드는 성능에 큰 영향을 주지 않는다.)\n\n## Spring Bean Definition\n\n### 그게 뭔데\nSpring bean을 생성하고 구성하기 위한 설정 정보이다. \n어떤 클래스를 bean으로 사용할 것인지, 어떤 의존성을 주입할 것인지, bean의 scope 등을 정의한다.\n\n`@Component`, `@Service`, `@Repository`, `@Controller` 어노테이션을 사용해서 bean을 등록할 수 있다. 위와 같은 어노테이션을 달게 되면 해당 클래스를 컴포넌트 스캔 대상으로 지정하여 스프링 컨테이너가 자동으로 bean으로 등록한다.\n\nJava 설정 클래스를 사용하는 방식에서는 `@Configuration` 어노테이션이 지정된 클래스를 생성하고, `@Bean` 어노테이션을 사용하여 bean을 생성한다. \n`@Bean` 어노테이션을 붙인 메서드는 해당 메서드가 생성한 객체를 Spring Bean으로 등록한다. \n기본적으로 `@Bean` 어노테이션을 붙이게 되면 bean이 싱글톤으로 생성된다. \n\n### 언제, 어디서 초기화 될까?\nSpring Bean은 스프링 컨테이너가 시작될 때 초기화된다. \n\n`ApplicationContext`의 `refresh()` 메서드가 호출되면, 스프링 컨테이너의 초기화 과정이 시작된다. 스프링 컨테이너의 구성 요소들을 설정하고, bean definition을 로드하며, bean 객체를 생성한다.\n`refresh()` 내부에서 bean 생성 및 의존성 주입이 이루어진다. `DefaultListableBeanFactory` 가 bean definition을 관리하고, bean의 생성, 의존성 주입을 담당한다.\n\n`DefaultListableBeanFactory` 는 `refresh()` 메서드에서 `preInstantiateSingletons()` 메서드를 호출하여 모든 싱글톤 bean들을 생성하고 의존성 주입을 수행한다.\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {  \n   // Initialize conversion service for this context.  \n   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&  \n         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {  \n      beanFactory.setConversionService(  \n            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));  \n   }  \n  \n   // Register a default embedded value resolver if no BeanFactoryPostProcessor  \n   // (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:   // at this point, primarily for resolution in annotation attribute values.   if (!beanFactory.hasEmbeddedValueResolver()) {  \n      beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));  \n   }  \n  \n   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.  \n   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);  \n   for (String weaverAwareName : weaverAwareNames) {  \n      getBean(weaverAwareName);  \n   }  \n  \n   // Stop using the temporary ClassLoader for type matching.  \n   beanFactory.setTempClassLoader(null);  \n  \n   // Allow for caching all bean definition metadata, not expecting further changes.  \n   beanFactory.freezeConfiguration();  \n  \n   // Instantiate all remaining (non-lazy-init) singletons.  \n   beanFactory.preInstantiateSingletons();  \n}\n```\n\nbean 객체의 의존성 주입이 완료되면 초기화 메서드가 호출된다. \n`InitializingBean` 인터페이스를 구현한 빈은 `afterPropertiesSet()` 메서드가 호출되며, `@PostConstruct` 어노테이션이 지정된 메서드는 자동으로 호출된다.\n\n## Bean LifeCycle\n\nBean으로 등록된 객체들을 초기화하고 싶은 경우, 의존관계 주입이 완료된 후에 초기화 작업을 수행해야 한다.\n스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려준다. \n스프링 컨테이너가 종료되기 직전에는 소멸 콜백을 제공한다.\n\n### 과정\n\n1. 스프링 컨테이너 생성\n2. 스프링 빈 생성\n3. 의존 관계 주입\n4. 초기화 콜백 실행\n5. 사용\n6. 소멸 전 콜백 실행\n7. 스프링 종료\n\n### 생명주기 콜백\n\n#### `InitializingBean`, `DisposableBean`\n\n```java\n@Component  \npublic class Bean implements InitializingBean, DisposableBean {  \n    @Override  \n    public void destroy() throws Exception {  \n        System.out.println(\"소멸 콜백\");  \n    }  \n  \n    @Override  \n    public void afterPropertiesSet() throws Exception {  \n        System.out.println(\"초기화 콜백\");  \n    }  \n}\n```\n\n```shell\n2023-06-06 15:46:26.932  INFO 49436 --- [           main] hello.DemoApplication                    : No active profile set, falling back to 1 default profile: \"default\"\n2023-06-06 15:46:27.289  INFO 49436 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2023-06-06 15:46:27.298  INFO 49436 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2023-06-06 15:46:27.298  INFO 49436 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.65]\n2023-06-06 15:46:27.335  INFO 49436 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2023-06-06 15:46:27.336  INFO 49436 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 385 ms\n2023-06-06 15:46:27.348  INFO 49436 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2023-06-06 15:46:27.391  INFO 49436 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2023-06-06 15:46:27.396  INFO 49436 --- [           main] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:testdb'\n초기화 콜백\n2023-06-06 15:46:27.553  INFO 49436 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2023-06-06 15:46:27.559  INFO 49436 --- [           main] hello.DemoApplication                    : Started DemoApplication in 0.757 seconds (JVM running for 0.999)\n소멸 콜백\n2023-06-06 15:46:34.602  INFO 49436 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...\n2023-06-06 15:46:34.604  INFO 49436 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.\n```\n\n**단점만 있네**\n스프링 전용 인터페이스에 의존하게 되어, POJO 객체가 아니게 된다.\n초기화, 소멸 메서드의 이름을 변경할 수 없다.\n코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.\n스프링 초창기에 나온 방식으로 지금은 거의 사용하지 않는다.\n\n#### `@PostConstruct`, `@PreDestroy` 어노테이션\n\n스프링에서 가장 권장하는 방식. \n`javax.annotation.PostConstruct` 를 사용하여 스프링이 아닌 다른 컨테이너에서도 동작한다.\n\n```java\n@Component  \npublic class AnnotationBean {  \n    @PostConstruct  \n    public void initializeCallBack() {  \n        System.out.println(\"어노테이션 초기화 콜백\");  \n    }  \n  \n    @PreDestroy  \n    public void destroyCallBack() {  \n        System.out.println(\"어노테이션 소멸 콜백\");  \n    }  \n}\n```\n\n단, 외부 라이브러리에는 적용하지 못한다.\n\n#### `@Bean`의 `initMethod`, `destroyMethod`\n\n외부 라이브러리에도 적용할 수 있는 콜백 메서드 지정 방식이다.\n`@Bean`의 `initMethod`, `destroyMethod` 에 각각 문자열로 메서드 이름을 지정해주면 된다.\n\n```java\npublic class NormalBean {  \n    public void initMethod() {  \n        System.out.println(\"빈 설정 초기화 콜백\");  \n    }  \n  \n    public void destroyMethod() {  \n        System.out.println(\"빈 설정 소멸 콜백\");  \n    }  \n}\n```\n\n```java\n@Configuration  \npublic class Config {  \n    @Bean(initMethod = \"initMethod\", destroyMethod = \"destroyMethod\")  \n    public NormalBean getNormalBean() {  \n        return new NormalBean();  \n    }  \n}\n```\n\n#### 동시에 사용하면\n\n```shell\n2023-06-06 15:54:38.077  INFO 49507 --- [           main] hello.DemoApplication                    : No active profile set, falling back to 1 default profile: \"default\"\n2023-06-06 15:54:38.429  INFO 49507 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2023-06-06 15:54:38.432  INFO 49507 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2023-06-06 15:54:38.432  INFO 49507 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.65]\n2023-06-06 15:54:38.473  INFO 49507 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2023-06-06 15:54:38.473  INFO 49507 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 379 ms\n2023-06-06 15:54:38.484  INFO 49507 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2023-06-06 15:54:38.528  INFO 49507 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2023-06-06 15:54:38.533  INFO 49507 --- [           main] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:testdb'\n어노테이션 초기화 콜백\n초기화 콜백\n빈 설정 초기화 콜백\n2023-06-06 15:54:38.692  INFO 49507 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2023-06-06 15:54:38.699  INFO 49507 --- [           main] hello.DemoApplication                    : Started DemoApplication in 0.761 seconds (JVM running for 1.003)\n빈 설정 소멸 콜백\n소멸 콜백\n어노테이션 소멸 콜백\n2023-06-06 15:54:40.466  INFO 49507 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...\n2023-06-06 15:54:40.469  INFO 49507 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.\n```\n\n신기하게도 언제나 어노테이션 초기화 콜백이 가장 먼저 불리고, 그다음은 `InitializingBean` 초기화 콜백, 마지막은 `@Configuration`에 설정해둔 초기화 콜백이 마지막으로 불린다.\n소멸은 반대 순서로 이루어진다. 신기하네\n\n## Bean Injection\n\n## Bean 등록 방법\n\nxml 방식도 있지만 자주 사용되지 않는 방식이니 제외했다.\n\n### `@Configuration`\n\n`@Configuration` 에서 수동으로 Bean을 등록해줄 수 있다. \n```java\n@Configuration  \npublic class Config {  \n    @Bean  \n    public NormalBean getNormalBean() {  \n        return new NormalBean();  \n    }  \n}\n```\n\n메서드 이름으로 bean 이름이 결정되니, 중복된 빈 이름이 존재하지 않도록 주의해야 한다.\n스프링 빈으로 등록된 다른 클래스 안에서 `@Bean` 으로 직접 빈을 등록해주는 것도 동작은 하지만, `@Configuration` 내부에서 `@Bean` 을 사용해야 싱글톤을 보장받을 수 있다. \n\n```java\n@Component  \npublic class CustomBean {  \n    @Bean  \n    @Scope(value = \"singleton\")  \n    public OtherBean getOtherBean() {  \n        return new OtherBean();  \n    }  \n}\n```\n\nbean을 싱글톤으로 생성하도록 설정해도 `getOtherBean` 을 호출할 때마다 계속해서 여러 객체가 생성된다.\n\n**어떤 때에 `@Bean` 을 쓰면 좋을까** \n\n다음과 같은 경우에 `@Bean` 으로 직접 빈을 등록해준다. \n1. 개발자가 직접 제어가 불가능한 라이브러리를 활용할 때 (외부 라이브러리 사용)\n2. 애플리케이션 전범위적으로 사용되는 클래스를 등록할 때\n3. 다형성을 활용하여 여러 구현체를 등록해주어야 할 때\n\n애플리케이션 전범위적으로 사용하는 클래스와 다형성을 활용하여 여러 구현체를 등록할 때 `@Bean` 을 사용하면 좋은 이유는 유지보수하기 좋기 때문이다. \n여러 구현체를 빈으로 등록할 때 어떤 구현체가 빈으로 등록되는지 파악하려면 `@Configuration` 만 확인하면 되어 유지보수가 용이하다.\n\n### `@Component`\n\n컴포넌트 스캔을 사용해서 `@Component` 어노테이션이 있는 클래스들을 찾아서 자동으로 빈 등록을 해준다.\n`@Service`, `@Controller`, `@Repository` 등은 `@Component` 어노테이션을 갖는다.\n\n원래 `@Component` 를 이용할 때 Main이나 App 클래스에서 `@ComponentScan` 으로 컴포넌트를 찾는 탐색 범위를 지정해주어야 하지만, SpringBoot 에서는 `@SpringBootConfiguration` 하위에 기본적으로 포함되어 있어 별도 설정이 필요 없다.\n\n**참고**\n- https://mangkyu.tistory.com/75"},{"excerpt":"LOG 잠깐 잠실에 가서 코드 리팩토링을 하는 시간을 가졌다. 생각보다 뼈대 코드를 리팩토링할 부분이 많아서, 오늘은 도메인과 엔티티를 분리하고 Repository를 만들었다. 배운 것  에서   에는 primary key를 적어주어야 한다. 다른 키를 함께 적게 되면 다른 키도 primary key로 인식되는 듯 하다. (composite key? 로 …","fields":{"slug":"/2023-05-28/"},"frontmatter":{"date":"2023년 05월 28일 14:05","title":"2023년 05월 28일","tags":null},"rawMarkdownBody":"## LOG\n- 잠깐 잠실에 가서 코드 리팩토링을 하는 시간을 가졌다. 생각보다 뼈대 코드를 리팩토링할 부분이 많아서, 오늘은 도메인과 엔티티를 분리하고 Repository를 만들었다. \n\n## 배운 것\n- `SimpleJdbcInsert` 에서  `usingGeneratedKeyColumns` 에는 primary key를 적어주어야 한다. 다른 키를 함께 적게 되면 다른 키도 primary key로 인식되는 듯 하다. (composite key? 로 인식하는 듯)\n- termius 좋다. 코드 템플릿도 적어두고 재사용 가능하고, 서버와 쉽게 연결 가능한 것도 좋다. 앞으로도 애용할 듯. 특히 ip 주소 까먹는 경우가 많은데 그래서 그런지 템플릿 기능이 매우 유용하다...\n- mysql 서버와 production 서버가 연결되지 않았던 이유: 외부에서는 root 권한으로 접근할 수가 없다. 따라서 production 서버를 user로 등록해서 외부에서도 연결할 수 있도록 user 테이블에 추가해주어야 한다. + 우리는 vero, hubk, dazzle 데이터베이스가 다 다른데, 각각의 유저에 데이터베이스에 접근할 수 있는 권한도 추가해주어야 했다.\n\n```sql\n+--------------------------------------------------------------+\n| GRANT USAGE ON *.* TO `wooteco`@`ip주소`                      |\n| GRANT ALL PRIVILEGES ON `vero`.* TO `wooteco`@`ip주소`        |\n+--------------------------------------------------------------+\n```\n\n- 진짜 이상하게도 아래 sql은 bad sql이라는 예외가 발생한다.\n```sql\nSELECT ci.id, ci.member_id, ci.quantity, \nm.email, m.point, \np.id, p.name, p.price, p.image_url\nFROM cart_item ci \nINNER JOIN member m ON ci.member_id = m.id\nINNER JOIN product p ON ci.product_id = p.id\nWHERE ci.member_id = ?\n```\n\n이걸 해결하려면 무조건 AS로 column 이름을 지정해줘야 한다.\n\n```sql\nSELECT ci.id AS cart_id, \nci.member_id AS cart_member_id, \nci.quantity AS cart_quantity,\nm.email AS member_email, \nm.point AS member_point, \np.id AS product_id, \np.name AS product_name, \np.price AS product_price, \np.image_url AS product_image_url \nFROM cart_item ci \nINNER JOIN member m ON ci.member_id = m.id   \nINNER JOIN product p ON ci.product_id = p.id   \nWHERE ci.member_id = ?\n```\n\n## 궁금한 것\n- 왜 저게 bad sql 일까\n\n## 느낀 것\n- 오늘도 기분이 좋다~ 비도오고 그래서~ 비오는 날이 안 좋기만 한 건 아닌 것 같다. 끈적거리고 습하고 우산들고 있는 팔은 아프지만 그래도 비오는 날만의 장점이 있다. 장점은 구체적으로 칭찬 안 하고 싶으니까 여기까지~"},{"excerpt":"앞으로 회고 모임에 적는 글들을 여기에도 올려보려고 한다 ˙ᵕ˙ 🌈 이번 주의 생각 💭 즐선생님, 헙선생님과 장바구니 협업 페어가 되었다. 프론트엔드인 도밥과 아이크도 정말 좋으신 분들이다. 특히 질문이 많으셔서 좋다. 나는 언제나 강의든 과외든 하게 되면 질문을 해달라고 하는 편이었는데, 그런 말을 하지 않아도 궁금한 게 많고 물어보기를 주저하지 않아서…","fields":{"slug":"/level2-seventh-retrospect/"},"frontmatter":{"date":"2023년 05월 28일 14:05","title":"레벨2 7주차 회고","tags":["회고"]},"rawMarkdownBody":"\n앞으로 회고 모임에 적는 글들을 여기에도 올려보려고 한다 ˙ᵕ˙\n\n## 🌈 이번 주의 생각 💭\n\n-   즐선생님, 헙선생님과 장바구니 협업 페어가 되었다. 프론트엔드인 도밥과 아이크도 정말 좋으신 분들이다. 특히 질문이 많으셔서 좋다. 나는 언제나 강의든 과외든 하게 되면 질문을 해달라고 하는 편이었는데, 그런 말을 하지 않아도 궁금한 게 많고 물어보기를 주저하지 않아서 좋다.\n    -   프론트엔드 분들과 잠실에서 만나서 요구사항 정의하고 명세를 정리했던 시간이 생각보다 너무 즐거웠다. 이번 페어의 컨셉은 ‘모든 생각들을 기록으로 남겨보자’ 였는데, 의외로 정리하는 시간이 즐거워서 앞으로도 페어하면서 정리하는 습관을 길러야겠다.\n    -   즐선생님은 내가 생각하지 못한 부분을 잘 짚어주신다. 헙선생님과 내가 프론트엔드에서 고려해야 하는 사항을 적을 때 즐선생님은 옆에서 이런 문제가 있을 수 있다, 이런 경우에는 어떻게 해야 할까를 항상 물어봐줘서 예외 케이스를 생각하는데 도움이 많이 됐다.\n    -   헙선생님은 뭔가 뚝딱해오신다. mysql 연결 문제가 있었을 때도 한 시간 만에 해결해오시고, logback 설정도 어떻게 알아오셔서 전체 로그와 warn 로그를 분리하는 기능까지 뚝딱 구현해 오셨다. 엄청 신기하다 ㅋㅋㅋ\n    -   나도 칭찬해보자. 이번 페어 때는 기록을 열심히 했다. 어떤 고민을 했고, 어떤 선택을 했는지를 (다는 아니지만) 적어두어서 지금 볼 때도 이런 생각으로 판단을 내렸다는 것을 확인할 수 있어 좋다. 의견을 낼 때는 장단점을 동시에 이야기 했다. 다른 사람이 판단을 할 때 좋고 나쁨을 확실하게 알고 판단하는 것이 좋다고 생각한다. 그래서 이게 무조건 좋다! 무조건 나쁘다! 보다는 이런 경우에는 좋다, 이런 경우에는 안 좋을 수 있다라는 화법으로 의견을 제안하니 다른 사람이 선택하기에 수월했던 것 같다.\n-   matzip에 좀 더 시간을 투자했다. 오리와 페어도 열심히 하고, PR 올라온 것도 보는 시간을 가졌다. 시간이 많지 않아 소홀했던 점이 아쉽다. 앞으로의 계획에 대해 회의하는 시간도 가졌는데, 의견이 빠르게 하나로 모이지는 않았지만 나는 그것대로 좋았다고 생각한다. 계획대로 안 되는 것도, 하고 싶은 게 많은 것도, 서로의 가치관과 생각이 다른 것도 어쩌면 당연한 것이라 자연스러운 일이었다. 만약 서로의 의견을 중재하는 사람이 필요해진다면 내가 해보고 싶다. 나는 크게 의견이 있는 사람이 아니라서, 의견을 좀 더 객관적으로 볼 수 있지 않을까 싶다. 그냥 그렇다고 ㅋㅋ\n-   그것과는 별개로 matzip에서 배우는 내용이 많다. 서브모듈도 matzip이 아니었다면 몰랐을 거고, 멀티 모듈이며 graceful shutdown도 하나도 몰랐을 것 같은데 알아가는 키워드들이 많아서 좋다. 4기 오리가 열심히 페어해주시는 것도 감사하다. 퇴근하고 솔직히 쉬고 싶으실 텐데 우리가 matzip을 이어나갈 우테코 후배 기수라는 이유만으로 도움을 주시는 것에 굉장한 감사를 느끼고 있다. 감사합니다 오리 🫶🏻\n-   새싹 교실이 끝났다. 인터페이스까지 다루지 못해 아쉬움을 느끼지만, 그래도 개인적으로 지금까지 강의했던 것에 비해 많이 늘었다고 느낀다. 처음에는 단지 정보 전달을 하기 위해 급급해서 재작년까지는 솔직히 새싹들에게 크게 도움이 된 건 아니었다고 생각한다. 그렇지만 이번에는 왜 이걸 써야 하는지, 왜 이렇게 하는 것이 좋은지 내가 고민했던 부분을 최대한 전달하려고 애썼다. 단순히 int의 범위나 상속을 하는 방법을 알려주는 게 아니라, 왜 변수를 써야하고 왜 final을 써야 하는지 등 개인적으로 고민했던 내용들을 전달하는 것에 중심을 두어서 나도 수업하면서 즐거웠다. 한 주만 더 있었다면 좋았겠다는 생각도 했다. (그렇지만 앞으로 2주가 시험기간이기 때문에 욕심은 마음에 고이 접어두었다…)\n\n## ✨ Keep\n\n> 현재 만족하고 있는 부분, 앞으로도 유지하고자 하는 부분\n\n-   지금의 소통하는 방식이 마음에 든다. 의견을 말할 때 무조건 장단점, 발생될 수 있는 효과를 동시에 말하는 습관을 들이자. 다른 사람이 내 의견을 듣고 나서 좀 더 쉽게 결정내릴 수 있게 된다.\n-   페어하면서 고민했던 내용을 정리하고, 어떤 주제에 대해 서로 의견을 나눴던 내용을 정리하자. 의외로 시간도 얼마 들지 않고 기록해 놓은 글이 나중에 너무 도움이 된다.\n\n## 🔥 Problem\n\n> 불편하거나 아쉽게 느끼는 부분, 앞으로 개선이 필요한 부분\n\n-   TIL을 많이 못 썼다. 할 일도 많긴 했지만 많이 놀아서도 맞다. 집에 가서 TIL 안 쓰고 놀거나 그냥 누워버리는 일이 잦았다. 최대한 그 날 알게 된 내용은 바로바로 적는 습관을 들여야겠다. 느낀점, LOG가 없더라도 배운 점이라도 있다면 좋을 거 같다.\n-   감정에 솔직하려고 노력했지만, 언제나 솔직하지는 못했다. 가끔 다른 사람의 눈치를 본 것도 있고, 내가 정말로 이 감정을 가지고 있는지 자신이 없는 경우도 있었다. 그럴 때 생각을 잠깐 멈추고 내가 어떤 생각을 하고 있는지, 정말로 원하고 있는 게 맞는지를 생각해보자.\n-   이번 주는 조금 피곤했다. 너무 늦게까지 깨어 있지 말고 졸릴 때 바로 자는 습관을 들여보자.\n\n## ⭐️ Try Problem\n\n> 잘하고 있는 것을 더 잘하기 위해, 당장 시도해 볼 부분\n\n-   틈틈이 matzip 코드를 읽어보자. 어떤 부분부터 읽자! 하고 읽기 보다는 이 부분 궁금한데 한 번 봐볼까? 라는 느낌으로 읽어보는 게 좋을 거 같다.\n-   미래 계획을 세워보자. 단기 목표도 좋고, 장기 목표도 좋다. 내가 무엇을 하고 싶은지 찾아갈 수 있는 좋은 기회가 될 것이다.\n\n## 📚 다음 주 목표\n\n-   무사히 협업 미션 제출하기\n-   내 감정에 솔직하게 살아가기\n-   다음 주 안에 목표가 무엇일지 생각해보고 글로 정리하기"},{"excerpt":"LOG 2시에 matzip 회의가 있었다. 루루, 체인저, 애슐리, 주드와 오찌, 블링, 오리가 참석했다. 나는 에어팟이 없어서 250만원짜리 전화기를 썼다... 근데 진짜 하나도 안 들려서 그냥 정리해준 거 봤다. 체인저 나이스. 생산적인 회의였다. 지하철 미션 제출했다. 리뷰 온 지 4일만에 죽은 자 가운데서 다시 태어나시고.. 하나의 쿼리로 모든 노…","fields":{"slug":"/2023-05-27/"},"frontmatter":{"date":"2023년 05월 27일 13:05","title":"2023년 05월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 2시에 matzip 회의가 있었다. 루루, 체인저, 애슐리, 주드와 오찌, 블링, 오리가 참석했다. 나는 에어팟이 없어서 250만원짜리 전화기를 썼다... 근데 진짜 하나도 안 들려서 그냥 정리해준 거 봤다. 체인저 나이스. 생산적인 회의였다.\n- 지하철 미션 제출했다. 리뷰 온 지 4일만에 죽은 자 가운데서 다시 태어나시고.. 하나의 쿼리로 모든 노선을 조회할 수 있도록 변경한 게 뿌듯했다. 근데 다시 돌아보면 이런 간단한 걸 왜 못했을까 싶긴 했다. 아무래도 select * 를 쓰면 조인이 제대로 안 됐는데 조회하는 컬럼의 이름을 지정해주면 조인이 잘 된다.\n\n## 배운 것\n- `@Positive` 를 컨트롤러 `@PathVariable`에 적어줄 수 있다. 다음과 같이 사용할 수 있다. \n\n```java\n@Validated  \n@RestController  \n@RequestMapping(\"/path\")  \npublic class PathController {  \n    private final PathService pathService;  \n  \n    public PathController(final PathService pathService) {  \n        this.pathService = pathService;  \n    }  \n  \n    @GetMapping(\"/{startStationId}/{endStationId}\")  \n    public ResponseEntity<ShortestPathResponse> findShortestPath(  \n            @PathVariable(\"startStationId\") @Positive(message = \"역 ID는 양수여야 합니다.\") final Long startStationId,  \n            @PathVariable(\"endStationId\") @Positive(message = \"역 ID는 양수여야 합니다.\") final Long endStationId  \n    ) {  \n        ShortestPathResponse shortestPathResponse = pathService.findShortestPath(startStationId, endStationId);  \n        return ResponseEntity.ok(shortestPathResponse);  \n    }  \n}\n```\n\n이때 리턴하는 예외는 `ConstraintViolationException` 이다. 해당 예외를 처리하기 위해 `@ControllerAdvice`  에 다음과 같이 작성해주었다. \n\n```java\n@ExceptionHandler(ConstraintViolationException.class)  \npublic ResponseEntity<ErrorResponse> handleNotFoundException(ConstraintViolationException e) {  \n    List<String> errorMessages = List.of(e.getMessage().split(\": \"));  \n    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(errorMessages.get(1)));  \n}\n```\n\n`ConstraintViolationException` 예외의 메시지는  `findShortestPath: \"역 ID는 양수여야 합니다.\"` 라고 전달되기 때문에 파싱해주는 작업을 추가로 진행하였다. \n\n## 궁금한 것\n- `ConstraintViolationException` 메시지는 무조건 저런 형태로 나오나?\n\n## 느낀 것\n- "},{"excerpt":"앞으로의 계획 크레딧을 가지고 전체 배포와 인프라 쪽을 옮겨오는 작업 CI/CD 안 되어 있음. 기존에는 손배포 진행 -> jar 로컬에서 만들어서 scp 후 run CI는 github action 으로 되고 있음. CD도 github action을 쓸 것이다. jenkins를 좀 더 실무에서 많이 쓴다. 쓰는 이유: jenkins의 플러그인들이 다양하고…","fields":{"slug":"/ori-05-26/"},"frontmatter":{"date":"2023년 05월 26일 13:05","title":"5월 26일 오리와 페어","tags":["matzip"]},"rawMarkdownBody":"\n### 앞으로의 계획\n- 크레딧을 가지고 전체 배포와 인프라 쪽을 옮겨오는 작업\n- CI/CD 안 되어 있음. 기존에는 손배포 진행 -> jar 로컬에서 만들어서 scp 후 run\n- CI는 github action 으로 되고 있음. CD도 github action을 쓸 것이다. jenkins를 좀 더 실무에서 많이 쓴다.\n\t- 쓰는 이유: jenkins의 플러그인들이 다양하고, 플러그인을 사용하기 위해 어쩔 수 없이 쓴다.(Circle CI) 커스텀이 편해서 대부분의 회사가 쓴다.\n\t- 안 쓰는 이유: 새로 구축하는 것이 귀찮다. 젠킨스용 서버를 따로 띄워야 해서 계속 관리를 해주어야 한다. (번거로움)\n\t- 손배포 할 때 메모리가 터진다. t4g.micro는 메모리가 딸리는데 jenkins 빌드할 때는 메모리가 중요하다. `./gradlew bootJar`는 메모리가 필요하다. 그러나 스왑 메모리 설정을 하면 매우 느리다.\n\t- 서버 관리 필요 없고, 메모리 관리가 필요 없는 github action을 쓸 것이다.\n- CI github action (확정)\n- CD github action (예정)\n\n### 기존 서버 설명\n- EC2\n\t- 실제 서버 application\n\t\t- 스프링 서버\n\t\t\t- 내부에서 ssl 설정을 해줄 수 있지만 안하는 이유? : 스프링 서버는 application(api 제공)의 역할만 해야 한다. \n\t\t\t- ssl을 수행할 수는 있지만, ssl을 관리하는 역할을 수행하면 안 된다.\n\t\t- nginx\n\t\t\t- ssl 인증을 할 때 443 포트로 요청을 한다. ssl redirect, dns 요청을 처리하는 역할\n\t\t\t- 통신 전반에 대한 처리를 수행한다.\n\t\t\t- https -> http + ssl 인증서\n\t- 테스트용 데이터베이스 서버\n- RDS (프리티어 사용할 예정)\n\t- 실제 서버 데이터베이스\n- 호스팅\n\t- 가비아 (블링)\n\t- 모두 수행한 후에 블링에게 옮겨달라고 요청하면 된다.\n\n### 오늘 해야 하는 것\n#### 기존 인프라 구조 가져오기\n- [x] aws ec2 테스트용 데이터베이스를 가져와서 로컬에 저장해둔다.\n\t- 성능 테스트용 데이터베이스 (리뷰 데이터가 1000만~2000만건이 들어가있다.)\n- [ ] aws rds 데이터베이스를 가져와서 dev.matzip에 올리기\n\t- 데이터 가져오기\n\t- security group 설정\n\t\t- 인바운드, 아웃바운드 설정\n- [x] aws ec2에 있는 nginx config 설정 값 가져와서 로컬에 저장해둔다.\n\t- 코드 보고 이해하기\n- [ ] github action에 CI용 yml script 정리 -> 오리가 과제로 내주기로 했다\n\n#### 인프라 구조 구축하기 (언젠가 누구든)\n- 새로 띄운 aws ec2를 dns에 붙이는 것 (블링한테 요청하기)\n- github action cd 구축\n\n#### 나중에 추가로 할 것들\n- 무중단 배포\n웬만하면 우테코 교육 과정 내에서 배우는 정도로 진행할 것.\n\n## 진행\n- 탄력적 IP는 언제나 할당하자. 안 그러면 과금되니까!\n- 프라이빗 IPv4을 막아두어야 하는 이유?\n\t- 퍼블릭 IP가 열려야 외부에서 접근할 수 있다.\n\t- 데이터베이스가 퍼블릭 IPv4가 열려있으면 디도스 공격을 맞을 수 있다. \n\t- application 서버가 디도스를 맞더라도 앞 단에서 조치를 취할 수 있기 때문에 프라이빗 ip는 막아두는 것이 좋다.\n- 굳이 서버 설정에서 퍼블릭 ip를 쓸 이유가 없다.\n\n### 설명해주신 개념들\n- 프록시 서버: 요청을 대리하는 것. 프론트 단에서 프록시 서버가 있어서 프론트의 요청을 대신 넘겨주는 역할을 한다. \n- 리버스 프록시: 백엔드 서버 앞에서 요청을 필터링하는 역할을 한다.\n- 게이트웨이: 요청에 대한 처리들을 앞쪽에서 처리해주는 것.\n- 사이드카 패턴: spring boot 애플리케이션이 nginx를 사이드카처럼 데리고 다닌다\n\t- 사이드카를 붙이든 떼어내는 것처럼 애플리케이션의 기능에 영향을 주지 않고 추가 기능을 적용할 수 있다.\n\n## 오늘 한 것\n- 테스트 DB dump (복사)\n\t- `scp -i pem키 복사할파일 ssh유저이름@주소:복사할파일경로/파일명`\n\t- `mysqldump -uroot -p루트비밀번호 데이터베이스이름 > 경로/저장될파일명.sql`\n- nginx config 코드 이해하기\n- github action ci 코드 읽어보기\n"},{"excerpt":"페어 기록 ori-05-26 ohzzi-05-30 ori-06-08","fields":{"slug":"/matzip_pair/"},"frontmatter":{"date":"2023년 05월 26일 13:05","title":"matzip 페어 활동","tags":["matzip","우테코"]},"rawMarkdownBody":"\n## 페어 기록\n- [[ori-05-26]]\n- [[ohzzi-05-30]]\n- [[ori-06-08]]\n"},{"excerpt":"LOG 도밥과 아이크가 잠실로 와서 같이 점심을 먹었다. 원래 59쌀피자에 가려고 했는데 사람이 많아서 나왔더니 갈 곳이 없었다. 가까운 식당 중에 그나마 괜찮은 곳이 연어식당이어서 거기서 밥을 먹었다. 32000원짜리 카이센동 먹은 아이크... 멋지다. 역시 롯데타워 오너는 다르다 ㄷㄷ 프론트 분들이랑 같이 이야기 하는 거 되게 재밌었다. 질문을 많이 …","fields":{"slug":"/2023-05-26/"},"frontmatter":{"date":"2023년 05월 26일 07:05","title":"2023년 05월 26일","tags":null},"rawMarkdownBody":"\n## LOG\n- 도밥과 아이크가 잠실로 와서 같이 점심을 먹었다. 원래 59쌀피자에 가려고 했는데 사람이 많아서 나왔더니 갈 곳이 없었다. 가까운 식당 중에 그나마 괜찮은 곳이 연어식당이어서 거기서 밥을 먹었다. 32000원짜리 카이센동 먹은 아이크... 멋지다. 역시 롯데타워 오너는 다르다 ㄷㄷ 프론트 분들이랑 같이 이야기 하는 거 되게 재밌었다. 질문을 많이 해주신 도밥에게 감사합니다.\n- 오리와 페어를 했다. 기록은 여기에 -> [[ori-05-26]] \n- matzip 기획 회의를 했다. 사실 까먹었는데 ㅋㅋㅋ 다행히 4시간 전에 알게 돼서 준비를 할 수 있었다. 아찔하다. 요즘에 todo를 안 써서 그런가 너무 일정이 아무것도 기억이 안 난다. 앞으로 다시 열심히 써보자.\n\n## 배운 것\n- restdocs가 별로인 이유 by 오리: 별도 테스트를 작성하는 리소스가 발생한다. asciidocs을 내가 관리해야 한다. (완전 자동화 아님) -> 차라리 swagger 쓰고 말지\n- https의 기본 포트는 443이다.\n- 리버스 프록시가 http 요청이 들어왔을 때 https로 리다이렉트를 해준다.\n- ssh 연결로 파일을 보낼 수 있다 : `scp -i pem키 전송할파일 접속할호스트이름@파일을보낼서버IP:복사할파일경로/복사할파일이름`\n- `@PropertySource` 를 사용하면 external properties를 가져올 수 있다. + 환경 변수로도 properties의 경로를 받아서 값을 전달해줄 수 있다.\n\t- 그냥 이 방법 자체가 별로다 by 오리 -> 대체제로는 submodule 이랑 뭔가 더 있었다...\n\t- 환경 변수를 쓰는 게 별로인 이유 by 오리: 환경 변수를 쓴다면 배포 스크립트가 존재할텐데, 여러 서버에서 동일한 애플리케이션을 실행할 때마다 스크립트가 공유되어야 한다. \n- 80 포트를 쓸 때는 관련 코드에 sudo 써야 한다.\n\t- `sudo fuser -k 80/tcp`\n\t- `sudo nohup java -jar jwp-shopping-order.jar &`\n\t- chat.gpt 인용\n\t> 일반적으로 1024보다 낮은 포트(80 포트 포함)는 관리자 권한이 필요합니다. EC2 인스턴스에서 애플리케이션을 80 포트로 실행하려면 애플리케이션을 루트 또는 슈퍼 유저 권한으로 실행해야 합니다. 예를 들어, `sudo` 명령어를 사용하여 애플리케이션을 실행해 보세요.\n\n - Well known port (0~1023번 포트)는 sudo 권한이 필요하다. 키워드 제공 by 포이\n\n## 궁금한 것\n- submodule 말고 다른 방법이 더 있었던 거 같은데 뭐였을까 (솔라가 키워드를 말해주셨던 거 같은데 기억이 안 난다. 물어보자~)\n\n## 느낀 것\n- 선한 의도로 선한 영향력을 끼치는 사람이 멋지다. 바로 오리. 퇴근하고 나서 피곤하고 귀찮으실텐데 아무런 대가도 없이 우테코 후배 기수라는 이유 하나만으로 굉장히 많은 도움을 주신다. 오리는 안 보시겠지만 항상 감사하고 있습니다 🚀 나도 선한 의도로 선한 영향력을 끼칠 수 있는 사람이 되고 싶다.\n- 아이크와 도밥이 열정적이어서 협업하는 것이 즐겁다. 두 분 다 궁금하거나 이해가 잘 안 되는 부분, 잘 모르겠는 부분을 적극적으로 말해주셔서 대답하는 것도 즐겁고 토론하는 것도 너무 재밌었다. 그것과는 별개로 ec2 db 연결하는 부분이 잘 안 돼서 나는 결국 해결 못하고 집에 갔다. 즐선생님과 헙선생님 두 분이 갑자기 해결해주셔서 황송했다... 감사합니다."},{"excerpt":"페어 규칙 시간은 재지 않고 진행한다. 궁금한 점이나 의견은 언제든지 자유롭게 말한다. 분위기에 끌려가지 말기. 둘 다 좋다고 하지 않기 -> 진짜 둘 다 좋은 경우에는 각각 좋은 이유를 말할 것. 마음 속에 뭔가 정답이 있는 경우에는 그냥 말하기. 경청 잘하기. 유저 받아서 변경하기 pull 로 바꾸기 기존에 디렉토리가 존재하면 pull, 없으면 clo…","fields":{"slug":"/level2-shopping-order/"},"frontmatter":{"date":"2023년 05월 23일 05:05","title":"레벨2 장바구니 협업 with 다즐 헙크","tags":["우테코","레벨2"]},"rawMarkdownBody":"\n## 페어 규칙\n- 시간은 재지 않고 진행한다.\n- 궁금한 점이나 의견은 언제든지 자유롭게 말한다. 분위기에 끌려가지 말기. \n- 둘 다 좋다고 하지 않기 -> 진짜 둘 다 좋은 경우에는 각각 좋은 이유를 말할 것.\n\t- 마음 속에 뭔가 정답이 있는 경우에는 그냥 말하기.\n- 경청 잘하기.\n\n### 유저 받아서 변경하기\n\n```shell\n#!/bin/sh\n\n# kill process\nfuser -k 8080/tcp\n\n# remove original code\nrm -rf jwp-shopping-order\n\n- [ ] # clone git main branch\ngit clone https://github.com/$1/jwp-shopping-order.git\n\n# build\ncd jwp-shopping-order\n./gradlew bootJar\n\n# execute\ncd build/libs\nnohup java -jar jwp-shopping-order.jar &\n```\n\n### pull 로 바꾸기\n\n- 기존에 디렉토리가 존재하면 pull, 없으면 clone\n\n```shell\n#!/bin/sh\n\n# kill process\nsudo fuser -k 80/tcp\n\n# clone git main branch\nif [ -d ~/jwp-shopping-order ]\nthen\n\tcd jwp-shopping-order\n\tgit pull origin $2\nelse\n\tgit clone https://github.com/$1/jwp-shopping-order.git\n\tcd jwp-shopping-order\nfi\n\n# build\n./gradlew bootJar\n\n# execute\ncd build/libs\nsudo nohup java -jar jwp-shopping-order.jar &\n```\n\n### https 설정하기\n- **도메인 사서 설정 -> cloudfare** \n\t- 서브 도메인 사용\n\n## 2단계\n\n### 필수 구현 사항\n\n- 추가될 테이블\n\t- ![[table_schema.png]]\n- 상품 주문하기 API\n- 주문 상세 정보 API\n- 사용자 별 주문 목록 확인\n- 특정 주문의 상세 정보 확인\n\n## 선택 구현 사항\n\n### 프론트가 추가 할 것 같은 부분?\n- 주문하기 버튼\n- 차감되는 포인트 (항상 전체 사용이냐 아니면 선택할 수 있게 하느냐)\n\t- 사용되는 포인트 프론트로부터 받는다. -> 값을 수정해야 한다.\n\t- 언제나 제공된 포인트까지만 입력할 수 있도록 넣어야 한다. (프론트에서 처리 필요)\n- 최종 결제 금액 (계산 로직 - 프론트에서 처리)\n- 백엔드로 전달되어야 하는 것\n\t- 사용한 포인트\n\t- 최종 결제 금액 -> 사용자의 포인트 계산 (백엔드에서 처리)\n\n### 프론트에게 질문\n- `/orders` 요청 한 번에 정보를 다 주는데 굳이 상세 정보 API가 필요할까? (클라이언트 단에서 캐싱하면 되는데)\n\t- `/orders` (모든 주문 정보)\n\t- `/orders/{orderId}` (주문 상세)\n\t- orders 페이지를 안 거치고 갈 가능성 있으므로 (주문 상세 페이지로 바로 들어가게 되는 경우도 존재할 것이다.) 따라서 필요하다.\n- 모든 정보를 다 주는 것 vs 현재 필요한 정보만 주는 것\n\t- 어차피 필요한 것은 프론트에서 선별하기 때문에 다 내려줘도 괜찮다 by 도밥\n\t- 뷰는 변화에 민감하므로 계속해서 변경될 수 있지만, 뷰의 변화에 따라 API가 변화하는 것은 바람직하지 않다. url에 맞는 정보를 최대한 제공해서 뷰가 변화할 때마다 필요한 정보를 선별하는 것이 낫다. by 포이\n\n### 백엔드에서 구현해야 하는 사항\n- 기존 애플리케이션에 포인트를 추가한다.\n- 계산 시에 포인트를 차감해서 할인을 받도록 한다.\n- 포인트는 현금과 1:1 매칭\n- 포인트는 어떻게 제공되나? -> 최종 결제 금액에서 10% 포인트 적립\n\n###  기존 코드 수정 필요\n- 도메인 검증 로직 추가\n- `delete cascade` 제외했으므로 product 삭제 시 `cart_item`도 삭제하는 로직 필요\n- DB 주소 `application.properties`\n\t- 서브 모듈은 기각 -> 각각의 데이터베이스가 다르므로 `application.yml`에 들어가야 할 DB 링크도 달라지게 된다. 그렇다면 파일을 여러 개를 만들어야 하는데 (헙크, 나, 다즐 용으로) 그러면 굳이 하나의 레포에서 관리할 이유가 없다. 여러 개의 레포를 사용하는 것이 오히려 나을 수 있다. 근데 그런 경우에는 굳이 서브 모듈을 사용할 필요가 있을까?\n\t- `application external properties`를 사용하자.\n\n## 함께 자라기 🌱\n\n### url 길이 조정\n- image_url이 255는 너무 작은 것 같다. -> internet explorer의 url 최대 길이인 2048로 변경\n\n### 엔티티와 도메인은 분리되어야 하는가?\n- 최대한 분리하는 것이 좋다.\n\n### dao, repository, service, controller 테스트?\n- dao: `@JdbcTest`\n- repository: `@JdbcTest`\n- service: `@SpringBootTest`\n- controller: 안 함\n\n### DB를 믿을 것인가? (선택)\n- FK가 걸려 있음에도 findById를 수행해야 하는가? vs 굳이 할 필요 없다.\n\t- 다즐: DB의 예외가 서비스 계층으로 올라오는 것이 좀 별로다.\n\t- 헙크: 좀 믿자ㅋㅋ\n\n- equals -> id로 정의\n\n### 도메인 동등성?\n\n### 어디까지 확장성을 고려해야 할까?\n\n## 논의할 내용\n- [x] 뭔가를 찾을 수 없으면 NOT_FOUND로 한다.\n- [x] orders에 delivery_fee 추가 \n\t- 프론트가 배송비를 알려줘야 하나?\n\t\t- 알려줄 때: deliver_fee가 유연하다. 이 값을 믿을 수 있는지? 서버 단에서 다시 검증해야 될 수도.\n\t\t- 안 알려줄 때: 추가 검증 과정 필요 X, 프론트 로직 수정 X, API 수정. deliver_fee가 서버 값으로 무조건 고정된다. (배송비를 바꾸려면 서버를 바꿔야 한다.)\n\t- 확장되는 순간: 5만원 이하면은 3000원, 3만원 이하면 5000원.\n-> 클라이언트 쪽에서 배송비 받는 것으로 변경. 배송비 받고 나서 추가 검증 수행하기 + 주문 내려줄 때도 배송비 포함하기로.\n만약 배송비 값이 달라지게 되었을 때, 클라이언트와 서버가 각각 배송비 계산을 하게 된다면 값이 변경되는 경우에 정합성 문제가 발생할 수 있다. (서버의 값은 바뀌었는데, 클라이언트는 안 바뀌는 문제)\n- [x] mysql 서버 타임 시간 설정\n- [x] 장바구니 상품 삭제하는 거 batch delete (step2 끝날 무렵쯤 반영)\n\t-  /cart-items DELETE 요청 -> batch delete는 주로 어떻게 Url 구성할까?\n\t- Request: \n```json\n{\n\tcartItemIds: [1, 3, 5, 7]\n}\n```\n \t     - Respose: 204 No Content\n- [x] 총 가격에서만 포인트 계산을 해줘야 한다. (배송비 제외)\n- [x] `OrderProductResponse` 내부 값을 `ProductResponse` 로 변경하기\n\n## 시나리오\n\n### 주문 저장 (POST)\n1. 입력된 멤버가 해당 장바구니의 상품의 owner와 동일한지 확인한다. (검증)\n2. 사용된 포인트가 멤버가 갖는 포인트보다 작거나 같은지 확인한다. (검증)\n3. 멤버가 사용할 포인트가 전체 상품 가격 + 배송비보다 작거나 같은지 확인한다. (검증)\n4. 멤버의 포인트를 사용한다.\n5. 멤버의 포인트를 적립한다.\n6. 선택된 장바구니 상품을 삭제한다.\n7. 주문을 저장한다.\n\n## 2단계 리뷰 도둑질\n\n- `createdAt`을 현재는 Java에서 생성해주고 있는데요.\n1. 이 부분을 Java에서 생성하는 것과, DB에서 생성하는 것은 어떠한 장/단점이 있을까요?\n2. Java에서 생성하는 방식을 선택한 이유는 무엇인가요?\n- 메서드의 이름을 지어줄 때, 각각 어떠한 기준으로 정의했는지, 그에 일관성이 있는지 궁금하네요!\n1. 어떠한 도메인의 Controller/Service/Repository일 때, 접미사로 그 어떠한 도메인을 붙여줄 것인가?\n    - ex. `orderApiController.createOrder()` vs `orderApiController.create()`\n2. 무언가를 등록할 때, 용어를 선정하는 기준은 무엇인가?\n    - ex. `create` vs `register` vs `save`\n    - ex. `get` vs `find`\n3. 조건에 대해서도 접미사로 붙여줄 것인가?\n    - ex. `get` vs `getById` / `find` vs `findById`"},{"excerpt":"5/23","fields":{"slug":"/level2-week6/"},"frontmatter":{"date":"2023년 05월 23일 01:05","title":"레벨2 6주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 5/23\n"},{"excerpt":"LOG 이상한 사람들이 많다. 잠실 가려고 항상 타던 버스를 탔는데 버스에 들어가자마자 어떤 분이 소리지르고 계셨다 ㅋㅋ 갑자기 소리지르신 분이 경찰에 신고하고 버스기사분과 승객들과 계속 말다툼을 했다. 원래는 그냥 계속 버스 타고 가려고 했는데 점점 언성이 높아지길래 일단 아무 곳에서나 내렸다. 근데 갑자기 내릴 때 그 분이 112에 전화하고 있었는데 …","fields":{"slug":"/2023-05-22/"},"frontmatter":{"date":"2023년 05월 22일 11:05","title":"2023년 05월 22일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 이상한 사람들이 많다. 잠실 가려고 항상 타던 버스를 탔는데 버스에 들어가자마자 어떤 분이 소리지르고 계셨다 ㅋㅋ 갑자기 소리지르신 분이 경찰에 신고하고 버스기사분과 승객들과 계속 말다툼을 했다. 원래는 그냥 계속 버스 타고 가려고 했는데 점점 언성이 높아지길래 일단 아무 곳에서나 내렸다. 근데 갑자기 내릴 때 그 분이 112에 전화하고 있었는데 '그냥 이 사람이랑 알아서 처리하세요' 이러더니 같이 내려버렸다. 그래놓고 뒤도 돌아보지 않고 골목길로 뚜벅뚜벅 사라졌다... ㅋㅋㅋㅋ 어쩌다보니 신림에서 지하철을 타게 됐는데 잡상인을 만났다. 1호선에서는 만나봤는데 2호선 잡상인은 귀해서 신기했다. 벌써 일주일간 이상한 사람 4명 정도 본 것 같은데 ㅋㅋㅋ 신기하네요...\n- 미션을 간신히? 제출했다. 1단계 리뷰를 반영 못한 채로 구현을 시작해서, 2단계 구현이 끝나고 나서 리뷰 반영을 했다. 왜 매일 미션만 했는데 시간이 부족했을까? 이상한 일이다 🤔\n- 주드, 체인저와 graceful shutdown PR을 제출했다. 사실상 주드가 다 한 feature 개발 ㅋㅋㅋ 그래도 찾아보는 과정이 되게 재밌었다. 조만간 matzip issue에 글로 정리해야겠다. 근데 submodule 적용은 언제하지.. 해야 하는 게 많아서 어떻게 시간 분배를 해야 할 지 모르겠다.\n\n## 배운 것\n\n- 오늘은 스터디가 있어서 [[bean-candidate|여러 개의 Bean 후보가 존재할 때 Bean을 주입받는 방법]] 에 대해 공부했다.\n- `application.yml` 을 분리할 거면 이름을 `application.yml` 로 통일해야 한다.\n```yaml\nspring:  \n  profiles:  \n    active: prod  \n---  \nspring:  \n  config:  \n    activate:  \n      on-profile: prod  \n  datasource:  \n    url: jdbc:mysql://localhost:3306/subway?useSSL=false&characterEncoding=UTF-8&serverTimezone=UTC  \n    username: root  \n    password: root  \n    driver-class-name: com.mysql.cj.jdbc.Driver  \n  sql:  \n    init:  \n      mode: always  \n      schema-locations: classpath*:schema.sql\n```\n\n```yaml\n# test/application.yml\nspring:  \n  profiles:  \n    active: test  \n---  \nspring:  \n  config:  \n    activate:  \n      on-profile: test  \n  h2:  \n    console:  \n      enabled: true  \n  \n  datasource:  \n    url: jdbc:h2:mem:testdb;MODE=MySQL  \n    driver-class-name: org.h2.Driver\n```\n\n## 궁금한 것\n\n## 어려웠던 것\n- 미션에 얼마나 많은 시간 분배를 해야 할까. 미션에 너무 집중하다보니 기술 관련 고민을 많이 하지 못했다. 미션 자체는 즐거웠지만 공부가 많이 되었는지는 잘 모르겠다.\n\n## 느낀 것\n- 데일리 때 자기 방어 기제 테스트를 해봤다. 좀 더 자세하게 알아보려고 체인저가 알려 준 서울 사이버 대학 질문지를 해봤다. 부정, 왜곡, 예견, 유머, 회피가 나왔다. 예견과 유머는 성숙한 자기 방어기제지만, 부정, 왜곡, 회피는 미성숙한 자기 방어 기제라고 한다. 그래도 좋은 게 두 개나 나왔으니 좋은 거 아닐까 싶다. 예전에는 안 좋은 것만 나왔던 거 같은데 ㅋㅋ 최근에는 좀 웃음으로 많이 승화시키려고 노력하는 것 같다.\n- 오 테스트 커버리지가 높다. 원래 이렇게 높게 나오는 건지 궁금하다 ㅋㅋㅋ\n![[test-coverage.png]]\n"},{"excerpt":"Bean의 후보가 여러 개라면? 의존성 주입을 수행할 때 bean이 여러 개라면 오류가 발생한다.\n이를 해결하기 위해 3가지 방법을 사용할 수 있다.  의 필드 이름 매칭   가장 잘 일치하는 하나의 bean을 찾을 수 없는 경우에는  이 발생한다. 사용할 클래스 정리  필드 이름 매칭 필드 이름으로 주입하는 방법이다. 먼저 필드 주입이 가능하다. 위와 …","fields":{"slug":"/bean-candidate/"},"frontmatter":{"date":"2023년 05월 22일 09:05","title":"여러 개의 Bean 후보","tags":["스터디","학습로그","spring"]},"rawMarkdownBody":"\n## Bean의 후보가 여러 개라면?\n\n의존성 주입을 수행할 때 bean이 여러 개라면 오류가 발생한다.\n이를 해결하기 위해 3가지 방법을 사용할 수 있다.\n\n- `@Autowired` 의 필드 이름 매칭\n- `@Qualifier`\n- `@Primary`\n\n가장 잘 일치하는 하나의 bean을 찾을 수 없는 경우에는 `NoUniqueBeanDefinitionException` 이 발생한다.\n\n## 사용할 클래스 정리\n\n```java\npublic interface ExtraFarePolicy {  \n    Fare calculateExtraFare(final Path path);  \n}\n```\n\n```java\n@Component  \npublic class DistanceBasedExtraFarePolicy implements ExtraFarePolicy {  \n\tpublic DistanceBasedExtraFarePolicy() {  \n\t    System.out.println(getClass());  \n\t}\n\t\n\t@Override  \n\tpublic Fare calculateExtraFare(final Path path) {  \n\t\treturn null;\n\t}\n}\n```\n\n```java\n@Component  \npublic class DummyPolicy implements ExtraFarePolicy{  \n    public DummyPolicy() {  \n        System.out.println(getClass());  \n    }  \n  \n    @Override  \n    public Fare calculateExtraFare(final Path path) {  \n        return null;  \n    }  \n}\n```\n\n```java\n@Component  \npublic class Dummy {  \n    public ExtraFarePolicy policy;  \n}\n```\n\n## `@Autowired` 필드 이름 매칭\n\n필드 이름으로 주입하는 방법이다.\n\n먼저 필드 주입이 가능하다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    private ExtraFarePolicy dummyPolicy;  \n}\n```\n\n위와 같은 코드를 작성하면, `ExtraFarePolicy` 에 들어가는 구현체는 놀랍게도 `DummyPolicy` 클래스가 된다.\n\n생성자로 주입을 받으면 매개변수 이름이 주입받는 클래스 이름이 된다. \n`distanceBasedExtraFarePolicy` 라는 이름으로 주입 받기 때문에 `DistanceBasedExtraFarePolicy` 가 `ExtraFarePolicy` 에 대입된다.\n\n```java\n@Component  \npublic class Dummy {  \n    private final ExtraFarePolicy dummyPolicy;  \n  \n    public Dummy(final ExtraFarePolicy distanceBasedExtraFarePolicy) {  \n        this.dummyPolicy = distanceBasedExtraFarePolicy;  \n        System.out.println(a.getClass());  \n    }  \n}\n```\n\n아예 구현체의 이름으로 존재하지 않는 다른 이름을 적으면 컴파일 에러가 발생한다.\n이 경우에는 Spring이 Bean을 주입할 때 여러 구현체 중에 어떤 구현체를 선택해야 할 지 모르기 때문에 컴파일 에러가 발생하게 된다. \n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    private ExtraFarePolicy extraFarePolicy;  \n}\n```\n\n그러나 이렇게 주입하는 방식은 추천하지 않는다.\nSpring이 컴파일러에게 높은 우선순위를 부여하는 구현체 기반의 주입 매커니즘과는 관련이 없는 일반적인 빈 이름 기반의 주입 매커니즘이기 때문에, 규칙을 따르는 것이 더 명확하고 안전하다.\n\n## `@Qualifier`\n\nSpring 컨테이너가 동일한 유형의 bean을 여러 개 찾았을 때, 모호함을 해결하기 위해 추가적으로 판단할 수 있는 정보를 제공한다. 주의할 점은 등록되는 bean의 이름을 바꾸는 것이 아닌, 구분자를 추가하는 형식이라는 점이다.\n\n**특징**\n- 메서드, 필드, 생성자 매개변수에 사용할 수 있다.\n- `@Autowired` 와 함께 사용해야 한다.\n\n`@Qualifier` 를 생성자 매개변수에 달아줄 수 있다.\n이런 경우에는 생성자 매개변수 이름이 다른 구현체 이름이더라도 정확하게 해당 bean을 등록하게 된다.\n\n```java\n@Component  \npublic class Dummy {  \n    private ExtraFarePolicy dummyPolicy;  \n  \n    public Dummy(@Qualifier(\"distanceBasedExtraFarePolicy\") final ExtraFarePolicy dummyPolicy) {  \n        this.dummyPolicy = dummyPolicy;  \n        System.out.println(\"dummy\" + dummyPolicy.getClass());  // dummyclass subway.domain.fare.DistanceBasedExtraFarePolicy\n\n    }  \n}\n```\n\n필드 주입을 사용하려면 다음과 같이 사용하면 된다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    @Qualifier(\"distanceBasedExtraFarePolicy\")  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n존재하지 않는 `@Qualifier` 를 사용하면 `NoSuchBeanDefinitionException` 이 발생한다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    @Qualifier(\"strangePolicy\")  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n```bash\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'subway.domain.fare.ExtraFarePolicy' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true), @org.springframework.beans.factory.annotation.Qualifier(value=\"strangePolicy\")}\n```\n\n## `@Primary`\n\n```java\n@Primary  \n@Component  \npublic class DummyPolicy implements ExtraFarePolicy {  \n    public DummyPolicy() {  \n        System.out.println(getClass());  \n    }  \n  \n    @Override  \n    public Fare calculateExtraFare(final Path path) {  \n        return null;  \n    }  \n}\n```\n\n우선순위를 주고 싶은 bean의 클래스 상단에 적어주면 된다.\n\n`@Primary` 어노테이션이 여러 개 존재하는 경우에는 `NoUniqueBeanDefinitionException` 이 발생한다.\n\n```bash\nCaused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'subway.domain.fare.ExtraFarePolicy' available: more than one 'primary' bean found among candidates: [distanceBasedExtraFarePolicy, dummyPolicy]\n```\n\n## `@Resource` ?\n\n`@Resource` 어노테이션은 필드 타입으로 bean을 찾는 `@Autowired`와 달리 bean의 이름으로 bean을 주입한다.\n\n```java\n@Component  \npublic class Dummy {  \n    @Resource  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n해당 코드에서는 `DummyPolicy` 를 주입받게 된다.\n\n## 우선 순위\n\n`@Qualifier` 와 `@Primary` 어노테이션이 모두 존재하는 경우, `@Qualifier` 가 우선된다.\n\n```java\n@Qualifier(\"dummyPolicy\")  \n@Component  \npublic class DummyPolicy implements ExtraFarePolicy{  \n    \n}\n```\n\n```java\n@Primary  \n@Component  \npublic class DistanceBasedExtraFarePolicy implements ExtraFarePolicy {\n}\n```\n\n```java\n@Component  \npublic class Dummy {  \n    @Autowired  \n    @Qualifier(\"dummyPolicy\")  \n    public ExtraFarePolicy dummyPolicy;  \n}\n```\n\n이런 경우에는 `Dummy` 의 `ExtraFarePolicy` 에는 `DummyPolicy` 가 주입되게 된다."},{"excerpt":"LOG matzip aws 계정 생성 드디어 했다 ㅋㅋ 나 왜 이렇게 시간이 없을까... 뭔가 해야 할 일이 많이 쌓여있는데 해결이 안 되고 쌓이기만 하는 느낌이다. 계정 생성 그거 별거 아닌데도 엄청 오래걸리고. 얼른 미션을 마무리하고 matzip 이슈 해결도 하고 오리가 맡겨주신 application.yml 설정도 완료해야겠다. 즐선생님, 헙크와 같이…","fields":{"slug":"/2023-05-21/"},"frontmatter":{"date":"2023년 05월 21일 16:05","title":"2023년 05월 21일","tags":null},"rawMarkdownBody":"\n## LOG\n- matzip aws 계정 생성 드디어 했다 ㅋㅋ 나 왜 이렇게 시간이 없을까... 뭔가 해야 할 일이 많이 쌓여있는데 해결이 안 되고 쌓이기만 하는 느낌이다. 계정 생성 그거 별거 아닌데도 엄청 오래걸리고. 얼른 미션을 마무리하고 matzip 이슈 해결도 하고 오리가 맡겨주신 application.yml 설정도 완료해야겠다.\n- 즐선생님, 헙크와 같이 페어가 된 걸 확인했다. 포이가 즐선생님 칭찬을 많이 해서 나도 같이 페어 해보고 싶다고 생각하던 차였는데 포이와 페어 교환했다 ㅋㅋㅋ 포이는 토리와 페어 ~ 역시 페어는 돌고 돈다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 나의 감정을 돌아보고, 솔직하게 표현하는 것이 어렵다. \n- 블로그 글을 열심히 쓰지 못하고 있다 😂 TIL은 그날 저녁에 계속 올려야 하는데 많이 밀리고 있고 ㅋㅋ 이번 미션이 어려워서 그런지 미션에 많이 집중하느라 블로그 포스팅에 소홀했다. 앞으로 노력하겠습니다~\n\n## 느낀 것\n- 오늘 TIL에 쓸 내용은 아니긴 하지만 ㅋㅋㅋ 레벨2 글쓰기로 썼던 주제 의외로 마음에 들어서 좋았다. 원래는 '나는 왜 살고 삶의 목표는 무엇인가'라는 무거운 주제라 시작하기 어려웠는데, 내가 자신있는 주제로 쓰다보니 훨씬 글이 잘 나오는 것 같다.\n- 계속해서 고민하고 있는 주제. '나는 어디까지 솔직해질 수 있는가?' 나는 솔직하지 못한 사람인데, 솔직하지 못한 사람을 좋아하지는 않는다. 역설적이다 ㅋㅋ 내가 느꼈던 것, 생각하는 것, 서운한 것, 슬픈 것, 기쁜 것 ... 여러 생각들을 하는데도 정말로 솔직하게 말하는 것은 요즘따라 몇 안 되는 기분이 든다. 문제는 좋은 것도 제대로 말 못한다는 것에 있다. 칭찬에 인색하지 말고, 감사에 인색하지 말아야 하는데 말은 그렇게 하면서도 지키기 어렵다. 솔직하게 내 생각을 이야기하는 것에 더 익숙해지기 위해 노력해야겠다. 오늘도 두 번의 노력을 해보았는데, 생각보다 큰 용기가 필요해서 내가 이만큼 솔직하지 못한 사람이라는 것만 알게 되었다 ㅋㅋ 어쨌든 앞으로도 노력해보자."},{"excerpt":"LOG 코엑스에 가서 가디언즈 오브 갤럭시를 봤다. 원래 좋아하던 영화였는데 왠지 이번이 마지막인 것처럼 영화가 끝나서 조금 아쉬웠다. 로켓의 과거가 좀 슬펐다. 솔라가 가오갤 팬이면 안 보면 후회한다고 한 말이 무슨 말인지 어렴풋이 느꼈다. 이제서야 미션 구현을 시작했다. 조금 많이 늦은 감이 있지만, 어쨌든 제출은 빨리 해야 한다... 배운 것 는 테…","fields":{"slug":"/2023-05-20/"},"frontmatter":{"date":"2023년 05월 20일 02:05","title":"2023년 05월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 코엑스에 가서 가디언즈 오브 갤럭시를 봤다. 원래 좋아하던 영화였는데 왠지 이번이 마지막인 것처럼 영화가 끝나서 조금 아쉬웠다. 로켓의 과거가 좀 슬펐다. 솔라가 가오갤 팬이면 안 보면 후회한다고 한 말이 무슨 말인지 어렴풋이 느꼈다.\n- 이제서야 미션 구현을 시작했다. 조금 많이 늦은 감이 있지만, 어쨌든 제출은 빨리 해야 한다...\n\n## 배운 것\n- `@ActiveProfiles`는 테스트 코드에서만 사용 가능하다.\n- `build.gradle` 을 수정할 때 깃허브 메시지는 `chore`를 사용한다.\n- stream의 결과가 `List<List<>>` 형태일 때 flat하게 `List<>`로 만들고 싶은 경우 `flatMap(List::stream)` 을 사용하면 된다.\n```java\n// List<Line> lines가 주어짐\n\nlines.stream()  \n        .map(Line::getSectionsByList)  \n        .flatMap(List::stream)  \n        .collect(Collectors.toList());\n```\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 요즘 니체의 생각이 좋다. 처음에는 니체 철학은 허무주의 아닌가? 해서 접하게 되었는데, 알아가다 보니 니체가 말하고 싶었던 것은 삶을 사랑하라는 것이다. '바람직한 죽음'에 관한 관점도 좋다. 주체적으로 죽음을 택하는 것, 즉 내가 어떻게 살아가야 하는지가 중요하다고 생각하는 것이다. 나에게 죽음은 두려운 것이 아니지만 나는 솔직한 사람이 아니다. 하루하루를 언제나 만족스럽게 보내고 있는 것도 아니다. 최선을 다해 내 마음을 돌아보고 솔직한 방향으로 나아가려고 하지만 항상 잘 되는 것만은 아니다. 그래서 요즘은 에라 모르겠다식 결정보다는 내 마음을 다시 돌아보고 솔직하게 선택하려고 노력하는 중이다. 계속 노력하다보면 살아가면서 솔직한 결정을 더 잘할 수 있지 않을까?\n- 새싹교실이 끝나간다. 드디어 상속까지 진행했다. 그런데 하고 싶은 말은 많은데 수업이 한 시간 밖에 안 남아서 좀 아쉽다. 새싹들이 어디까지 알고 있을지 궁금하다. 예전에 수업할 때보다 더 잘 가르치는 것 같기는 해서 뿌듯하다."},{"excerpt":"신나게 사는 법 저는 우테코에서 신나게 사는 사람 중 하나라고 자부합니다. (신나게 사는 사람 배틀은 언제나 환영입니다.)\n여러분도 신나게 살고 싶으시다면 제 글을 읽고 한 번 따라 해 보세요 ˙ᵕ˙ 긍정적으로 생각하기 저는 굉장히 부정적인 사람입니다. 어떤 상황이 주어졌을 때 항상 최악을 가장 먼저 생각합니다. 가장 안 좋은 일을 미리 대비해야 마음의 …","fields":{"slug":"/level2-writing/"},"frontmatter":{"date":"2023년 05월 18일 06:05","title":"레벨2 글쓰기","tags":["레벨2","우테코","글쓰기"]},"rawMarkdownBody":"\n# 신나게 사는 법\n\n저는 우테코에서 신나게 사는 사람 중 하나라고 자부합니다. (신나게 사는 사람 배틀은 언제나 환영입니다.)\n여러분도 신나게 살고 싶으시다면 제 글을 읽고 한 번 따라 해 보세요 ˙ᵕ˙\n\n## 긍정적으로 생각하기\n\n저는 굉장히 부정적인 사람입니다. 어떤 상황이 주어졌을 때 항상 최악을 가장 먼저 생각합니다. 가장 안 좋은 일을 미리 대비해야 마음의 준비를 할 시간이 있기 때문입니다. \n\n그런데 그렇게 살다 보니까 언제나 안 좋은 점만 보였습니다.\n우테코를 신청하기 전에도 먼저 부정적인 생각부터 들었습니다.\n\n`떨어지면 어떡하지?`\n`떨어질 것 같은데 그냥 시험공부나 하는 게 좋지 않을까?`\n`잘하지도 못하는데 붙을 수 있을까?`\n\n무수히 많은 부정적인 생각을 했습니다. 생각하다 보니 우테코에 지원하지 않아야 할 이유만 계속해서 꼬리를 물었습니다.\n\n그렇지만 에라 모르겠다 하고 신청을 넣어서 제가 지금 우테코에 있는 거겠죠?\n곰곰이 생각해 보면 잘 된 경험은 준비 없이 뭐라도 시작하고 나서 생각한 일이 잘됐습니다. 먼저 안 좋은 생각부터 할 이유가 없는 거죠.\n특히 시도해 보지 않고 안 좋은 생각을 하면 더 과장되게 생각하게 됩니다.     \n\n그러니 일단 잘될 거라고 생각하고 해봅시다. 앞으로 어떻게든 되겠죠!     \n잘 되면 좋은 거고, 안 되면 어떤가요. 어차피 인생은 많이 남았습니다. 👍\n\n## 많이 웃기\n\n웃으면 복이 온다는 진부한 내용은 아니니 계속 읽어주세요.   \n전 원래 웃음이 많은 사람입니다. 이제 겨우 23년 살았지만, 동 나이대 사람 중에 제가 제일 많이 웃었을 것 같으니 저는 웃음 전문가라고 할 수 있겠습니다.     \n웃는 걸 노력해 본 적은 없지만, 대충 생각해 봤을 때 저는 확실히 하루에 4시간 정도는 웃습니다. 매우 많네요.    \n\n웃다 보면 제가 웃는 것에 웃겨서 더 웃게 됩니다.     \n그러면 가끔 옆에 있는 사람이 제가 웃는 걸 보고 웃습니다. 주로 '너는 이런 걸로 또 웃니?' 라는 느낌이기는 합니다.   \n확실히 생각해 봤을 때, 다른 사람이 웃는 걸 보면 기분이 좋습니다.    \n저의 웃음이 다른 사람에게 감정적으로 긍정적 영향을 줄 수 있다는 것이 기쁩니다.    \n\n여러분도 일단 아무렇게나 웃어보시는 건 어떨까요.    \n실소도 좋고, 억지 미소도 좋고, 갑자기 뜬금없이 웃어도 좋습니다.     \n복은 안 와도, 주변 사람들과 함께 행복해지면 그것 자체로 좋은 것 아닐까요?     \n이 글을 보고 여러분이 웃게 된다면 제가 행복해질 것 같네요. 웃어주세요. 😊     \n\n## 사소한 것에서 즐거움 찾기\n\n'재밌는' 하루를 보내는 것은 어렵습니다. 반복되는 일상, 어려운 공부, 미래에 대한 걱정 ... 많은 사람이 다양한 주제의 걱정으로 하루를 살아갑니다.    \n\n그런데도 하루에 '즐거운' 일은 있습니다. 막 재밌는 게 아니어도 좋습니다.     \n점심으로 먹었던 밥이 맛있었다든지, 친구가 웃긴 농담을 했다든지, 10분 더 집중했다든지 같은 사소한 일들을 생각해 봅시다.      \n오히려 사소하고 당연한 즐거운 일을 자각하기가 어렵습니다.      \n우리는 오늘 '무엇을 해냈다'에 집중하느라 오늘 있었던 '즐거운 일'에는 관심을 덜 쏟는 경향이 있습니다.      \n\n대부분 사람의 목표는 행복일 것으로 생각합니다.     \n그렇지만 행복이 거창한 건 아닙니다. 거창한 행복을 바랄수록 평범한 현실을 자각하면 오히려 불행해집니다.      \n주변에는 의외로 감사한 일, 즐거운 일이 많습니다.     \n\n큰 행복을 향해 뛰는 것도 좋지만, 가끔은 잠시 멈춰 오늘의 소소한 행복을 발견해 봅시다.     \n과거의 작은 행복이 모이다 보면 힘들 때 뒤를 돌아봤을 때 큰 위로가 되더라고요. \n\n생각보다 그렇게 어렵지 않죠? 여러분도 신나는 삶에 도전해 보세요 💪"},{"excerpt":"LOG 토리 테코톡이 있어서 아침에 연습하는 거 들었다. 엄청 걱정하더니 테코톡 때는 안 떨고 잘 말해서 대단했다 👏 질문 나온 것들도 잘 대답해서 멋졌다. 역시 토리가 최고다~ 배운 것 jar, war 파일 프로젝트의 내용을 압축해서 담아놓은 파일. 컴퓨터가 읽을 수 있는 형태의 파일을 전달하기 위해 만든다. (plain) jar : 자바 프로젝트를 압…","fields":{"slug":"/2023-05-18/"},"frontmatter":{"date":"2023년 05월 18일 05:05","title":"2023년 05월 18일","tags":null},"rawMarkdownBody":"\n## LOG\n- 토리 테코톡이 있어서 아침에 연습하는 거 들었다. 엄청 걱정하더니 테코톡 때는 안 떨고 잘 말해서 대단했다 👏 질문 나온 것들도 잘 대답해서 멋졌다. 역시 토리가 최고다~\n\n## 배운 것\n### jar, war 파일\n프로젝트의 내용을 압축해서 담아놓은 파일. 컴퓨터가 읽을 수 있는 형태의 파일을 전달하기 위해 만든다. \n- (plain) jar : 자바 프로젝트를 압축한 파일. 외부 라이브러리가 포함되지 않는다. 다른 프로젝트에 종속성으로 사용될 때, 로컬 환경에서 실행되는 애플리케이션으로 사용한다. \n- (Runnable) jar : 웹 애플리케이션이 의존하는 라이브러리나 외부 모듈 등을 포함한다. 내장 톰캣을 포함하여 웹 프로젝트를 압축한 파일. 외부 웹서버 없이 웹 애플리케이션을 단독 실행할 수 있다.\n\t- war : 웹 프로젝트를 압축한 파일. 해당 파일을 실행하려면 WAS가 필요하다. 웹 애플리케이션을 통째로 패키징하고 배포하기 위해 사용한다.\n\t- 스프링 부트에서 빌드하는 표준형식은 jar -> 그러나 내장된 서블릿 컨테이너는 JSP를 실행할 수 없다.\n\t- war는 jsp를 사용해서 화면을 구성하거나, 외장 WAS를 사용하게 된다면 사용하는 것이 좋다.\n\n### 배포\n#### 서버 환경 구축\n- 어떤 서버를 사용하느냐, 어떤 파일을 업로드 하냐에 따라 달라진다. \n\n#### nohup, &\nnohup : 터미널이 종료된 후에도 프로그램이 실행해야 할 때\n& : 사용자가 터미널을 다른 작업에 사용해야 할 때 (멀티 태스킹)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"LOG 배운 것  의 를 사용할 때 주의할 점 : as 내부에 DTO가 존재하고 DTO의 매개변수가 1개라면 꼭 기본 생성자가 필요하다. (Response용으로 사용되더라도!) 일관성을 위해 모든 DTO에 기본 생성자를 달아주자.","fields":{"slug":"/2023-05-17/"},"frontmatter":{"date":"2023년 05월 17일 04:05","title":"2023년 05월 17일","tags":null},"rawMarkdownBody":"## LOG\n\n## 배운 것\n- `RestAssured` 의 `as`를 사용할 때 주의할 점 : as 내부에 DTO가 존재하고 DTO의 매개변수가 1개라면 꼭 기본 생성자가 필요하다. (Response용으로 사용되더라도!) 일관성을 위해 모든 DTO에 기본 생성자를 달아주자.\n```java\nExtractableResponse<Response> response = RestAssured  \n        .given().log().all()  \n        .accept(MediaType.APPLICATION_JSON_VALUE)  \n        .when().get(\"/lines/{노선_ID}\", 노선_ID)  \n        .then().log().all()  \n        .extract();  \n        \nLineResponse lineResponse = response.as(LineResponse.class);\n```\n"},{"excerpt":"5/16 피드백 DTO는 어디에? DTO는 어느 레이어에 속하게 하는 게 좋을까? -> 나는 서비스라고 생각한다. 우르와 페어할 때 DTO가 컨트롤러 레이어에 두게 되면 하위 계층인 서비스에서 상위 계층인 DTO를 참조하게 되는 역류 참조가 발생하므로 서비스에 사용하는 것이 좋다고 생각한다. 이 의견은 DTO가 서비스에서 사용된다는 가정하에 있는 것이기는…","fields":{"slug":"/level2-week5/"},"frontmatter":{"date":"2023년 05월 16일 01:05","title":"레벨2 5주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 5/16\n\n## 피드백\n\n### DTO는 어디에?\n- DTO는 어느 레이어에 속하게 하는 게 좋을까? -> 나는 서비스라고 생각한다. 우르와 페어할 때 DTO가 컨트롤러 레이어에 두게 되면 하위 계층인 서비스에서 상위 계층인 DTO를 참조하게 되는 역류 참조가 발생하므로 서비스에 사용하는 것이 좋다고 생각한다. 이 의견은 DTO가 서비스에서 사용된다는 가정하에 있는 것이기는 하다. 만약 서비스에서 사용하는 DTO가 따로 있다면 기존 DTO는 컨트롤러 레이어, 서비스로 값이 전달될 때 사용하는 DTO를 서비스 레이어에 둘 것 같다. \n\n### 단위 테스트 중복?\n- 레이어별로 만들어놓은 단위 테스트가 같은 기능을 검증하고 있는 것 같다. 컨트롤러 테스트에서 세부적인 비즈니스 규칙을 모두 검증할 필요가 있을까? \n-> 검증하고자 하는 대상이 무엇인지에 집중한다.\n\n컨트롤러의 역할은 요청을 받고 응답을 하는 것이다. \n비즈니스 규칙의 일부는 검증될 수 있을지언정 컨트롤러의 역할을 검증하는 것이 목표가 되어야 한다. 즉, 컨트롤러 테스트에서는 비즈니스 규칙을 테스트할 필요는 없다고 생각한다.\n\n**테스트 피라미드**\n![[test_pyramid.jpg]]\n\n### 테스트에서만 사용되는 프로덕션 코드?\n\n테스트만을 위한 프로덕션 코드는 지양하되, 과하게 사용하는 것이 아니라면 제한적으로 허용하자.\n\nEx. 적절한 생성자가 없는 경우 테스트를 위한 생성자를 추가하는 방법\n\nbut, 테스트를 짜기 쉬운 코드를 만드는 것에 좀 더 집중하자.\n\n## Spring JDBC with Datasource\n\n### Datasource\n연결 설정, 쿼리 실행, 트랜잭션 관리에 필요한 메서드들을 인터페이스로 제공하는 틀\n애플리케이션과 기본 데이터베이스 사이의 브리지 역할을 한다.\n\n### Datasource로 설정할 수 있는 것들\n- url\n- driver class\n- user name & password\n- connection pool 설정\n\n### Profile\n선택적으로 Spring Context를 구성하고, 선택적으로 활성화할 수 있다.\n다양한 배포 시나리오에 따라서 변경할 수 있다.\n\n`@Profile` 로 설정할 수 있다.\n\napplication-prod.properties와 application-test.propterties 중에 누가 우선순위가 높을까?\n\n# 5/19\n\n## ATDD\n\n요구사항을 검증하는 테스트로 소프트웨어를 개발하는 프로세스\n-> 인수테스트로 소프트웨어를 개발하는 프로세스\n\n## ATDD를 하는 이유\n\n### 생산성 증가\n구현 전에 인수 테스트를 수행하는 경우, 팀의 생산성이 두 배가 되었다.\n-> 작업의 명확한 시작과 끝을 제시한다.\n-> 빠른 피드백이 가능하다. \n-> 귀찮은 작업을 프로세스로 강제한다.\n\n### Acceptance Test\n- 사용자 스토리를 검증하는 기능 검증 테스트\n- 소프트웨어 이외 다른 분야에서도 사용되는 용어\n- 보통 마지막 단계에서 수행하는 테스트를 의미\n\n### 테스트 종류\n- 단위 테스트\n- 통합 테스트\n- E2E 테스트\n- 인수 테스트 : 사용자 스토리를 검증하는 기능 테스트\n\n### 인수테스트?\n- 인수 테스트는 API 테스트? E2E 테스트? 통합 테스트?\n\n인수테스트는 테스트 의도에 따라 정해지는 것이지 어떻게 구현하는지에 따라 정해지는 것이 아니다. (단위 테스트가 될 수도 있다?)\n\n### 이번 특강에서 말하는 인수 테스트\n- 백엔드 개발자가 단독적으로 적용해서 실천해볼 수 있는 범위\n- 고객은 프론트엔드 개발자 혹은 API 활용하는 사람 대상\n- API 접점에서 검증하는 E2E 테스트\n- API 의 Request와 Response 정보 이외 내부 정보는 최대한 가리는 블랙 박스 형식의 테스트\n\n## 인수 테스트 만들기\n\n### 만들기 전에 알아야 할 것\n- 블랙박스 테스트 : 인수 테스트는 블랙 박스 테스트의 성격을 가지고 있다. 내부 동작의 구현보다는 시나리오가 잘 동작하는지 확인한다.\n- 블랙박스?\n\t- 클라이언트는 표먼적으로 확인할 수 있는 요소를 바탕으로 검증한다.\n\t- 실제 사용하는 상황의 시나리오를 바탕으로 요구사항을 작성한다.\n\t- 내부 구현이나 기술에 의존적이지 않는 블랙 박스 테스트\n- E2E 테스트 : 종단간 테스트. API 레벨의 블랙박스 테스트이므로 요청과 응답 기준으로 API 레벨의 E2E 테스트로 검증한다.\n\n### 인수 테스트 도구 설명\n\n- SpringBootTest\n\t- ApplicationContext를 쉽게 지정하게 도와준다.\n\t- 기존 `@ContextConfiguration` 의 발전된 기능\n- webEnvironment\n\t- MOCK, RANDOM_PORT, DEFINED_PORT, NONE(웹 요청을 안 받는)\n- MockMvc\n\n## 인수 테스트 격리\n\n`@DirtiesContext` 를 사용하면 컨텍스트를 테스트마다 계속해서 생성한다. 캐시 기능을 사용하지 않게 설정하면 매번 Context를 새로 구성하다보니 시간이 많이 걸린다.\n\n설정이 같으면 캐싱된 컨텍스트를 재사용한다. (MockBean을 사용하는 경우)\n\nDatabaseCleanup : EntityManager를 활용하여 테이블 이름 조회 후 각 테이블 Truncate 수행. ID auto-increment 숫자를 1로 복구시킨다.\n\n## 인수 조건\n- 인수 테스트가 충족해야 하는 조건\n- 이번 과정에서는 시나리오 형태로 표현\n\n## 인수 테스트에서 TDD로 넘어가기\n\n인수 조건을 세우고 -> 이를 검증하는 인수테스트를 만들고 -> 인수테스트를 만족시키는 기능을 구현해도 인정\n\n컨트롤러부터 도메인 방향 -> outside in\n도메인에서 컨트롤러 방향 -> inside out\n왔다갔다 해도 좋지만 잘 아는 것을 기반으로 모르는 방향으로 진행할 것"},{"excerpt":"LOG 오늘도 지하철 타고 가는데 30초에 한 번 문 쪽을 쳐다보는 아저씨가 계셨다. 나중 가니까 문을 보는지 나를 보는지 모르겠어서 자리를 옮겼는데 갑자기 근처로 오셔서 ㅋㅋㅋ 옆 칸으로 도망갔다. 아무 일도 일어나지 않았고 진짜 나를 본 것도 아니겠지만 그냥 피하는 게 맞았던 것 같다. 체인저, 주드와 함께 오늘도 matzip 이슈 보는 시간을 가졌다…","fields":{"slug":"/2023-05-16/"},"frontmatter":{"date":"2023년 05월 16일 01:05","title":"2023년 05월 16일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘도 지하철 타고 가는데 30초에 한 번 문 쪽을 쳐다보는 아저씨가 계셨다. 나중 가니까 문을 보는지 나를 보는지 모르겠어서 자리를 옮겼는데 갑자기 근처로 오셔서 ㅋㅋㅋ 옆 칸으로 도망갔다. 아무 일도 일어나지 않았고 진짜 나를 본 것도 아니겠지만 그냥 피하는 게 맞았던 것 같다.\n- 체인저, 주드와 함께 오늘도 matzip 이슈 보는 시간을 가졌다. 후니가 `ApplicationEvent` 를 사용해서 asyncExecutor가 종료되기를 기다리고 + 일정 시간 뒤에 종료하라는 힌트를 더 주셔서 같이 찾아봤다. 찾아보니 `ThreadPoolTaskExecutor` 의 속성 중에 `setWaitForTasksToCompleteOnShutdown` 을 설정하면 모든 진행중인 작업이 끝날 때까지 기다리고, `setAwaitTerminationMillis` 를 설정해주면 종료되기까지 최대 몇 밀리초를 기다릴지 설정할 수 있다. 주드 말로는 비동기 스레드는 graceful shutdown을 해주지 않아도 잘 종료되는데 동기 스레드는 graceful shutdown을 해야 한다고 한다. 내일 가서 좀 더 설명을 들어야겠다. \n- 포이와 체인저 집에 가서 밥을 먹었다 ㅋㅋㅋ 집 가기 전에 체인저가 제육 먹는다고 하고 같이 먹을래? 라고 말하길래 장난인줄 알았더니 진짜 가게 돼서 당황스러웠다 ㅋㅋㅋㅋ 근데 체인저 제육 폼 미쳤다.. 닭강정까지 같이 사서 먹었는데 양이 많았다. 체인저랑 포이는 그렇게 생각 안 한 것 같지만 ㅋㅋㅋ\n\n## 배운 것\n- 복합키를 구성하는 값은 NULL일 수 없다. 기본 키는 행을 고유하게 식별하는 데 사용한다. 그런데 NULL값이 존재하게 되면 비교가 되지 않는다. (NULL = NULL 비교는 실패한다) 따라서 NULL 이 포함된 열은 복합키가 될 수 없다.\n- 애그리거뜨 루뜨에 대한 설명을 누누한테 들었는데 다시 정리하자니 어렵네... 내일 누누한테 다시 물어봐야겠다.\n\n## 궁금한 것\n- 도대체 헥사고날이 뭘까 ㅋㅋ 누누 등장해서 알려줘\n\n## 어려웠던 것\n\n## 느낀 것\n- 요즘 공부 많이 해서 기분은 좋은데 중간에 안 쉬니까 머리가 너무 아프다 ㅋㅋ 막판에 가면 아무것도 집중 안 되는 상태가 되는데, 공부 하다가도 중간에 쉬는 시간이 필요한 것 같다. 4시간 - 5시간을 한 번에 집중하는 건 역시 어렵군..\n- 세상에 웃긴 게 너무 많다 ㅋㅋㅋ 그냥 별 것도 아닌데 특정 말을 듣기만 하면 너무 기분이 좋아진다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ 왕주먹 랄프.. 까만 이우진...ㅋㅋㅋㅋㅋㅋㅋㅋ"},{"excerpt":"cloudfront의 image 링크를 열면 이미지 열기가 아니라 파일을 다운로드하는 문제 MIME 유형을 지정해 주지 않아 발생한 문제였다. -> mime 로컬 환경에서 로컬 프로필이 적용되지 않는 문제 여러 개의 active가 설정되어 있어 발생한 문제였다. -> Spring Profile 적용 순서","fields":{"slug":"/matzip-issue/"},"frontmatter":{"date":"2023년 05월 15일 07:05","title":"matzip에서 발생한 issue 정리","tags":["우테코","matzip","issue"]},"rawMarkdownBody":"\n## cloudfront의 image 링크를 열면 이미지 열기가 아니라 파일을 다운로드하는 문제\n\nMIME 유형을 지정해 주지 않아 발생한 문제였다. -> [[mime]]\n\n## 로컬 환경에서 로컬 프로필이 적용되지 않는 문제\n\n여러 개의 active가 설정되어 있어 발생한 문제였다. -> [[spring-multi-profile-issue|Spring Profile 적용 순서]]"},{"excerpt":"matzip-issue matzip 페어 기록 matzip-feature-develop","fields":{"slug":"/matzip/"},"frontmatter":{"date":"2023년 05월 15일 07:05","title":"matzip 개발기","tags":["우테코","matzip"]},"rawMarkdownBody":"- [[matzip-issue]]\n- [[matzip_pair|matzip 페어 기록]]\n- [[matzip-feature-develop]]\n"},{"excerpt":"LOG 스터디 주제 공부하기, matzip 이슈 공부하기, 저녁에는 지하철 리뷰 반영하기 해서 내내 공부했다. 그러고 나니까 머리가 어지럽다 ㅋㅋㅋ 집에 갈 때쯤에 말해보카를 했는데 똑같은 문장 4번 틀려서 확실히 뇌 자원을 다썼구나.. 라는 생각이 들었다. 그래도 열심히 공부했으니 뿌듯하다~ 오늘 지하철에서 이상한 아저씨를 만났다ㅋㅋㅋ 냅다 나보고 휴먼…","fields":{"slug":"/2023-05-15/"},"frontmatter":{"date":"2023년 05월 15일 05:05","title":"2023년 05월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 스터디 주제 공부하기, matzip 이슈 공부하기, 저녁에는 지하철 리뷰 반영하기 해서 내내 공부했다. 그러고 나니까 머리가 어지럽다 ㅋㅋㅋ 집에 갈 때쯤에 말해보카를 했는데 똑같은 문장 4번 틀려서 확실히 뇌 자원을 다썼구나.. 라는 생각이 들었다. 그래도 열심히 공부했으니 뿌듯하다~\n- 오늘 지하철에서 이상한 아저씨를 만났다ㅋㅋㅋ 냅다 나보고 휴먼이라고 하는 아저씨... 솔직히 뭐라고 하시는지 대부분은 못 알아먹었다 ㅋㅋ 처음엔 좀 거리가 있었는데 점점 가리키는 손이 가까워져서 다른 칸으로 이동해서 집에 갔다. 가끔 이런 이슈가 발생할 때가 있는데 역시 아무렇지 않은 것처럼 행동하는 게 나은 거 같다.\n- matzip issue를 후니에게 전달 받아서 공부해봤는데, graceful shutdown이라는 키워드를 알게 되었다. 1시간의 짧은 시간이었지만, GracefulShutdown 코드 내부를 살펴볼 수 있었다. 운영체제 때 이런 내용은 안 배웠는데;; 우리 학교는 대체 무엇을 가르치는가.. 어쨌든 이슈 해결을 해야 되니까 좀 더 공부를 해봐야겠다.\n- 말랑이 아침에 내 출입증을 빌려가서 가져가버렸다 ㅋㅋㅋ 나는 내일 들어갈 수 있을까... 역시 괴도 말랑\n\n## 배운 것\n- 스프링 부트 버전 3부터는 패키지명에서 Java를 모두 없애고 jakarta로 바꾸었다. mysql이 8.0.31 버전부터 자신들의 네이밍 가이드라인에 맞춰 groupid, artifactid를 바꾸어서 이제 `runtimeOnly 'com.mysql:mysql-connector-j'`를 사용해야 한다.\n- 오늘 스터디가 있어서 스터디 주제를 공부했다: [[vepohuhemal-study-question|5월 15일]]\n\n## 궁금한 것\n- 면접 보면서 `ProxyMode`라는 말이 나왔는데 사실 아직도 무슨 말인지 잘 이해를 못했다 ㅋㅋㅋ 내일 시간 나면 좀 더 알아봐야겠다.\n\n## 어려웠던 것\n- 하는 일이 잘 안 풀릴 때에도 긍정적인 마음을 유지하자. 저녁에 리팩토링이 잘 안 되고 해낸 게 없는 것 같아서 평소처럼 기분을 유지하기 어려웠다. 기분이 태도가 되지 않도록 하자.\n\n## 느낀 것\n- 요즘 마음이 평온하다. 말을 할 때에도 차분하게 말할 수 있고 (안 웃는다는 건 아니고) 일이 잘 안 풀리더라도 그냥 그럴 수 있지 라는 마인드로 살아가고 있다. 지금의 내 감정이 왔다갔다 하지 않아서 좋다. 특히 안 좋은 감정이 드는 걸 내 머릿속에서 의도적으로 배제하는 것 같아서 안 좋은 감정을 못 느끼고 있는 거 같다. 오히려 좋아\n- 공부를 하면 에너지가 많이 소모된다. 아무래도 오늘은 공부를 많이 한 날이라 집에 왔더니 그냥 누워버릴 수밖에 없었다..ㅋㅋㅋ 딴 짓 안 하고 그냥 누워있기만 하니까 오히려 좋은 거 같기도 하고. 긍정적으로 생각하자."},{"excerpt":"LOG 한강에 놀러 갔다. 제이슨이 올려주신 글을 보니까 재밌을 것 같아서 갔다. 뚜벅뚜벅 축제를 하고 있어서 열심히 걸었다. 웬 물이 뿜어져 나오는 잠수교가 있었는데, 노래가 바뀔 때마다 물이 뿌려지는 게 달라져서 신기했다. 배운 것  : Foreign Key의 제약 조건을 끄고 하위 명령어들을 실행할 수 있게 해준다.  : Foreign Key의 제약…","fields":{"slug":"/2023-05-14/"},"frontmatter":{"date":"2023년 05월 14일 09:05","title":"2023년 05월 14일","tags":null},"rawMarkdownBody":"## LOG\n- 한강에 놀러 갔다. 제이슨이 올려주신 글을 보니까 재밌을 것 같아서 갔다. 뚜벅뚜벅 축제를 하고 있어서 열심히 걸었다. 웬 물이 뿜어져 나오는 잠수교가 있었는데, 노래가 바뀔 때마다 물이 뿌려지는 게 달라져서 신기했다.\n\n## 배운 것\n- `SET foreign_key_checks = 0` : Foreign Key의 제약 조건을 끄고 하위 명령어들을 실행할 수 있게 해준다. \n- `SET foreign_key_checks = 1` : Foreign Key의 제약 조건 켜기 - 출처 https://iambeginnerdeveloper.tistory.com/84\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"2단계 리뷰 혹시 Index를 걸면 좋을만한 것들을 고민해보셨을까요? index란 추가적인 쓰기 작업과 저장공간을 활용하여 DB 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 조회 뿐만 아니라 update, delete의 성능이 함께 향상된다. create, delete, update가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능…","fields":{"slug":"/level2-cart/"},"frontmatter":{"date":"2023년 05월 14일 05:05","title":"레벨2 장바구니 미션","tags":["레벨2","미션","우테코"]},"rawMarkdownBody":"## 2단계 리뷰\n\n- 혹시 Index를 걸면 좋을만한 것들을 고민해보셨을까요?\n\t- index란 추가적인 쓰기 작업과 저장공간을 활용하여 DB 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 조회 뿐만 아니라 update, delete의 성능이 함께 향상된다.\n\t- create, delete, update가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능이 저하되는 역효과가 발생할 수 있다.\n\t- 복합 인덱스는 join, select 쿼리에 유용할 수 있다. mysql에서는 최대 16 column까지 인덱스를 정의할 수 있다. \n\t- where 절에서 참조되거나 join 절에서 사용되는 필요한 column을 기준으로 인덱싱해야 한다.\n\t- 키가 아닌 인덱스 열을 너무 많이 추가하게 되면 인덱스를 저장하는데 더 많은 디스크 공간이 필요하다.\n\t- 쿼리 성능의 이득이 데이터 수정 중 성능에 미치는 영향과 추가 디스크 공간 요구 사항보다 더 큰지 판단하는 것이 중요하다. 모든 열을 인덱싱하고 싶을 수 있지만, 불필요한 것은 추가하지 않는 것이 좋다.\n- create, update, delete가 빈번한 column에 index를 걸면 안 되는 이유?\n\t- 자주 업데이트되는 column을 인덱싱하면 인덱스 조각화가 발생할 수 있다. (인덱스 페이지가 연속적이지 않다는 것) 데이터베이스는 데이터를 검색하기 위해 추가 I/O 작업을 수행해야 한다. 따라서 인덱스를 사용하는 쿼리의 성능이 저하될 수 있다.\n\t- 인덱스 조각화란? \b인덱스에 있는 페이지의 논리적 순서가 데이터 파일의 페이지의 물리적 순서와 일치하지 않을 때 발생하는 상태이다. 인덱스를 스캔할 때 성능 문제를 일으킬 수 있다. \n\t- 자주 업데이트 되는 column을 인덱싱하면 페이지 분할 가능성이 높아질 수 있다. 이미 꽉 찬 페이지에 새 레코드가 삽입되면 페이지를 두 페이지로 분할해야 하며, 디스크 I/O가 추가되고 성능이 저하될 수 있다.\n\t- 디스크 공간 사용량이 증가한다.\n\t- 자주 업데이트되지만 검색 빈도도 높은 column의 경우 해당 column을 인덱싱하면 쿼리 성능이 개선된다. 따라서 상황에 따라서는 자주 업데이트되는 column을 인덱싱하는 것이 도움이 될 수도 있다.\n- 페이지가 꽉 찼을 때 새로운 데이터가 추가되는 경우에는 기존 페이지의 데이터 절반을 새로운 페이지에 할당한다. 따라서 페이지 밀도가 100%에서 50%로 줄어들게 된다."},{"excerpt":"이번 페어는 토리~ 🐿️ 1단계 미션에서 궁금했던 것 foreign key를 삭제해서 테스트는 편한데 이래도 될까? foreign key가 있으면 foreign key가 존재하는지에 대한 검증을 하지 않아도 된다는 장점이 있다. 그러면 foreign key를 믿을 것인가? foreign key가 있다가 없어질 수 있나? 그렇다면 foreign key가 있더…","fields":{"slug":"/level2-subway/"},"frontmatter":{"date":"2023년 05월 12일 07:05","title":"지하철 미션","tags":["우테코","미션","레벨2"]},"rawMarkdownBody":"\n이번 페어는 토리~ 🐿️\n\n## 1단계 미션에서 궁금했던 것\n- foreign key를 삭제해서 테스트는 편한데 이래도 될까?\n\t- foreign key가 있으면 foreign key가 존재하는지에 대한 검증을 하지 않아도 된다는 장점이 있다.\n\t- 그러면 foreign key를 믿을 것인가?\n\t- foreign key가 있다가 없어질 수 있나? 그렇다면 foreign key가 있더라도 검증을 하는 게 맞을 듯하다. 그런데 DB 설계가 수정되는 일이 많을까?\n- 도메인에 id가 있어도 될까?\n\t- 일단 id가 있으면 너무 편하다. id를 찾기 위해 DB를 다시 확인하는 일이 없어도 된다.\n\t- DB 의존적이라고 생각한다.\n- 모든 상황을 고려해서 예외 처리해야 할까?\n\t- 언제나 쓰는 곳이 정해져 있는데 그렇지 않은 경우를 상정하고 예외처리할 것인가?\n- 여러 개 추가될 때 어떤 값을 Location에 적어야 할까? 정말 전달하지 않는 것만이 최선이었을까?\n- dao 테스트 굳이 필요한가. 너무 복붙 코드고(대부분의 dao 테스트가 유사한 코드를 작성하게 된다) 의미가 없는 느낌이다.\n\t- 어쩔 수 없이 실제 DB를 사용하기 위해서는 save 메서드에 의존하게 되는데 이렇게 dao 테스트 하는 게 맞을까?\n- 도메인을 굳이 만들었어야 했을까? 사실 서비스에서 다 할 수 있는데 객체지향을 위해 도메인을 추가한 느낌?\n- 조인 vs 여러 번의 쿼리 중에 언제나 조인이 좋을까?\n\n\n## 1단계 미션에서 고민했던 것\n\n### 객체 설계 방법과 그 이유\nLine 안에 Sections가 있고, Section은 시작역과 도착역, 거리를 저장한다. Station은 역 이름을 저장한다.모든 Station에 종점인지 확인하기 위한 필드를 둘지 고민했다. 계산할 때는 편하지만 의미없는 데이터들이 많이 생길 것 같아 이런 설계를 고안하게 되었다.  \n\n장점: 의미 없는 데이터가 없다. 종점을 저장하는 것은 종점이 바뀔때마다 데이터가 변경되어야 하므로 데이터 안정성이 떨어진다.  \n단점: 종점을 찾는 로직을 설계하는게 어려웠다.\n\n### 테이블 설계 방법과 그 이유  \nstation 테이블은 id, 이름, line_id를 갖는다. section 테이블은 id, 시작역_id, 도착역_id, 거리, line_id를 갖는다. line 테이블은 id와 이름을 갖는다.객체 설계와 유사하게 테이블을 구성했다.  \nstation이 여러 line에 존재할 수 있기 때문에 line_id를 갖도록 했다.\n\n### API 설계 방법과 그 이유  \n노선 추가, 전체 노선과 역 조회, 특정 노선과 역 조회, 역 추가, 역 삭제하는 API를 설계했다.요구사항을 만족하는 기능만 구현했다.  \n\n시간이 부족했다. 역 조회, 역 목록 조회가 뼈대 코드에는 있었는데 노선 조회나 역 CREATE에서 역 id를 리턴하지 않아 클라이언트가 역 id를 알 수 있는 방법이 없다. 따라서 역 DELETE에서 이름을 받아 삭제하도록 했다.장점은 딱히 없고 상황상 어쩔 수 없이 선택했다. \n역을 추가할 때 역이 두 개가 한 번에 추가되는 경우가 있어 Location 헤더에 어떤 값을 전달해야 할 지 몰라서 id를 보내지 않았다. 또한 노선 조회에서 역 id를 찾으려면 N번 쿼리를 보내야 했기 때문에 성능상 전달할 수 없었다.  \n단점: http 컨벤션에 맞지 않는 API다. id는 index 처리가 되어 있지만 이름은 index 처리가 되어 있지 않아 쿼리 속도가 느리다.\n\n### 설계 과정에서 가장 고민을 많이 했던 부분  \n1. 종점 찾는 로직  \n2. 객체지향을 어떻게 지킬까  \n3. 노선을 생성만 하면 역이 어떻게 알아서 정렬되게 할까\n"},{"excerpt":"LOG 어제의 음주로 인해 아침에 일어나자마자 머리가 아팠다;; 이제 앞으로는 음주를 좀 자제해야 할 것 같다. 아침에 오니 디투랑 홍실도 아무것도 기억 못해서 웃겼다 ㅋㅋㅋ 자제하는 법 배우기... 주드, 박스터, 포이와 함께 제줏간에 갔다. 토리가 리사조 회식을 제줏간에서 한다고 해서 우연을 가장한 잠입을 했다. 백김치가 맛있었다. 배운 것 홍합은 영…","fields":{"slug":"/2023-05-12/"},"frontmatter":{"date":"2023년 05월 12일 06:05","title":"2023년 05월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 어제의 음주로 인해 아침에 일어나자마자 머리가 아팠다;; 이제 앞으로는 음주를 좀 자제해야 할 것 같다. 아침에 오니 디투랑 홍실도 아무것도 기억 못해서 웃겼다 ㅋㅋㅋ 자제하는 법 배우기...\n- 주드, 박스터, 포이와 함께 제줏간에 갔다. 토리가 리사조 회식을 제줏간에서 한다고 해서 우연을 가장한 잠입을 했다. 백김치가 맛있었다. \n\n## 배운 것\n- 홍합은 영어로 mussel이다.\n- foreign key가 있으면 foreign key가 존재하는 지에 대한 검증을 하지 않아도 된다는 장점이 있다. 쿼리를 날릴 때 FK가 유효하지 않은 경우 예외를 발생시킨다.\n\n## 궁금한 것\n- foreign key가 있다가 없어질 수 있나? 그렇다면 foreign key가 있더라도 검증을 하는 게 맞을 듯하다. 그런데 DB 설계가 수정되는 일이 많을까?\n- DB를 신뢰하는 것은 옳은가\n\n## 어려웠던 것\n\n## 느낀 것\n- 오늘 제줏간에서 술을 마실 수 있었지만 자제했다. 2차도 갈 수 있었지만 술을 안 마시기로 했기 때문에 가지 않았다. 절제하는 나자신 칭찬해 \n- 리뷰어와 디엠으로 소통하는 게 좋은 것 같다. 장바구니 리뷰 중에 이해가 안 되는 리뷰가 있어서 디엠을 보냈는데 빠르게 답변받을 수 있어서 좋았다. 제대로 이해되지 않거나 궁금한 것들은 앞으로 디엠으로 물어봐볼까."},{"excerpt":"LOG 미션을 완료했다! 사실 전날도 matzip 약속 때문에 저녁에 아무것도 못한 게 마음에 걸렸는데 다행이었다. 말랑의 코드를 아침에 보면서 왔는데 많은 도움이 된 것 같다. 말랑 그는 나의 거인. 거인의 어깨 위에서 많은 걸 배웠다. 서비스에 있던 비즈니스 로직을 다 도메인으로 옮기는 대작업을 했는데도 불만없이 잘 따라와준 토리한테도 감사하다 🥹 설…","fields":{"slug":"/2023-05-11/"},"frontmatter":{"date":"2023년 05월 12일 06:05","title":"2023년 05월 11일","tags":null},"rawMarkdownBody":"## LOG\n- 미션을 완료했다! 사실 전날도 matzip 약속 때문에 저녁에 아무것도 못한 게 마음에 걸렸는데 다행이었다. 말랑의 코드를 아침에 보면서 왔는데 많은 도움이 된 것 같다. 말랑 그는 나의 거인. 거인의 어깨 위에서 많은 걸 배웠다. 서비스에 있던 비즈니스 로직을 다 도메인으로 옮기는 대작업을 했는데도 불만없이 잘 따라와준 토리한테도 감사하다 🥹 설계가 자주 바뀌어서 제출 못할까봐 걱정했는데 다행이다.\n- 디투, 포이, 홍실과 육화식당에 갔다. 원래는 꿉당에 가려고 했는데 어제 오찌가 육화 식당 맛있다고 했던 것 같아서 (근데 확실하지 않다 ㅋㅋㅋ) 말했더니 목적지가 변경됐다. 고기는 맛있었고 김치찌개는 진짜 맛있었다;; 한 시간 만에 소주 3병 마시는 빠른 템포로 가다가 2차 갔는데 결국 기억이 하나도 안 난다ㅋㅋㅋ 진짜 음주를 했다... 집에는 어떻게 갔는지... 술 마시고 1일 3감사에 1감사만 올렸던데 올린 것도 기억이 안 난다 ㅋㅋㅋㅋㅋㅋ 술 좀 자제하자\n\n## 배운 것\n- Integer 같은 wrapper 클래스가 아닌 primitive 타입을 사용하고 `@Positive` 같은 validation 어노테이션을 사용하면 적용되지 않는다.\n- URL에 복수형을 쓸 때 컬렉션이나 배열에 추가/조회할 때로 생각하면 편하다.\n\n## 궁금한 것\n- foreign key를 삭제해서 테스트는 편한데 이래도 될까?\n- 도메인에 id가 있어도 될까?\n\t- 일단 id가 있으면 너무 편하다. id를 찾기 위해 DB를 다시 확인하는 일이 없어도 된다.\n\t- DB 의존적이라고 생각한다.\n- 모든 상황을 고려해서 예외 처리해야 할까?\n\t- 언제나 쓰는 곳이 정해져 있는데 그렇지 않은 경우를 상정하고 예외처리할 것인가?\n- 여러 개 추가될 때 어떤 값을 Location에 적어야 할까? 정말 전달하지 않는 것만이 최선이었을까?\n- dao 테스트 굳이 필요한가. 너무 복붙 코드고(대부분의 dao 테스트가 유사한 코드를 작성하게 된다) 의미가 없는 느낌이다.\n\t- 어쩔 수 없이 실제 DB를 사용하기 위해서는 save 메서드에 의존하게 되는데 이렇게 dao 테스트 하는 게 맞을까?\n- 도메인을 굳이 만들었어야 했을까? 사실 서비스에서 다 할 수 있는데 객체지향을 위해 도메인을 추가한 느낌?\n- 조인 vs 여러 번의 쿼리 중에 언제나 조인이 좋을까?\n\n## 어려웠던 것\n\n## 느낀 것\n- 미션이 끝나고 긴장이 풀려서 그런가 너무 신나게 놀아버렸다. 장바구니 미션 PR도 보내야 하고, 스터디도 있다는 거 잊지 말자. 할 일이 없을 때가 제일 열심히 해야할 때라고 생각한다~\n- 왠지 모르겠는데 말이 잘 나오는 날이었다. 사람들이랑 만나서 이야기하는 거 역시 재밌따~"},{"excerpt":"LOG mat.zip 4기 오리, 오찌, 후니, 블링, 태태, 샐리와 함께 밥을 먹게 되었다. 원래 교촌에 가기로 했는데 가는 곳마다 자리가 없어서 결국 크래프트 아일랜드에서 저녁을 먹게 되었다. 맛있게 잘 먹었습니다~ 이것저것 이야기를 많이 들었는데, 현업에서 일어나는 일들, 지금 하면 좋은 것들, 앞으로 어떻게 공부하면 좋을지 인사이트를 얻을 수 있어…","fields":{"slug":"/2023-05-10/"},"frontmatter":{"date":"2023년 05월 10일 15:05","title":"2023년 05월 10일","tags":null},"rawMarkdownBody":"## LOG\n- mat.zip 4기 오리, 오찌, 후니, 블링, 태태, 샐리와 함께 밥을 먹게 되었다. 원래 교촌에 가기로 했는데 가는 곳마다 자리가 없어서 결국 크래프트 아일랜드에서 저녁을 먹게 되었다. 맛있게 잘 먹었습니다~ 이것저것 이야기를 많이 들었는데, 현업에서 일어나는 일들, 지금 하면 좋은 것들, 앞으로 어떻게 공부하면 좋을지 인사이트를 얻을 수 있어서 매우 감사한 시간이었다. 다들 너무 유쾌하시고 재밌었다 ㅋㅋㅋ 2023 mat.zip 파이팅~!\n- 토리와 함께 지하철 역 추가를 구현하느라 하루를 다 썼다. 중간에 전혀 객체지향 하고 있지 않다는 걸 발견해서 그거 바꾸느라 시간이 너무 많이 들었다 😂 미션 완료할 수 있겠지...? 오늘 약속이 있는 바람에 구현을 많이 못해서 내일 9시에 만나서 하기로 했다. 열심히 노력해보고, 잘 되기를 바라야지..\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 객체지향을 지키는 것을 까먹어버렸다. 하도 DB랑 뭔가 하다보니까 절차 지향에 익숙해진걸까 ㅠ 객체지향을 놓지 않도록 앞으로 주의해야겠다.\n\n## 느낀 것\n- 이번 미션 너무 어렵다 ㅋㅋㅋ ㅜ 이것저것 이벤트들이 많은 바람에 시간이 조금 모자라서 걱정이 된다. 못 내면 어쩔 수 없긴 하지만 그래도 최선을 다해보자!! 토리 베로 파이팅 💪\n- 모르는 분들과 이야기할 주제를 많이 생각할 수 있게 되었다. 좀 더 덜 어색하게 말할 수 있어서 다행이었다. 애슐리와 말하는 것도 너무 즐거웠고, 다른 4기분들과 이야기하는 것도 즐거웠어서 역시 요즘은 사람 만나는 게 좋다~ 지금은 바빠서 많이 못하고 있는 것 같지만 😂\n"},{"excerpt":"나는 왜 사는가 왜 살아야 할까 살면서 계속해서 들었던 생각이다. 어떻게든 답을 듣고 싶어서 다른 사람들에게 물어보면, 그런 이야기 하지 말라고 했다. 어린 놈(?)이 무슨 벌써 그런 걱정을 하냐고 타박부터 들었다. 부모님한테 미안하지도 않냐는 말도 들었다. 그런 말은 하는 거 아니라며 다짜고짜 화내는 사람도 있었다. 그 중에서도 '원래 그냥 사는거다' …","fields":{"slug":"/writing-subject-candidate/"},"frontmatter":{"date":"2023년 05월 10일 01:05","title":"글감 주제","tags":["글"]},"rawMarkdownBody":"\n# 나는 왜 사는가\n\n**왜 살아야 할까**\n\n살면서 계속해서 들었던 생각이다.   \n어떻게든 답을 듣고 싶어서 다른 사람들에게 물어보면, 그런 이야기 하지 말라고 했다.   \n어린 놈(?)이 무슨 벌써 그런 걱정을 하냐고 타박부터 들었다. 부모님한테 미안하지도 않냐는 말도 들었다.    \n그런 말은 하는 거 아니라며 다짜고짜 화내는 사람도 있었다.\n\n그 중에서도 '원래 그냥 사는거다' 는 말이 제일 싫었다.   \n정말 이상하지 않나. 나는 앞으로도 계속 살아갈 텐데 내가 왜 사는지 묻지도 말라니.   \n어떻게든 정답을 찾고 싶었다. 살아가는 인생의 목적을 알고 싶었다.    \n앞으로 뭘 하고 싶은지도 모르는데 열심히 살 수는 없다. \n\n오기가 생겨서 오히려 일찍 죽겠다고 여기저기 말하고 다녔다. 처음엔 반쯤 오기였는데 이제는 진심이 되었다. \n나는 정말 내일 당장 죽어도 아쉽거나 미련이 남지 않을 것 같다.\n\n**목표가 없다**\n\n다른 사람들은 되고 싶은 것, 하고 싶은 것, 먹고 싶은 것 ... 원하는 게 많다. \n단기적으로든 장기적으로든 멋진 목표를 갖고 있는 사람들도 꽤나 많다. \n\n그런 사람들을 동경해서 나도 목표를 정하고 싶었다. \n\n**나는 재밌는 게 좋다**\n\n간절하지 않다. 하고 싶은 것도 없다. 그래서 내 인생은 꽤나 따분하다.\n오히려 재미를 찾는 이유는 그래서일지도 모른다. \n\n**나는 되는 대로 살고 싶다**\n\n사는 이유에 대한 정답은 못 찾았다.\n어쩌면 정답 같은 건 상관 없었을지도 모른다. 나에게는 살아야 하는 정당성이 필요하지 않았을까?\n\n현재를 살고 싶다. 앞으로 어떻게 사는지는 미래의 나에게 맡기자.\n그렇지만 결정을 할 때 과거가 방해가 되지 않게 살자. "},{"excerpt":"5/9 단위 테스트 단위 테스트란? 작은 코드 조각(단위)을 검증 빠르게 수행 가능 격리된 방식으로 처리 통합과 고립 협력 객체를 실제 객체로 사용하는지 mock 객체로 사용하는지에 따라 테스트 구현이 달라진다. Test Double 실제 객체 대신 사용되는 모든 종류의 객체에 대한 일반 용어 즉, 실제를 가짜 버전으로 대체한다는 의미 Stub 테스트 중…","fields":{"slug":"/level2-week4/"},"frontmatter":{"date":"2023년 05월 09일 02:05","title":"레벨2 4주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"\n# 5/9\n\n## 단위 테스트\n\n### 단위 테스트란?\n- 작은 코드 조각(단위)을 검증\n- 빠르게 수행 가능\n- 격리된 방식으로 처리\n\n### 통합과 고립\n- 협력 객체를 실제 객체로 사용하는지 mock 객체로 사용하는지에 따라 테스트 구현이 달라진다.\n\n## Test Double\n- 실제 객체 대신 사용되는 모든 종류의 객체에 대한 일반 용어\n- 즉, 실제를 가짜 버전으로 대체한다는 의미\n\n### Stub\n테스트 중에 만들어진 호출에 미리 준비된 답변을 제공하며 일반적으로 테스트를 위해 프로그래밍된 것 외에는 전혀 응답하지 않는다.\n\n`mock()` 을 사용하면 stub 객체를 만들 수 있다.\n\n`@Mock` 을 사용해도 stub 객체를 주입받을 수 있다.\n`@MockBean` 는 스프링 컨테이너에 올라가는 객체를 stub 객체로 만들 때 사용한다. \n\n### Fake\n실제 객체가 있고, 실제 객체와 똑같은 행위를 하는 비슷한 Fake 객체를 만드는 것.\n\n### 협력 객체를 실제 객체로? 가짜 객체로?\n실제 객체를 사용하면 협력 객체의 행위를 협력 객체 스스로가 정의한다.\n가짜 객체를 사용하면 협력 객체의 행위를 테스트가 정의한다.\n\n실제 객체를 사용하면 협력 객체의 상세 구현에 대해 알 필요가 없지만 협력 객체의 정상 동작 여부에 영향을 받는다. \n\n### 테스트 코드를 작성할 때\n가짜 객체를 활용하면 실제 객체를 사용할 때보다 좀 더 편하게 테스트를 작성할 수 있다. \n\n그러나 상세 구현에 의존하는 테스트가 될 수 있다.\n\n## Mockist의 단위 테스트\n테스트 대상을 협력 객체로부터 격리하기 위해 테스트 대상이 의존하는 모든 것을 가짜 객체로 대체한다.\n\n따라서 Line과 Station 모두 잘 동작하는지 검증한다는 것은 단위와 단위의 통합이 잘 동작하는지를 검증하는 것이다!\n\n### Outside In\nMockist TDD (London style)\n\n상위 레벨 테스트부터 시작한다.\n테스트 더블을 활용해서 테스트 대상이 의존하는 협력 객체의 예상 결과를 정의하고, 다음 사이클로 테스트 더블로 미리 정의한 협력 객체를 테스트 대상으로 한다.\n\n**단점**\n\n### Inside Out\nClassic TDD(Chicago style)\n\n실제 객체를 다뤄야 하기 때문에 도메인 모델을 시작.\n의존하는 협력 객체가 실제 존재해야 테스트를 작성할 수 있다.\n공유하는 객체(외부 리소스)를 사용할 때는 가짜 객체를 사용하기도 한다.\n\n**단점**\n도메인 설계가 충분히 이루어진 다음 진행 가능하다.\nTDD 사이클을 이어나가기가 상대적으로 어렵다.\n\n각 방법의 장단점이 명확하다.\n둘 중 하나를 선택해야 하는 문제가 아니다. 컨트롤러를 먼저 만들 것인지, 도메인 모델을 먼저 만들 것인지는 정답이 없다.\n\n### 아는 것에서 모르는 것으로\n> 사실은 상향식, 하향식 둘 다 TDD의 프로세스를 효과적으로 설명해줄 수 없다. 만약 어떤 방향성을 가질 필요가 있다면 아는 것에서 모르는 것으로 가는 방향이 유용할 것이다. 우리가 어느 정도의 지식과 경험을 가지고 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.\n\n### 추천하는 방법\n- Top-down으로 방향을 잡고, Bottom-up으로 구현하기\n- 통합 테스트 작성을 통해 요구사항과 기능 전반에 대한 이해를 선행한다.\n- 내부 구현에 대한 설계 흐름을 구상한다.\n- 설계가 끝나면 도메인부터 차근차근 TDD로 기능 구현\n- 만약 도메인이 복잡하거나 설계가 어려울 경우 이해하고 있는 부분부터 기능 구현\n\n# 5/10\n## 워크숍 Day 1\n1. 각자 쓰고 싶은 주제에 대한 이야기 나누기\n\t1. 어떤 경험을 글에 담아내고 싶은지 이야기하기\n\t2. 왜 이 주제를 선택했는지, 어떤 경험에서 비롯된 소재인지, 어떤 형식의 글을 쓰고 싶은지, 예상 독자는 누구인지 등등\n2. 저자의 이야기를 듣고 다른 사람들은 그 이야기를 4-5줄로 간단히 요약\n3. 독자들이 요약해 준 글에서 본인 이야기의 핵심이라고 생각하는 부분을 뽑아 한 문장으로 공유\n\n## 글의 핵심 씨앗 만들기 (소재 탐색하기)\n\n각자 쓰고 싶은 주제에 대한 이야기를 나눌 때, 저자가 아닌 다른 크루들의 역할이 매우 중요하다. \n저자가 주제에 대해 소개할 때, 소재(쓸 거리)를 풍부하게 찾아낼 수 있도록 경험을 끌어내주자.\n\n그 주제에 대해 가장 좋았던 경험?\n그 주제와 관련해 힘들고 후회되는 경험? 재밌었던 일화 등등\n\n### 목차 만들기\n\n각 그룹에서 글의 목차를 함께 만든다. 글에서 가장 핵심이 되는 부분을 위에 적고, 핵심을 더 잘 드러내기 위한 내용을 목차로 함께 추가해야 한다.\n핵심과 멀어지는 부분을 추가하는 것을 지양한다.\n\n"},{"excerpt":"LOG 오늘 스터디가 있어서 공부를 열심히 했다. 이번에 맡은 부분은 ApplicationContext 인데, 내용이 너무 어려워서 오열하면서 했다 ㅋㅋㅋ 스프링은 왜 이렇게 어려울까... 스터디 하고 나니까 공부할 게 더 많아져서 ㅋㅋㅋ 할 게 생겼다. 내일 새로운 페어와 또 다른 미션을 하게 되는데 기대가 되네요. 공부를 열심히 해봅시다. 평소보다 너…","fields":{"slug":"/2023-05-08/"},"frontmatter":{"date":"2023년 05월 08일 12:05","title":"2023년 05월 08일","tags":null},"rawMarkdownBody":"\n## LOG\n- 오늘 스터디가 있어서 공부를 열심히 했다. 이번에 맡은 부분은 ApplicationContext 인데, 내용이 너무 어려워서 오열하면서 했다 ㅋㅋㅋ 스프링은 왜 이렇게 어려울까... 스터디 하고 나니까 공부할 게 더 많아져서 ㅋㅋㅋ 할 게 생겼다. 내일 새로운 페어와 또 다른 미션을 하게 되는데 기대가 되네요. 공부를 열심히 해봅시다.\n- 평소보다 너무 늦게 일어났다. 10시 40분에 기상해서 너무 촉박하게 준비했지만? 의외로 잠실에는 빨리 도착해서 도착한 김에 맥날에 갔다. 빅맥을 먹어봤는데 맛있었다. \n\n## 배운 것\n- Filter에서는 Spring ExceptionHandler 예외 처리가 불가능하다. Filter도 요즘에는 Spring Bean으로 등록된다고 한다.\n\n## 궁금한 것\n- BeanDefinition이 어디서 초기화되는가?\n- Filter가 어떻게 bean으로 등록될까?\n- OncePerRequestFilter 가 일반 Filter와 다른 점이 뭘까?\n\n## 어려웠던 것\n- `ApplicationContext` 코드를 읽다 보니까 너무 머리에 안 들어와서 고생했다. 내 능력을 좀 많이 벗어나는 일을 빠른 시간 내에 해치우려고 하니 많이 힘들었을지도.. 좋은 프롤로그 글이 나온 건 아닌 것 같아서 아쉬웠다.\n\n## 느낀 것\n- 특별하게 있었던 일은 없었지만, 그래도 오늘 하루 재밌었다. 다만 공부할 게 어려워서 하루가 너무 금방 지나간 것 같아서 조금 아쉽다.\n- 스프링은 파면 팔수록 너무 어려운 것 같다 ㅋㅋㅋ ㅜ 내일 지하철 미션에도 '레벨2에는 스프링 기능 학습이 전부일 것이라는 생각을 해서 스프링 동작 원리에 집중했던 과거의 나를 원망하기' 라는 말이 있었는데 ㅋㅋㅋㅋ 아무래도 난가... 싶네요ㅋㅋ 그렇지만 어떻게 되지 않을까 싶습니다~ 너무 깊게 들어가서 고민하는 중인가도 고민이 된다. 아직 스프링을 잘 사용할 줄 아느냐, 하면 그렇지 않아서 어디까지 공부해야 할 지 고민이 많이 된다. 일단 지금은 그냥 공부하고 싶은 것 이것저것 공부하는 중이다. 이렇게 하면 효율이 별로일 때도 있으니, 좀 더 고려해봐야 할 것 같다."},{"excerpt":"LOG 오늘은 공부를 열심히 했다. 스타벅스에 가서 집중했는데, 한 6시까지는 집중이 잘 되다가 너무 어려운 내용이 나오니까 집중하기 쉽지 않았다. 중간에는 몇 번 존 것 같기도 하다 ㅋㅋㅋ ㅠ 확실히 잘 모르거나 집중이 안 되는 상황만 오면 졸리다. 요즘 그냥 졸린 거 같기도 하고? 날이 추웠다. 반팔, 셔츠, 니트까지 껴입었는데도 추웠는데 기온은 18…","fields":{"slug":"/2023-05-07/"},"frontmatter":{"date":"2023년 05월 07일 08:05","title":"2023년 05월 07일","tags":null},"rawMarkdownBody":"\n## LOG\n- 오늘은 공부를 열심히 했다. 스타벅스에 가서 집중했는데, 한 6시까지는 집중이 잘 되다가 너무 어려운 내용이 나오니까 집중하기 쉽지 않았다. 중간에는 몇 번 존 것 같기도 하다 ㅋㅋㅋ ㅠ 확실히 잘 모르거나 집중이 안 되는 상황만 오면 졸리다. 요즘 그냥 졸린 거 같기도 하고?\n- 날이 추웠다. 반팔, 셔츠, 니트까지 껴입었는데도 추웠는데 기온은 18도여서 그냥 날씨 자체가 아이러니했다. 내일은 좀 안 추웠으면 좋겠다.\n- 미션 2단계 PR을 제출했다. 벌써 모레면 새로운 페어를 만나게 된다는 게 와닿지 않는다. 이번에는 좀 더 빨리 미션을 제출할 수 있었을 것 같은데 컨디션 난조로 인해 늦게 제출한 게 많이 아쉽다. 리뷰를 빨리 받기 위해서는 얼른 얼른 제출하는 게 훨씬 더 이득 같다. 그래도 늦게 제출했지만 다른 크루들의 리뷰를 많이 훔쳐봐서 그 과정에서 많이 배운 것 같다. 리뷰 savage 좋아요~\n\n## 배운 것\n- `RestAssured` 와 같이 외부에 API 요청을 하는 방식으로는 `@Transactional`이 적용되지 않는다.\n\n## 궁금한 것\n- 인증 로직은 대체 어디에 있어야 할까? ArgumentResolver, Filter, Interceptor, AuthService?\n- ArgumentResolver의 패키지 위치는 어딜까? (Controller, 혹은 다른 패키지?)\n- audit이 필요한 이유?\n\n## 어려웠던 것\n- 어렵고 지루한 내용이 나올 때 집중을 유지하기 어렵다. 이럴 때는 잠깐 쉬었다가 하는 게 좋을까? 근데 아까는 쉬어도 끝까지 집중력이 돌아오지 않았다. \n- 어려운 내용을 어디까지 파야 할까? 아직 그 기준을 세우는 게 너무 어렵다. 어디까지가 깊고, 어디까지가 얕은 건지 몰라서 그런 것 같기도 하다. \n\n## 느낀 점\n- 인생에 대한 고찰과 내가 어떻게 살아가고 있는지, 어떻게 살고 싶은지에 대한 생각을 많이 했다. 그냥 흘러가는 대로 사는 것도 좋지만, 살아가는 것에 대한 의미를 계속해서 사유하며 살아가자.\n- 잠실캠에 안 간 지 좀 됐는데 사람들이 보고 싶다 ㅋㅋㅋ 어쩔 수 없이 사람들과 이야기하는 게 재밌어서 그런 거 같다. 데일리도 하고 싶고, 이야기도 하고 싶고, 공부도 하고 싶다~"},{"excerpt":"IoC Container란? 각각의 용어를 풀어보자. IoC 란 Inversion of Control 의 약자로서, 제어의 역전을 뜻한다. 의존성 주입이라고 하기도 한다.\n컨테이너는 객체의 생명주기를 관리하고, 생성된 인스턴스들에게 추가적인 기능을 제공한다. 즉, IoC Container는 객체의 생성과 라이프사이클을 관리하고, 의존성을 클래스에 주입하기…","fields":{"slug":"/ioc-container-and-di/"},"frontmatter":{"date":"2023년 05월 07일 07:05","title":"IoC Container와 DI","tags":["spring","개발"]},"rawMarkdownBody":"\n## IoC Container란?\n\n각각의 용어를 풀어보자.\n\n**IoC** 란 Inversion of Control 의 약자로서, 제어의 역전을 뜻한다. 의존성 주입이라고 하기도 한다.\n**컨테이너**는 객체의 생명주기를 관리하고, 생성된 인스턴스들에게 추가적인 기능을 제공한다.\n\n즉, IoC Container는 객체의 생성과 라이프사이클을 관리하고, 의존성을 클래스에 주입하기도 한다.\n\n주로 다음과 같은 기능을 제공한다.\n\n- IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다.\n- POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.\n- 개발자들이 직접 POJO를 생성할 수 있지만 컨테이너에게 맡긴다.\n- 개발자는 비즈니스 로직에 집중할 수 있다.\n- 객체 생성 코드가 없으므로 TDD가 용이하다.\n\nSpring Framework의 IoC 컨테이너 구현은 org.springframework.beans, org.springframework.context 패키지의 기반이 된다.\n\n그 중에서도 `BeanFactory` 인터페이스는 모든 유형의 객체를 관리할 수 있는 고급 Configuration 메커니즘을 제공한다.\n`BeanFactory` 와 `ApplicationContext` 인터페이스는 Spring IoC 컨테이너를 가리킨다.\n\nSpring IoC 컨테이너가 관리하는 객체를 **빈(bean)** 이라고 하고, 이 빈(bean)들을 관리한다는 의미로 컨테이너를 **빈 팩토리(BeanFactory)** 라고 부른다.\n- 객체의 생성과 객체 사이의 런타임(run-time) 관계를 DI 관점에서 볼 때는 컨테이너를 **BeanFactory**라고 한다.\n- BeanFactory에 여러 가지 컨테이너 기능을 추가하여 **애플리케이션 컨텍스트(ApplicationContext)** 라고 부른다.\n\n### BeanFactory와 ApplicationContext\n\n- **BeanFactory**\n**Bean Factory**는 Bean을 등록, 생성, 조회, 반환을 관리한다. 보통은 BeanFactory를 바로 사용하지 않고, 이를 확장한 ApplicationContext를 사용한다. `getBean()` 메서드가 정의되어 있다.\n\n- **ApplicationContext**\nBean을 등록,생성,조회,반환을 관리하는 기능은 **BeanFactory**와 같다. Spring의 각종 부가 서비스를 추가로 제공한다. \n\n## DI (Dependency Injection) 이란?\n\n외부에서 클라이언트에게 서비스를 제공하는 것이다. \n즉, 객체가 필요로 하는 어떤 것을 외부에서 전달해주는 것이다.\n\n### 장점\n- 코드의 재사용성과 유연성이 높다.\n- 객체간 결합도가 낮아 한 클래스를 수정했을 때 다른 클래스를 수정해야 하는 상황을 막아준다.\n- 유지보수가 쉬우며 테스트가 용이하다. 어떤 클래스가 의존하는 객체가 변경되었을 때 코드의 변경을 최소화하며 유지보수할 수 있다. 또한 의존성 주입을 사용하면 클래스가 의존하는 객체를 외부에서 주입받아 사용하게 된다. 테스트 시에 클래스의 의존성을 변경하며 테스트할 수 있어 테스트가 용이하다.\n- stub, mock 객체를 사용하여 단위 테스트 시에 이점을 갖는다.\n\n### 단점\n- 주입된 객체들에 대해 코드 추적이 어렵고, 가독성이 떨어진다.\n- 간단한 프로그램을 만들 때는 오히려 번거롭다.\n\n## 의존관계 주입 방식\n\n### 생성자 주입\n생성자를 통해 의존 관계를 주입 받는다.\n\n스프링에서는 생성자 주입을 권장하고 있다. \n객체 생성 이후 의존 관계가 변경되지 않는 경우 생성자 주입을 사용하는 것이 좋다.\n\n#### 특징\n- 생성자 호출 시점에 한 번만 호출하는 것이 보장된다.\n- 생성자가 1개만 존재하는 경우에는 `@Autowired` 를 생략해도 자동으로 주입된다. 2개 이상일 때는 컴파일 예외가 발생한다.\n- 필드가 존재하지 않는 NPE를 방지할 수 있다.\n- 주입 받을 필드가 final이 될 수 있다.\n- 순환 참조를 방지한다. 필드 주입과 setter 주입은 빈이 생성된 이후에 참조하기 때문에 애플리케이션이 예외, 경고 없이 실행되어 실제 코드가 호출될 때까지 문제를 알 수 없다. 생성자를 통해 의존관계를 주입하면 `BeanCurrentlyInCreationException` 이 발생하여 문제를 알 수 있다.\n\n```shell\n2023-06-06 17:01:38.453  WARN 49905 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'circularReferenceBean' defined in file [/Users/cyma/IdeaProjects/sample-project/build/classes/java/main/hello/practice/CircularReferenceBean.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'practiceBean' defined in file [/Users/cyma/IdeaProjects/sample-project/build/classes/java/main/hello/practice/PracticeBean.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'circularReferenceBean': Requested bean is currently in creation: Is there an unresolvable circular reference?\n```\n\n### Setter 주입\n\n필드 값을 변경하는 setter로 의존 관계를 주입하는 방법이다.\n`@Autowired` 가 있는 setter로 자동으로 의존관계를 주입한다.\n\n#### 특징\n- 객체 생성 이후 변경 가능성이 있는 의존 관계에서 사용한다.\n- `@Autowired` 를 입력하지 않으면 실행이 되지 않는다.\n- `set필드명` 메서드로 의존 관계를 주입한다.\n\n### 필드 주입\n\n필드에 `@Autowired`를 붙여서 주입하는 방식이다.\n\n```java\npublic class A {\n\t@Autowired\n\tprivate B b;\n}\n```\n\n#### 특징\n- 필드 주입을 하게 되면 DI 컨테이너 안에서만 정상 작동한다. 즉, POJO가 아니다.\n- final 키워드를 사용할 수 없기 때문에 불변이 아닌 필드를 갖게 되고, setter로 가변 속성도 아닌 애매한 포지션이다.\n\n### 일반 메서드 주입\n\n```java\npublic class A {\n\tprivate B b;\n\tprivate C c;\n\n\t@Autowired\n\tpublic void method(B b, C c) {\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t}\n}\n```\n\n#### 특징\n- 여러 필드를 주입받을 수 있다. -> 근데 이럴거면 생성자 주입 씀"},{"excerpt":"장바구니 미션  는  방식보다는 되도록 Controller를 작성해주는 것이 좋다. 해당 엔드포인트에 대한 컨트롤러가 중복될 수도 있고, 찾지 못할 수도 있기 때문이다. admin용 응답과 서비스용 응답은 현재 응답이 같더라도, 다른 service, 다른 responseDto를 활용하는게 좋습니다.  admin용 응답에는 더 디테일한 데이터가 들어갈 수 …","fields":{"slug":"/level2-review-mosquito/"},"frontmatter":{"date":"2023년 05월 07일 06:05","title":"레벨2 리뷰 훔쳐보기","tags":["레벨2","우테코"]},"rawMarkdownBody":"\n## 장바구니 미션\n\n- `ViewController` 는 `Configuration` 방식보다는 되도록 Controller를 작성해주는 것이 좋다. 해당 엔드포인트에 대한 컨트롤러가 중복될 수도 있고, 찾지 못할 수도 있기 때문이다.\n- admin용 응답과 서비스용 응답은 현재 응답이 같더라도, 다른 service, 다른 responseDto를 활용하는게 좋습니다.  admin용 응답에는 더 디테일한 데이터가 들어갈 수 있고, 서비스용 메서드는 인증 절차와 같은 부수적인 기능이 포함될 수 있기 때문입니다.\n- 오류메시지의 정보는 많이 넣어주자. 대신 클라이언트까지 전달되는 값은 보안상 부적절하니, Exception의 메시지 자체에는 오류 내용을 풍부하게 싣고 ExceptionHandler에서 사용자 메시지로 전달되는 부분을 변경하면 좋을 것 같다.\n- 인증인가 부분은 특히 메시지에 신경을 써야한다. 오류에서 생성되는 메시지들이 공격자에게 유효한 정보를 주지는 않는지 점검해보자.\n- jackson 2.13 릴리즈 패치에서 기본생성자 없이도 직렬화가 가능하도록 변경되었습니다[https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.13#no-constructor-deserializer-module](https://github.dev/woowacourse/jwp-shopping-cart/pull/298/files \"https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.13#no-constructor-deserializer-module\")\n\n### 의문점\n- 인증 로직은 대체 어디에 있어야 할까? ArgumentResolver, Filter, Interceptor, AuthService?\n- ArgumentResolver의 패키지 위치는 어딜까? (Controller, 혹은 다른 패키지?)\n- audit이 필요한 이유?\n\n테스트에서 데이터를 통해 의존성이 생기는 것은 주의하자.\n인증 쪽에서 로그인을 해야 사용할 수 있다. 유저를 매번 생성하지 않고 미리 하나 만들어두고 재사용하는 방식을 사용한다. 테스트 스코프는 중요하다.\n\n**슬라이스 테스트**가 의미가 있다고 생각하시는가? \n컨트롤러 계층에 대한 테스트는 e2e 테스트로도 충분히 검증할 수 있다고 생각한다. 컨트롤러 mocking은 굳이 의미 없다고 생각한다. 그러나 컨트롤러에 로직이 들어간다면 그럴 수 있다.\n서비스도 슬라이스 테스트가 의미 없다. 지금은 dao 에서 조회만 하고 있기 때문에 그렇다. 서비스에 로직이 들어가게 되면 의미가 있을 것이다. 그러나 그런 로직이 없기 때문에 더욱 의미가 없는 것처럼 느껴진다. \n\n### 럿고\n\n서비스 계층을 mocking을 하는 것\n테스트는 현재에 대해서만 검증하면 된다고 생각하지만, 미래를 대비하는 역할을 한다. 그런 부분에서는 테스트 코드가 안정성이 더 중요하다. 더 꼼꼼하게 작성하자. slice 테스트든 뭐든 학습 목적으로는 많이 고민해보는 것이 좋다. 호되게 당해보는 것도 오히려 좋을 수 있다. \n\n클라이언트에서 찾을 수 없는 id에 대한 업데이트와 삭제를 요청하는 경우, 현재는 404를 리턴하고 있는데, 200 ok나 500 예외를 던지는 것 중 어떤 것이 좋을까요? -> **404 Not Found**\nbody로 전달을 하게 된다면? -> update를 할 때도 URI에는 ID를 넣기 때문에(컨벤션) 해당 API가 존재하지 않는다는 뜻을 가지므로 괜찮다고 생각한다.\nHttpStatus Code에 대해 좀 더 알아보자.\n\nDB는 최대한 데이터를 가공하는 것은 피하는 것이 좋다고 생각한다.\n\nDB 테이블에 audit을 추가하면 좋다는 리뷰를 다른 크루의 리뷰에서 봤었는데, audit을 추가했을 때 관리 측면에서 좋은 이유가 무엇인가요? -> created_at, updated_at가 필요한 이유? 장애가 발생했을 때 롤백을 하기 위해서? 관리 측면도 있고, 게시판 형태에서 많이 사용한다. 차후에 미래를 생각하면서 만드는 것 같다. 예전에 만들어진 데이터에 관해서도 \n\n### 고칠 부분\n- [ ] 404 응답을 5xx 예외로 변경하기"},{"excerpt":"LOG 몸 상태가 너무 안 좋아서 네오에게 재택한다고 말씀드리고 집에서 재택을 했다. 네오도 어제 병가를 냈다고 하시던데 아마 나와 같지 않으셨을까 싶다...ㅋㅋㅋ 어제 검사해보니 A형 독감이라고 나와서 다른 사람들에게 옮기지 않기 위해서라도 재택을 하는 게 맞았던 거 같다. 아침까지는 열이 정말 많이 났는데, 약을 좀 꾸준히 먹으니 좀 더웠다. 다행히 …","fields":{"slug":"/2023-05-04/"},"frontmatter":{"date":"2023년 05월 04일 17:05","title":"2023년 05월 04일","tags":null},"rawMarkdownBody":"## LOG\n- 몸 상태가 너무 안 좋아서 네오에게 재택한다고 말씀드리고 집에서 재택을 했다. 네오도 어제 병가를 냈다고 하시던데 아마 나와 같지 않으셨을까 싶다...ㅋㅋㅋ 어제 검사해보니 A형 독감이라고 나와서 다른 사람들에게 옮기지 않기 위해서라도 재택을 하는 게 맞았던 거 같다. 아침까지는 열이 정말 많이 났는데, 약을 좀 꾸준히 먹으니 좀 더웠다. 다행히 지금은 그렇게 열이 많이 나거나 하지 않는다!\n- 드디어 도메인을 등록했다. 허브신님이 어떻게 하는지 알려줘서 한 2일간 못하던 거 끝냈따~ 앞으로는 vero.wiki 로 접속해주세요 ^-^\n\n## 배운 것\n- `Interceptor` 는 특정 url path를 지정할 수 있고, `Filter` 는 모든 url에 적용된다고 한다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 몸 관리를 잘하자... 건강하지 않으니 아무것도 할 수가 없다. 오늘도 공부하려고 했는데 너무 졸려서 4시간 자버려서 공부를 거의 못했다. 실제로 컨디션이 공부에 영향을 미치게 되니 나도 미칠 노릇이다 ㅋㅋ 얼른 나아서 열심히 공부하자 ~\n- 집에서보다 밖에서 공부하는 게 집중이 더 잘 되는 거 같다. 집에 붙어있지 않도록 노력해봐야겠다... 😂"},{"excerpt":"LOG 확실히 감기가 걸렸다. 이번에는 오래 안 아프고 싶어서 바로 병원에 갔다. 사실 병원에 안 가도 괜찮을 것 같다는 생각을 잠깐 했는데, 기침을 하다보니 피맛이 나서 ㅋㅋ 그냥 병원에 갔다. 병명은 원인불명의 기관지염. 기관지염 뭘까.. 자꾸 의사선생님이 비염이 있냐고 물어봤다. 없던 비염이 생긴 건 아니겠지? 회고 모임에서 한강으로 오프라인 모임을…","fields":{"slug":"/2023-05-02/"},"frontmatter":{"date":"2023년 05월 02일 15:05","title":"2023년 05월 02일","tags":null},"rawMarkdownBody":"## LOG\n- 확실히 감기가 걸렸다. 이번에는 오래 안 아프고 싶어서 바로 병원에 갔다. 사실 병원에 안 가도 괜찮을 것 같다는 생각을 잠깐 했는데, 기침을 하다보니 피맛이 나서 ㅋㅋ 그냥 병원에 갔다. 병명은 원인불명의 기관지염. 기관지염 뭘까.. 자꾸 의사선생님이 비염이 있냐고 물어봤다. 없던 비염이 생긴 건 아니겠지?\n- 회고 모임에서 한강으로 오프라인 모임을 갔다. 날이 좋아서 (생략) 기분이 좋았다. 뭔가 뛰고 싶었는데 못 뛰어서 좀 아쉬웠다. 기술적인 성장 + 기술 외적인 성장에 대해 회고했다. 기술적인 성장에서 다들 뭘 배웠는지에 대해 말하는 게 아니라 내가 어떤 식으로 공부하게 되었는지 말하는 게 되게 좋은 방향이라고 생각했다. 기술 외적인 성장에서는 내가 얼마나 이전의 나보다 긍정적으로 바뀌었는지, 사람들에게 더 잘 다가가게 되었다는 이야기를 했다. 회고 끝나고는 체인저의 여자친구 목도리 돌리기, 당신의 이웃을 사랑하십니까 게임을 했다 ㅋㅋㅋ 재밌었다. 이런 게임은 언제 안 재밌을까 ㅋㅋ\n- 말랑과 오잉의 테코톡 발표를 들었다. 둘 다 내용도 유익하고 발표도 잘해서 여기는 발표 잘 하는 사람밖에 없나? 라는 생각을 했다. 나도 나중에 테코톡 발표할 때 말을 어떻게 해야 좋을지 갑자기 고민이 됐다.\n\n## 배운 것\n- Base64에 대해 좀 더 알아봤다 : 아직 덜 쓴 [[spring-authentication]]\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 오늘따라 공부가 하고 싶었는데, 항상 이런 날에는 약속이 있다. 베로의 약속 법칙... 공부가 하기 싫은 날에는 아무 일도 없어서 확실히 타이밍을 잘 맞춰야 한다. 요즘에 많이 놀아서 더 공부가 하고 싶은 거 같기도 하다. 그만 놀고 공부해야겠다.\n- 최근에 니체의 책을 읽었다. `마흔에 읽는 니체` 였나 ㅋㅋ 마흔은 아니지만 마흔의 나를 상상하며 읽었다. 갑자기 인간 말종에 대한 말이 나왔는데, 제대로 된 사람은 삶을 욕망한다고 한다. 그런데 생각해보면 내가 삶을 살면서 욕망했던 것은 손에 꼽는 것 같다. 그래서 아마도 ? 과거의 나는 확실하게 인간 말종이었을지도?ㅋㅋㅋ 지금의 나를 대입해서 봐도 아직은 인간 말종일 수도 있을 것 같다. 니체에 따르면 인간 말종은 그저 즐거운 소일거리에만 매달리는 삶을 산다고 한다. 아직 나는 즐거운 소일거리가 너무 좋은 거 같다. 니체가 그렇게 말했다고 해서 ABN? by all means~ 아직은 바뀌고 싶은 생각이 없으니 좀 더 인간 말종으로 살아보자 ~"},{"excerpt":"인증과 인가 인증 식별 가능한 정보로 서비스에 등록된 유저의 신원을 입증하는 과정 인가 인증된 사용자에 대한 자원 접근 권한 확인 (인증이 선행되어야 한다) 인증과 인가 => 자원을 적절한 / 유효한 사용자에게 전달하거나 공개하기 위한 방법이다. Basic Authentication 클라이언트가 사용자 이름과 비밀번호를 통해 인증을 수행하는 것이다. Ba…","fields":{"slug":"/spring-authentication/"},"frontmatter":{"date":"2023년 05월 02일 06:05","title":"Authentication","tags":["레벨2","spring","개발"]},"rawMarkdownBody":"\n## 인증과 인가\n\n### 인증\n- 식별 가능한 정보로 서비스에 등록된 유저의 신원을 입증하는 과정\n\n### 인가\n- 인증된 사용자에 대한 자원 접근 권한 확인 (인증이 선행되어야 한다)\n\n인증과 인가 => 자원을 적절한 / 유효한 사용자에게 전달하거나 공개하기 위한 방법이다.\n\n## Basic Authentication\n\n클라이언트가 사용자 이름과 비밀번호를 통해 인증을 수행하는 것이다. \n\nBasic 키워드로 시작해서 base64로 인코딩된 `사용자이름:비밀번호` 값으로 이어진다. 이때, `:` 는 구분자로 사용되므로 빼놓지 말고 사용해야 한다.\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class CustomWebSecurityConfigurerAdapter {\n\n    @Autowired private MyBasicAuthenticationEntryPoint authenticationEntryPoint;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        auth\n          .inMemoryAuthentication()\n          .withUser(\"user1\")\n          .password(passwordEncoder().encode(\"user1Pass\"))\n          .authorities(\"ROLE_USER\");\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/securityNone\")\n            .permitAll()\n            .anyRequest()\n            .authenticated()\n            .and()\n            .httpBasic()\n            .authenticationEntryPoint(authenticationEntryPoint);\n        http.addFilterAfter(new CustomFilter(), BasicAuthenticationFilter.class);\n        return http.build();\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n`httpBasic()` 요소를 사용하여 `SecurityFilterChain` 빈 내에서 basic authentication을 정의할 수 있다.\n\n```http\n###### HTTP Request ######\nGET /members/my HTTP/1.1\nauthorization: Basic ZW1haWxAZW1haWwuY29tOjEyMzQ=\naccept: application/json\nhost: localhost:54560\nconnection: Keep-Alive\nuser-agent: Apache-HttpClient/4.5.13 (Java/11.0.19)\naccept-encoding: gzip,deflate\n\n\n###### HTTP Response ######\nHTTP/1.1 200 OK\nTransfer-Encoding: chunked\nKeep-Alive: timeout=60\nConnection: keep-alive\nDate: Tue, 02 May 2023 08:28:03 GMT\nContent-Type: application/json\n```\n\n`authorization` 헤더에 인코딩된 값을 넣어 Request로 전달한다.\n\n### Base64\n\nBase64는 바이너리 데이터를 내용 자체의 손실이나 수정 없이 전송할 수 있는 ASCII 문자 집합으로 인코딩 하는 방식이다.\n\n컴퓨터 간에 데이터를 전송하려면 데이터를 0과 1로 인코딩하여 전송한 다음 다시 디코딩해야 한다. \n문자당 비트 수를 다르게 사용하는 다양한 인코딩이 만들어졌지만, 결국 문자당 7비트를 사용하는 ASCII가 표준이 되었다.\n그러나 대부분의 컴퓨터는 바이너리 데이터를 각각 8비트로 구성된 바이트로 저장하므로, ASCII는 바이너리 데이터 전송에 적합하지 않았다. 이때 Base64 인코딩이 도입되었다. 그러나 Base64를 사용하여 메시지를 인코딩하면 3바이트의 데이터가 4개의 ASCII 문자로 인코딩되기 때문에 전송되는 데이터의 길이가 늘어난다.\n\n또한 Base64 인코딩은 데이터를 인코딩하고 디코딩하는데 추가적인 시간이 필요하다.\n\n결정적으로 Base64 인코딩은 지나치게 간단하다. 따라서 패스워드를 제대로 보호하기 힘들다.\nBase64 인코딩은 암호화가 아닌 인코딩이다. 개발할 때 encoding을 사용하는 이유는 암호화가 아니라 가시성과 보관성을 위해서이다. 따라서 암호화를 위해 Base64 인코딩을 사용하면 취약하다고 할 수 있다.\n\n결론! 중요한 보안 정보를 보호하는 데에 Base64 인코딩을 사용해서는 안 된다.\n\n## Token Authentication\n\nSpring에서 token authentication 은 인증, 권한 부여를 위한 프로토콜인 OAuth2.0을 사용하여 구현할 수 있다.\n\nBearer 토큰은 인증 서버에서 발급하는 보안 토큰으로, OAuth2.0 리소스 서버에 의해 보호되는 리소스에 접근하기 위해 사용된다. 유효한 Bearer 토큰으로 사용자를 인증할 수 있다.\n\n## Session Authentication\n\n## 참고 자료\n- [토니의 인증과 인가](https://www.youtube.com/watch?v=y0xMXlOAfss)\n- https://www.baeldung.com/java-httpclient-basic-auth\n"},{"excerpt":"5/2 인증 일단 인증을 붙이고 생각하는 게 아니라 구현할 기능에 따라서 인증을 붙일지 말지 고민한다. 인증: 누구인가?\n인가: 권한이 있는가? 기능이 어떤 요구사항을 가지는지에 따라 인증/인가 구현이 달라진다 => 테코톡 보고 학습하자 ? 권한이 없는 사용자의 요청 인증 & 인가는 내가 특정 자원을 요청할 때 응답을 받을 수 있는지 없는지 확인하는 것.…","fields":{"slug":"/level2-week3/"},"frontmatter":{"date":"2023년 05월 02일 01:05","title":"레벨2 3주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 5/2\n\n## 인증\n\n일단 인증을 붙이고 생각하는 게 아니라 구현할 기능에 따라서 인증을 붙일지 말지 고민한다. \n\n**인증: 누구인가?\n인가: 권한이 있는가?**\n\n기능이 어떤 요구사항을 가지는지에 따라 인증/인가 구현이 달라진다 => 테코톡 보고 학습하자\n\n## ?\n\n### 권한이 없는 사용자의 요청\n\n인증 & 인가는 내가 특정 자원을 요청할 때 응답을 받을 수 있는지 없는지 확인하는 것.\n\n클라이언트는 서버에 사용자가 누구인지 식별할 수 있는 정보를 보내고, 서버에서 접근 가능한 사용자인지 판단한다.\n\n서버에는 사용자의 정보를 저장하지 않는다. (무상태성)\n모든 서버가 그런 것은 아니다. 앞서 보낸 정보가 누구의 정보인지 알고 있는 서버가 있기도 하다.\n그러나 보편적으로 사용하는 서버에서는 상태가 없다고 생각하면 된다.\n\n### Basic Auth\n\n`Authorization` 헤더에 구분자와 키 값을 넣어서 전송한다.\n인증을 할 수 있는 값을 넣어서 전송하는 것. \n아이디와 패스워드를 계속해서 입력 받아야 한다.\n\n### 인증 정보\n\n인증 정보를 다른 형태의 정보로 저장한다. (쿠키/세션, 토큰 등)\n인증 정보를 매 요청 때마다 보내는 것은 똑같지만, 1차원적으로 아이디/패스워드를 인코딩한 값을 보내는 것과 서버와 약속한 정보를 보내느냐의 차이가 있다.\n\n### Session\n\n1. 사용자 로그인\n2. 서버에서 DB를 통해 사용자 확인\n3. 서버가 회원 정보 세션을 생성하여 세션 저장소에 저장한다.\n4. 세션 저장소에서 서버에게 Session ID를 발급해준다.\n5. 사용자에게 Session ID를 포함한 응답을 전송한다.\n6. 사용자는 다음 요청부터 쿠키에 Session ID를 함께 전송한다. 특정 헤더 값에 포함해서 보내면 된다.\n7. 서버가 쿠키를 검증한다.\n8. 세션 저장소에서 유저 정보(세션)을 획득한다.\n9. 요청 데이터를 응답한다.\n\n## 학습 테스트\n\n- `preemitive()` : 최초에 어떤 인증을 하는지 확인하는 과정을 생략하면 효율적으로 진행할 수 있다.\n\n```java\n@Test  \nvoid basicLogin() {  \n    MemberResponse member = RestAssured  \n            .given().log().all()  \n            .auth().preemptive().basic(EMAIL, PASSWORD)  \n            .accept(MediaType.APPLICATION_JSON_VALUE)  \n            .when().get(\"/members/my\")  \n            .then().log().all()  \n            .statusCode(HttpStatus.OK.value()).extract().as(MemberResponse.class);  \n  \n    assertThat(member.getEmail()).isEqualTo(EMAIL);  \n}\n```\n\n`preemitive()` 를 생략하면 `authorization` 헤더가 없어지게 된다.\n\n```java\n// PreemptiveBasicAuthScheme.java\npublic String generateAuthToken() {  \n  (\"Basic \" + \"$userName:$password\".getBytes(AUTH_ENCODING).encodeBase64()).toString()  \n}\n```\n\nBasic의 경우 :로 구분하는 것을 볼 수 있다.\n\n- Basic을 꼭 붙여야 할까? : https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization#directives\n- `validateToken` 은 토큰이 만료되었는지 아닌지를 판단하기 위해 사용한다.\n\n## Spring Mvc with 다른 구성 요소\n\n- `MethodArgumentResolver`: 특정 요청들을 분리해서 매개변수로 전달하는 것\n"},{"excerpt":"LOG 갑자기 오늘따라 눈이 일찍 떠져서 6시에 일어났다;;; 다시 자려고 했는데 잠이 안 왔다.. 일찍 일어난 김에 오랜만에 아침을 만들어서 먹었다. 집에 스팸이 쌓여서 스팸 김치 볶음밥을 해먹었는데 맛있었다. 빨래도 하고 설거지도 하고 오랜만에 집안일을 좀 했더니 집이 그나마 깨끗해졌다. 포켓몬 전시회에 갔다. 판교에서 하는 줄 알고 판교까지 갔는데 …","fields":{"slug":"/2023-05-01/"},"frontmatter":{"date":"2023년 05월 01일 12:05","title":"2023년 05월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 갑자기 오늘따라 눈이 일찍 떠져서 6시에 일어났다;;; 다시 자려고 했는데 잠이 안 왔다.. 일찍 일어난 김에 오랜만에 아침을 만들어서 먹었다. 집에 스팸이 쌓여서 스팸 김치 볶음밥을 해먹었는데 맛있었다. 빨래도 하고 설거지도 하고 오랜만에 집안일을 좀 했더니 집이 그나마 깨끗해졌다.\n- 포켓몬 전시회에 갔다. 판교에서 하는 줄 알고 판교까지 갔는데 알고보니 잠실에서 하는 전시회였다. 판교 간 김에 규카츠를 먹었다. 구워 먹는 것보다 그냥 먹는 게 더 맛있었다. 포켓몬 전시회 가서 루카리오도 보고 따라큐 핀 같은 걸 샀다. 귀엽다. 내일부터 가방에 달고 다녀야겠다.\n- 네오한테 포켓몬 전시회가 있다고 말했더니 보러 오신다고 했다. 오신 김에 저녁을 같이 먹자고 해서 냉면을 같이 먹었다. TIL에 내내 먹는 얘기 밖에 없네 ㅋㅋ 그래도 되게 재밌었다.\n\n## 배운 것\n- 리뷰어가 int 범위 제한을 어떻게 할 수 있을지 물어봐서 예외 처리를 해야했다. int 범위가 넘는 값이 들어오면 이상하게 `@range` 로도 안 잡히고 `HttpMessageNotReadableException` 이 발생했다. 그래서 `@ExceptionHandler` 로 처리해주었다.\n\n## 궁금한 것\n- 문제는 `HttpMessageNotReadableException` 를 따로 예외 처리하면 예외 메시지를 html에 띄울 수 없다. 어떻게 하면 할 수 있을까? \n\n## 어려웠던 것\n\n## 느낀 것\n- 날씨가 좋았다. (날이 좋아서, 이하 생략) 또 다시 감기에 걸렸다;; 그렇게 안 심했는데 오늘 돌아다니다 보니까 기침이 심해졌다 ㅋㅋㅋ again human disaster... 건강이 최고다.\n- 판교에서 전시회 하는 줄 알고 갔지만 판교에서 노는 것도 재밌었다. 처음으로 판교에 가봤는데 길이 되게 깨끗하고 더 발달된(?) 광명처럼 생겼다. 판교에 취직하고 싶다~ 포켓몬 전시회 그냥 가 본 거였는데 애들도 귀엽고 의외로 볼 게 많았다. 나중에 판교에서 더 큰 포켓몬 전시회가 있으면 가 봐야겠다."},{"excerpt":"2023-05-01 2023-05-02 2023-05-04 2023-05-07 2023-05-08 2023-05-10 2023-05-11 2023-05-12 2023-05-14 2023-05-15 2023-05-16 2023-05-17 2023-05-18 2023-05-20 2023-05-21 2023-05-22 2023-05-26 2023-05-27 2…","fields":{"slug":"/2023-05/"},"frontmatter":{"date":"2023년 05월 01일 12:05","title":"2023년 05월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-05-01]]\n- [[2023-05-02]]\n- [[2023-05-04]]\n- [[2023-05-07]]\n- [[2023-05-08]]\n- [[2023-05-10]]\n- [[2023-05-11]]\n- [[2023-05-12]]\n- [[2023-05-14]]\n- [[2023-05-15]]\n- [[2023-05-16]]\n- [[2023-05-17]]\n- [[2023-05-18]]\n- [[2023-05-20]]\n- [[2023-05-21]]\n- [[2023-05-22]]\n- [[2023-05-26]]\n- [[2023-05-27]]\n- [[2023-05-28]]\n- [[2023-05-29]]\n- [[2023-05-30]]\n"},{"excerpt":"LOG 네오와 커피챗을 했다. 오늘은 네오와 내내 같이 있을 수 밖에 없었다. 점심에 포이, 망고, 토리와 같이 토도로끼에서 점심을 먹었고, 5시부터는 면담을 했다. 6시에는 회식을 하러 갔으니 오늘 내내 네오와 같이 있었던 셈이다. 면담에서는 페어가 어떤 피드백을 남겨주었는지 알려주었다. 아직 페어 회고를 하지 않은 깃짱을 제외하고는 모두 알고 있는 내…","fields":{"slug":"/2023-04-28/"},"frontmatter":{"date":"2023년 04월 28일 16:04","title":"2023년 04월 28일","tags":null},"rawMarkdownBody":"## LOG\n- 네오와 커피챗을 했다. 오늘은 네오와 내내 같이 있을 수 밖에 없었다. 점심에 포이, 망고, 토리와 같이 토도로끼에서 점심을 먹었고, 5시부터는 면담을 했다. 6시에는 회식을 하러 갔으니 오늘 내내 네오와 같이 있었던 셈이다. 면담에서는 페어가 어떤 피드백을 남겨주었는지 알려주었다. 아직 페어 회고를 하지 않은 깃짱을 제외하고는 모두 알고 있는 내용이라 새롭지는 않았다. 그래도 칭찬이 많아서 다행이었다. \n- 네오와 면담을 했다. 주제는 `인생의 목표와 가치관을 어떻게 정할 수 있을까?` 라는 주제였다. 답을 정하고 간 주제는 아니었는데, 생각보다 네오가 좋은 답변을 많이 해줘서 가치관을 정립할 수 있었던 거 같다. 네오 같은 사람을 지금까지 만나본 적이 없었는데, 나와 비슷한 점이 많아서 공감이 잘 됐다. 뭔가 멋진 말이 많이 나왔던 거 같은데 지금 쓰려고 하니까 기억이 안 난다. 어쨌든 결론적으로는 오늘의 롤모델은 네오라는 것이다. 네오가 굉장히 뿌듯해했다. 근데 감명받았던 내용이 기억이 안 난다...\n- 베포헤말 스터디 했는데 오늘 면접이 되게 어려웠다 ㅋㅋㅋ ㅜ 이번에 어려운 내용이 많았는데 그래도 많이 얻어간 것 같아서 좋았다. 내용 더 많이 알아봐야겠다...\n- 네오조 회식이 있었다. 로지, 호이, 테오와 말을 놓았다. 작살치킨에 40명이나 있었는데 꽤 많은 사람들이랑 만난 거 같다 ㅋㅋㅋ 로지도 중간에 만나고 히이로와 하디랑도 이야기해봤다. 처음 보는 사람들이 많아서 재밌었다~ 요즘 사람 만나는 게 즐거워서 하루하루가 즐겁다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 인생의 목표 비슷한 게 생겼다. 오늘의 멘토 네오 덕분이다. 막 살아도 괜찮은 인생을 살자라는 목표가 생겼다. 네오의 인생을 들어봤는데, 분명 막 사는 거 같은데 잘 되는 거 같아서 그게 간지라고 생각했다. 뭔가 목표를 만들고 그걸 지키려고 했는데, 생각해보니 많은 사람들이 목표를 가지고 있어서 그건 힙스터 같지 않다고 생각했다. 나는 힙스터가 좋기 때문에 목표도 안 만들고 뭐할지도 안 정하려고 한다. 정확하게는 아무것도 안 해도 잘 사는 사람이 되고 싶다. 그게 멋이니까 ㅋㅋ 이렇게 적어도 되나 싶지만 네오가 오히려 좋아했다. 네오한테 다윈상 말해줬는데 죽기전에 한 번쯤 달성해보고 싶다고 해서 나도 네오한테 목표를 만들어준 거 아닐까? 하는 긍정적인 생각을 했다. 좋은데요?\n- 네오와 면담을 분명 30분만 하기로 했는데 정신차려 보니까 1시간이나 했다. 굉장히 나랑 비슷한 사람이라고 느꼈다. 근데 포이랑도 비슷하다 ㅋㅋ 네오랑 비슷한 점이 하지말라고 하면 더 하고 싶은 청개구리같은 마인드다. 근데 아무리 생각해도 내가 네오보다 철이 덜 든 것 같다. 아닌가? ㅋㅋ"},{"excerpt":"베포후헤말 스터디 면접 공부를 위한 글입니다. Dispatcher Servlet 이란? 프론트 컨트롤러 디자인 패턴에서 하나의 Controller가 들어오는 HttpRequest를 애플리케이션의 다른 모든 Controller와 Handler에 전달하는 역할을 담당한다. 즉, Spring의 DispatcherServlet 가 Front Controller …","fields":{"slug":"/dispatcher-servlet/"},"frontmatter":{"date":"2023년 04월 28일 02:04","title":"DispatcherServlet","tags":["spring","스터디","개발"]},"rawMarkdownBody":"\n**베포후헤말 스터디 면접 공부를 위한 글입니다.**\n\n## Dispatcher Servlet 이란?\n\n프론트 컨트롤러 디자인 패턴에서 하나의 Controller가 들어오는 HttpRequest를 애플리케이션의 다른 모든 Controller와 Handler에 전달하는 역할을 담당한다. \n\n즉, Spring의 DispatcherServlet 가 Front Controller 역할을 맡고 있다.\n\n## Dispatcher Servlet은 무엇을 하는가?\n\n들어오는 URI를 받아 해당 위치에서 찾아서 하는 페이지나 리소스를 형성하기 위해 결합되는 handler와 view의 올바른 조합을 찾는 역할을 한다.\n\n들어오는 HttpRequest를 처리하고, Request를 위임하고, handler, controller endpoint 와 reponse 객체를 지정하는 어노테이션과 함께 Spring 애플리케이션 내에 구현된 `HandlerAdapter` 인터페이스에 따라 해당 요청을 처리한다.\n\n## 순서\n\nDispatcherServlet은 `getHandler()` 를 사용하여 Dispatcher에 대해 구성한 HandlerAdapter 인터페이스의 모든 구현을 찾는다. \n\nDispatcherServlet은 대상 컨트롤러를 결정하기 위해 다음 mapper 중 하나를 참조하여 대상 컨트롤러를 결정한다.\n\n`BeanNameUrlHandlerMapping`, \n`ControllerBeanNameHandlerMapping`, \n`ControllerClassNameHandlerMapping`, \n`DefaultAnotationHandlerMapping`, \n`SimpleUrlHandlerMapping`\n\nconfiguration을 수행하지 않으면 DispatcherServlet은 기본적으로 `BeanNameUrlHandlerMapping`, `DefaultAnnotationHandlerMapping` 을 사용한다. 대상 컨트롤러가 식별되면 DispatcherServlet이 해당 컨트롤러로 요청을 보낸다. 컨트롤러는 요청에 따라서 몇 가지 작업을 수행한 후, Model과 View의 이름과 함께 DispatcherServlet으로 다시 반환한다.\n\n1. Request를 DispatcherServlet이 받는다.\n2. Request에 맞는 적절한 Controller를 찾는다.\n3. Request를 Controller로 건네줄 HandlerAdapter를 찾아서 전달한다.\n4. HandlerAdapter가 Controller로 Request를 전달한다.\n5. 비즈니스 로직을 처리한다.\n6. 처리된 반환값을 HandlerAdapter한테 전달한다.\n7. HandlerAdapter는 반환값을 DispatcherServlet에게 전달한다.\n8. Response를 응답한다.\n\n## DispatcherServlet 의 동작\n\n### DispatchServlet\n\n`getHandler()` : Request에 맞는 HandlerMapping을 선택하여 HandlerExecutionChain을 가져온다.\n`getHandlerAdapter()` : HandlerExecutionChain에 맞는 HandlerAdapter를 가져온다. \n`handle()` : HandlerAdapter를 실행한다. (컨트롤러 메서드 실행)\n\n### HandlerMapping\n\n`getHandlerAdapter()` : `HandlerExecutionChain` 에는 요청에 맞는 핸들러가 저장되어 있다. `HandlerAdapter` 를 가져오기 위해 `HandlerExecutionChain` 에 있는 핸들러로 판단한다. \n\n## 참고 자료\n- [헤나의 Dispatcher Servlet 둘러보기 블로그 글](https://programming-hyena.tistory.com/38)\n- https://www.baeldung.com/spring-dispatcherservlet\n"},{"excerpt":"LOG 장바구니 미션 1단계 PR을 보냈다.  를 사용해서 에러 처리를 추가했다. 갑자기 예외 나온 이유를 프론트에서 보여주고 싶어서 js, html도 수정했다. 글렌이 만든  를 참고해서 구현했다. 우르 코드도 조금 참고했는데 이렇게 하는 게 best practice인 건지 궁금하다. 럿고의 리뷰 기다리는 중.... 오늘 새벽집에 술을 마시러 갔다. 배…","fields":{"slug":"/2023-04-27/"},"frontmatter":{"date":"2023년 04월 27일 08:04","title":"2023년 04월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 장바구니 미션 1단계 PR을 보냈다. `@ControllerAdvice` 를 사용해서 에러 처리를 추가했다. 갑자기 예외 나온 이유를 프론트에서 보여주고 싶어서 js, html도 수정했다. 글렌이 만든 `ErrorResponse` 를 참고해서 구현했다. 우르 코드도 조금 참고했는데 이렇게 하는 게 best practice인 건지 궁금하다. 럿고의 리뷰 기다리는 중....\n- 오늘 새벽집에 술을 마시러 갔다.\n\n## 배운 것\n- `ControllerAdvice` 에서도 `@ReponseBody` 를 사용할 수 있다.\n- `@NotBlank` 같은 validation 로직에 `message` 속성을 지정하면 예외 메시지 값을 정해줄 수 있다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부할 게 많이 쌓였다. 우르와 같이 페어하면서 궁금한 게 많았는데 그게 그대로 다 기술부채로 갔다. 오늘은 미션을 하느라 딱히 공부한 건 많이 없는 것 같다. 공부할 시간이 필요하다. 그런데 요즘 계속 끝나고 약속 있어서 남아서 공부를 못한다 ㅋㅋㅋ... 다음 주에 좀 더 빡세게 공부해야겠다. 대신 미션에는 시간을 많이 투자했던 게 좋았다. \n- 내일은 네오와 면담이 있다. `인생의 가치관과 목표를 정하는 방법` 이라는 주제로 커피챗을 신청했다. 요즘 많이 고민하던 주제인데 네오와 이야기 하면서 어떤 인사이트를 얻어갈지 궁금하다. 정답을 찾지 못하더라도 앞으로 어떻게 생각할지? 힌트가 주어진다면 좋을 것 같다."},{"excerpt":"LOG 우르와 페어가 됐다. 레벨 인터뷰 때도 같은 조고 같은 데일리 조원이라 사실상 아는 사람이었다. 처음으로 아는 사람과 페어가 되었다! 우르는 아는 게 정말 많다. 김영한님 강의를 다 들었다고 했는데 그래서 그런지 이번 미션하는 게 굉장히 수월했다. 칭찬을 많이 해줘서 뿌듯하게 페어 프로그래밍 할 수 있었다. 중간에 우르와 같이 이해가 안 되는 부분…","fields":{"slug":"/2023-04-25/"},"frontmatter":{"date":"2023년 04월 25일 11:04","title":"2023년 04월 25일","tags":null},"rawMarkdownBody":"## LOG\n- 우르와 페어가 됐다. 레벨 인터뷰 때도 같은 조고 같은 데일리 조원이라 사실상 아는 사람이었다. 처음으로 아는 사람과 페어가 되었다! 우르는 아는 게 정말 많다. 김영한님 강의를 다 들었다고 했는데 그래서 그런지 이번 미션하는 게 굉장히 수월했다. 칭찬을 많이 해줘서 뿌듯하게 페어 프로그래밍 할 수 있었다. 중간에 우르와 같이 이해가 안 되는 부분이 있었는데 납득할 만한 결론이 나온 것도 좋았다. 주장이 부딪힐 때 의견을 접지 않고 설득하려는 부분도 좋았다. 쓰고 나니 칭찬밖에 없네\n- 점심에 우르, 주노, 레오와 연어 식당에 갔다. 연어 식당에서 연어 비빔밥을 먹었다. 레오와 이야기 안 해봤는데 오늘 꽤 이야기한 것 같아서 좋았다.\n- 미션 구현이 빨리 끝났다. 내일 테스트 코드만 작성하면 돼서 조금 여유롭다. 하고 싶은 공부를 할 수 있어서 기쁘다~\n- 박스터와 저녁에 체스해서 졌다. 체스 어렵네;;; 열심히 하지는 않았지만 역시 머리 쓰는 거라 어려운 듯.. 주드에게 체스 실력 삼투압 받았어야 했는데 못 받아서 졌나 보다~\n\n## 배운 것\n- `@Controller` 에서 상태 코드 지정 없이 void를 리턴하게 되면 view를 찾을 수 없다는 예외가 발생한다. 그런데 201 상태 코드를 지정하면 예외가 발생하지 않아서 이상하다고 생각했다. 찾아보니 상태 코드를 지정하지 않으면 자동으로 200 상태 코드가 지정되는데, 200이 반환되면 `DispatcherServlet` 이 뷰를 렌더링 해야 한다고 가정하게 된다. 제공된 view가 없으므로 view를 찾을 수 없다는 예외 메시지를 던지게 된다. 201의 경우에는 `DispatcherServlet` 이 요청이 성공적으로 처리되어 view를 렌더링할 필요가 없는 것으로 간주한다.\n- `@ResponseStatus` 를 사용하여 status code를 지정해 줄 수 있다.\n\n```java\n@Controller\npublic class MyController {\n\n    @PostMapping(\"/my-endpoint\")\n    @ResponseStatus(HttpStatus.CREATED)\n    public void handlePostRequest() {\n        // handle the request and create the new resource\n    }\n}\n```\n\n- `resources/data.sql` 에 insert 문을 적어두면 자동으로 값을 넣어준다. (auto-increment 값도 넣어줘야 한다.)\n\n```sql\ninsert into product(id, name, price, image_url)  \nvalues (1, '피자', 10000, 'https://t1.daumcdn.net/cfile/tistory/241D303357DD2A1404');  \n  \ninsert into product(id, name, price, image_url)  \nvalues (2, '치킨', 20000, 'https://pelicana.co.kr/resources/images/menu/best_menu03_200623.jpg');\n```\n\n애플리케이션이 실행되면 data가 자동으로 삽입 된다.\n\n- validation 코드 작성하기\n\n```\n// build.gradle\nimplementation 'org.springframework.boot:spring-boot-starter-validation'\n```\n\ngradle에 의존성을 작성해준다.\n\n```java\nimport javax.validation.constraints.NotBlank;  \nimport javax.validation.constraints.Positive;  \n  \npublic class ProductModifyRequest {  \n  \n    @NotBlank  \n    private String name;  \n  \n    @Positive  \n    private int price;  \n  \n    @NotBlank  \n    private String imageUrl;  \n  \n    public ProductModifyRequest() {  \n    }  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public int getPrice() {  \n        return price;  \n    }  \n  \n    public String getImageUrl() {  \n        return imageUrl;  \n    }  \n}\n```\n\nvalidation 어노테이션을 사용해서 값 검증을 한다.\n\n## 궁금한 것\n- `@Validated` 와 `@Valid` 의 차이점이 뭘까?\n- axios는 뭘까\n\n## 어려웠던 것\n\n## 느낀 것\n- 친구가 쓴 블로그 글을 보게 되었는데, 가치관 글이었다. 최근에 내 가치관에 대해서 생각해 볼 일이 있었는데 나와 다르게 좀 더 긍정적인 글이라 신기했다. 멋지다고 생각하는 친구인데 가치관도 멋있어서 좀 본받아야겠다고 생각했다. 지금 밝고 긍정적으로 살고 있으니까 이때를 틈타서 긍정적인 가치관을 가져보는 것도 좋을 것 같다.\n- 사람마다 공부의 방식이 다른 것 같다는 생각을 요즘 더 많이 한다. 강의가 정말 잘 맞는 사람도 있고, 책 읽는 게 도움이 많이 되는 사람도 있다. 나는 어떻게 공부하나... 생각해 봤는데, 항상 뭔가를 사용해보고 이해가 안 되거나 궁금한 부분을 알아보는 방식으로 공부하는 게 제일 재밌는 것 같다. 생각해보면 예전부터 뭔가를 먼저 배우고 사용하는 건 너무 재미없었다. 앞으로도 부딪히면서 배워가는 사람이 되고 싶다.\n- 오늘은 많이 공부하고 배웠다. 이번주 시작한 지 2일 되기는 했지만 ㅋㅋ 주간 회고 모임에서 다짐했던 것처럼 이번 주에는 미션에 좀 더 열중하고 있어서 기쁘다. 이번 리뷰어는 럿고인데, 좋은 리뷰 받았으면 좋겠다!\n- 조급하지 않다. 조급하지 않은 게 좋은 걸까 아닌 걸까 싶다. 앞으로 인생이 좀 남았으니 너무 조급하지 않은 게 좋은 것 같다가도 내년에는 취업을 하고 싶은데 그걸 생각하면 좀 더 조급해야 할 것 같다. 내가 모든 걸 챙길 수는 없지만 지금 내가 챙겨야 할 걸 못 챙기고 있는 건 아닐까..? 그런 생각이 갑자기 든다. 뭐든 확신이 없어서 그런 듯. 조만간 뭐 어떻게든 방향을 정해야겠다."},{"excerpt":"4/25 2주차 목표 템플릿 엔진을 이용해 페이지 응답을 경험한다. 웹 애플리케이션에서의 테스트와 전구간 기능 테스트 구현을 경험한다. 인증 방법에 대해 학습하고 직접 구현해본다. Spring MVC Configuration 설정을 경험한다. Spring MVC 에서 MVC는 무엇을 의미하고 활용하는 이유를 궁금해 해보자. 목표와 계획을 제출한 이유 내가…","fields":{"slug":"/level2-week2/"},"frontmatter":{"date":"2023년 04월 25일 01:04","title":"레벨2 2주차","tags":["레벨2","우테코"]},"rawMarkdownBody":"# 4/25\n\n## 2주차 목표\n\n- 템플릿 엔진을 이용해 페이지 응답을 경험한다.\n- 웹 애플리케이션에서의 테스트와 전구간 기능 테스트 구현을 경험한다.\n- 인증 방법에 대해 학습하고 직접 구현해본다.\n- Spring MVC Configuration 설정을 경험한다.\n- Spring MVC 에서 MVC는 무엇을 의미하고 활용하는 이유를 궁금해 해보자.\n\n## 목표와 계획을 제출한 이유\n\n내가 잘 알고 있는 것이 맞는가? 어떻게 하면 더 잘 알 수 있을까? 에 대해 스스로에게 계속해서 질문을 던지자.\n\n## 한 번 세운 목표와 계획은 끝까지 가야 하나?\n\n목표: 레벨2 로드맵에 있는 것들을 제대로 알고 쓰고 싶다.\n방법: 학습 로그 스터디를 하고, 공부하면서 모르는 내용을 계속해서 마인드맵처럼 공부하자.\n\n다음의 질문을 계속하자.\n- 레벨2가 끝날 때 내가 세운 목표를 달성했을 때의 내 모습이 만족스러울 것 같은가?: 만족스러울 것이다. 그러나 더 알았어야 했나라는 생각은 들 것 같다.\n- 목표를 달성하는 것이 진정 내가 원하는 모습인가? 내가 원하는 모습에 도달하기 위한 목표는 아닌가? : 원하는 모습은 내가 쓰는 기술들을 알고 쓰는 것이다. 시간은 많으니 지금은 도달하지 못하더라도 계속해서 목표에 가까워지는 사람이 될 수 있을 것이다.\n- 계획을 달성하면 목표에 도달할 수 있는가?: 도달할 수는 있지만, 완전히 도달할 수 있는지는 알 수 없다.\n- 실행하는 데 어려움은 없었는가? 그 어려움은 해결할 수 없는 어려움은 아닌가?: 아직은 무엇을 모르는지, 어떤 것을 알아야 하는지 알지 못한다. 무언가를 판단하기에 지금은 너무 이른듯하다.\n\n## Spring MVC 어디까지 왔나?\n\nSpring MVC Annotation + Exception -> 오늘\nDispatcher Servlet이 추구하는 패턴 -> 두 번째 피드백 강의\nHTTP & REST, API 설계 -> 금요일 강의\n인증 + Spring MVC Configuration -> 다음 주 화요일 강의\n\nSpring MVC Configuration이나 Spring MVC Annotation 등에서 삽질을 많이 해봐야 Dispatcher Servlet을 이해하기 수월할 것이다.\n\n## Template Engine\n(오늘 토리랑 허브랑 이야기한 내용인데 나와서 신기하다 ㅋㅋ)\n\n![[request-structure.png]]\n\nview는 Dispatcher Servlet에 의해 변환된다.\n템플릿을 가지고 view가 결과물을 만들어서 Web browser에 전달한다.\n\n```java\n@Controller\npublic class SampleController{\n\n\t@RequestMapping(value = ~~)\n\tpublic String SampleMethod(Model model) {\n\t\tmodel.addAttribute(\"~~~~\");\n\t\treturn \"sample\";  // sample 이라는 template를 찾는다.\n\t}\n}\n```\n\n템플릿의 기본 경로는 src/main/resources/templates이다.\n\nSpring MVC는 thymeleaf view를 찾고, thymeleaf는 template으로 렌더링을 한다. 렌더링한 것을 web browser한테 전달한다.\n\n## SpringBootTest\n\n@SpringBootTest\n\n-   ﻿﻿테스트 환경을 손쉽게 설정하도록 도와줌\n-   ﻿﻿ApplicationContext를 자동으로 생성하여 테스트에서 사용할 수 있게 함\n-   ﻿﻿기존 @ ContextConfiguration의 발전된 기능\n\n### webEnvironment\n\n@SpringBootTest의 webEnvironment 속성을 사용하여 테스트 서버의 실행 방법을 설정\n\n-   ﻿﻿MOCK: Mocking된 웹 환경을 제공, MockMvC를 사용한 테스트를 진행 할 수 있음. 가짜 웹 환경을 구성한다.\n-   ﻿﻿RANDOM_PORT: 실제 웹 환경을 구성\n-   ﻿﻿DEFINED_PORT: 실제 웹 환경을 구성, 지정한 포트를 listen\n-   ﻿﻿NONE: 아무런 웹 환경을 구성하지 않음\n\n![[mockmvc.png]]\n\n## RestAssured\n\n![[rest-assured-test.png]]\nRANDOM_PORT를 쓰면 포트 번호를 모르니까 주입을 받아야 한다. \n\n주입 받을 때 `@LocalServerPort` 로 주입을 받아야 한다.\n\n```java\n@LocalServerPort\nint port;\n\n@BeforeEach\npublic void setUp() {\n\tRestAssured.port = port;\n}\n```\n\nRestAssured와 SpringBootTest로 전체 테스트를 경험해보자.\n\n왜 부분이 아닌 전체를 검증할까?   \n부분과 전체 중에 어떤 것이 더 중요할까?  \n\n# 4/28\n\n## 좋은 API 설계란?\n\n### API 설계를 꼭 잘해야 하는가?\n\n그냥 서버와 클라이언트 간의 약속만 잘하면 되는 거 아닌가?\n\nbut...\n- 한 번 정해진 API는 바꾸기 쉽지 않다. API의 변경에 클라이언트가 영향을 받기 떄문이다.\n- 새로운 데이터 요소와 비즈니스 규칙이 계속 추가/변경될 수 있다. 확장성 있는 API를 만들게 되면 앞으로의 시간을 아낄 수 있다.\n- 잘 설계된 API는 커뮤니케이션 비용을 아껴준다.\n\n### API 설계 표준화 시도\n\n- 한 곳에 모아서 비교할 수 있는 서비스가 있었지만 없어졌다.\n- 표준을 만드는 시도들이 있었지만 거의 사용되지 않고 있다.\n- 각 서비스들마다 요구사항이 다르고 환경이 다르다.\n- 자신들만의 설계를 원하는 경향이 있다.\n\n### 좋은 API 특징\n\n- 배우기 쉬울 것\n- 문서가 없어도 사용하기 쉬울 것\n- ﻿﻿잘못 사용하기 어려울 것\n- ﻿﻿읽기 쉽고, API를 사용하는 코드를 유지보수하기 쉬울 것\n- ﻿﻿요구사항을 만족시키기에 충분히 강할 것\n- ﻿﻿확장하기 쉬울 것\n- ﻿﻿사용하는 사람들의 수준에 맞을 것\n\n## REST\n\n미션 권장사항은 아님.\n\n### REST 란?\n\n- ﻿﻿WWW(web)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍 처의 한 형식, 로이 필딩의 2000년 논문을 통해서 공개\n- 당시 웹은 큰 성공을 거두었지만 발전이 너무 빨라 관련 내용에 대한 표준이나 문서가 부족한 시기\n- ﻿﻿웹과 같은 시스템이 어떻게 동작해야 하는지에 대한 구조적 모델을 만들어내고 표준 역할을 하기 위해 몇 가지 제약 조건을 만들어 냄\n- ﻿﻿웹 기반으로 동작하는 대부분의 서비스도 글 뿐이 아닌 다양한 형태로 제공되기 때문에 분산 하이퍼미디어 시스템으로 볼 수 있음\n\n### 요즘 REST 용어의 사용\n\n- 최초 소개되었던 목적 보다 다소 과하게 쓰이기도 함\n- 잘못 사용되는 경우도 많음\n- 역사적인 관점에서 SOAP API와 경쟁관계인 시점에 마케팅 버즈워드로 많 이 사용되면서 SOAP 계열의 반대 슬로건으로 사용됨\n- 그럼에도 리소스와 URI의 개념 등 API 설계 시 중요한 요소로 잘 스며들었다고 평가됨\n- RESTful API 규칙이라고 불리는 것은 참고만 하고, 추상적인 제약 조건을 이해하고 일부 조건의 구체적인 세부 규칙을 직접 정해보자.\n- 이게 어렵다면 굳이 REST를 시도하지 말고 HTTP 프로토콜 사용법에 맞는 정도로만 API를 설계하자.\n\n## 용어 설명\n\n### 리소스\n\n자원과 내부적인 클래스 설계는 다를 수 있다. \n또한 클래스 설계는 데이터베이스와 다를 수 있다.\n\n주소창으로 요청을 보내면 웹 페이지를 응답받을 수 있다.\n페이지나 json 형태의 문자열을 응답으로 받을 수 있다.\n서버로부터 얻을 수 있는 자원이 리소스다.\n\n즉, 리소스란\n- 네트워크 데이터 개체\n- 클라이언트가 얻길 원하는 것\n- URI로 식별할 수 있는 대상\n\n## URI - path와 query\n\n- path: 계층적 형태로 구성된 데이터\n- query: 비계층적 형태로 구성된 데이터\n\n### 리소스의 표현\n\n서버로부터 응답 받는 것은 리소스인가? -> 아니다.\n\n`RacingCar` 를 받는다고 했을 때 실제로 `RacingCar` 를 응답 받는 것이 아니라 표현을 전달받는 것이다.\n\n서버는 리소스의 표현만 내려주는 것이 아니라 해석하는 방법을 알려줘야 한다.\n=> 클라이언트가 리소스에 GET 요청을 보내면 서버는 그 리소스를 나타내는 방법을 제공해야 한다.\n\n```http\nContent-Type: application/json;charset=UTF-8\n```\n\n### 만약 여러 개의 표현이 있는 리소스라면?\n\n- /racingcars/1이라는 리소스를 요청할 때 html 표현과 json 표현이 있다면 어떻게 해야할까?\n\t- html: 1번 레이싱카를 소개하는 페이지\n\t- json: 1번 레이싱카의 정보를 응답하는 JSON\n\n## 많이 사용하는 API 설계\n\n### 리소스 네이밍 가이드\n\n- https://restfulapi.net\n\n```java\n@RestController\npublic class CartApiController {\n\t@PostMapping(\"/cart/add/{productId}\")\n\tpublic ResponseEntity addCart(@PathVariable String productId) {\n\t\tcartService.addCart(autoService.toCart(Long.parseLong(productId)));\n\t\treturn new ResponseEntity(HttpStatus.OK);\n\t}\n}\n```\n\nCart의 add는 계층이라고 보기 어렵다. \nadd를 빼고, POST로 표현하는 것이 더 좋지 않을까.\n\n```java\n@RestController\npublic class HttpMethodController {\n\t@GetMapping(\"/items\")\n\tpublic ResponseEntity<Void> addItem(@RequestBody Item item) {\n\t\tItem item = itemService.addItem(item);\n\t\treturn ResponseEntity.ok().build();\n\t}\n}\n```\n\nGET이 아닌 POST가 되면 좋을 것 같다.\nok 대신 201 (CREATED) 를 사용하면 좋겠다."},{"excerpt":"LOG 네오의 면담 일정이 열렸다. 금요일 5시가 비어있길래 바로 신청했다. 딱 그 때가 가장 널널할 것 같았다. 면담 일정이 열림과 동시에 리뷰어->리뷰이 피드백이 와서 읽어봤다. 다행히(?) 좋은 말이 많아서 기분이 좋았다. 초반에 리뷰어한테 댓글도 안 남기고 그냥 피드백 혼자 반영한 적이 있었는데 그 때 피드백이 있었다. 지금은 고쳐서 다행이다. 그…","fields":{"slug":"/2023-04-24/"},"frontmatter":{"date":"2023년 04월 24일 11:04","title":"2023년 04월 24일","tags":null},"rawMarkdownBody":"\n## LOG\n\n- 네오의 면담 일정이 열렸다. 금요일 5시가 비어있길래 바로 신청했다. 딱 그 때가 가장 널널할 것 같았다. 면담 일정이 열림과 동시에 리뷰어->리뷰이 피드백이 와서 읽어봤다. 다행히(?) 좋은 말이 많아서 기분이 좋았다. 초반에 리뷰어한테 댓글도 안 남기고 그냥 피드백 혼자 반영한 적이 있었는데 그 때 피드백이 있었다. 지금은 고쳐서 다행이다. 그래도 아직까지는 잘하고 있구나 싶다.\n- 늦게 일어났다. 요즘 계속 피곤해서 그런가 잠을 계속 자게 된다. 잠을 못 자던 옛날보다는 나은 거 같기도 하고..? 점심은 못 먹었지만 잠실 오기 전에 비요뜨를 먹고 와서 그나마 나았다. \n- 토리가 준 비타민 구미 택배를 드디어 뜯었다. 약 한 달 만이다..ㅋㅋㅋ 이제는 비타민을 좀 챙겨먹으려고 한다. 아침 저녁으로 1개씩 먹으려고 비타민 통도 들고 왔다. 앞으로 꾸준히 먹어보자~\n- 요즘 집이 개판이다. 집에 있을 일도 없고 저녁까지 잠실에 있다보니 청소할 시간도 없다...라는 핑계를 대본다. 오늘은 집에 가서 뭐라도 해결을 좀 해봐야겠다. 미루지 말고 뭐라도 하자 😂\n\n## 배운 것\n\n- 스터디 중에 궁금했던 내용 공부했다 : [[mock-vs-mockbean|@Mock vs @MockBean]]\n- 오늘의 스터디 주제: [[webmvctest|@WebMvcTest]]\n- `@ControllerAdvice` 가 여러 개 있는 경우 `@Order` 를 사용하면 순서를 보장할 수 있다고 한다. 그렇지만 `@Order` 를 쓰는 것보다는 하나의 `@ControllerAdvice` 에 예외 처리를 몰아두는 것을 스프링에서는 더 권장한다고 한다.\n\n## 궁금한 것\n- 계속 서블릿 관련 이야기가 나오는데 서블릿이 뭘까?\n\n## 어려웠던 것\n- Dispatcher Servlet, Auto-Configuration 부분 내용을 배운 적이 없다 보니까 이해하기가 좀 어려웠다.  그 부분 공부하기 전에 이해가 안 됐던 부분을 정리하고 더 파봐야겠다.\n\n## 느낀 것\n\n- 공부에 집중을 많이 했다. 오늘 베포헤말 스터디도 있었고 굉장히 많은 걸 얻어갈 수 있었다. 항상 생각하는 거지만 스터디는 강제성이 생겨서 좋다. 특히 내가 발표해야 하는 스터디다 보니까 더 강제성이 부여되는 게 좋다. 혼자였다면 Dispatcher Servlet이고 Auto-Configuration이든 아무것도 안 찾아봤을 것 같은데 나보다 더 똑똑한 크루들이 설명해주는 내용이라 더 좋은 것 같다 ㅋㅋㅋ 스터디에서 배운 내용 공부를 더 열심히 해보려고 한다. 오늘 한 내용 솔직히 잘 이해는 못한 것 같아서 좀 더 찾아보고 공부하는 시간을 가져야 겠다. 역시 공부하는 게 재밌다.\n- 예전이라면 어려운 내용이 나오고 내용이 잘 이해가 안 됐을 때 자괴감이 들었을텐데, 요즘은 안 그래서 좋다. 오히려 내가 모르겠는 부분이 나오면 주저없이 물어볼 수 있게 되었다는 게 제일 멋진 변화라고 느낀다. 자존심을 내려놓고 (정확하게 말하면 내려놨다기보다는 모르는게 부끄럽지 않다는 걸 알게 됐다...? 가 더 맞을 듯 하다) 질문하는 습관을 들이게 되어 기쁘다. 앞으로도 어제의 나보다 더 나아지는 내가 되자!"},{"excerpt":"Mockito.mock()  메서드를 사용하면 클래스나 인터페이스의 mock 객체를 만들 수 있다.\n 으로 Mock 객체의 행동을 정의할 수 있다. (stub: mock 객체의 기대행위를 작성하는 것) mock 클래스 필드나 메서드의 지역 mock 객체를 생성하는데 사용할 수 있다. @Mock  메서드의 축약어이다. 테스트 클래스에서만 사용해야 한다.\n …","fields":{"slug":"/mock-vs-mockbean/"},"frontmatter":{"date":"2023년 04월 24일 10:04","title":"Mock vs MockBean","tags":["개발","spring"]},"rawMarkdownBody":"\n## Mockito.mock()\n\n```java\n@Test\npublic void givenCountMethodMocked_WhenCountInvoked_ThenMockedValueReturned() {\n    UserRepository localMockRepository = Mockito.mock(UserRepository.class);\n    Mockito.when(localMockRepository.count()).thenReturn(111L);\n\n    long userCount = localMockRepository.count();\n\n    Assert.assertEquals(111L, userCount);\n    Mockito.verify(localMockRepository).count();\n}\n```\n\n`Mockito.mock()` 메서드를 사용하면 클래스나 인터페이스의 mock 객체를 만들 수 있다.\n`Mockito.when(메서드).thenReturn(리턴값)` 으로 Mock 객체의 행동을 정의할 수 있다. (stub: mock 객체의 기대행위를 작성하는 것)\n\nmock 클래스 필드나 메서드의 지역 mock 객체를 생성하는데 사용할 수 있다.\n\n## @Mock\n\n`Mockito.mock()` 메서드의 축약어이다. 테스트 클래스에서만 사용해야 한다.\n`mock()` 메서드와 달리 `MockitoJUnitRunner` 를 사용하여 테스트를 실행하거나 `MockitoAnnotations.initMocks()` 메서드를 명시적으로 호출하여 실행할 수 있다.\n\n단, `@SpringBootTest` 또는 `@SpringMvcTest` 를 사용하여 mock 객체를 생성하는 `@MockBean` 및 테스트하려는 클래스의 인스턴스를 가져오는 `@Autowired` 와 함께 스프링 컨텍스트를 시작하면 mock bean이 autowired 의존성에 사용된다. \n\n데이터베이스와 상호 작용하는 코드에 대한 통합 테스트를 작성하거나, REST API를 테스트하고자 할 때 이 방법을 사용한다.\n\n## @MockBean\n\n스프링 컨텍스트에 mock 객체를 등록하고, 스프링 컨텍스트에 의해 `@Autowired` 가 동작할 때 등록된 mock 객체를 사용할 수 있도록 동작한다.\n\nmock 객체를 애플리케이션 컨텍스트에 추가하기 위해 `@MockBean` 을 사용할 수 있다. mock 객체는 애플리케이션 컨텍스트에서 동일한 유형의 기존 bean을 대체한다. \n\n동일한 유형의 bean이 정의되어 있지 않으면 새로운 bean을 추가한다. 해당 어노테이션은 외부 서비스와 같은 특정 bean을 mocking 해야 하는 통합 테스트에 유용하다.\n\n## 언제 사용하나?\n\nSpring Boot Container가 테스트 시에 필요하고, Bean이 Container에 존재한다면 `@MockBean` 을 사용하고 아닌 경우에는 `@Mock` 을 사용한다.\n\n`@WebMvcTest` 어노테이션을 사용하는 경우, Controller까지는 로드되지만 Controller의 협력 객체인 Service는 로드 되지 않는다. 따라서 Controller에 요청을 보낼 때 Service가 Bean Container에 생성되어 있지 않다면 NPE가 발생하게 된다.\n\n다음 예제로 확인해보자.    \n`RacingCarController` 는 `RacingCarService` 에 의존성을 가지고 있는 `@RestController` 이다.   \n`RacingCarService` 내부에는 `RandomMoveStrategy` 라는 객체를 갖는다. 랜덤하게 값을 생성하여 움직일 수 있는지 없는지 확인하는 `isMovable()` 이라는 메서드를 제공한다.\n\n`RandomMoveStrategy` 의 값이 랜덤하지 않고 항상 true를 리턴하도록 `@Mock` 어노테이션을 사용하여 행위를 정의했다.\n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  \n  \n    @Autowired  \n    private ObjectMapper objectMapper;  \n  \n    @Mock  \n    // @MockBean\n    private RacingCarService racingCarService;  \n  \n    @Mock  \n    RandomMoveStrategy randomMoveStrategy;  \n  \n    @Test  \n    void play_메서드가_적절한_형식을_반환한다() throws Exception {  \n        final PlayRequest playRequest = new PlayRequest(\"브리,토미,브라운\", 1);  \n        final String request = objectMapper.writeValueAsString(playRequest);  \n        Car bri = new Car(\"브리\");  \n        Car tomi = new Car(\"토미\");  \n        Car brown = new Car(\"브라운\");  \n        List<Car> cars = List.of(bri);  \n        final PlayResponse playResponse = PlayResponse.of(  \n                RacingCarWinnerDto.of(cars),  \n                List.of(  \n                        RacingCarStatusDto.from(bri),  \n                        RacingCarStatusDto.from(tomi),  \n                        RacingCarStatusDto.from(brown)  \n                )  \n        );  \n  \n        // given  \n        given(randomMoveStrategy.isMovable()).willReturn(true);  \n        given(racingCarService.play(any(PlayRequest.class)))  \n                .willReturn(playResponse);  \n  \n        // then  \n        mockMvc.perform(post(\"/plays\")  \n                        .content(request)  \n                        .contentType(MediaType.APPLICATION_JSON))  \n                .andExpect(status().isOk())  \n                .andExpect(jsonPath(\"$.winners[0]\").value(\"브리\"))  \n                .andExpect(jsonPath(\"racingCars\", hasSize(3)))  \n                .andExpect(jsonPath(\"$.racingCars[0].name\").value(\"브리\"))  \n                .andExpect(jsonPath(\"$.racingCars[0].position\").value(0));  \n    }  \n}\n```\n\n`@MockBean` 을 사용해야 하는 `RacingCarService` 를 `@Mock` 으로 선언하게 되면, `RacingCarController` 에서 필요한 `RacingCarService` 를 auto-wiring 할 수 없게 된다.\n\n```shell\nCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'racingcar.service.RacingCarService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}\n```\n\n그러나 `RandomMoveStrategy` 가 `@MockBean` 어노테이션으로 변경되었을 때는 아무런 예외가 발생하지 않는다.\n`RandomMoveStrategy` 는 bean이 아니지만, Spring Bean Container가 관리해도 아무런 영향이 없기 때문에 예외가 발생하지 않는다.\n\n즉, `@MockBean` 은 Bean Container에 생성되어야만 하는 mock 객체일 때 사용하면 된다.\n\n## 참고 자료\n\n- https://www.baeldung.com/java-spring-mockito-mock-mockbean\n- https://stackoverflow.com/questions/44200720/difference-between-mock-mockbean-and-mockito-mock"},{"excerpt":"WebMvcTest 어노테이션 WebMvcTest 는 Spring MVC controller를 테스트하기 위해 사용되는 Spring Boot의 어노테이션이다.\n이 어노테이션은 전체 auto-configuration을 비활성화하고 대신 MVC 테스트와 관련된 구성만 적용한다.\n즉, Application Context 를 완전하게 Start 하지 않고 Web…","fields":{"slug":"/webmvctest/"},"frontmatter":{"date":"2023년 04월 24일 04:04","title":"WebMvcTest","tags":["spring","레벨2","학습로그","스터디"]},"rawMarkdownBody":"\n## WebMvcTest 어노테이션\n\nWebMvcTest 는 Spring MVC controller를 테스트하기 위해 사용되는 Spring Boot의 어노테이션이다.\n이 어노테이션은 전체 auto-configuration을 비활성화하고 대신 MVC 테스트와 관련된 구성만 적용한다.\n즉, Application Context 를 완전하게 Start 하지 않고 Web Layer를 테스트 하고 싶을 때 `@WebMvcTest` 를 사용하는 것을 고려해볼 수 있다.\n\n단위 테스트를 위해 Spring MVC 인프라를 자동으로 구성하지만, 스캔되는 Bean을 `@Controller`, `@ControllerAdvice`, `@RestController`, `@JsonComponent`, `Filter`, `WebMvcConfigurer`, `HandlerMethodArgumentResolver` 로 제한한다.    \n만약 Service나 Repository의 Dependency가 필요한 경우에는 `@MockBean` 으로 주입 받아 테스트를 진행한다.    \n\n`@WebMvcTest`를 사용할 때, 일반 `@Component`, `@Service`, `@Repository` bean은 스캔되지 않는다.   \n따라서 `@MockBean` 또는 `@SpyBean` 을 사용하여 가짜 객체를 bean으로 등록해주어야 한다.    \n\n## @SpringBootTest\n\n프로젝트 안의 모든 bean을 등록하여 테스트를 한다. 단위 테스트처럼 기능을 테스트할 때보다는 통합 테스트를 할 때 사용한다.\n\n서버를 띄우고 모든 bean을 등록하기 때문에 다양한 테스트 중에서 가장 운영환경과 유사한 테스트이다.\n\n그러나 모든 bean을 로드하기 때문에 테스트 구동 시간이 오래 걸리고, 테스트 단위가 크기 때문에 디버깅이 어려울 수 있다.\n\nController 레이어만 테스트하고 싶을 때에는 `@WebMvcTest` 를 쓰는 것이 유용하다.\n\n## WebMvcTest 사용하기\n\n기본적으로 `@WebMvcTest` 로 주석을 단 테스트는 Spring Security 및 MockMvc도 자동으로 구성한다.\n\n테스트 클래스에 `@WebMvcTest` 어노테이션을 달고 테스트할 컨트롤러를 지정한다.\n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest\n```\n\n이렇게 테스트할 컨트롤러를 지정하게 되면 전체 애플리케이션 컨텍스트가 아닌 `RacingCarController` 만 구성하게 된다.\n\n해당 테스트에 적용해서는 안 되는 auto-configuration 클래스를 제외하도록 `excludeAutoConfiguration` 옵션을 지정할 수도 있다.\n\n```java\n@WebMvcTest(\n    controllers = RacingCarController.class,\n    excludeAutoConfiguration = SecurityAutoConfiguration.class,\n    excludeFilters = {\n        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = SecurityConfig.class)}\n)\n```\n\n`excludeAutoConfiguration`: 해당 테스트에 적용되는 자동 설정들에서 제외할 빈을 등록할 수 있다.   \n`excludeFilters` : 추가되는 bean들 중에 제외하고 싶은 Bean의 필터를 등록한다. 즉, `classes`에 들어갈 Bean을 제외하기 위한 필터를 정의하는 것이다. `ASSIANABLE_TYPE` 속성은 제외할 기준을 클래스로 지정한다.    \n\n```java\n@WebMvcTest(RacingCarController.class)   \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  // 주입 O  \n\n\t...\n}\n```\n\n`@WebMvcTest` 만 선언해주어도, MockMvc 객체가 주입되게 된다.   \n또한 `@MockBean` 을 사용해서 필요한 의존성에 대해 mock 구현을 제공할 수도 있다.\n\nWeb Layer 관련 빈들만 등록하기 때문에, 컨트롤러는 주입이 정상적으로 되지만, `@Component` 로 등록된 Repository와 Service는 주입이 되지 않는다.  \n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  // 주입 가능하다.\n  \n    @Autowired  \n    private RacingCarService racingCarService;  // 주입이 되지 않는다.  \n\t...\n}\n```\n\n따라서, `@WebMvcTest` 에서 Repository와 Service를 사용하기 위해서는 `@MockBean` 을 사용하여 bean으로 등록해주어야 한다.  \n\n`@MockBean` 이란 가짜 객체로, 호출과 결과를 임의로 조작하여 해당 단위 테스트에만 집중할 수 있도록 도와준다.   \n\n```java\n@WebMvcTest(RacingCarController.class)  \nclass RacingCarControllerTest {  \n  \n    @Autowired  \n    private MockMvc mockMvc;  \n  \n    @MockBean  \n    private RacingCarService racingCarService;  // 주입이 가능하다.   \n  \n    @Mock  \n    RandomMoveStrategy randomMoveStrategy;   // Service 내부에서 사용하는 RandomMoveStrategy Mocking   \n\n\t...\n}\n```\n\n### 테스트 코드 작성해보기\n\n```java\n    @Test  \n    void play_메서드가_적절한_형식을_반환한다() throws Exception {  \n        final PlayRequest playRequest = new PlayRequest(\"브리,토미,브라운\", 1);  \n        final String request = objectMapper.writeValueAsString(playRequest);  \n        Car bri = new Car(\"브리\");  \n        Car tomi = new Car(\"토미\");  \n        Car brown = new Car(\"브라운\");  \n        List<Car> cars = List.of(bri);  \n        final PlayResponse playResponse = PlayResponse.of(  \n                RacingCarWinnerDto.of(cars),  \n                List.of(  \n                        RacingCarStatusDto.from(bri),  \n                        RacingCarStatusDto.from(tomi),  \n                        RacingCarStatusDto.from(brown)  \n                )        );  \n  \n        // given  \n        given(randomMoveStrategy.isMovable()).willReturn(true);  \n        given(racingCarService.play(any(PlayRequest.class)))  \n                .willReturn(playResponse);  \n  \n        // then  \n        mockMvc.perform(post(\"/plays\")  \n                        .content(request)  \n                        .contentType(MediaType.APPLICATION_JSON))  \n                .andExpect(status().isOk())  \n                .andExpect(jsonPath(\"$.winners[0]\").value(\"브리\"))  \n                .andExpect(jsonPath(\"racingCars\", hasSize(3)))  \n                .andExpect(jsonPath(\"$.racingCars[0].name\").value(\"브리\"))  \n                .andExpect(jsonPath(\"$.racingCars[0].position\").value(0));  \n    }\n}\n```\n\n`given()`, `when()`, `willReturn()`, `thenReturn()` 메서드들은 BDDMockito에 정의되어 있다.\n\n`@MockBean` 으로 등록한 Service의 행동을 `given()` 으로 지정해준다.  \n`willReturn()` 에서는 해당 행동에서 어떤 값을 리턴해야 하는지 지정한다.\n\n`perform()` 에서 컨트롤러에 요청을 전송한다.  \n`andExpect()`에서는 응답을 검증하는 역할을 한다.   \n`status()` 은 상태 코드를 검증한다.\n`content()` 은 응답에 대한 정보를 검증할 수 있다.\n\n### WebMvcTest의 장단점\n\n`@WebMvcTest`를 사용하면 Spring MVC에 집중한 테스트를 할 수 있다.   \nWeb Layer에 필요한 bean들만 등록하기 때문에 상대적으로 빠르고 가벼운 테스트를 할 수 있다.   \n또한 통합 테스트가 어려운 상황에서 Mock으로 테스트할 수 있다는 장점이 있다.   \n\n그러나 요청부터 응답까지 모든 테스트를 Mock 기반으로 테스트하기 때문에 실제 환경에서는 오류가 발생할 수 있다는 단점이 있다.   \n\n이러한 이유로 `@WebMvcTest` 는 컨트롤러 테스트나 단위 테스트 시에 많이 사용한다.   \n\n### 추가 : @RunWith 은 안 써도 될까?\n\n구글링을 하다보면 많은 코드에서 Test를 작성할 때 `@RunWith(SpringRunner.class)` 를 같이 써준 것을 볼 수 있다.\n\n```java\n// 많이 찾아볼 수 있는 코드\n@RunWith(SpringRunner.class) \n@WebMvcTest(RacingCarController.class) \npublic class Test { \n\t... \n}\n```\n\nJUnit4를 사용한다면 `@RunWith(SpringRunner.class)` 를 같이 추가해줘야지만 annotation이 무시되지 않는다.   \nJUnit5를 사용한다면 `@RunWith`을 추가해 줄 필요가 없다. JUnit5에서는 `@WebMvcTest` 에도 `@RunWith` 어노테이션이 내장되어 있다.   \n\n![[junit-dependency.png]]\n\n이번 jwp-racingcar 미션에서는 JUnit5가 의존성에 포함되어 있기 때문에 테스트 코드마다 매번 `@RunWith` 를 써줄 필요가 없다.\n\n## 참고 자료\n\n- [공식 문서](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.html)\n"},{"excerpt":"LOG 네오, 에밀, 망고, 토리, 포이, 여우, 주노와 함께 점심을 먹었다. 원래 토도로끼에 갈 생각이었는데 사람들이 너무 많아서 네오가 아는 곳으로 제육을 먹으러 갔다. 네오와 같이 앉아서 이야기를 했는데 영화에 대한 이야기를 하다가 종교에 대한 이야기를 하게 됐다. 나와 가치관이 비슷한 부분이 많아서 되게 재밌게 이야기 했다 ㅋㅋㅋ 박스터, 주드, …","fields":{"slug":"/2023-04-20/"},"frontmatter":{"date":"2023년 04월 21일 00:04","title":"2023년 04월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 네오, 에밀, 망고, 토리, 포이, 여우, 주노와 함께 점심을 먹었다. 원래 토도로끼에 갈 생각이었는데 사람들이 너무 많아서 네오가 아는 곳으로 제육을 먹으러 갔다. 네오와 같이 앉아서 이야기를 했는데 영화에 대한 이야기를 하다가 종교에 대한 이야기를 하게 됐다. 나와 가치관이 비슷한 부분이 많아서 되게 재밌게 이야기 했다 ㅋㅋㅋ\n- 박스터, 주드, 망고, 토리, 포이와 교촌치킨에서 저녁을 먹었다. 살면서 교촌치킨 콤보는 먹어본 적 없는데 처음으로 먹어봤다. 그렇지만 역시 콤보 같이 뼈가 있는 메뉴는 먹기 귀찮아서 많이 먹기 힘들다..ㅋㅋㅋ\n- 어쩌다보니 금요일 약속에 에밀도 끼고 토리도 시간이 된다고 해서 같이 술을 마시기로 했다~~ 감기가 거의 다 나아서 내일 술을 마시는 건 괜찮을 거 같다. 재밌겠다~\n- 머리를 자르려고 미용실을 예약했다. 머리를 기르다가 못해먹겠어서..ㅋㅋㅋ 다시 단발로 돌아간다. 항상 이정도 길이까지 기르고 잘랐다. 생각보다 머리 기르는 게 쉽지 않다. 하는 김에 폰케이스도 샀다. 지금 살 게 많은데 사러 가기 귀찮아서 미루다 보니까 집에 없는 게 굉장히 많다. 토요일에 한 번에 사러가야겠다.\n\n## 배운 것\n- TEXT와 VARCHAR의 차이점에 대해 정리했다: [[text-vs-varchar]]\n- 허브신의 코드를 보고 `@WebMvcTest` 에 대해 배웠다.\n\n`@WebMvcTest(RacingCarController.class)` WebMvcTest 어노테이션을 달아준다.\n\n```java\n@Autowired  \nprivate MockMvc mockMvc;  \n  \n@Autowired  \nprivate ObjectMapper objectMapper;  \n  \n@MockBean  \nprivate RacingCarService racingCarService;  \n  \n@Mock  \nRandomMoveStrategy randomMoveStrategy;\n\n@Test  \nvoid play_메서드가_적절한_형식을_반환한다() throws Exception {  \n    final PlayRequest playRequest = new PlayRequest(\"브리,토미,브라운\", 1);  \n    final String request = objectMapper.writeValueAsString(playRequest);  \n    Car bri = new Car(\"브리\");  \n    Car tomi = new Car(\"토미\");  \n    Car brown = new Car(\"브라운\");  \n    List<Car> cars = List.of(bri);  \n    final PlayResponse playResponse = PlayResponse.of(  \n            RacingCarWinnerDto.of(cars),  \n            List.of(  \n                    RacingCarStatusDto.from(bri),  \n                    RacingCarStatusDto.from(tomi),  \n                    RacingCarStatusDto.from(brown)  \n            )    );  \n  \n    // given  \n    given(randomMoveStrategy.isMovable()).willReturn(true);  \n    given(racingCarService.play(any(PlayRequest.class)))  \n            .willReturn(playResponse);  \n  \n    // then  \n    mockMvc.perform(post(\"/plays\")  \n                    .content(request)  \n                    .contentType(MediaType.APPLICATION_JSON))  \n            .andExpect(status().isOk())  \n            .andExpect(jsonPath(\"$.winners[0]\").value(\"브리\"))  \n            .andExpect(jsonPath(\"racingCars\", hasSize(3)))  \n            .andExpect(jsonPath(\"$.racingCars[0].name\").value(\"브리\"))  \n            .andExpect(jsonPath(\"$.racingCars[0].position\").value(0));  \n}\n```\n\n`given()` 에 어떤 행동을 하면 `willReturn()` 에 어떤 값을 리턴할지를 정한다.\n`RacingCarService` 에서 사용하는 `RandomMoveStrategy` 를 mock 하기 위해 `@Mock` 어노테이션을 붙여준다.\n`RacingCarService` 는 bean으로 등록되어 있는 클래스이기 때문에 `@MockBean` 을 붙여준다.\n\n## 궁금한 것\n- mock으로 테스트하는 게 정말 의미가 있을까?\n\n## 어려웠던 것\n\n## 느낀 것\n- 네오와 이야기를 하면서 내가 왜 살고 있는지에 대해 더 생각해볼 필요가 있다고 느꼈다.\n- 알고리즘을 풀어야 될까, 말아야 할까 고민이 된다. 다들 알고리즘을 풀고 있는데, 내 생각에 알고리즘은 꾸준히 많은 문제를 풀면 많이 풀 수 있는 거 같다. 물론 선배는 문제를 한 번에 많이 푸는 기간이 있어야 한다고 하기는 했지만ㅋㅋ 우테코 내에서 알고리즘을 하는 게 맞을지 아닐지 아직 고민중이다."},{"excerpt":"LOG 이동욱님의 강의가 있었다. 자존감 높이기에 대한 이야기였는데, 내가 기댈 수 있는 기둥을 여러 개 만들어두라는 말이 있었다. 지금의 나의 자존감 기둥에는 뭐가 있을까... 생각해볼 수 있었던 시간이었다. 주노, 포이, 글렌과 함께 한강 공원에 갔다. 생각보다 벌레가 많았다... 오늘 날씨가 좋아서 롯데월드도 가고 싶었고, 보드 게임 카페도 갈까 하…","fields":{"slug":"/2023-04-19/"},"frontmatter":{"date":"2023년 04월 19일 14:04","title":"2023년 04월 19일","tags":null},"rawMarkdownBody":"## LOG\n- 이동욱님의 강의가 있었다. 자존감 높이기에 대한 이야기였는데, 내가 기댈 수 있는 기둥을 여러 개 만들어두라는 말이 있었다. 지금의 나의 자존감 기둥에는 뭐가 있을까... 생각해볼 수 있었던 시간이었다.\n- 주노, 포이, 글렌과 함께 한강 공원에 갔다. 생각보다 벌레가 많았다... 오늘 날씨가 좋아서 롯데월드도 가고 싶었고, 보드 게임 카페도 갈까 하다가 너무 시간이 애매해서 그냥 바람만 쐬다가 왔다. 날씨가 좋아서 그런지 되게 재밌었다. 맥주는 마시지 말 걸 (?) 그랬다... 마시자마자 기침이 났다. 이제 감기가 그만 좀 나았으면 좋겠다.\n\n## 배운 것\n- Spring Core를 정리했다: [[spring-core]]\n- 저번에 Pure Fabrication 관련해서 Factory를 예제로 들었었는데, 올바른 예제였다. [[grasp]] 에서 확인해볼 수 있다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 내일은 MockMvc에 대해 공부해볼 생각이다. 지금 미션에 테스트가 하나도 없는데 단위 테스트를 추가해서 커밋해봐야겠다. "},{"excerpt":"LOG 2단계 미션 PR을 보냈다. PR 보낼 때 질문을 많이 생각해보려다가 브라운이 리뷰어들이 질문에 대답하는 게 오래 걸린다고 해서 그냥 생각난 것 하나만 적었다. Bean을 만드는 기준에 대해서 질문했는데 아마도 답이 없는 질문이라 just 리뷰어의 생각이 궁금하다. 결국 병원에 갔다. 갑자기 깃짱이랑 얘기하다가 목이 간지럽더니 기침을 안 쉬고 20…","fields":{"slug":"/2023-04-18/"},"frontmatter":{"date":"2023년 04월 18일 14:04","title":"2023년 04월 18일","tags":null},"rawMarkdownBody":"## LOG\n- 2단계 미션 PR을 보냈다. PR 보낼 때 질문을 많이 생각해보려다가 브라운이 리뷰어들이 질문에 대답하는 게 오래 걸린다고 해서 그냥 생각난 것 하나만 적었다. Bean을 만드는 기준에 대해서 질문했는데 아마도 답이 없는 질문이라 just 리뷰어의 생각이 궁금하다.\n- 결국 병원에 갔다. 갑자기 깃짱이랑 얘기하다가 목이 간지럽더니 기침을 안 쉬고 20번 정도 했다. 기침을 많이 하면 생리적으로 눈물이 난다는 사실 알고 계셨나요 다들. 왠지 모르게 울고 있는 사람 돼서 토리가 많이 걱정했다. 병원에 갔는데 신속항원검사부터 하라고 해서 혹시나 코로나인가 해서 걱정했다. 다행히 음성이 나와서 나한테 옮은 주드는 그냥 감기인 걸로... ^^ 약을 3일간 먹어야 하는데 금주령이 내려졌다. 금요일에 술을 마셔야겠다.\n- 오늘 강의 실습 시간에 네오, 포이, 주노와 함께 필드 주입과 프록시 객체에 대해 이야기를 나눴다. 역시 책을 읽거나 검색으로 지식을 늘리는 것보다 사람들과 이야기 하면서 지식을 얻는 게 즐거운 거 같다.\n- 포이 테코톡 리허설을 들었다. 제대로 공부하고 많이 알고 있다보니 발표를 잘하는게 느껴졌다. 스크립트 없이 발표하는 게 신기했다.\n\n## 배운 것\n- **필드 주입이 안 좋은 이유? (Easy to add too many dependencies 가 생기는 이유가 무엇일까?)** : 필드가 늘어나면 객체 생성 책임이 늘어나는지 모른다. 그런데 생성자에서는 알 수 있다. 필드 주입을 하게 된다면 의존성이 런타임에서 변경될 수 있다. (트레이드 오프 있음) -> final을 못 쓰는 것과 동일한 이유이다.\n- **생성자 주입이 왜 테스트에 좋은가?**: 이미 우리가 의존성 주입을 잘 구현해놔서 지금은 크게 와닿지 않을 수 있다.\n- **필드 주입과 생성자 주입을 동시에 하면 뭐가 우선일까?**: 생성자 주입이 먼저 실행되고 필드 주입으로 덮어씌워진다.\n- **Repository 의존성 주입을 할 때 프록시 객체가 만들어지는가?**: 만들어진다. DB Vendor마다 다른 예외 변환을 위해서이다.\n- **@Controller는 프록시 객체가 만들어질까?**: 안 만들어진다. (뇌피셜) 스프링 내부에서 통제할 수 있기 때문에 그런 거 아닐까.\n- @Service는 사실상 @Component와 다를 게 없다. 명시적으로 DDD 관점에서 서비스인 걸 알려주기 위해 추가된 기능이다.\n- **스프링 빈을 모두 등록하는 게 좋을까?**: 스프링 빈을 모두 등록할 때 성능상 차이는 크게 고려하지 않아도 된다. 그러나 스프링을 모두 걷어냈을 때 제대로 작동하는 프로그램으로 수정하기 어려워진다. (라이프 사이클이 스프링에 종속되기 때문에) 그렇기 때문에 의존성을 최대한 줄이는 방향으로 설계해야 한다.\n\n## 궁금한 것\n- `Optional` 의 `orElseGet`은 왜 supplier null check를 하지 않는걸까 by 포이\n\n## 어려웠던 것\n\n## 느낀 것\n- 진지하게 몸을 가만히 못 있겠다. 뭐라도 흔들어야 할 것 같은.. 그런 기분이 든다 ㅋㅋㅋㅋㅋ 아니 진짜 진지하다... 에너지가 넘친다기보다는 그냥 뭔가 ... 뭐라도 해야 할 것 같은 느낌이 들어서 가만히 못 있겠다. 실제로 아무것도 못할 수가 없다. 집중력이 낮아지는 거 같다.\n- 왜 느낀 것이 점점 줄어들까 생각해봤다. 역시 요즘 생각 없이 살고 있는 거 같다. 좋게 말하면 긍정적이고 재밌게 살고, 안 좋게 말하면 아무 생각 없이 막 살고 있다. 그런데 굳이 나쁘게 생각할 필요 있나? 좋은 점을 보자 ㅋㅋ"},{"excerpt":"Scan   는 repository(DAO로 알려진) 의 역할을 하는 class에 붙인다.\n 를 사용하면 예외의 자동변환을 가능하게 해준다. (Exception Translation) Spring은 추가적인 어노테이션을 제공한다.\n, ,  는 일반적으로 Spring에서 관리하는 component이다.\n, ,  는  의 특화 버전으로 더 구체적인 사용 ca…","fields":{"slug":"/spring-core/"},"frontmatter":{"date":"2023년 04월 18일 02:04","title":"Spring Core","tags":["레벨2","우테코","개발","spring"]},"rawMarkdownBody":"\n## Scan\n\n### `@Component`\n\n`@Repository` 는 repository(DAO로 알려진) 의 역할을 하는 class에 붙인다.\n`@Repository` 를 사용하면 예외의 자동변환을 가능하게 해준다. (Exception Translation)\n\nSpring은 추가적인 어노테이션을 제공한다.\n`@Component`, `@Service`, `@Controller` 는 일반적으로 Spring에서 관리하는 component이다.\n`@Repository`, `@Service`, `@Controller` 는 `@Component` 의 특화 버전으로 더 구체적인 사용 case를 위해 사용된다. \n\ncomponent 클래스들에 `@Component` 어노테이션을 쓸 수는 있지만, `@Repository`, `@Service`, `@Controller` 를 사용하면 tool로 처리하거나 aspect(비즈니스 로직 외에 다른 기능들이 정의되어 있는 모듈)들과 연결하여 더 적절하게 다뤄질 수 있다.\n`@Service` 는 `@Component` 와 다른 바가 없지만, DDD 관점에서의 사용을 위해 추가된 어노테이션이다.\n`@Repository`, `@Service`, `@Controller` 는 Spring의 이후 release에서 추가적인 의미를 전달할 수도 있다. 따라서 service layer에 `@Component`, `@Service` 둘 중 하나의 어노테이션을 붙여야 한다면, `@Service` 가 더 좋은 선택이다.\n\n마찬가지로 앞서 설명한 것처럼 `@Repository` 는 persistence layer에서 자동 예외 변환을 위한 marker로서 지원되고 있다.\n\n## DI\n\n### Dependencies\n\n일반적인 엔터프라이즈 애플리케이션은 단일 객체(bean)로 구성되지 않는다. 가장 단순한 애플리케이션 조차도 end-user 에게 서비스를 제공할 때 여러 개의 객체들이 협력해서 기능을 제공하게 된다.\n\n### Dependency Injection\n\nDI(의존성 주입)는 객체들이 자신들의 의존성을 무어\n\nContainer는 bean을 만들 때 의존성을 주입해준다. \n이런 과정은 근본적으로 클래스를 직접 생성하여 사용하는 것 또는 Service Locator Pattern을 사용하여 bean 자체가 의존성의 위치와 인스턴스화를 제어하는 IoC(제어의 역전)이다.\n\nDI 원칙을 따르는 코드는 더 깔끔하고, 객체들이 의존성들을 제공받을 때 decoupling(낮은 결합도) 측면에서 더 효과적이다.\n주입받는 객체는 의존성을 찾지 않아도 되고, 의존성의 위치나 클래스를 알지 못한다.\n결론적으로 의존성이 인터페이스나 추상 클래스에 있는 경우 단위 테스트에서 stub 또는 mock 구현을 사용할 수 있어 테스트하기 더 쉽다.\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies)\n\n### Constructor-based Dependency Injection\n\nConstructor-based DI(생성자 주입)는 container가 constructor를 호출하여 수행된다. \n정적 팩토리 메서드를 호출해서 bean을 생성하는 것은 거의 동일한 방법이다.\n\n```java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on a MovieFinder\n    private final MovieFinder movieFinder;\n\n    // a constructor so that the Spring container can inject a MovieFinder\n    public SimpleMovieLister(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n```\n\ncontainer 특정 인터페이스나 base 클래스, 어노테이션에 대한 종속성이 없는 POJO 이다.\n\n**POJO**\nPlain Old Java Object\n어떤 특정 framework이나 convention에 종속되지 않거나 property들과 method의 naming convention에 구속되지 않는 Java 객체다.\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection)\n\n### Setter-based Dependency Injection\n\nSetter-based DI(setter 주입)는 container가 bean을 인스턴스화하기 위해 매개변수가 없는 consturctor를 호출하거나 매개변수가 없는 정적 팩토리 메서드를 호출하고 setter 메서드를 호출하는 것이다.\n\n순수 setter 주입을 사용해서 의존성 주입이 가능한 클래스이다. 해당 클래스는 기존 Java 클래스로, 특정 container 인터페이스, base 클래스, 어노테이션에 대한 종속성이 없는 POJO이다.\n\n```java\npublic class SimpleMovieLister {\n\n    // the SimpleMovieLister has a dependency on the MovieFinder\n    private MovieFinder movieFinder;\n\n    // a setter method so that the Spring container can inject a MovieFinder\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // business logic that actually uses the injected MovieFinder is omitted...\n}\n```\n\n`ApplicationContext` 는 관리할 bean들을 위해 생성자 주입과 setter 주입을 지원한다.\n몇몇 의존성이 이미 constructor 을 통해 주입된 후에도 setter 주입이 가능하다.\n`BeanDefinition` 의 형태로 의존성을 설정하고, `PropertyEditor` 인스턴스와 함께 사용하여 property들을 하나의 format에서 다른 형태로 변환한다.\n\n그러나 대부분의 Spring 사용자들은 이러한 클래스를 직접 사용하는 것이 아니라 XML의 bean 정의와 `@Component`, `@Controller` 등의 어노테이션이 달린 클래스의 `@Bean` 메서드를 사용하여 작업한다.\n내부적으로 `BeanDefinition` 의 인스턴스로 변환되어 전체 Spring IoC container 인스턴스를 로드하는데 사용된다.\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-setter-injection)\n\n### Constructor-based DI vs Setter-based DI\n\n생성자 주입과 setter 주입은 혼합사용이 가능하기 때문에, 필수 의존성에는 생성자 주입을 사용하고 선택적 의존성에는 setter 메서드나 configuration 메서드를 사용하는 것이 좋다. setter 메서드에 `@Autowired` 어노테이션을 사용하면 필드를 필수 의존성으로 만들 수 있지만 프로그래밍 유효성 검사를 통해 생성자 주입을 사용하는 것이 바람직하다.\n\n일반적으로 생성자 주입을 지지한다. 애플리케이션 컴포넌트를 불변 객체로 구현하고 필요한 의존성이 null이 되지 않도록 보장하기 때문이다. 생성자 주입하는 컴포넌트가 항상 완전히 초기화된 상태로 클라이언트에 반환된다. 생성자 매개변수가 많게 되면 code smell 이고, 클래스에 너무 많은 책임이 있을 수 있어서 적절한 분리를 위해 리팩터링해야 한다는 뜻이다.\n\nsetter 주입은 주로 클래스 내에서 합리적인 default value를 할당할 수 있는 선택적 의존성에만 사용해야 한다. 그렇지 않으면 의존성을 사용하는 모든 곳에서 null이 아닌지 검사를 수행해야 한다. \n\nsetter 주입의 한 가지 이점은 setter 메서드를 사용하면 해당 클래스의 객체를 나중에 재구성하거나 다시 주입할 수 있다는 것이다. (JMX MBeans를 통한 관리에서 setter 주입을 사용한다.)"},{"excerpt":"LOG 월급을 받아서 토리, 망고, 포이랑 저녁에 표현 식당에 가서 고기를 먹었다. 표현 식당 처음 가봤는데 사장님이 우리 명찰을 보시고 예전에 회식 왔던 사람들이랑 같은 회사(?)냐고 물어보셔서 신기했다 ㅋㅋㅋ 2단계 구현을 완료했다. 구현할 게 많지 않아서 금방 끝났다. 그런데 잘한건지는 잘 모르겠다.. 데일리 미팅 때 마피아를 하고 나서 액션 훈민정…","fields":{"slug":"/2023-04-17/"},"frontmatter":{"date":"2023년 04월 17일 14:04","title":"2023년 04월 17일","tags":null},"rawMarkdownBody":"## LOG\n- 월급을 받아서 토리, 망고, 포이랑 저녁에 표현 식당에 가서 고기를 먹었다. 표현 식당 처음 가봤는데 사장님이 우리 명찰을 보시고 예전에 회식 왔던 사람들이랑 같은 회사(?)냐고 물어보셔서 신기했다 ㅋㅋㅋ\n- 2단계 구현을 완료했다. 구현할 게 많지 않아서 금방 끝났다. 그런데 잘한건지는 잘 모르겠다..\n- 데일리 미팅 때 마피아를 하고 나서 액션 훈민정음 게임을 했다. 훈민정음을 몸으로 표현하고 채채한테 패스 받는 거였는데 너무 웃겼다 ㅋㅋㅋㅋ 관중들이 늘어나니까 훈수가 많아져서 더 웃겼다. 아침 데일리가 웃기니까 하루 종일 즐거운 마음으로 지낼 수 있었다. 네오조... 정말 데일리를 열심히 즐기는 거 같다 ㅋㅋㅋ\n- 감기가 여전히 떨어지지 않고 있다. 주노가 약을 사다줬다. **THANKS JUNO...** He is angel. 내일 낫는 건 때려치우고 이번 주 안에 낫는 걸 목표로 하려고 한다. 병원은 가기 싫다.\n\n## 배운 것\n- `@Bean` 을 `@Configuration` 에 등록하지 않고 사용하면 싱글톤이 보장되지 않는다.\n- `groupingBy` 는 매개변수로 classifier라는 함수형 인터페이스가 필요하다. \n```java\nMap<Long, List<Player>> playersGroupingByGameId = allPlayers.stream()  \n        .collect(Collectors.groupingBy(Player::getGameId));\n```\n\n어떤 값으로 grouping 할 지를 매개변수로 넣는다.\n\n## 궁금한 것\n- 자동차 경주 콘솔 애플리케이션을 만들 때도 웹 애플리케이션의 Service를 써도 되는걸까? 서로 별개여야 되는 거 아닐까?\n\n## 어려웠던 것\n\n\n## 느낀 것\n- 조용히 말하기... 실패 중이다. 웃으면 데시벨 조절이 안 돼서 굉장히 먼 곳에서도 내 목소리가 들린다고 한다. 좀 더 조용히 말해보려고 노력은 할 거지만 잘 될 거라는 자신은 없다 ㅋㅋㅋ 그렇지만 최선을 다했으니 오케이입니다.\n- 공부가 잘 됐다. 오늘 목표한 미션 구현을 완료할 수 있어서 다행이다. 집중하고 싶을 때 페어룸으로 폐관수련 가려고 한다. 확실히 공부할 수 있는 조용한 환경이 있으면 공부가 잘 되는 거 같다.\n"},{"excerpt":"DAO Data Access Object의 약자이다. DAO는 data persistence (애플리케이션과 데이터베이스 사이를 추상화한 계층을 제공하는 것) 를 추상화한 것이다.\nDAO는 data mapping과 접근을 관리하고, 애플리케이션으로부터 쿼리의 복잡함을 숨겨준다.\n주로 table 중심적이고, 데이터베이스에 더 가까우며 low level 개념…","fields":{"slug":"/dao-vs-repository/"},"frontmatter":{"date":"2023년 04월 15일 14:04","title":"DAO vs Repository","tags":["개발","spring"]},"rawMarkdownBody":"\n## DAO\n\nData Access Object의 약자이다. \n\nDAO는 data persistence (애플리케이션과 데이터베이스 사이를 추상화한 계층을 제공하는 것) 를 추상화한 것이다.\nDAO는 data mapping과 접근을 관리하고, 애플리케이션으로부터 쿼리의 복잡함을 숨겨준다.\n주로 table 중심적이고, 데이터베이스에 더 가까우며 low level 개념으로 간주된다.\n많은 경우, database 테이블과 일치하게 된다.\n\n## Repository\n\n객체들의 집합을 추상화한 것이다. \ndomain 객체에 더 가까운 개념으로 Aggregate Roots만 다루는 상위 개념이다.\n\n도메인 객체에 접근하기 위한 collection 과 유사한 interface를 사용하여 domain 객체와 \ndata mapping layer 사이를 중재한다. \n즉, Repository는 객체의 Collection을 다루듯이 캡슐화(인터페이스)를 제공한다는 점에서 테이블보다는 객체 중심의 layer라고 할 수 있다.\n\n객체 중심으로 데이터를 다루기 위해 하나 이상의 DAO를 사용할 수 있어 DAO보다 상위 layer라고 할 수 있다.\n\n## DAO vs Repository\n\n프로젝트 요구 사항에 따라 구현은 주관적일 수 있다.\n\nDAO는 간단한 CRUD 작업에 더 적합하며 구현하기 쉽다.\nRepository는 여러 테이블을 포함하는 복잡한 작업에 더 적합하며 더 높은 수준의 추상화를 제공한다.\n\n## 참고 자료\n\n- https://www.baeldung.com/java-dao-vs-repository"},{"excerpt":"LOG 감기 금방 나을 줄 알았는데 진짜 안 낫는다. 말을 많이 하면 기침이 나온다. 그래서 의도치 않은 열혈 마스크 맨이 되었다... 월요일에 잠실 가기 전까지 나았으면 좋겠다. 음식 쓰레기를 버렸다. 일주일간 냉장고에 함께한 치킨이 떠났다. 떠나보내는 김에 이것저것 같이 떠나보냈다. 마음이 후련했다. 하는 김에 설거지도 했다. 집이 깨끗해졌다. 배운 …","fields":{"slug":"/2023-04-15/"},"frontmatter":{"date":"2023년 04월 15일 13:04","title":"2023년 04월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 감기 금방 나을 줄 알았는데 진짜 안 낫는다. 말을 많이 하면 기침이 나온다. 그래서 의도치 않은 열혈 마스크 맨이 되었다... 월요일에 잠실 가기 전까지 나았으면 좋겠다.\n- 음식 쓰레기를 버렸다. 일주일간 냉장고에 함께한 치킨이 떠났다. 떠나보내는 김에 이것저것 같이 떠나보냈다. 마음이 후련했다. 하는 김에 설거지도 했다. 집이 깨끗해졌다.\n\n## 배운 것\n- `@Controller` 와 `@RestController` 의 차이점을 알아보았다: [[controller-vs-restcontroller]]\n- Spring에서는 HikariCP 로 DB Connection을 공유한다. 여러 개의 Connection 을 미리 생성해두고, Connection이 필요할 때마다 할당해준다. 프로그램마다 최적의 Connection 개수는 다르다.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 요즘 긴 글은 많이 못 쓰고, 짧은 글을 많이 양산하고 있다. 그래도 아무것도 안 쓰는 것보다는 낫다고 생각한다. "},{"excerpt":"네트워크 HTTP/2.0 Server Push HTTP/2.0 Binary Framing HTTP/2.0 Multiplexing 어떤 페이지에서는 왜 HTTP 버전이 다른 리소스가 존재할까? 소켓 HTTPS 서버 무상태성이란? Spring bean Filter Servlet Dispatcher Servlet  vs  -> TIL에 정리해둔 거 글로 정리하…","fields":{"slug":"/technical-debt/"},"frontmatter":{"date":"2023년 04월 15일 04:04","title":"기술 부채","tags":["기술부채"]},"rawMarkdownBody":"\n## 네트워크\n- HTTP/2.0 Server Push\n- HTTP/2.0 Binary Framing\n- HTTP/2.0 Multiplexing\n- 어떤 페이지에서는 왜 HTTP 버전이 다른 리소스가 존재할까?\n- 소켓\n- HTTPS\n\n## 서버\n- 무상태성이란?\n\n## Spring\n- bean\n- Filter\n- Servlet\n- Dispatcher Servlet\n- `@Validated` vs `@Valid` -> TIL에 정리해둔 거 글로 정리하기\n- objectmapper의 역직렬화 과정 -> dto 기본 생성자가 private이 가능한 이유\n- Spring Validation\n\n## SQL\n- outer join vs inner join\n- cascade\n\n## 아키텍처"},{"excerpt":"는  클래스가 특화된 것으로, classpath scanning 을 통해 구현 클래스들을 자동으로 감지하도록 해준다. 보통  와  어노테이션이 함께 쓰인다.  어노테이션은 리턴되는 객체를  로 자동 직렬화하도록 한다.  Spring 4.0 에서 RESTful 웹서비스 생성을 단순화 하기 위한  가 소개되었다.\n 는  와  를 합친 어노테이션이다.\n 가 존…","fields":{"slug":"/controller-vs-restcontroller/"},"frontmatter":{"date":"2023년 04월 15일 02:04","title":"Controller vs RestController","tags":["개발","spring"]},"rawMarkdownBody":"\n## `@Controller`\n\n`@Controller` 는 `@Component` 클래스가 특화된 것으로, classpath scanning 을 통해 구현 클래스들을 자동으로 감지하도록 해준다.\n\n보통 `@Controller` 와 `@RequestMapping` 어노테이션이 함께 쓰인다.\n\n```java\n@Controller\n@RequestMapping(\"books\")\npublic class SimpleBookController {\n\n    @GetMapping(\"/{id}\", produces = \"application/json\")\n    public @ResponseBody Book getBook(@PathVariable int id) {\n        return findBookById(id);\n    }\n\n    private Book findBookById(int id) {\n        // ...\n    }\n}\n```\n\n`@ResponseBody` 어노테이션은 리턴되는 객체를 `HttpResponse` 로 자동 직렬화하도록 한다.\n\n## `@RestController`\n\nSpring 4.0 에서 RESTful 웹서비스 생성을 단순화 하기 위한 `@RestController` 가 소개되었다.\n`@RestController` 는 `@Controller` 와 `@ResponseBody` 를 합친 어노테이션이다. \n`@RestController` 가 존재하는 클래스의 모든 메서드에는 `@ResponseBody` 어노테이션이 존재하는 것과 같다. \n\n`@RestController` 는 controller의 특화 버전이다.\n\n```java\n@RestController\n@RequestMapping(\"books-rest\")\npublic class SimpleBookRestController {\n    \n    @GetMapping(\"/{id}\", produces = \"application/json\")\n    public Book getBook(@PathVariable int id) {\n        return findBookById(id);\n    }\n\n    private Book findBookById(int id) {\n        // ...\n    }\n}\n```\n\n`@RestController` 어노테이션이 붙은 클래스들은 `@ResponseBody` 가 필요하지 않다.\n모든 Controller의 Request Handling method는 리턴되는 객체들을 `HttpResponse` 로 자동적으로 직렬화한다.\n\n## 두 어노테이션의 차이점\n\n`@Controller` 는 reponse가 주로 HTML 페이지인 UI 기반의 애플리케이션에서 사용된다. \n메서드가 view name을 리턴하면 view resolver 가 해당하는 view를 찾아 응답한다.\n\n`@RestController` 는 데이터를 HTML로 변경하는 server-side rendering을 수행하지 않고, HTTP response를 JSON 또는 XML로 전달한다.\n\n## 참고 자료\n\n- https://www.baeldung.com/spring-controller-vs-restcontroller\n"},{"excerpt":"포이가 TEXT와 VARCHAR의 차이점이 무엇인 것 같냐고 물어봐서 알아보게 되었다. TEXT 긴 문자열을 저장할 수 있는 가변 길이 데이터 유형이다. 고정된 최대 크기 문자 개수는 2^16 - 1 이다. TEXT(M) 은 M <= 255 에서 2 + c 바이트의 디스크 공간을 차지한다. (c는 저장된 문자열의 길이) index의 완전한 일부가 될 수 …","fields":{"slug":"/text-vs-varchar/"},"frontmatter":{"date":"2023년 04월 14일 11:04","title":"TEXT와 VARCHAR의 차이점은 무엇일까?","tags":["개발"]},"rawMarkdownBody":"\n포이가 TEXT와 VARCHAR의 차이점이 무엇인 것 같냐고 물어봐서 알아보게 되었다.\n\n## TEXT\n\n- 긴 문자열을 저장할 수 있는 가변 길이 데이터 유형이다.\n- 고정된 최대 크기 문자 개수는 2^16 - 1 이다.\n- TEXT(M) 은 M <= 255 에서 2 + c 바이트의 디스크 공간을 차지한다. (c는 저장된 문자열의 길이)\n- index의 완전한 일부가 될 수 없고, prefix length를 지정해야 한다.\n\n## VARCHAR\n\n- 최대 크기 M에 대해 2^16-1 의 가변 크기를 갖는다.\n- TEXT보다 더 적은 공간을 차지한다.\n- VARCHAR(M) 은 1 + c 바이트 (M <= 255 인 경우) 또는 2 + c 바이트 (256 <= M <= 65535) 의 디스크 공간을 차지한다.\n- index의 일부가 될 수 있다.\n- 8비트 code page로 제한되는 non-Unicode character data type이다.\n- NVARCHAR 보다 디스크 공간을 덜 차지한다.\n\n## NVARCHAR\n- 모든 Unicode data를 저장할 수 있는 Unicode character data type이다.\n- VARCHAR 대신 NVARCHAR를 사용하면 데이터베이스에서 읽거나 쓸 때마다 인코딩 변환을 수행하지 않아도 된다. 변환에는 시간이 걸리고 오류가 발생하기 쉽다. 발생한 변환 오류로부터 값을 복구하는 것은 어렵다.\n\n## Index\n\n테이블에 효율적으로 접근하기 위한 데이터 구조이다.\n필수는 아니지만 인덱스가 없으면 쿼리 응답 시간이 느려질 수 있다.\n\n인덱스는 테이블과 연관되어 있고, 하나 이상의 테이블 column으로 구성된 키를 갖는다.\n데이터베이스에서 검색 속도를 높이는 데 사용할 수 있다.\n\n## 예제\n\n테이블에 몇 단어에서 몇 단락에 이르는 사용자의 자기소개가 저장된다고 하자.\n이 경우에는 TEXT를 사용하는 것이 좋다. 자기소개는 길이가 매우 다양할 수 있고, index화 하거나 외래 키 제약 조건에 사용될 필요가 없기 때문이다. \n또한 사용자 테이블에 다른 열이 있을 가능성이 높기 때문에 bio 열에 VARCHAR를 사용하여 최대 행 크기인 65535 바이트를 초과하지 않으려는 것이다. TEXT를 사용하면 bio를 행 외부에 저장하고 행에 해당 bio에 대한 포인터만 가질 수 있으므로 행의 크기가 줄어든다.\n\n```sql\nCREATE TABLE user (\n  id INT PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  email VARCHAR(50) NOT NULL,\n  bio TEXT\n);\n```\n\n전자 상거래 웹사이트용 테이블이 있다고 가정하자.\n하나의 column에는 몇 단어에서 몇 문장에 이르는 제품 설명이 저장된다. 이 경우에 description column에는 VARCHAR를 사용한다. 설명이 비교적 짧고, column을 index화하여 외래키 제약 조건에서 사용할 수 있기를 바라기 때문이다. 또한 product 테이블에 다른 column이 있을 가능성이 높으므로 설명 열에 TEXT를 사용하여 최대 행 크기인 65535 바이트를 초과하지 않기 위해서이다. \n\n```sql\nCREATE TABLE product (\n  id INT PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  category VARCHAR(50) NOT NULL,\n  description VARCHAR(255),\n  price DECIMAL(10,2) NOT NULL\n);\n```\n\n즉, 많은 양의 텍스트를 저장해야 하는 경우 TEXT를 사용하고, 비교적 짧은 텍스트를 저장해야 하는 경우에는 VARCHAR를 사용한다. (라는 말 밖에 안 나온다...)\n\n## 그럼 왜 TEXT를 쓸까?\n\n베로 피셜: 엄청 큰 문자열을 저장할 거 아니면 TEXT를 딱히 쓸 이유가 없는 거 같다.\n\n## 결론\n\n몇 단어 또는 문장을 저장하고, (전체) column을 index로 만들거나 외래 키 제약 조건이 있는 column을 사용하려는 경우 VARCHAR를 사용해야 한다.\n\n단락 이상의 텍스트를 저장하려는 경우, column을 index로 만들 필요가 없거나 테이블 column 크기 제한에 도달한 경우 TEXT를 사용해야 한다.\n\n단, VARCHAR 또는 TEXT 필드에 필요한 실제 바이트 수는 column (또는 콘텐츠의 인코딩)에 따라 달라진다는 것을 유의해야 한다.\n"},{"excerpt":"LOG 학습로그 스터디에 말랑이 합류했다! 베포후헤말 스터디가 되었다 ㅋㅋ 이번에 같이 스터디했는데 아는 게 정말 많아서 잘 몰랐던 부분에 대해 많이 도움받을 수 있었다. 역시 스프링 컨트리뷰터 말랑 👍 슬랙에 matzip 서비스 같이 개발할 5기를 모집한다고 해서 주드, 체인저와 같이 신청하기로 했다. 나는 실제 사용자가 있는 서비스를 배포해본 적이 없…","fields":{"slug":"/2023-04-14/"},"frontmatter":{"date":"2023년 04월 14일 11:04","title":"2023년 04월 14일","tags":null},"rawMarkdownBody":"## LOG\n- 학습로그 스터디에 말랑이 합류했다! 베포후헤말 스터디가 되었다 ㅋㅋ 이번에 같이 스터디했는데 아는 게 정말 많아서 잘 몰랐던 부분에 대해 많이 도움받을 수 있었다. 역시 스프링 컨트리뷰터 말랑 👍\n- 슬랙에 matzip 서비스 같이 개발할 5기를 모집한다고 해서 주드, 체인저와 같이 신청하기로 했다. 나는 실제 사용자가 있는 서비스를 배포해본 적이 없어서 만약 참가할 수 있게 된다면 정말 좋은 경험이 될 것 같다. 질문 답변을 열심히 생각해 봐야겠다!! 4기 오리가 matzip 서비스 관리하시는 줄은 몰랐는데 너무 재밌겠다~~\n\n## 배운 것\n- 드디어 spring-jdbc 정리 완료: [[spring-jdbc]]\n- 베포후헤말 스터디에서 준비한 학습로그: [[grasp|GRASP 원칙이란 무엇일까?]]\n\n## 궁금한 것\n- Argument Resolver 를 따로 정의해서 사용하는 방법이 있을까?\n\n## 어려웠던 것\n- 오늘 헤나가 발표했던 argument resolver 내용이 아직 잘 이해가 안 된다. 좀 더 공부해봐야겠다. 앞으로 Argument Resolver를 구현해서 쓸 일이 있을까?\n\n## 느낀 것\n- 요즘 조용히 말하기를 하고 있는데 잘 되고 있는지는 모르겠다..ㅋㅋ 자리를 옮겨볼까 생각도 했는데 이제 다들 자리가 고정된 것 같아서 어디로 이동하는 게 쉽지 않다.\n- 말하는 거에 자신이 없으면 어, 이제, 그, 라는 말을 많이 쓴다는 걸 알게 되었다. 내가 준비한 내용, 준비한 말에 자신이 있고 확신이 있어야 말하기를 잘할 수 있는 거 같다. 후추처럼 말에 군더더기가 없었으면 좋겠다. 좀 더 많이 조사하고, 많이 준비해보자."},{"excerpt":"GRASP General Responsibility Assignment Software Patterns 의 약자로, 일반적인 책임 할당을 위한 소프트웨어 패턴이다. 모든 예제는 체스 미션을 예시로 들 예정이다. Information Expert Pattern (정보 전문가 패턴) 정보 전문가에게 책임을 할당하라.\n객체에게 책임을 할당할 때는 책임을 수행할…","fields":{"slug":"/grasp/"},"frontmatter":{"date":"2023년 04월 14일 00:04","title":"GRASP는 무엇인가요?","tags":["스터디","우테코","학습로그"]},"rawMarkdownBody":"## GRASP\n\n**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns 의 약자로, 일반적인 책임 할당을 위한 소프트웨어 패턴이다.\n\n모든 예제는 체스 미션을 예시로 들 예정이다.\n\n### Information Expert Pattern (정보 전문가 패턴)\n\n**정보 전문가에게 책임을 할당하라.**\n객체에게 책임을 할당할 때는 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당해야 한다.\n\n체스 미션의 Board와 Board를 구성하는 Square와 Piece를 생각해보자.\n\n사용자로부터 move a2 a4 라는 입력을 받은 경우, a2에 있는 말을 a4로 움직여야 한다.\n그렇다면 이 메시지를 수신할 적합한 객체는 무엇일까?\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> ???\n```\n\n객체는 상태와 행동을 통합한 캡슐화의 단위이다.\n따라서, 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.\n\n아마 Board라는 객체가 말을 움직이는 것이 적합해보인다.\nBoard는 말과 현재 턴을 알고 있다. 말을 움직이는 것을 위한 정보 전문가라고 할 수 있다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board\n```\n\n그렇지만 a2에 있는 말이 a4에 갈 수 있는지는 Board가 알 수 없다. 이럴 때는 외부에 도움을 요청해야 한다.\n외부 객체에게 요청해서 말이 움직일 칸으로 이동할 수 있는지를 알아내야 한다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> ???\n```\n\n말이 움직일 칸으로 이동할 수 있는지 계산하는 데 필요한 정보를 알고 있는 전문가는 Piece이다. \n따라서 Information Expert 패턴에 따라 메시지를 수신할 적당한 객체는 Piece가 된다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> Piece\n```\n\n단, 정보 전문가가 데이터를 반드시 저장하고 있을 필요는 없다.\n객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나, 필요한 정보를 계산해서 제공할 수도 있다.\n\nInformation Expert Pattern은 정보를 알고 있는 객체만이 책임을 어떻게 수행할지 스스로 결정할 수 있으므로 객체가 자율적인 존재가 되도록 돕는다. 필요한 정보를 가진 객체들로 책임이 분산되어 더 응집력 있고, 이해하기 쉬워진다. 따라서 응집도는 올라가고, 결합도가 낮아져서 간결하고 유지보수하기 쉬운 시스템을 구축할 수 있다.\n\n### 높은 응집도와 낮은 결합도\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> Piece\n```\n\n```mermaid\nflowchart LR\n\tPiece -- 해당 칸이 나이트 이동으로 갈 수 있는지 확인해라 --> Direction\n```\n\n이런 식의 설계가 되어 있을 때, Board가 Direction에게 직접 나이트 이동으로 갈 수 있는지 확인해도 되지 않을까?\n\n즉, 다음과 같은 설계를 말한다.\n\n```mermaid\nflowchart LR\n\tUser -- 말을 움직여라 --> Board -- 해당 칸으로 이동할 수 있는지 확인해라 --> Piece\n\tBoard -- 해당 칸이 나이트 이동으로 갈 수 있는지 확인해라 --> Direction\n```\n기능적인 측면에서는 차이가 없는 것처럼 보인다. \nDirection이 Board와 협력하는 것이 좋을까, Piece와 협력하는 것이 좋을까?\n\n#### Low Coupling (낮은 결합도)\n\n**의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시키도록 책임을 할당하라.**\n\n첫 설계에서는 Board와 Piece가 이미 결합되어 있다.\n이때 Piece와 Direction이 협력하게 하면 설계 전체적으로 결합도를 추가하지 않고도 협력을 완성할 수 있다.\nBoard와 Direction이 협력할 경우에는 새로운 결합도가 추가된다.\n\nLow Coupling 패턴의 관점에서는 새로운 결합도를 추가하지 않는 방향으로 설계하는 것이 좋다.\n\n#### High Cohesion (높은 응집도)\n\n**복잡성을 관리할 수 있는 수준으로 유지하기 위해 높은 응집도를 유지하는 방향으로 책임을 할당하라.**\n\nBoard의 중요한 책임은 말을 움직이는 것이다. 이때, Direction과 협력하게 되면 거리 계산과 관련된 책임을 갖게 될 수 밖에 없다.\n그렇다면 이후 말을 움직이는 방식이 변경되는 경우, Board도 같이 변경되어야 한다. 이런 경우 응집도가 낮아질 수 밖에 없다.\n\n그러나 Piece의 주된 책임은 해당 칸으로 이동할 수 있는지에 대한 것이다.\n따라서 필요한 조건을 확인하기 위해 Direction과 협력하는 것은 응집도에 해를 끼치지 않는다.\n\nHigh Cohesion 패턴 관점에서는 객체들이 서로 관련되도록 설계하는 것이 좋다.\n\n### Creator Pattern (창조자 패턴)\n\n**협력에 참여하는 어떤 객체에게는 인스턴스를 생성할 책임이 있다.\n다음 조건을 최대한 만족하는 객체에게는 객체 생성 책임을 할당하라.**\n\n- B가 A 객체를 포함하거나 참조한다.\n- B가 A 객체를 기록한다.\n- B가 A 객체를 긴밀하게 사용한다.\n- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (B가 A에 대한 정보 전문가이다.)\n\n### Polymorphism (다형성)\n\n**타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.**\n\nBoard 입장에서 생각했을 때, 말을 움직일 때 말이 어떤 말인지는 상관 없다. 어떤 말이든지 움직일 수 있어야 한다.\n즉, Board가 구체적인 클래스는 알지 못하고 '말'이라는 역할에 대해서만 결합되도록 의존성을 제한할 수 있다.\n\n```mermaid\nclassDiagram\n\tPiece <|-- Knight\n\tPiece <|-- Queen\n\tPiece <|-- King\n```\n\nPiece라는 클래스를 추상화하고, 해당 클래스를 상속하는 Knight, Queen, ... 등의 말을 추가한다.\nBoard는 각 말들 (Queen, Knight...) 의 구현이 바뀌거나 추가되어도 Piece의 추상화된 메서드로만 기능을 수행하기 때문에, 구체적인 타입을 몰라도 괜찮다.\n\n객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당한다. 이를 Polymorphism 패턴이라고 한다.\n\n구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스를 사용한다.\n역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요가 있다면 추상 클래스를 사용하면 된다.\n\n### Protected Variations (변화에 대한 보호)\n\n객체를 변경으로부터 분리하고, 추상화 타입을 통해 캡슐화한다.\n**변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.**\n\n갑자기 체스의 룰이 크게 바뀌어서 Vero Piece가 추가된다고 하자.\n그렇지만 추상화된 Piece를 사용하면, Board 입장에서 Piece가 추가된다고 해서 Board에게는 영향을 주지 않는다. 오직 VeroPiece라는 클래스를 추가하는 것으로 말을 추가할 수 있다.\n\n이처럼 변경을 캡슐화하도록 책임을 할당하는 것은 Protected Variations 패턴이라고 한다.\n\n추상화 타입을 사용하므로 변경에 더 유연하게 대응할 수 있지만, 코드의 복잡성이 올라간다는 단점이 있다.\n\n### Pure Fabrication (순수 조립)\n\nInformation Expert 패턴을 적용하면 Low Coupling과 High Cohesion의 원칙이 깨어진다면, 기능적인 역할을 별도로 한 곳으로 모으자.\n\n도메인의 개념을 나타내지 않고 낮은 결합도, 높은 응집도, 높은 재사용 가능성을 달성하기 위해 만들어진 클래스를 의미한다. 도메인 중심 설계에서는 'service' 라고 부른다. \n도메인과 직접 관련이 없는 기능이나, 기능을 구현하기 위해 별도의 클래스나 객체를 만드는 것이다.\n**공통적인 기능을 제공하는 역할을 한 곳으로 모아서 가상의 객체, 서브시스템을 만들어라.**\n\nBoard를 생성하는 로직은 보통 하드코딩이 필요하다. \n이런 생성로직을 분리해 놓은 BoardFactory가 존재한다고 생각해보자.\n\nFactory는 도메인 모델에 속하지 않으며, 순수하게 기술적으로 추가된 것이다.\n전체적으로 결합도와 재사용성을 높이기 위해 객체 생성 책임을 가공의 객체로 이동시킨 것이다.\n\n책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 Pure Fabrication이라고 한다.\n\n클래스와 객체가 급증하여 코드가 더 복잡하고 이해하기 어려워질 수 있다는 단점이 있다. 또한 공통 함수와 기능을 수정해야 하는 경우, 여러 클래스와 객체를 변경해야 하므로 시간이 많이 걸리고 오류가 발생할 수 있다.\n또한 Information Expert 원칙을 위배할 수 있다. 특정 정보나 동작에 대한 책임은 해당 정보나 동작에 대한 정보를 가장 많이 보유한 객체에 할당되어야 한다. 그러나 Pure Fabrication 객체가 생성되면 해당 정보 또는 동작에 대한 가장 많은 정보를 가진 객체로부터 책임을 빼앗는 격이 되므로 Information Expert 원칙을 위반할 수 있다.\n\n어떤 객체가 책임을 수행하는 데 필요한 많은 정보를 가졌지만, 해당 책임을 할당한 경우 응집도가 낮아지고 결합도가 높아지는 건 다른 가공의 객체를 추가해서 책임을 옮기는 것을 고민해보자.\n\n### Controller Pattern (컨트롤러 패턴)\n\n**시스템 이벤트를 처리할 객체를 만들어라.**\n\n직접적으로 각 객체에 접근하게 되면, 서브 시스템과 외부간의 Coupling이 증가된다.\n서브시스템의 어떤 객체를 수정할 경우, 외부에 주는 충격이 커진다.\n서브시스템을 사용하는 입장에서 보면, Controller 객체만 알고 있으면 되므로 사용하기 쉽다.\n\nController는 요청을 받고 적절한 행위를 하는 객체에게 지시하는 행위 관점의 패턴이다.\n내부적으로 별도의 비즈니스 로직을 가져서는 안 되고, 요청을 전달하고 위임하는 것에 중점을 두어야 한다.\n\nController 패턴을 사용하면 View와 Model이 서로 영향 없이 쉽게 변경할 수 있게 된다.\nView와 Model이 서로를 직접적으로 알고 있게 되면 각 클래스가 변경이 일어날 때마다 다른 클래스에 변경이 일어나게 된다.\n\nMVC의 컨트롤러는 메서드가 사용자 입력에 응답하는 시스템 이벤트를 나타내는 경향이 있으므로, 일종의 GRASP 컨트롤러라고 할 수 있다.\n\n### Indirection (간접 참조)\n\n**두 객체 사이의 직접적인 `Coupling`을 피하고 싶으면, 그 사이에 다른 객체를 사용하라.**\n\n다른 구성 요소 간에 중재할 책임을 중간 객체에 할당하여 직접 연결이 되지 않도록 한다.\n\nModel 과 View를 중재하기 위해 Controller component를 추가한 것은 간접 참조의 한 예시이다.\nController 객체는 시스템 이벤트를 수신하거나 처리하는 역할을 담당하고, 수행해야 하는 작업을 다른 객체에 위임하고 활동을 조정하거나 제어한다. \nController를 사용하여 View와 Model가 간접 참조를 하게 되면 의존도를 낮추고 변화의 영향을 줄일 수 있다.\n\n중재자 패턴을 사용하여 두 객체 사이에 또 하나의 객체를 추가하여 복잡한 관계를 단순화할 수 있다.\n중간에 인터페이스를 두면 Protected Variation 패턴에 해당한다.\n\n느슨한 연결이 되지만, 시스템의 가독성과 분별력을 떨어뜨린다는 단점이 있다.\n\n## 참고 자료\n\n- [오브젝트](http://www.yes24.com/Product/Goods/74219491?pid=123487&cosemkid=go15597183843649229&gclid=CjwKCAjw0N6hBhAUEiwAXab-TZjHYK2AP78T13MA3x-XoWv8GF71zhDrEzXV3MvFT6ZWEGgDC83C0xoCnPIQAvD_BwE) 5장"},{"excerpt":"LOG 웹 자동차 경주 미션 PR을 보냈다. 조금만 리팩토링하려고 했는데 너무 커져버렸다... DB 설계도 바뀌고 코드도 많이 바뀐 거 같다. 이번에도 리뷰어는 다니인데 어떤 리뷰를 받게 될 지 궁금하다. 키아라의 생일파티에 참여했다. 원래 토리랑 채채랑 같이 간맥할 생각이었는데 초대를 받게 돼서 (사실 초대해달라고 했음) 6시에 범맥주에 갔다. 역시 재…","fields":{"slug":"/2023-04-13/"},"frontmatter":{"date":"2023년 04월 13일 05:04","title":"2023년 04월 13일","tags":null},"rawMarkdownBody":"## LOG\n- 웹 자동차 경주 미션 PR을 보냈다. 조금만 리팩토링하려고 했는데 너무 커져버렸다... DB 설계도 바뀌고 코드도 많이 바뀐 거 같다. 이번에도 리뷰어는 다니인데 어떤 리뷰를 받게 될 지 궁금하다.\n- 키아라의 생일파티에 참여했다. 원래 토리랑 채채랑 같이 간맥할 생각이었는데 초대를 받게 돼서 (사실 초대해달라고 했음) 6시에 범맥주에 갔다. 역시 재밌었고 나름대로(?) 절제하면서 마신 것 같다. 키아라 생일 축하했어~~\n\n## 배운 것\n- **`assertAll()`로 해당 함수들을 묶을 시 중간에 `assert함수`가 실행이 되지 않더라도 assert의 모든 함수를 실행할 수 있다.**\n- `@Repository`에 final을 쓰면 안 된다. 스프링 내부적으로 Respository를 생성할 때 프록시 객체를 생성하기 때문에 Repository는 final이나 invisible한 클래스면 안 된다.\n- `SqlParameterSourceUtils.createBatch()` 로 NamedParameter를 한 번에 매핑해줄 수 있다.\n- `@SpringBootTest` 의 webEnvironment 옵션을 넣은 테스트 클래스와 넣지 않은 테스트 클래스를 동시에 실행할 때만 데이터베이스가 중복 생성되는 이유: webEnvironment 옵션을 사용하지 않은 테스트 클래스는 자바 애플리케이션의 일반적인 테스트를 수행하는 것이다. 이 경우에는 스프링 애플리케이션 컨텍스트가 단 하나만 생성되어 모든 테스트에서 공유된다. 그러나 webEnvironment 옵션을 사용한 테스트 클래스는 스프링 부트 애플리케이션을 실행하는 것으로, 이 경우 각각의 테스트에서 새로운 스프링 애플리케이션 컨텍스트가 생성된다.\n- `@SpringBootTest` 와 `@SpringBootTest(webEnvironment = WebEnvironment.NONE)` 가 달려있는 두 개의 테스트 클래스를 동시에 수행하면 데이터베이스가 중복 생성되는 이유: `@SpringBootTest(webEnvironment = WebEnvironment.NONE)` 는 스프링 애플리케이션을 실행하지 않고, 내장 서버를 사용하지 않도록 설정한다. 따라서 스프링 애플리케이션 컨텍스트는 생성되지만, 웹 환경에서 실행되지 않는다. 반면, `@SpringBootTest` 는 스프링 부트 애플리케이션을 실행하고 내장 서버를 사용한다. 이 경우에는 웹 환경에서 애플리케이션을 실행하므로, 스프링 애플리케이션 컨텍스트와 함께 웹 환경에서 데이터베이스가 생성된다. 따라서 스프링 부트 애플리케이션 컨텍스트가 생성되면서 DB가 중복 생성되게 된다. (아마도 내장 DB는 단 하나 존재하는 모양이다.)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 술을 안 마시려고 했는데 역시 즐거운 자리를 참기 힘들다. 그래도 일주일에 1회만 술을 마실 생각이다. 술 마시고 잠만 어느 정도 잘 수 있다면 그 다음 날 컨디션이 안 좋은 건 아니라서 괜찮을 것 같다.\n- chat-GPT 생각보다 진짜 좋다. 배운 것 중에 Repository에 final을 쓰면 안 되는 이유나, SpringBootTest에 대한 내용도 chat-GPT 한테 물어본 내용이다. 질문을 어떻게 해야 할 지 모를 때, 어떻게 설명해야 할 지 모를 때 그냥 아무렇게나 써도 잘 이해해준다는게 되게 좋은 것 같다. 문제는 얘가 이상한 말을 할 때 내가 알 수 없다는 거? 확실한 지식을 쌓을 수 있을지는 잘 모르겠다. 가끔 얘가 거짓말을 해서 믿어야 될 지 말아야 할 지... 키워드를 얻는 용도로는 확실히 좋은 거 같다."},{"excerpt":"LOG 깃짱이랑 자동차 API 미션을 완료했다!! 미션 완료는 항상 뿌듯하다. 깃짱은 스프링을 처음 해봤다고 했는데 이번 미션동안 잘 이해한 것 같아서 대단하다. 컨디션이 안 좋았다. 아침에 일어날 때부터 목감기 걸린 것처럼 목이 아팠는데 낮에는 열이 났다. 주노가 타이레놀 주니까 좀 나았다. THANK YOU, JUNO... 그렇게 여기 있을 때까지는 …","fields":{"slug":"/2023-04-12/"},"frontmatter":{"date":"2023년 04월 13일 00:04","title":"2023년 04월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 깃짱이랑 자동차 API 미션을 완료했다!! 미션 완료는 항상 뿌듯하다. 깃짱은 스프링을 처음 해봤다고 했는데 이번 미션동안 잘 이해한 것 같아서 대단하다.\n- 컨디션이 안 좋았다. 아침에 일어날 때부터 목감기 걸린 것처럼 목이 아팠는데 낮에는 열이 났다. 주노가 타이레놀 주니까 좀 나았다. ***THANK YOU, JUNO***... 그렇게 여기 있을 때까지는 좀 나았는데 집에 가니까 귀신같이 다시 열이 나서 약을 먹고 잤다. 열은 떨어진 것 같아 다행이다. 어제보다는 몸 상태가 나아졌다.\n\n## 배운 것\n- `JdbcTemplate` 의 `batchupdate`\n\n```java\npublic void insertPlayer(List<RacingCarStatusResponse> responses) {\n    List<Object[]> players = responses.stream()  \n            .map(response -> new Object[]{  \n                    response.getName(), response.getPosition()  \n            }).collect(Collectors.toList());  \n    String sql = \"INSERT INTO player (name, position) VALUES (?, ?)\";  \n    jdbcTemplate.batchUpdate(sql, players);  \n}\n```\n\n`List<Object[]>` 로 객체 리스트를 만든 후, `batchUpdate` 를 실행하면 된다.\n\n- `GeneratedKeyHolder`\n\n```java\n    KeyHolder generatedKeyHolder = new GeneratedKeyHolder();  \n    String sql = \"INSERT INTO player(name, position) VALUES(:name, :position)\";  \n  \n    for (RacingCarStatusResponse response : responses) {  \n        SqlParameterSource parameterSource = new BeanPropertySqlParameterSource(response);\n        jdbcTemplate.update(sql, parameterSource, generatedKeyHolder);  \n  \n        if (winnerNames.contains(response.getName())) {  \n            int playerId = generatedKeyHolder.getKey().intValue();  \n            winnerInsertDao.insertWinner(gameId, playerId);  \n        }  \n    }\n```\n\nupdate할 때 `GeneratedKeyHolder` 를 같이 넣으면 auto-increment 된 id를 가져올 수 있다.\n\n## 궁금한 것\n- 현업에서는 GET을 거의 쓰지 않고 POST만 쓰는 경우가 많다고 하는데(by 포이) 왜일까? GET의 장점은 없을까?\n\t- GET이 되면 정보가 다 노출이 되니까 POST는 정보가 노출되지 않으니까 그런 거 아닐까 by 우가\n\t- 근데 body 암호화 하지 않으면 GET이랑 큰 차이 없다. URL에 노출되지 않을 뿐. 암호화해서 보내는 것이 좋다.\n\n## 어려웠던 것\n- 컨디션 관리해야겠다.\n\n## 느낀 것\n- 목소리를 작게 하자...ㅋㅋㅋㅋ 목소리 작게... 어제 오늘 계속 혼나니까 앞으로는 좀 더 조용한 사람으로 살아봐야겠다...\n- 집에 가면 역시나 공부를 안 한다. 그냥 잠실에 오래 남아있는 걸 목표로 해야겠다. 어제 날이 너무 춥고 컨디션도 안 좋아서 빨리 갔는데 집에서 아무것도 안 했다."},{"excerpt":"내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요! 👍 JDBCTemplate Querying Dao 하나의 객체를 query할 때 사용한다. 첫 번째 인자: sql, 두 번째 인자: 리턴 타입 하나의 객체를 query할 때 with placeholder (가 placeholder임) 첫 번째 인자: sql, 두 번째 인자: 리턴 타…","fields":{"slug":"/spring-jdbc/"},"frontmatter":{"date":"2023년 04월 11일 10:04","title":"Spring JDBC","tags":["레벨2","우테코","개발","spring"]},"rawMarkdownBody":"\n**내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요!** 👍\n\n## JDBCTemplate\n\n### Querying Dao\n\n- 하나의 객체를 query할 때 사용한다.\n\t- 첫 번째 인자: sql, 두 번째 인자: 리턴 타입\n\n```java\nint rowCount = this.jdbcTemplate.queryForObject(\"select count(*) from t_actor\", Integer.class);\n```\n\n- 하나의 객체를 query할 때 with placeholder (`?`가 placeholder임)\n\t- 첫 번째 인자: sql, 두 번째 인자: 리턴 타입, 세 번째 인자: ?에 들어갈 값\n\n```java\nint countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(\n        \"select count(*) from t_actor where first_name = ?\", Integer.class, \"Joe\");\n```\n\n- query 결과가 필드 여러 개일 때\n\t- sql, mapper, ?에 들어갈 값\n\n```java\nActor actor = jdbcTemplate.queryForObject(\n        \"select first_name, last_name from t_actor where id = ?\",\n        (resultSet, rowNum) -> {\n            Actor newActor = new Actor();\n            newActor.setFirstName(resultSet.getString(\"first_name\"));\n            newActor.setLastName(resultSet.getString(\"last_name\"));\n            return newActor;\n        },\n        1212L);\n```\n\n- query 결과 행이 여러 개일 때\n\t- sql, mapper, (?에 들어갈 값)\n\n```java\nList<Actor> actors = this.jdbcTemplate.query(\n        \"select first_name, last_name from t_actor\",\n        (resultSet, rowNum) -> {\n            Actor actor = new Actor();\n            actor.setFirstName(resultSet.getString(\"first_name\"));\n            actor.setLastName(resultSet.getString(\"last_name\"));\n            return actor;\n        });\n```\n\n- RowMapper를 분리해서 사용할 때\n\t- sql, mapper, (?에 들어갈 값)\n\n```java\nprivate final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {\n    Actor actor = new Actor();\n    actor.setFirstName(resultSet.getString(\"first_name\"));\n    actor.setLastName(resultSet.getString(\"last_name\"));\n    return actor;\n};\n\npublic List<Actor> findAllActors() {\n    return this.jdbcTemplate.query(\"select first_name, last_name from t_actor\", actorRowMapper);\n}\n```\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate-examples-query)\n\n### Updating Dao\n\n- insert, update, delete query를 하나의 메서드로 사용 가능\n\t- sql, ? 값 가변인자\n\n```java\nthis.jdbcTemplate.update(\n        \"insert into t_actor (first_name, last_name) values (?, ?)\",\n        \"Leonor\", \"Watling\");\n```\n\n```java\nthis.jdbcTemplate.update(\n        \"update t_actor set last_name = ? where id = ?\",\n        \"Banjo\", 5276L);\n```\n\n```java\nthis.jdbcTemplate.update(\n        \"delete from t_actor where id = ?\",\n        Long.valueOf(actorId));\n```\n\n- 참고 자료: [공식 문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-JdbcTemplate-examples-update)\n\n### Named Parameter\n\nNamedParameterJdbcTemplate 클래스는 `?` 인수만 사용하여 JDBC 문을 프로그래밍하는 것과 달리 이름이 있는 매개변수를 사용하여 JDBC 문을 프로그래밍할 수 있게 한다.\n\n`MapSqlParameterSource` 를 사용하면 다음과 같이 쓸 수 있다.\n\n```java\n// some JDBC-backed DAO class...\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\n    String sql = \"select count(*) from T_ACTOR where first_name = :first_name\";\n\n    SqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\n\n    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n만약 SQL에 값을 여러 개 넣어야 하는 경우는 `addValue()` 로 값을 추가해줄 수 있다.\n\n```java\nString sql = \"SELECT :a + :b\";\n\nSqlParameterSource param = new MapSqlParameterSource()\n\t\t\t\t\t\t\t\t.addValue(\"a\", 100)\n\t\t\t\t\t\t\t\t.addValue(\"b\", 200);\n```\n\nMap을 사용하여 `String` 형의 매개변수 이름과 값을 `NamedParameterJdbcTemplate` 에 전달할 수 있다.\n\nMap을 사용하는 방법의 예제이다.\n\n```java\n// some JDBC-backed DAO class...\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActorsByFirstName(String firstName) {\n\n    String sql = \"select count(*) from T_ACTOR where first_name = :first_name\";\n\n    Map<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName);\n\n    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);\n}\n```\n\n** `Collections.singletonMap` 은 단 하나의 키를 갖는 맵을 나타낼 때 사용한다.\n\n### `BeanPropertySqlParameterSource` 클래스\n\n아래와 같은 Actor 클래스가 있다고 가정하자.\ngetter는 필수적으로 필요하고, Actor의 필드 이름들은 자동으로 카멜 케이스에서 스네이크 케이스로 변환된다.\n\n```java\npublic class Actor {\n\n    private Long id;\n    private String firstName;\n    private String lastName;\n\n    public String getFirstName() {\n        return this.firstName;\n    }\n\n    public String getLastName() {\n        return this.lastName;\n    }\n\n    public Long getId() {\n        return this.id;\n    }\n\n    // setters omitted...\n\n}\n```\n\n`:` 의 뒤에는 Actor 클래스의 필드 이름을 넣는다. (카멜 케이스 그대로)\n`BeanPropertySqlParameterSource` 의 인자로 필드 이름과 같은 값을 갖는 객체를 넣어주면 자동으로 JdbcTemplate이 인식하여 쿼리가 수행된다.\n\n```java\n// some JDBC-backed DAO class...\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\npublic void setDataSource(DataSource dataSource) {\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n}\n\npublic int countOfActors(Actor exampleActor) {\n\n    // notice how the named parameters match the properties of the above 'Actor' class\n    String sql = \"select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName\";\n\n    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);\n\n    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n}\n```\n\n`NamedParameterJdbcTemplate` 은 JdbcTemplate을 래핑한 클래스이다.\n래핑된 JdbcTemplate 에 접근하기 위해서는 `getJdbcOperations()` 를 사용하여 JdbcTemplate 에 접근할 수 있다.\n\n-  참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-NamedParameterJdbcTemplate)\n\n## SimpleJdbcInsert\n\nData access layer의 초기화 메서드에서 `SimpleJdbcInsert` 클래스를 인스턴스화 해야 한다.\n`setDataSource()` 메서드에서 dataSource를 초기화하고, 테이블 이름을 설정할 수 있다.\n\n`SimpleJdbcInsert` 의 `execute()` 를 실행하기 위해서는 Map 객체를 만들어서 인자로 넘겨준다.\nMap의 key는 테이블의 column 이름과 정확하게 일치해야 한다.\n\n```java\npublic class JdbcActorDao implements ActorDao {\n\n    private SimpleJdbcInsert insertActor;\n\n    public void setDataSource(DataSource dataSource) {\n        this.insertActor = new SimpleJdbcInsert(dataSource).withTableName(\"t_actor\");\n    }\n\n    public void add(Actor actor) {\n        Map<String, Object> parameters = new HashMap<>(3);\n        parameters.put(\"id\", actor.getId());\n        parameters.put(\"first_name\", actor.getFirstName());\n        parameters.put(\"last_name\", actor.getLastName());\n        insertActor.execute(parameters);\n    }\n\n    // ... additional methods\n}\n```\n\n### Auto-generated key 를 얻는 방법\n\nauto-increment 되는 id가 있는 경우, 다음과 같은 방법을 사용해야 한다.\n\n`SimpleJdbcInsert` 선언 시 `usingGeneratedKeyColumns(\"auto-increment 되는 컬럼 이름\")` 을 설정해준다.\n\n```java\npublic class JdbcActorDao implements ActorDao {\n\n    private SimpleJdbcInsert insertActor;\n\n    public void setDataSource(DataSource dataSource) {\n        this.insertActor = new SimpleJdbcInsert(dataSource)\n                .withTableName(\"t_actor\")\n                .usingGeneratedKeyColumns(\"id\");\n    }\n\n    public void add(Actor actor) {\n        Map<String, Object> parameters = new HashMap<>(2);\n        parameters.put(\"first_name\", actor.getFirstName());\n        parameters.put(\"last_name\", actor.getLastName());\n        Number newId = insertActor.executeAndReturnKey(parameters);\n        actor.setId(newId.longValue());\n    }\n\n    // ... additional methods\n}\n```\n\n`executeAndReturnKey` 메서드로 auto-increment 된 ID의 값을 가져올 수 있다.\n\n### insert에 필요한 column 제한하기\n\n`usingColumns` 메서드를 사용하면 column 이름 목록을 지정해서 insert할 column을 제한할 수 있다.\n\n```java\npublic class JdbcActorDao implements ActorDao {\n\n    private SimpleJdbcInsert insertActor;\n\n    public void setDataSource(DataSource dataSource) {\n        this.insertActor = new SimpleJdbcInsert(dataSource)\n                .withTableName(\"t_actor\")\n                .usingColumns(\"first_name\", \"last_name\")\n                .usingGeneratedKeyColumns(\"id\");\n    }\n\n    public void add(Actor actor) {\n        Map<String, Object> parameters = new HashMap<>(2);\n        parameters.put(\"first_name\", actor.getFirstName());\n        parameters.put(\"last_name\", actor.getLastName());\n        Number newId = insertActor.executeAndReturnKey(parameters);\n        actor.setId(newId.longValue());\n    }\n\n    // ... additional methods\n}\n```\n\n실제로 코드에서는 이렇게 사용했다.\n\n```sql\n// 데이터 구조\nCREATE TABLE GAME  \n(  \n    id          BIGINT   NOT NULL AUTO_INCREMENT,  \n    trial_count INT      NOT NULL,  \n    time        DATETIME NOT NULL default current_timestamp,  \n    PRIMARY KEY (id)  \n);  \n  \nCREATE TABLE PLAYER  \n(  \n    id        BIGINT      NOT NULL AUTO_INCREMENT,  \n    game_id   BIGINT      NOT NULL,  \n    name      VARCHAR(10) NOT NULL,  \n    position  INT         NOT NULL,  \n    is_winner BOOL     NOT NULL,  \n    PRIMARY KEY (id),  \n    FOREIGN KEY (game_id) references GAME (id) on update cascade  \n);\n```\n\n내가 웹자동차 미션에서 사용했던 코드는 다음과 같다. \n\n```java\n@Repository  \npublic class GameRepository {  \n  \n    private final SimpleJdbcInsert insertGame;  \n  \n    public GameRepository(final DataSource dataSource) {  \n        this.insertGame = new SimpleJdbcInsert(dataSource)  \n                .withTableName(\"game\")  \n                .usingColumns(\"trial_count\")  \n                .usingGeneratedKeyColumns(\"id\");  \n    }  \n  \n    public long save(final int trialCount) {  \n        HashMap<String, Object> parameters = new HashMap<>();  \n        parameters.put(\"trial_count\", trialCount);  \n        return insertGame.executeAndReturnKey(parameters).longValue();  \n    }  \n}\n```\n\ntime이 default 값을 가지고 있기 때문에 사용하는 column을 넣어주지 않으면 null이 들어가게 된다.\ntime은 not null 이므로, `usingColumns` 를 사용하지 않으면 예외가 발생한다.\ndefault 값을 갖는 column의 경우에는 `usingColumns` 를 사용하면 필요한 column만 지정할 수 있어 좋다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-simple-jdbc-insert-1)"},{"excerpt":"내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요 👍 Mapping Request Mapping Request Mapping은 Controller의 메서드에 Request를 매핑하기 위해 사용한다.\nclass level에서 사용하면 shared mapping을 표현할 수 있다. method level에서 사용하면 특정 endpoint…","fields":{"slug":"/spring-mvc/"},"frontmatter":{"date":"2023년 04월 11일 10:04","title":"Spring MVC","tags":["레벨2","우테코","개발","spring"]},"rawMarkdownBody":"\n**내용을 주관적으로 덜어냈습니다. 자세한 내용은 참고 링크를 확인해주세요 👍**\n\n## Mapping\n\n### Request Mapping\n\nRequest Mapping은 Controller의 메서드에 Request를 매핑하기 위해 사용한다.\nclass level에서 사용하면 shared mapping을 표현할 수 있다. method level에서 사용하면 특정 endpoint mapping 으로 좁혀서 표현할 수 있다.\n\nHTTP 메서드 별로 `@RequestMapping` 의 변형은 다음과 같다.\n\n-   `@GetMapping`\n-   `@PostMapping`\n-   `@PutMapping`\n-   `@DeleteMapping`\n-   `@PatchMapping`\n\n```java\n@RestController\n@RequestMappping(\"/customers\")\nclass CustomerController {\n\n\t@GetMapping(\"/{id}\")\n\tpublic Customer getCustomer(@PathVariable Long id) {\n\t\t// ...\n\t}\n}\n```\n\n`@RequestMapping` 어노테이션을 Controller 상단에 적어주면, Controller 내부의 모든 메서드가 같은 URL을 공유하게 된다.\n\n`@GetMapping` 같은 specific annotation은 메서드 상단에 적는다. \n해당 메서드가 어떤 URL에서 불려야할 지를 범위를 좁혀 특정지을 수 있다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping)\n\n### URI Patterns\n\n`@RequestMapping` 은 URL 패턴을 이용해서 mapping 될 수 있다.\n\n- `PathPattern` : URL 경로와 매칭되는 사전 구문 분석된 패턴을 `PathContainer` 로 사전 구문 분석한다. \n\t- `AntPathMatcher` 와 달리 `**` 가 패턴 끝에서만 지원된다. `/pages/{**}` 는 가능하지만, `/pages/{**}/details` 는 안 된다.\n\t- 참고: [공식문서](https://docs.spring.io/spring-framework/docs/6.0.7/javadoc-api/org/springframework/web/util/pattern/PathPattern.html)\n- `AntPathMatcher` : 문자열 패턴을 문자열 경로와 일치시킨다. 덜 효율적이고, 문자열 경로 입력은 URL과 관련된 인코딩, 기타 문제를 효과적으로 처리하는데 어려움이 있다.\n\t- 참고: [공식문서](https://docs.spring.io/spring-framework/docs/6.0.7/javadoc-api/org/springframework/util/AntPathMatcher.html)\n\n`PathPattern` 을 사용하는 것을 권장한다.\n\n### Media Types - produces\n\nRequest Header와 Controller Method가 생성하는 콘텐츠 유형 목록을 기반으로 Request Mapping의 범위를 좁힐 수 있다.\n\n```java\n@GetMapping(path = \"/pages/{id}\", produces = \"application/json\")\n```\n\n위 예제에서 `/pages/{id}` 로 들어오는 요청 중 \"application/json\" 속성을 갖는 요청만 해당 메서드로 mapping 된다.\n\n`!text/plain` 같은 부정 표현도 지원된다.\n\nclass level에서 `produces` 을 사용하면 class level에서 `produces` 가 공유된다.\n그러나 method level에서 `produces` 를 사용하면 class level에서 설정이 확장되는 것이 아니라 method level의 `produces` 로 설정이 덮어 씌워진다.\n\n> `MediaType` 중에 빈번하게 사용되는 media type을 상수로 제공한다.\n> Ex. `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE` \n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-produces)\n\n### Media Types - consumes\n\nRequest Header와 Controller Method가 생성하는 콘텐츠 유형 목록을 기반으로 Request Mapping의 범위를 좁힐 수 있다.\n\n```java\n@PostMapping(path = \"/page\", consumes = \"application/json\")\n```\n\n위 예제에서 `/pages/{id}` 로 들어오는 요청 중 \"application/json\" 속성을 갖는 요청만 해당 메서드로 mapping 된다.\n\n`!text/plain` 같은 부정 표현도 지원된다.\n\nclass level에서 `consumes` 을 사용하면 class level에서 `consumes` 가 공유된다.\n그러나 method level에서 `consumes` 를 사용하면 class level에서 설정이 확장되는 것이 아니라 method level의 `consumes` 로 설정이 덮어 씌워진다.\n\n> `MediaType` 중에 빈번하게 사용되는 media type을 상수로 제공한다.\n> Ex. `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE` \n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-consumes)\n\n### Parameters, headers\n\nRequest Parameter 조건에 따라 Request Mapping의 범위를 좁힐 수 있다.\nRequest Parameter가 존재하는지, 아닌지, 특정 값을 갖는지 테스트할 수 있다.\n\n```java\n@GetMapping(path = \"/pages/{pageId}\", params = \"myParam=myValue\")\n```\n\n`myValue` 값을 갖는 `myParam` 인 경우에만 해당 메서드가 실행된다.\n\nContent-Type, Accept를 체크할 수도 있지만, consumes나 produces를 사용하는 것이 더 낫다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-params-and-headers)\n\n## Handler\n\n### Method Arguments\n\n종류가 너무 많으므로, 학습 테스트에서 다룬 `@RequestBody` , `@RequestParam` 만 살펴보겠다.\n\n#### `@RequestParam`\n`@RequestParam` 은 Multipart file을 포함해서 Request Parameter에 접근할 수 있게 한다. Parameter 값은 선언된 메서드 매개변수로 바인딩 된다.\n\n기본적으로는 `@RequestParam` 을 사용하는 메서드의 매개변수가 필수이지만, `required` 를 `false` 로 선언하면 메서드 매개변수가 선택 사항이라는 것을 지정할 수 있다.\n\n```java\n@GetMapping\npublic String setupForm(@RequestParam(\"petId\") int petId, Model model) {\n\t// ...\n}\n```\n\nParameter 타입이 String이 아닌 경우에는 타입 변환이 자동으로 일어난다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestparam)\n\n#### `@RequestBody` \n\n```java\n@PostMapping(\"/accounts\") \npublic void handle(@RequestBody Account account) { // ... }\n```\n\n`@Valid` annotation과 같이 조합되어 사용될 수 있다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestbody)\n\n### Return Values\n\n### `@ResponseBody`\n\n자바 객체를 HTTP Request body로 전송할 수 있다.\nclass level을 지원한다. class level에서 사용하면 모든 controller method에서 사용할 수 있다.\n\n```java\n@GetMapping(\"/account/{id}\")\n@ResponseBody\npublic Actor handle() {\n\t// ...\n}\n```\n\n`@ResponseBody` 어노테이션이 적용된 메서드는 `HttpMessageConverter` 를 사용해서 변환을 처리한다.\n\n- 참고 자료: [공식문서](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types)\n\n### `ResponseEntity<B>`\n\n`@ResponseBody` 와 비슷하지만 HttpStatus와 HttpHeaders, HttpBody가 있다.\n\n```java\n@GetMapping(\"/something\")\npublic ResponseEntity<String> handle() {\n\tString body = ... ;\n\tString etag = ... ;\n\treturn ResponseEntity.ok().eTag(etag).body(body);\n}\n```\n\n`ResponseEntity` 가 제네릭 타입\n\n## Exception\n\n`@ExceptionHandler` 로 Controller 메서드의 예외를 처리하는 메서드를 가질 수 있다.\n\n```java\n@ExceptionHandler \npublic ResponseEntity<String> handle(IOException ex) { // ... }\n```\n\n일치시킬 예외 유형을 좁힐 수도 있다.\n\n```java\n@ExceptionHandler({FileSystemException.class, RemoteException.class}) public ResponseEntity<String> handle(IOException ex) { \n\t// ...\n}\n```\n\n`IOException` 중에 `FileSystemException`, `RemoteExceptoin` 을 처리한다.\n\n주어진 예외 인스턴스를 원래 형식으로 다시 throw 하여 처리하지 않도록 선택할 수도 있다. 특정 context의 일치에만 관심있는 때에 유용하다. \n\n`@ExceptionHandler`는 `@Controller` 클래스에서만 적용된다. \n\n그러나 `@ControllerAdvice`가 적용되면 `@ControllerAdvice` 내부에 있는 모든 ExceptionHandler는 모든 컨트롤러에 적용될 수 있다."},{"excerpt":"LOG 깃짱이랑 페어가 됐다 😎 오늘은 이번 Spring 미션 하기 전에 학습 테스트 두 개를 했다. 내가 느끼기에는 꽤 어려운 내용이었는데, 솔라가 공식문서 보면서 하는 게 좋다고 해서 오늘 내내 열심히 공부했다. 공식문서가 영어로 되어 있기는 했지만 깃짱이랑 같이 보면서 하니까 금방 끝낼 수 있었다. 많이 배운 것 같아서 뿌듯했다. 레벨2 데일리 조는…","fields":{"slug":"/2023-04-11/"},"frontmatter":{"date":"2023년 04월 11일 10:04","title":"2023년 04월 11일","tags":null},"rawMarkdownBody":"## LOG\n\n- 깃짱이랑 페어가 됐다 😎 오늘은 이번 Spring 미션 하기 전에 학습 테스트 두 개를 했다. 내가 느끼기에는 꽤 어려운 내용이었는데, 솔라가 공식문서 보면서 하는 게 좋다고 해서 오늘 내내 열심히 공부했다. 공식문서가 영어로 되어 있기는 했지만 깃짱이랑 같이 보면서 하니까 금방 끝낼 수 있었다. 많이 배운 것 같아서 뿌듯했다.\n- 레벨2 데일리 조는 네오조였다. 하마드, 채채, 우르, 오잉, 홍실과 같이 점심을 먹었다. 먹다보니까 너무 호칭이 정리가 안 돼서 그냥 다 말을 놔버렸다~ 생각해보니 깃짱, 허브와도 말을 놓게 되었는데 오늘은 말 놓는 날인가 싶다 ㅋㅋㅋ\n- 모던 자바 인 액션 람다 부분을 읽고 있다. 아직 덜 읽었지만(ㅋㅋ), 확실히 람다를 사용해보고 이론을 공부하니 더 이해가 잘 됐다. 일단 써보고 공부하는 방법이 틀리지 않았다는 생각을 했다.\n\n## 배운 것\n\n- [[spring-mvc]]\n- [[spring-jdbc]] : 시간이 없어서 못 썼다... 😭 내일은 완성해보자.\n\n## 궁금한 것\n\n- POST는 항상 Consumes을 사용하고, GET이 항상 Produces를 사용할까?\n- header를 읽는 순서가 궁금해졌다. URL을 먼저 확인하고, 그 다음에 조건을 확인하는 건지..?\n\n## 어려웠던 것\n\n- 나도 공식문서를 찾아보는 게 가장 질 좋은 정보라고 생각하지만 역시 언어의 장벽.. 쉽지 않다. 영어 공부를 해야겠다고 느꼈다.\n\n## 느낀 것\n\n- 오랜만에 잠실에 가서 그런가 굉장히 기분이 좋은 날이었다. 보고 싶었던 사람들도 보고, 같이 공부도 해서 하루 종일 업된 상태였다. 기분이 좋은 건 좋은 거니까 좋다~\n- 집에 돌아오니 역시 아무것도 하기 싫은 거 같다. 최대한 잠실에 있는 시간을 늘리려고 한다. 그렇지만 아무리 늦어도 9시... 가 최대다. 오늘 아침은 잠도 그렇게 적게 자지는 않았는데 졸려서 중간에 트랙룸에서 자버렸다 ㅋㅋ.. 컨디션 관리를 제대로 해야겠다.\n- 다들 미션이 쉽다고 했다. 스프링을 한 사람들이 많아서 그런지 빨리 끝난 조가 많았다. 내일은 열심히 해서 미션을 끝내고 집에 가고 싶다.\n"},{"excerpt":"4/11 레벨2를 슬기롭게 소화하기 학습해야하는 내용의 범위가 넓으니, 깊이를 제한한다. 얼마까지 해야 할까? -> 프롤로그 참고하기 다른 웹 서비스를 유심히 살펴보자. 평소 자주 사용하거나 내가 만드는 것과 비슷한 서비스를 뜯어본다. 현재 상태에 따라서 목표를 설정하자. 나는 스프링을 접해본 적이 있지만 얕은 지식을 가지고 있다. 내가 쓰고 있는 기술들…","fields":{"slug":"/level2-week1/"},"frontmatter":{"date":"2023년 04월 11일 01:04","title":"레벨2 1주차","tags":["우테코","레벨2"]},"rawMarkdownBody":"# 4/11\n\n## 레벨2를 슬기롭게 소화하기\n\n- 학습해야하는 내용의 범위가 넓으니, 깊이를 제한한다.\n- 얼마까지 해야 할까? -> 프롤로그 참고하기\n- 다른 웹 서비스를 유심히 살펴보자. 평소 자주 사용하거나 내가 만드는 것과 비슷한 서비스를 뜯어본다.\n- 현재 상태에 따라서 목표를 설정하자. 나는 스프링을 접해본 적이 있지만 얕은 지식을 가지고 있다. 내가 쓰고 있는 기술들을 알고 쓰고 싶다!\n- 꾸준함을 잃지 말자.\n- 레벨2의 나의 목표는 무엇인가? 내가 쓰는 기술들이 무엇인지, 왜 좋은지, 어떤 점에서는 안 좋을 수 있는지 알고 사용하고 싶다. '알고 쓰자!'가 이번 레벨2의 목표다.\n- 왜 스프링을 학습해야할까? 그건 아직 모르겠다... 그냥 자바로 웹 애플리케이션을 만들어보고 싶어서?\n- 처음 하는 사람보다는 이미 알고 있는 사람이 동작 원리에 대해서 학습했으면 좋겠다.\n\n# 4/14\n\n## Spring MVC\n\n### `@RestController` vs `@Controller`\n\n- `@RestController` 는 `@ResponseBody`를 포함하는 것으로, 그냥 객체를 리턴해도 `@ResponseBody` 를 한 것과 동일하다.\n- `@Controller` 에서 String을 리턴하면 view 파일을 찾는다. `@RestController` 는 String을 리턴하면 `@ResponseBody` 로 감싸진 String 이 리턴된다.\n\n### `@ResponseEntity`\n\nstatus와 header를 포함한다. status를 설정해줄 수 있다.\n컨벤션을 통일하는 것이 좋다.\n내 생각: 차라리 모든 응답에 `ResponseEntity`로 감싸는 게 나을 것 같다. (status 설정하고 쓰는 것)\n\n`ResponseEntity` raw type으로 사용하지 말자.\n\n## Spring JDBC\n\nconnection을 열고 닫는 과정이 필요 없다.\n나는 간단하게 쿼리만 작성하면 되어서, 도메인 로직에만 집중할 수 있다.\n\n`JdbcTemplate`, `NamedParameterJdbcTemplate`, `SimpleJdbcInsert` 를 사용하는 기준을 잡으면 좋겠다. DB에 조회에 그치지 말고, 해당 template 들의 차이점을 알고 썼으면 좋겠다.\n\n# 4/18\n\n## 의존성\n\n```mermaid\nflowchart LR\n\tclass1 -- 사용 생성 호출 --> class2\n```\n\n### 객체 내부에서 객체를 생성하고, 사용한다면\n\n협력의 문맥이 고정된다.\n사용하는 객체가 변경되었을 때 변경이 필요하게 된다. \n\n```mermaid\nflowchart LR\n\t클래스 -- 사용 --> 인터페이스\n\t클래스 -- 호출 --> 팩토리\n\t팩토리 -- 생성 --> 구현클래스\n\t인터페이스 -- 구현 --> 구현클래스\n```\n\n```mermaid\nflowchart LR\n\t조립기 -- 생성 --> 구현클래스\n\t조립기 -- 의존성 삽입 --> 클래스\n\t클래스 -- 사용 --> 인터페이스\n\t구현클래스 -- 구현 --> 인터페이스\n```\n다음과 같은 코드가 된다.\n\n```java\npublic RacingCarService(PlayerResultDao playerResultDao) {\n\tthis.playResultDao = playerResultDao;\n}\n```\n\n이런 역할을 Spring이 해준다.\n\nSpring IoC Container는 의존성을 주입하는 방식으로 객체를 생성, 관리한다. 객체 간의 연결 관계, 의존성을 관리해준다.\n\nSpring이 모든 객체를 관리하는 것은 아니다. 개발자가 설정한 특정 객체들만 관리한다.\n\n## 설정의 방식\n\n1. XML\n2. Annotation-based configuration\n3. Java-based configuration\n\n`@Service`, `@Component`, `@Repository` ... 등등\nService, Repository가 아니지만 Bean으로 설정하기 위해 `@Component` 를 사용할 수 있다.\n\n`@Service`, `@Controller`, `@Repository` 는 모두 `@Component` 를 포함한다. \n위의 어노테이션은 해당 클래스를 Spring bean으로 만들라는 뜻이다.\n\n`@ComponentScan` 어노테이션을 통해 등록할 빈을 스캔할 classpath를 지정한다.\n`@SpringBootApplication` 의 내부에 `@ComponentScan` 이라는 어노테이션이 존재해서, 자동으로 bean을 생성할 수 있다.\n\n# 4/21\n\n## 계층화\n\n이번 미션 때 Console 기반의 애플리케이션을 Web에서도 제공하는 프로그램을 작성했다.\nConsole과 Web의 비즈니스 로직과 데이터 로직은 어느정도 중복되는 부분이 있다. \n중복 로직을 `Service` 라는 것으로 분리하게 되면, `RacingCarDao` 가 추상화된다.\n-> 자연스럽게 계층이 나눠지게 된다. 이전부터 사용한 보편적인 구조이다.\n\n```mermaid\nflowchart TD\n\tPresentation --> Domain\n\tDomain --> Data\n```\n\n관심사를 분리(단일 책임 원칙)해서 계층이 나눠지게 된다. 변경이 잘 되지 않는 도메인 로직을 보호하기 위해 계층화를 사용하게 된다. 변경으로부터 보호하기 위해 단방향으로 진행한다. \n\n## Validation\n\n검증해야 할 입력 값이 존재한다. 그렇다면 입력 값의 검증은 어떤 계층에서 확인해야할까?\n사람마다 규칙은 다를 수 있다.\n\n## 스프링을 사용하지 않는 환경을 고려해야 할까?\n\n브리: 프레임워크의 큰 변동이 있는 경우에는 보통 다시 만든다. 그래서 그 부분은 큰 문제가 되지 않는다고 생각한다.\n\n솔라: 현업에서는 같은 기능을 하는데 아예 새로운 프로그래밍 언어로 하도록 변경하거나, 아예 새로운 웹 프레임워크를 쓸 정도의 작업은 ‘리팩토링’ 보다는 ’porting’ 에 해당하는 작업으로 정의합니다. 보통 포팅에서는 기존 코드를 최대한 재활용하는 이점보다 새로운 언어나, 프레임워크를 선택하는 이점이 더 크다고 판단해 선택하는 경우가 많아서, 기존코드의 언어적, 프레임워크적 특징이 담긴 코드를 못 가져가는 것은 당연히 감수해야하는 것으로 생각하긴 했습니다.\n\n=> 나의 결론: 스프링 프레임워크 열심히 활용하자!"},{"excerpt":"LOG 박스터, 여우, 주노와 함께 한강 코딩하러 갔다. 사실 나는 거기 가서 딱히 할 게 없었기 때문에... 얼마 안 남아 있던 class 3 에센셜 문제를 풀었다. 오랜만에 문제 푸는 거라 기분이 희한했다. 배운 것 궁금한 것 어려웠던 것 느낀 것 마음이 싱숭생숭하다. 일단 내일 잠실을 간다는 게 믿기지 않는다. 나는 방학이 끝나기를 기다려온 사람이라…","fields":{"slug":"/2023-04-10/"},"frontmatter":{"date":"2023년 04월 10일 13:04","title":"2023년 04월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 박스터, 여우, 주노와 함께 한강 코딩하러 갔다. 사실 나는 거기 가서 딱히 할 게 없었기 때문에... 얼마 안 남아 있던 class 3 에센셜 문제를 풀었다. 오랜만에 문제 푸는 거라 기분이 희한했다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 마음이 싱숭생숭하다. 일단 내일 잠실을 간다는 게 믿기지 않는다. 나는 방학이 끝나기를 기다려온 사람이라 당연히 가는 건 좋다. 예전에는 내일 새로운 사람들을 만나게 되어서 좋았는데, 지금은 또 그 정도는 아니다. 그냥 내 마음이 이상하다~\n"},{"excerpt":"LOG 미루던 빨래를 했다. 팔에 근육이 생긴 거 같다...ㅋㅋㅋ 집안일은 미루면 계속 늘어난다. 방학 끝나면  또 집안일 하기 싫을 거니까 미리 좀 해두려고 하는 중이다. 배운 것 궁금한 것 어려웠던 것 느낀 것 벌써 방학이 끝나고 화요일에는 다시 잠실에 간다. 진짜 방학 너무 길었다.. 방학 때에 뭐라도 하고 싶은 날이 계속됐는데 같이 할 사람이 없으…","fields":{"slug":"/2023-04-08/"},"frontmatter":{"date":"2023년 04월 08일 10:04","title":"2023년 04월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 미루던 빨래를 했다. 팔에 근육이 생긴 거 같다...ㅋㅋㅋ 집안일은 미루면 계속 늘어난다. 방학 끝나면  또 집안일 하기 싫을 거니까 미리 좀 해두려고 하는 중이다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 벌써 방학이 끝나고 화요일에는 다시 잠실에 간다. 진짜 방학 너무 길었다.. 방학 때에 뭐라도 하고 싶은 날이 계속됐는데 같이 할 사람이 없으니 더 많이 못했다. 좀 아쉽긴 하지만 오히려 그냥 푹 쉬었다고 생각하자~\n"},{"excerpt":"LOG 드디어 RSS를 등록할 수 있게 되었다! graphql query가 문제여서 데이터가 안 가져와졌다는 걸 오늘에서야 깨달았다. 역시 개츠비든 graphql이든 잘 모르니 간단한 블로그 커스텀도 어렵다... RSS 등록하고 싶으신 분들은 (https://cyma-s.github.io/rss.xml) 등록해주시면 됩니다~ 스터디 면접 하는 날인줄 알았…","fields":{"slug":"/2023-04-07/"},"frontmatter":{"date":"2023년 04월 07일 02:04","title":"2023년 04월 07일","tags":null},"rawMarkdownBody":"## LOG\n- 드디어 RSS를 등록할 수 있게 되었다! graphql query가 문제여서 데이터가 안 가져와졌다는 걸 오늘에서야 깨달았다. 역시 개츠비든 graphql이든 잘 모르니 간단한 블로그 커스텀도 어렵다... RSS 등록하고 싶으신 분들은 (https://cyma-s.github.io/rss.xml) 등록해주시면 됩니다~\n- 스터디 면접 하는 날인줄 알았는데 아니었다... 서로의 소통 미스 ㅋㅋㅋ 슬랙을 미리미리 확인하자\n- 포이랑 종각에서 만났다. 중간에 나갈 시간을 생각하면서 놀았어야 했는데 그냥 놀다 보니 결국 집에 못 들어갔다.. 😂 앞으로는 시간 보면서 집에 좀 들어가자 🥺 나중 가서는 너무 졸려서 헛소리했다.\n\n## 배운 것\n- [[stack-unwinding|스택 풀기]]\n- [[simultaneously-throw-exception|예외가 여러 개 발생한다면?]]\n\n## 궁금한 것\n\n## 어려웠던 것\n- 새로운 루틴에 적응하기. 내가 세웠던 계획 지키기\n- 요즘 잠을 많이 못 자는데, 잠을 더 잘 수가 없다는 게 문제다. 한 3주째인 거 같은데 아침마다 심장이 두근거린다. 기분 나쁜 두근거림이라 몸이 긴장 상태가 된다. 근데 술 마시고 일어나니 안 그런다. 뭐가 문제지?\n\n## 느낀 것\n- 앞으로 공부를 열심히 해야겠다. 우테코 끝나고 멋진 사람이 되는 게 목표가 됐다. 궁금한 것은 끝까지 찾아보고 끈질기게 배우자!\n- 내 주위에는 생각보다 상냥한 사람들이 많은 것 같다. 주변에 좋은 사람들이 많아서 좋다.\n"},{"excerpt":"문에서  와 가 동시에 예외를 던지는 경우를 조사하다 stack unwinding을 알게 되었다. 스택 풀기, 스택 되감기 등 여러 가지 이름을 사용한다. Stack Unwinding란? 예외가 발생한 함수에서 예외 처리가 되지 않았을 때 함수 호출 스택을 풀면서 함수가 호출되었던 부분으로 돌아가 예외 처리를 시도하는 것 예외를 catch하지 않은 메서드…","fields":{"slug":"/stack-unwinding/"},"frontmatter":{"date":"2023년 04월 07일 01:04","title":"스택 풀기 (Stack Unwinding)","tags":["Java","개발"]},"rawMarkdownBody":"\n`try-catch` 문에서 `finally` 와 `catch`가 동시에 예외를 던지는 경우를 조사하다 stack unwinding을 알게 되었다.   \n\n스택 풀기, 스택 되감기 등 여러 가지 이름을 사용한다.\n\n## Stack Unwinding란?\n\n- 예외가 발생한 함수에서 예외 처리가 되지 않았을 때 함수 호출 스택을 풀면서 함수가 호출되었던 부분으로 돌아가 예외 처리를 시도하는 것\n- 예외를 catch하지 않은 메서드가 종료되고, 해당 메서드의 모든 로컬 변수들이 scope를 벗어나 원래 해당 메서드를 호출한 문으로 제어가 반환되는 것을 의미한다.\n- 호출한 곳에서 `try` 블록이 해당 statement를 감싸고 있다면, 예외를 `catch` 하는 것을 시도한다.\n- `try` 블록이 해당 statement를 감싸고 있지 않은 경우, stack unwinding이 다시 일어난다.\n- 해당 예외를 처리하는 `catch` 블록이 없고, 예외가 `checked exception` 인 경우, 프로그램 컴파일이 에러를 일으킨다.\n\n## 예제\n\n```java\npublic class Main {  \n    public static void main(String[] args) {  \n        function1();  \n    }  \n  \n    private static void function1() {  \n        function2();  \n    }  \n  \n    private static void function2() {  \n        function3();  \n    }  \n  \n    private static void function3() {  \n        throw new IllegalArgumentException(\"Unchecked exception 발생\");  \n    }  \n}\n```\n\n프로그램을 실행하면 다음과 같은 메시지가 뜬다.\n\n```\nException in thread \"main\" java.lang.IllegalArgumentException: Unchecked exception 발생\n\tat Main.function3(Main.java:15)\n\tat Main.function2(Main.java:11)\n\tat Main.function1(Main.java:7)\n\tat Main.main(Main.java:3)\n```\n\n예외 메시지 출력 아래에 어떤 함수에서 불렸는지 trace가 함께 출력된다.\n\n## 참고 자료\n\n- [참고자료](https://luckygg.tistory.com/372)\n- [참고자료2](http://underpop.online.fr/j/java/help/stack-unwinding-exception-handling.html.gz)"},{"excerpt":"예외가 동시에 발생하는 경우 새로운 예외가 ,  블록에서 발생하는 경우, 현재 예외가 이전 예외를 무시하고 외부로 전파된다. (메서드는 단 하나의 예외만 던질 수 있으므로) 새로운 예외는 다른 예외와 동일하게 스택을 풀기 시작한다. (stack unwinding)  블록에서 새 예외가 발생하는 경우, 해당 예외는 의  블록의 영향을 받는다. 즉  에  가…","fields":{"slug":"/simultaneously-throw-exception/"},"frontmatter":{"date":"2023년 04월 07일 00:04","title":"try, finally에 모두 예외가 발생하는 경우에는 어떻게 될까?","tags":["Java","개발"]},"rawMarkdownBody":"\n## 예외가 동시에 발생하는 경우\n\n- 새로운 예외가 `catch`, `finally` 블록에서 발생하는 경우, 현재 예외가 이전 예외를 무시하고 외부로 전파된다. (메서드는 단 하나의 예외만 던질 수 있으므로)\n- 새로운 예외는 다른 예외와 동일하게 스택을 풀기 시작한다. (stack unwinding)\n- `catch` 블록에서 새 예외가 발생하는 경우, 해당 예외는 `catch`의 `finally` 블록의 영향을 받는다.\n- 즉 `try/catch` 에 `finally` 가 존재하는 경우, `finally` 는 예외를 catch한 후에 실행된다. 그러나  예외를 던지기 전에 `finally` 까지 실행한 후에 가장 마지막 예외가 던져진다. \n- [[stack-unwinding|스택 풀기]]\n\n## 참고 자료\n- [stack-overflow-참고자료](https://stackoverflow.com/questions/3779285/exception-thrown-in-catch-and-finally-clause)\n"},{"excerpt":"LOG 유정, 정민과 롯데월드에 갔다. 나이가 드니 놀이기구가 별로 재미없었다. 그냥 롯데월드 놀이기구가 재미없었을지도? ㅋㅋㅋ 그래도 오랜만에 만나서 논 거는 재밌었다~ 유정, 정민한테 LCK 결승전 티켓팅 같이 해달라고 했는데 S석 잡았다... 🥹 작년 스프링도 갔는데 이번 스프링도 가게 되어서 너무 기쁘다. 작년에도 이겼으니까 올해도 이기자~ 배운 …","fields":{"slug":"/2023-04-06/"},"frontmatter":{"date":"2023년 04월 07일 00:04","title":"2023년 04월 06일","tags":null},"rawMarkdownBody":"## LOG\n\n- 유정, 정민과 롯데월드에 갔다. 나이가 드니 놀이기구가 별로 재미없었다. 그냥 롯데월드 놀이기구가 재미없었을지도? ㅋㅋㅋ 그래도 오랜만에 만나서 논 거는 재밌었다~\n- 유정, 정민한테 LCK 결승전 티켓팅 같이 해달라고 했는데 S석 잡았다... 🥹 작년 스프링도 갔는데 이번 스프링도 가게 되어서 너무 기쁘다. 작년에도 이겼으니까 올해도 이기자~\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n\n- 너무 놀았더니 이제 공부가 하고 싶다. 모던 자바 인 액션을 읽을 생각이다. 저번에 레벨 인터뷰 때 제이슨이 Java 8 람다와 stream 관련해서 질문했었는데 진짜 처음 듣는 내용이었다. 앞으로 Java를 깊게 팔 일이 없을 것 같아서, 방학 때라도 (얼마 안 남았지만..) 모던 자바 인 액션을 읽어보자. 이제 레벨2 때 아침에 오면 독서를 할 생각이다.\n- 근데 왜 RSS 달았는데 작동을 안 할까. 개인 슬랙에 연동해봤는데 알림 1도 안 와서 진짜 속상하다...ㅋㅋㅋㅋ RSS 파일 바뀌는 것까지 봤는데 왜 알림이 안 가지?\n- 열심히 해야겠다. 나는 몰라서 허둥대는 모습보다 내가 많이 아는 모습이 더 좋다. 질문할 때는 부끄러움 없이 물어보고, 알게 된 내용은 남에게 부끄러움 없이 대답할 수 있을 정도로 공부하자."},{"excerpt":"LOG 블로그에 rss를 추가했다. 잘 작동하는지 확인하는 중이다. 배운 것 궁금한 것 어려웠던 것 느낀 것","fields":{"slug":"/2023-04-05/"},"frontmatter":{"date":"2023년 04월 05일 06:04","title":"2023년 04월 05일","tags":null},"rawMarkdownBody":"## LOG\n- 블로그에 rss를 추가했다. 잘 작동하는지 확인하는 중이다.\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"LOG 그 전날 5시까지 술을 마시는 바람에.. ㅎ 9시에 일어나게 돼서 40분 지각했다. 앞으로는 잠을 좀 더 많이 자자~ 레벨1 방학식이었다. 체인저가 우지컬 우승했다. 내가 그 전날 알코올 이슈로 지각하는 바람에 참여하진 못했지만 차라리 못한게 다행인 거 같다 ㅋㅋㅋ 그날 입은 옷으로 우지컬을 할 수는 없었다... 체인저의 기타를 빌려서 리오와 제이…","fields":{"slug":"/2023-03-31/"},"frontmatter":{"date":"2023년 04월 01일 14:04","title":"2023년 03월 31일","tags":null},"rawMarkdownBody":"## LOG\n\n- 그 전날 5시까지 술을 마시는 바람에.. ㅎ 9시에 일어나게 돼서 40분 지각했다. 앞으로는 잠을 좀 더 많이 자자~\n- 레벨1 방학식이었다. 체인저가 우지컬 우승했다. 내가 그 전날 알코올 이슈로 지각하는 바람에 참여하진 못했지만 차라리 못한게 다행인 거 같다 ㅋㅋㅋ 그날 입은 옷으로 우지컬을 할 수는 없었다... 체인저의 기타를 빌려서 리오와 제이, 민트가 기타 메들리?를 해줬다. 앉아서 노래부르고 기타치는 모습들이 낭만 그 자체여서 분위기가 되게 좋았다. 왠지 나도 기타를 쳐보고 싶다는 생각이 들었다 ㅋㅋ 일렉 기타 배워보고 싶었는데 아직도 도전 못하고 있다.\n- 내가 사연에 체인저, 박스터를 적었는데 그 두 명이 다 사연 선정돼서 상 받게 될 줄은 몰랐다... 그럴 줄 알았으면 좀 더 정성스럽게 쓸 걸 ㅋㅋㅋ 중간에 주노도 상을 받았는데 이름 퀴즈 대상자(?)로 선정돼서 망고랑 같이 앞에 나가게 됐다. 솔라.. 저희 5시까지 같이 있었는데... ㅋㅋㅋㅋ 다행히도 주노가 내 닉네임 맞춰줘서 좋았다~\n- 박스터, 주드, 주노, 포이, 글렌이랑 건대에서 방탈출했다. 근데 방에 들어가자마자 2명씩 격리돼서 ㅋㅋㅋ 웃겼다. 이렇게 서로 떨어져서 하는 방탈출은 처음해봤는데 재밌었다. 방탈출 끝나고 닭갈비 집에서 술을 마셨다. 중간에 다른 크루들도 보드게임하다가 그 닭갈비 집에서 밥을 먹어서 만나게 됐다 ㅋㅋ 헤나, 성하, 썬샷, 코코닥은 남아서 같이 마셨다. 성하랑 글쓰기 같은 조여서 얘기해보고 싶었는데 우연히 거기서 만나게 돼서 좋았다 ㅋㅋ\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n\n- 배운 게 없는 TIL... 그냥 일기가 됐다. Today I Felt 이런 걸로 바꿔야 되는거 아닌가 싶다..\n- 술을 좋아하는 건지 술자리를 좋아하는 건지 ... 이번 주는 수요일 빼고 (레벨 인터뷰 전날) 4일을 술마셨다. 원래 그렇게 마시면 속도 안 좋고 그래야 하는 게 맞는데 요즘에는 숙취가 없어졌다. 친구 말대로 너무 많이 마시면 숙취가 사라진다더니 진짜인가.\n"},{"excerpt":"LOG 새싹교실 수업을 했다. 진행하다보니까 너무 쉬웠나 싶었다. 좀 더 어렵게 가도 될지 아닐지 고민했는데 오늘 수업 회고 보니 적당한 거 같다. 제발 질문을 해줬으면 좋겠다 ㅋㅋㅋ 그냥 내용은 대충하고 질문으로 수업하는 시간이 됐으면 좋겠다. 그렇지만 이렇게 3년 말해본 결과 절대 질문 안 나올거라는 건 잘 안다... ㅋㅋㅋ 투썸 스트로베리 피치 프라…","fields":{"slug":"/2023-04-01/"},"frontmatter":{"date":"2023년 04월 01일 13:04","title":"2023년 04월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 새싹교실 수업을 했다. 진행하다보니까 너무 쉬웠나 싶었다. 좀 더 어렵게 가도 될지 아닐지 고민했는데 오늘 수업 회고 보니 적당한 거 같다. 제발 질문을 해줬으면 좋겠다 ㅋㅋㅋ 그냥 내용은 대충하고 질문으로 수업하는 시간이 됐으면 좋겠다. 그렇지만 이렇게 3년 말해본 결과 절대 질문 안 나올거라는 건 잘 안다... ㅋㅋㅋ\n- 투썸 스트로베리 피치 프라페 맛있었다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 과외하면서 내가 선생하면 안 된다는 것만 느끼고 있다.. 어떻게 하면 잘 설명하고, 잘 이해시킬 수 있을까?\n\n## 느낀 것\n- 벌써 4월이다. 새롭게 TIL 페이지를 만들면서, 기분이 이상했다. TIL을 이렇게까지 열심히 쓰게 될 줄 몰랐는데. 오히려 TIL을 봐주는 사람들이 있어서 더 열심히 적었던 것 같다. 구독자 여러분 감사합니다~\n- 갑자기 회고 모임 댓글이 달려서 봤는데 글렌이 멋진 글을 달아줬다. 이 사람... 감동이다 🥹 내가 처음에 우테코에 붙게 되었을 때 그냥 휴학 때 할 거 없었는데 잘 됐다는 생각만 있었다. 혼자 공부하면 금방 슬럼프가 올 걸 알았기 때문이다. 마침 친구들도 인턴에 학부 연구생에 바빠서 진짜 혼자 공부했어야 했다. 그런데 이렇게 우테코에 와서 같이 공부할 사람도 생기고, 같이 놀 사람도 생기고, 프로그래밍 고민, 내 고민을 진지하게 들어줄 사람들이 생겨서 정말 좋다. 그래서 나는 우테코에서 좋은 사람들을 많이 만나고 싶다. 주노처럼 100명과 모두 알게 되기는 힘들겠지만, 그냥 앞으로도 사람을 챙기는데 열중할 것 같다. 그냥 그렇게 하고 싶다~ 내가 하고 싶은 게 얼마 없으니까 하고 싶은 게 생겼을 때 진심으로 할 수 있다.\n- 나를 돌아보는 오글거리는 말을 많이 써보자. 지금 생각했던 고민들은 나중에 하나도 기억 안 나니까 지금만 쓸 수 있는 글이다. 거의 반 일기가 되어 가는 TIL 정말 괜찮은가?\n"},{"excerpt":"2023-04-01 2023-04-05 2023-04-06 2023-04-07 2023-04-08 2023-04-10 2023-04-11 2023-04-12 2023-04-13 2023-04-14 2023-04-15 2023-04-17 2023-04-18 2023-04-19 2023-04-20 2023-04-24 2023-04-25 2023-04-27 2…","fields":{"slug":"/2023-04/"},"frontmatter":{"date":"2023년 04월 01일 13:04","title":"2023년 04월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-04-01]]\n- [[2023-04-05]]\n- [[2023-04-06]]\n- [[2023-04-07]]\n- [[2023-04-08]]\n- [[2023-04-10]]\n- [[2023-04-11]]\n- [[2023-04-12]]\n- [[2023-04-13]]\n- [[2023-04-14]]\n- [[2023-04-15]]\n- [[2023-04-17]]\n- [[2023-04-18]]\n- [[2023-04-19]]\n- [[2023-04-20]]\n- [[2023-04-24]]\n- [[2023-04-25]]\n- [[2023-04-27]]\n- [[2023-04-28]]\n"},{"excerpt":"LOG 레벨 인터뷰 했다. 내가 첫 번째였는데, 아침 8시 30분까지 왔어야 해서 좀 많이 졸렸다. 이걸 쓰고 있는 지금도 너무 졸리다. 생각보다 덜 떨어서 생각보다 잘 말한 거 같다. 사실 제이슨이 말한 것처럼 내가 말하고 싶은 주제를 유도했었는데 알아채셔서 역시 코치구나 싶었다 ㅋㅋㅋ 첫 타자라 그런지 칭찬을 많이 받아서 기분이 좋았다. 내가 말할 때…","fields":{"slug":"/2023-03-30/"},"frontmatter":{"date":"2023년 03월 30일 06:03","title":"2023년 03월 30일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨 인터뷰 했다. 내가 첫 번째였는데, 아침 8시 30분까지 왔어야 해서 좀 많이 졸렸다. 이걸 쓰고 있는 지금도 너무 졸리다. 생각보다 덜 떨어서 생각보다 잘 말한 거 같다. 사실 제이슨이 말한 것처럼 내가 말하고 싶은 주제를 유도했었는데 알아채셔서 역시 코치구나 싶었다 ㅋㅋㅋ 첫 타자라 그런지 칭찬을 많이 받아서 기분이 좋았다. 내가 말할 때 어,그,저 라는 말을 많이 쓰는 편인데 우르가 그 부분 지적해줘서 고마웠다. 소중한 피드백 감사합니다 👍 다음 레벨로그때는 잘 모르는 거 써도 될 거 같다. 오히려 질문을 받는게 좋았다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 내가 질문을 잘하고 있는 것 같지 않았다. 인터뷰 때 너무 쉬운 내용만 물어봤나? 싶어서 인터뷰이한테 좀 미안했다. 여우, 우르 미안합니다 😂\n\n## 느낀 것\n"},{"excerpt":"LOG 아침부터 대청소를 했다. 방점검이 있어서 9시부터 12시까지 청소만 했다. 밀린 일들을 한 번에 해결하니 기분은 좋았다. 근데 청소하는 게 너무 힘들어서 하루 끝까지 기운이 없었다. 토리와 같이 레벨 인터뷰 준비를 했다. 청소 끝나고 검사 받아야 돼서 잠깐 카페에서 공부하고 있었는데 토리가 같이 준비하자고 해서 구디단에서 만났다. 각자 상대 레벨로…","fields":{"slug":"/2023-03-29/"},"frontmatter":{"date":"2023년 03월 30일 06:03","title":"2023년 03월 29일","tags":null},"rawMarkdownBody":"## LOG\n- 아침부터 대청소를 했다. 방점검이 있어서 9시부터 12시까지 청소만 했다. 밀린 일들을 한 번에 해결하니 기분은 좋았다. 근데 청소하는 게 너무 힘들어서 하루 끝까지 기운이 없었다.\n- 토리와 같이 레벨 인터뷰 준비를 했다. 청소 끝나고 검사 받아야 돼서 잠깐 카페에서 공부하고 있었는데 토리가 같이 준비하자고 해서 구디단에서 만났다. 각자 상대 레벨로그를 읽어보고 질문을 준비해줬다. 하나씩 대답하는 시간을 가졌는데 진짜 도움이 많이 됐다. 예전에도 그렇게 떨리진 않았지만 질문까지 준비하고 대비(?)하다보니 훨씬 더 잘 준비할 수 있었던 것 같다.\n- 그 분에게 메일을 보냈다. 최근에 메일이 왔었는데 예전 생각이 많이 났다. 보낼까 말까 하다가 그냥 보내버렸다. 답장은 안 와도 괜찮다. 답장을 바라고 쓴 게 아니었으니까.\n\n## 배운 것\n- `System.lineseperator()`는 시스템에 저장된 개행 문자를 읽어와서 리턴한다. 각 OS마다 개행 문자가 다르기 때문에 `\\n`보다 lineseparator를 사용하는 것이 좋다.\n\n## 궁금한 것\n- 어떤 경우에는 디미터의 법칙을 위반해도 괜찮을까?\n- 보편적으로 확장이 예상되는 경우에도 구현하지 않아야 할까? (YAGNI 원칙을 지켜야 할까?)\n\n## 어려웠던 것\n- 질문에 정확하게 대답하는 게 어렵다. 질문에 꼬리 질문이 계속되면 원래 질문을 잃어버린다. 배경을 열심히 설명하다보니 어떤 걸 말하고 있는지 까먹는다... 계속 질문이 뭐였는지 생각하면서 말해야겠다.\n- 하나에 집중하는 게 어렵다. 금방 집중이 분산된다. 레벨로그 주제가 여러 개 있었는데 하나 쓰다가 갑자기 다른 거 쓰고 싶어서 다른 거 쓰다가 다시 돌아오고 무한 반복이었다. 진짜 집중력 부족이다..\n\n## 느낀 것\n- 그때 나는 정말 아무것도 없었구나 싶다. 지금은 정말 많이 나아졌는데, 그때는 그냥 깜깜했다. 해야 하는 게 있는데도 아무것도 손에 안 잡히고, 그냥 누워있고 싶었던 날들이었다. 그렇지만 그때도 이겨냈다. 지금의 내가 있으니까. 만약 앞으로 그런 때가 다시 온다고 하더라도, 지금의 기억이 힘든 날들을 무사히 보내게 도와줄 것 같다. 정말로 감사하다.\n- 예전보다 생각을 덜한다. 좋게 말하면 걱정이 없고, 나쁘게 말하면 생각이 없다. 이런 때가 예전에도 종종 있었는데 그럴 때마다 바보같은 결정을 해버렸다. 그래서 지금도 조심해야 한다. 걱정이 없는 건 좋은 건데 생각이 없는 건 안 좋은거다. 지금보다는 좀 더 생각을 하면서 살아보자.\n\n"},{"excerpt":"디미터의 법칙 객체의 내부 구현에 대한 정보를 외부로 노출하지 않는 것이다. 객체의 결합도를 낮출 수 있고, 변경에 유연하고 유지보수하기 쉬운 코드를 작성할 수 있다. IllegalStateException vs IllgalArgumentException : 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알린다. : 메서드에 잘못되거나 …","fields":{"slug":"/level1-level-log/"},"frontmatter":{"date":"2023년 03월 28일 04:03","title":"레벨1 레벨로그","tags":["우테코","레벨1","레벨로그"]},"rawMarkdownBody":"\n## 디미터의 법칙\n\n- 객체의 내부 구현에 대한 정보를 외부로 노출하지 않는 것이다.\n- 객체의 결합도를 낮출 수 있고, 변경에 유연하고 유지보수하기 쉬운 코드를 작성할 수 있다.\n\n## IllegalStateException vs IllgalArgumentException\n\n- `IllegalStateException`: 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알린다.\n- `IllegalArgumentException`: 메서드에 잘못되거나 부적절한 매개변수가 전달되었음을 알린다.\n\n## YAGNI (You are not gonna need it)\n\n- 필요가 생기기 전에는 구현하지 않는다.\n- 현재는 사용하지 않지만 확장성을 고려해서 미리 작업하는 것은 자제하자.\n\n## 상속과 조합\n\n- 상속: 기존 클래스를 재활용하여 새로운 클래스를 작성하는 것. 중복된 코드를 줄이고 기능 확장이 가능하다.\n- 조합: 새로운 클래스를 만들고 필드로 기존 클래스의 인스턴스를 참조하는 것\n- 상속의 경우 하위 클래스가 상위 클래스의 구현에 의존하기 때문에 상위 클래스의 변경에 모든 하위 클래스가 영향을 받는다.\n\n## 불변 객체\n\n- 생성 후 내부 값을 바꿀 수 없는 객체이다. 사용되지 않고 버려지는 객체는 메모리 관리와 성능에 부담을 끼칠 수 있다.\n- 객체의 상태를 변경할 수 없도록 하고, 클래스를 final로 선언하여 클래스의 확장을 막는다. 클래스의 상태가 가변 객체일 경우 방어적 복사를 적용한다.\n- 장점: 생성자, 접근 메소드에 대한 방어적 복사가 필요 없다. 멀티 스레드 환경에서 동기화 처리 없이 객체를 공유할 수 있다.\n- 단점: 메모리 누수 문제가 존재한다. 사용해야 하는 값의 가짓수가 많으면 그만큼 많은 객체가 생성되어야 하여 성능에 부담을 줄 수 있다.\n\n## VO\n\n- 도메인에서 한 개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미한다.\n- aliasing 문제 때문에 불변 객체로 만들어야 한다.\n- 속성 값이 동일할 때 같은 객체로 만들기 위해 `equals()`와 `hashCode()` 를 재정의해야 한다.\n\n## 함수형 인터페이스\n\n- 1개의 추상 메서드를 갖는 인터페이스\n- 구현 클래스, 익명 클래스, 람다로 구현할 수 있다.\n- 동시성 side effect를 없앨 수 있다. 구조적으로 유연하고 간결하다.\n\n## DTO\n\n- 계층 간 데이터 교환을 하기 위해 사용하는 객체\n- `getter`, `setter`를 포함하며, 비즈니스 로직은 포함하지 않는다. 그러나 굳이 값을 변경할 필요가 없는 경우 `setter`를 만드는 것보다 생성자에서 값을 할당하는 것이 좋다.\n\n## 디폴트 메서드\n\n- 인터페이스에 있는 구현 메서드.\n- 기존의 구현을 고치지 않고 이미 공개된 인터페이스를 변경하기 위해 고안되었다.\n- 선택형 메서드: 기존 인터페이스에서 잘 사용되지 않는 메서드를 디폴트 메서드로 작성하여 인터페이스 구현 클래스에서 빈 메서드 구현을 하지 않도록 한다.\n- 동작 다중 상속: 인터페이스는 여러 개를 구현할 수 있어 인터페이스를 조합하여 다양한 클래스를 만들 수 있다.\n\n## 우르 질문\n\n- 원시 값 포장의 단점\n- **모든 원시값을 포장하시는 편이신가요? 기준이 따로 있으신가요? 원시 값 포장을 할 때 드는 비용과 하지 않을 때의 비용 차이는 어떨까?**\n- VO가 불변성을 지원해야 하는 이유는 뭐라고 생각하는가?\n- 설계에 얼마나 시간을 쏟는 편인가?\n- 설계는 계속해서 변경되지 않나? 얼마나 완벽한 설계를 추구하는가?\n- **일급 컬렉션을 사용하지 않았을 때 발생하는 사이드 이펙트란 무엇을 의미하는가? 일급 컬렉션을 사용해서 어떻게 막을 수 있는가?**\n- **`unmodifiableList`  는 어떤 때 사용하면 좋을까?**\n- 설계하면서 객체지향적 설계가 안 좋은 점이 있었나요?\n- 설계에서 가장 중요하게 생각하는 부분은?\n- **역할과 책임을 적절하게 할당이 되었는지 어떻게 확인할 수 있을까?**\n- **어떤 경우에 일급 컬렉션을 사용하면 좋을까?**\n- 코드를 구현하다 보면 어느 정도 확장성을 고려해서 구현해야 하는 부분도 있다고 느껴지는데, 아예 확장성을 제외하고 미션을 진행하셨나요? 그것이 아니라면 어느 기준까지 확장성을 고려해야 한다고 생각하시나요?\n- 메모리 누수 문제가 단점이라고 하셨는데 어느 기준까지 사용해도 된다고 생각하시나요?\n- 어째서 VO를 사용해야겠다고 생각하셨나요?\n- TDD 커밋 단위는 어떻게 하는 게 좋다고 생각하시나요?\n\n### 우르 피드백\n\n자신의 생각을 자신감 있게 말하는 모습이 좋았다.   \n솔직하게 답변하는 모습이 좋다.   \n경직되지 않고 여러 제스처를 사용해서 답변이 어색하지 않았다.   \n답변에서 자신만의 철학이 느껴져서 좋았습니다.   \n\n## 제나\n\n### 질문\n\n- `private` 메서드도 테스트 하는가? 왜 그렇게 쓰는가?\n- domain과 view의 의존은 어떤 경우에 의존한다고 할 수 있을까?\n- 프로덕션 출력용으로 사용하지 말아야 하는 이유가 무엇일까?\n- `toString()`  을 정의해서 좋았던 점이 있나?\n- 어느 정도의 개수까지 캐싱해도 된다는 기준이 있나?\n- 캐싱을 하게 되면 접근 시간이나 계산이 없게 되는 것인가?\n- 어떤 경우에 캐싱을 주로 사용하면 좋을까? (얼마나 자주 사용될 때?)\n- TDD를 할 때 힘들었던 점은 없나?\n- 정의한 `toString()` 은 어디서 쓰는가?\n- 캐싱할 때 주로 어떤 자료구조로 구현하는가?\n- 방어적 복사를 안 해도 되는 경우가 있을까?\n- view에서 모델 객체를 받아서 출력해도 된다고 생각하시나요? 아니면 DTO 객체를 따로 두는 것이 좋다고 생각하시나요?\n- 모델에서 view에서 출력하기 위한 로직이 있어도 된다고 생각하시나요?\n- 모든 경우에 일급 컬렉션을 사용하는 게 좋은가요?\n\n## 테오\n\n### 속기\n\n- 모든 도메인 속성들에 대해 커스텀 예외를 만들었나? : 예외 객체가 지금은 작은 시스템이지만 큰 시스템이라고 한다면 예외 객체가 관리 대상이 되기 때문에 비용이 클 수 밖에 없다. 예외 객체도 도메인이 수정될 때 같이 수정되어야 하기는 하지만 관리가 어렵다.\n- 예외 필드로 무엇을 가질 수 있는지가 중요하다. 예외 객체가 추상화 레벨을 파괴할 수 있다. 원시 타입 정도는 가져도 될 거 같다.\n- 예외 객체가 도메인에 의존된다는 느낌이 있는 경우 사용하면 안 될 거 같다.\n- 자료구조는 값이 중심이 될 수 밖에 없어서 디미터의 법칙이 적용되지 않아도 된다고 생각한다.\n- 일급 컬렉션에서는 디미터의 법칙을 덜 지켜도 되나? : 일급 컬렉션 객체를 반환하는 것에 대해 큰 문제라 생각하지 않는다. 상태와 행위를 동시에 관리하기 위한 객체라고 생각한다. 굳이 일급 컬렉션에서는 디미터의 법칙을 준수하지 않아도 된다고 생각한다.\n- 모든 과정에서 TDD 했는가? : 모든 과정에서 하지는 못했다. 시간적 압박 때문에 초반에는 TDD를 하게 되었지만 마감일이 다가올 때는 프로덕션 코드만 작성하고 테스트는 검증용으로만 사용했다.\n- TDD가 시간이 오래 걸리는 이유? : 만들어지지 않은 것에 대한 행위를 작성하기 때문에.\n- 이상적으로는 안정적인 코드. 현실적으로 생각했을 때 버려야 할 때가 있다. \n- TDD에서 신경쓰는 것?: 인간의 인지 능력을 제어하는 것이라고 생각한다. 베이비 스텝으로 진행하려고 의식적으로 노력했다. 그런 과정을 통해 예측하고 있던 자신만의 기준이 사라지는 듯한 느낌을 받았다.\n- TDD를 잘하지 않는 환경에서 TDD 하자고 설득한다면?: 테스트 코드가 하나의 문서가 될 수 있다. 테스트 코드는 변경에 대처할 수 있는 하나의 수단이 될 수 있다.\n- TDD를 왜 해야 하는가?: 테스트 코드를 잘 짜고, 좋은 프로덕션 코드를 만드는 수단으로서 TDD를 사용하는 것이 좋을 거 같다.\n- TDD가 어떻게 좋은 프로덕션 코드를 만들 수 있는가? : 가독성 측면에서 이점이 있을 거 같다.\n- TDD 사이클 중에서 가장 중요한 것: 실패한 테스트를 만드는 것. 실패한 테스트이면서 클라이언트가 원하는 정보인가? 이 객체에 해당하는 행위인지를 생각해봐야 한다. 실패한 테스트를 선별하는 작업이 중요하다.\n- 실패하는 요구사항을 작성하면 되지 않을까? TDD 만의 장점인가?: TDD는 하나의 구현 과정이기 때문에 요구사항 분석보다는 잘 사용하는 것이 좋을 것 같다.?\n- 테스트 코드 작성함에 있어서 검증 코드를 만드는데 있어서 본인만의 신경쓰는 부분이 있는가?: 모든 테스트가 당연히 통과할 수 밖에 없는 코드로 만들어졌다. 이것을 검증으로 볼 수 있을까에 대한 고민을 많이 했다. 예측하는 행동인가? 예측할 수 없는 부분에 대한 테스트를 만들기 위해 의식적인 생각을 많이 하게 된다.\n- 테스트에 대한 기법이 뭐가 있을까? : 테스트를 작성할 때 이것이 과연 클라이언트가 원하는 정보인가?에 대한 생각을 하게 된다. 모든 유스케이스를 생각해보고 필요한 행동이라고 생각될 때 구현한다.\n- 유스케이스 작성??: 어떤 시나리오가 존재할지 생각해보는 것. 프로덕션 코드와 테스트 코드 작성자를 분리하는 것도 좋은 방법이다.\n- 테스트 코드가 부정적인 영향을 준 적은 없는가?: 설계 반영에 대한 테스트는 실패하는 것이 맞다. 그에 따른 오버헤드가 발생할 수 밖에 없다. \n- 테스트 코드가 없는게 확인하기 편하지 않을까? : 테스트가 있으면 변경했을 때 이게 아니다 라는 것을 알게 되기 때문에 필요하다.\n- 테스트 코드를 작성하면서 유의했던 점?: 국소적인 부분을 테스트하고 있나?라는 생각을 하고 있다. 프로덕션 코드와 연결해서 생각해서 해당 부분에 대한 테스트가 정말 이 부분에 대한 테스트가 \n- 데이터 베이스 연동 부분 테스트는 했는가? : 데이터베이스는 테스트하지는 못했다. 작성을 해야 한다면 테스트용 툴을 사용할 것 같다. mock이나 spy 같은 것을 사용할 것 같다.\n- 데이터 베이스는 테스트를 안 해도 되나?: 해야 하기는 하지만 데이터베이스의 값을 확인하기 위한 테스트는 필요 없다고 생각한다. 테스트 해야 할 부분은 서비스 계층, DAO 비즈니스 로직 부분이라고 생각한다.\n- 쿼리는 따로 검증의 대상이 되어야 한다고 생각한다.\n- 죄송해요 이 이후부터는 잘 못 적었어요 ㅋㅋ ㅜㅜ\n\n### 피드백\n\n말을 적당한 속도로 차분하게 잘 말했다.   \n개발에 대한 확실한 자기 주관이 있다는 생각이 들어서 좋았다.   \n말을 더듬는 부분이 없이 명확한 답변을 해주셔서 좋았다.    \n대답을 하다 보면 질문에 대한 답이 아닌 다른 답을 할 때가 있었다. 꼬리 질문을 하다보면 원래 질문에서 멀어진 답을 한 적이 있어서 그 부분을 신경 써주시면 좋을 것 같다 ˙ᵕ˙   \n\n## 필립\n\n### 속기\n\n- 이전에는 기능적으로 할 수 있는 단위로 커밋했었는데 실행 가능한 단위로 커밋하는 것이 좋아보인다.\n- 언제 hashcode, equals를 하거나 하지 않나요? : 단순 기능 구현을 위해 사용한다기보다는 같은 것으로 확인하는 경우에는 동등하다고 생각한다. 그 외의 경우에는 ...\n- 인덱스만 같으면 동등한가요?\n- 자바의 hashcode 내부 알고리즘은 알고 계신가요?\n- 미션 수행 하시면서 null 반환을 하셨나요 아니면 Optional을 반환하셨나요?: 굳이 해야 한다면 Optional을 리턴하거나 예외를 반환하는 방식으로 구현했다.\n- Optional을 굳이 쓰는 이유가 있나요? : null을 반환하게 되면 실행 결과를 받는 곳에서 null 체크를 하는지 확인해야 한다. Optional을 사용하면 빈값인지 아닌지 확인하는 것을 명시적으로 할 수 있어서 좋다.\n- 이번 미션에서 상속과 조합을 어떻게 적절하게 사용하셨나요? : 체스 미션의 기물에서는 상속을 사용했습니다. 킹, 퀸이라는 각자의 기물들 종류가 기물에 포함 관계가 확실하기 때문에 사용했습니다. 조합의 경우는 블랙잭 때 사용했다. Money를 만들고 BettingMoney가 Money를 인스턴스로 사용했었다.\n- 모든 동등성을 가진 객체가 캐싱이 필요한가요?: 반복적으로 생성하는 일이 많을 때 하는것이 좋다.\n- 그런 경우가 어떤 경우가 있을까요?: 체스 판에서의 위치 정보를 표현할 때. 매 이동마다 시작점과 끝점, 사이의 점을 계속 생성해야 해서, 이런 경우 캐싱을 사용하면 좋을 거 같다.\n- 캐싱을 할 때 고려할 점이 있을까요?: \n- 캐싱을 할 때 문제가 발생할 수 있는 점이 있을까요? : 캐싱을 한 객체가 불변 객체가 아닌 경우 다른 곳에서 값이 변경되면 캐싱 내부의 객체 값이 변경되어 사용하는 다른 곳도 값이 변경되게 된다.\n- 상태 패턴을 어떻게 쓰셨나요?: 체스에서 게임 상태를 표현할 때 사용했다. 각각의 경우에 따라 체스의 말을 움직이거나 명령을 내렸을 때 기능을 수행할 수 있는지 없는지 구분이 필요할 때 사용했다.\n- 전략 패턴에 대해서 아시나요?: 정확하게는 잘 모른다. 행위를 해야 할 때 행위에 대한 의미나 행위를 통해 나와야 할 결과물이 정해졌을 때, 결과물을 만드는 방법이 다른 경우 다양한 전략들을 생성해두고 필요에 따라 구현된 전략을 사용할 수 있는 것이 전략 패턴인 것 같다.\n- 상태 패턴과 전략 패턴을 비교해서 설명해주세요.: 전략은 한 번 정해진 전략을 잘 바꾸지 않는 것 같다. 상태 패턴은 진행되면서 유연한 변화가 가능하다는 차이가 있다. 변경된 상태를 반환하는 방법으로 새로운 상태를 반환할 수 있다.\n- DTO를 생성할 때 도메인을 전달 받도록 하셨나요? : 도메인이 내부에 포함되게 되면 뷰에서 받을 때 도메인 객체를 그대로 가져올 수 있게 되어서 숨기고 싶은 정보들도 공개될 수 있다. 그래서 DTO를 생성할 때 풀어서 주는 편이다.\n- 파라미터가 너무 많아지지 않나요? : 도메인의 정보를 숨기는 것이 우선시 되어야 한다고 생각한다.\n- 도메인의 정보를 어떤 이유로 숨겨야 할까?\n- 이번 미션에서 숨겨야 하는 경우가 존재했나요?: 체스에서 기물에 대한 정보를 꺼내서 사용했는데, 기물 자체가 자신이 이동한 위치의 기물을 반환하는 기능을 갖고 있었다. 기물 정보를 그대로 보내면 뷰에서 기물을 조작할 수 있기 때문에 이를 막기 위해 사용했다.\n- 도메인과 뷰를 개발한 사람이 달랐나요?: 혼자서 개발한다고 하면 굳이 DTO를 쓸 필요가 없다고 생각한다. 연습하고 공부하는 입장에서 언젠가 함께 일하는 상황을 연습하려고 사용해보고 있습니다. \n- 프로젝트가 길어지게 되면 유지보수를 하고 다음에 사용할 때도 어떤 목적을 위해 전달했는지 확실히 하기 위해 썼다는 걸 명시해줄 수 있다. 그런 경우 DTO를 사용하는 것이 좋아보인다.\n- 도메인 하나만 전달하면 값을 전달하는 것보다 유지 보수가 편하지 않을까요? : 도메인이 변하거나 뷰가 변하는 사항이 있을 때 도메인에 대한 변화까지 전파될 수 있어서 좋지 않다고 생각한다.\n- 방어적 복사를 사용하게 되면 굳이 DTO를 사용하지 않아도 되지 않을까요? 훼손이 문제라면?: 훼손만 문제가 된다면 내부적으로 변화에 대한 것은 막을 수 있지만 ... ()\n- 모델 뷰 컨트롤러는 레이어인가요?: 목적이 다르니까 레이어라고 봐도 된다고 생각합니다.\n- 일단 뷰에서 컨트롤러로 올 때는 원시 타입으로 받을 수 있을 때는 그대로 받고 연관이 되는 데이터를 받아서 합쳐서 보낼 때에는 DTO를 사용했습니다. 컨트롤러에서 도메인으로 넘길 때도 단순한 하나의 원시값이나 문자열로 보낼 때는 그냥 보내지만 연관된 정보가 있는 경우에는 DTO를 리턴합니다.\n- 본질적으로 DTO라는 것은 왜 생겼을까요?: 제가 생각했을 때 어떤 한 쪽의 변화가 다른 한 쪽으로 전파되는 것을 최대한 막기 위해서입니다.\n- 도메인에 DTO는 왜 필요할까요?: 도메인 객체에 대한 것을 다른 곳에서 모르게 하기 위해서.\n\n### 피드백\n\n꼬리질문이 계속해서 이어졌는데 최대한 열심히 대답하려고 하는 모습이 좋았습니다.   \n미션에서 직접 사용한 내용에 대해서 작성한 것이 느껴져서 좋았습니다.   \n모르는 부분에 대해서 미리 인정하는 것이 좋았습니다. 잘 모르겠는 부분을 인정해주셔서 좋았습니다.   \n꼬리 질문이 이어질 때 약간 당황하는 모습이 보였는데 답변 잘 이어나갔던 것 같습니다.   \n'이제' 라는 단어가 당황할 때 자주 언급되는 것 같습니다.   \n\n## 달리\n\n### 속기\n\n- 미션 하면서 TDD로 개발했는데, TDD의 장점과 힘든 점이 있었을까요?: 여러 가지 객체들이 이런 기능을 갖겠다, 라는 일종의 방향성을 갖는 장점이 있었습니다. 프로덕션 코드가 변경이 될 때마다 테스트 코드를 고쳐주는 과정에서 오히려 시간이 오래걸렸다.\n- 프로덕션 코드를 고치면서 테스트가 깨졌던 경험이 있었나요? : 처음에 TDD를 하면서 이런 방향성을 갖고 작성했지만, 이후 놓쳤던 부분이 발견되기도 하여서 변경 사항이 생겼습니다. 설계적인 부분에서 문제가 발생한 경우에도 문제가 생겼었다.\n- 달리가 생각하는 리팩토링의 정의란 무엇인가요?: 기능적인 면이나 프로덕션 코드를 구현했음에도 유지보수 측면에서 좋은 방향으로 만들거나 변경할 때가 리팩토링이라고 생각합니다.\n- 테스트 코드를 고치는 것도 리팩토링일까요? : 같은 기능을 하되 설계적 측면에서 변경이 될 수도 있기 때문에 유지보수 측면에서 코드 추가적인 수정이 필요할 때는 필요하다면 리팩토링이라고 할 수도 있을 거 같다.\n- 객체에 물어보지 말고 일을 시키는 것을 지양해야 하는 이유가 무엇인가요?: 자동차 미션 때 왜 getter를 지양해야 하는가에 생각해야 했다. 책임을 객체에게 주라는 뜻으로 이해했다.\n- JUnit5와 JUnit4의 차이?: 모르겠다.\n- 원시값 포장, 값 객체 모두 값을 포장하는 것인데 차이점이 뭐가 있을까요?: 원시값 포장은 어떤 값을 포장함으로써 유효성 검사를 내부에서 할 수 있기 때문에 사용한다. 다른 값들과의 비교가 필요한 경우 값 객체를 사용한다.\n- extracting 메서드를 사용한 이유는 무엇인가요?: 체스 미션에서 64개의 칸을 갖고 있는지 확인하기 위해 사용했다. 테스트로 제대로 확인하기 위해 extracting을 사용했습니다.\n- private을 테스트 하는 이유는 무엇인가요?: 테스트를 위해 public을 사용하지 않기 위해서 사용했다.\n- private으로 막아두는 이유는? : 외부에서 값을 감추기 위해서\n- 테스트에서는 열어서 검증할 필요가 있을까?: 특수한 상황이었다. 생성과 관리를 내부에서 하기 때문에 프로덕션에서는 감춰져 있지만 테스트에서는 해야 할 거 같다.\n- 다른 방법으로 해결할 수 있는 방법이 있을까?: 찾지 못했다.\n- equals를 사용해서 해시코드를 비교하는 방법도 있었을 것 같은데 어떤가요?: 테스트를 위해 equals, hashcode를 만드는 것은 getter를 만드는 것과 차이가 없다고 생각한다.\n- getter를 안 만들어야 하는 이유가 있나요? : 캡슐화를 깨는 것이고, 프로덕션 로직에도 필요 없어서 테스트에서 해결하는 방법인 extracting을 사용하였다.\n- extracting을 사용해서 생기는 문제점이 있을까요?: 하드코딩이기 때문에 문제가 될 것이라고 생각했다. getter를 추가하거나 프로덕션 코드를 바꾸느니 extracting을 사용하는 것이 나은 거 같다.\n- 책임 연쇄 패턴과 상태 패턴을 어떤 경우에 사용하셨나요?: 책임 연쇄 패턴은 같은 요청에 따라 자동적으로 구현체가 정해지고 고르게 되어 어떤 움직임을 하는지 알기 위해 사용했다. 상태 패턴을 통해 체스 게임의 상태를 관리했다.\n- 다형성에 대해 설명해주세요.: 추상적인 것을 통해 어떤 것을 추상화하고 입력을 했을 때 추후에 입력할 것을 정의해서 유지보수 차원에서 유연하게 한다.\n- 어떤 부분에서 유지보수가 좋나요?\n- 좋은 객체지향은 무엇일까요?: 객체가 응답과 요청을 통해서 객체 스스로가 일을 시키게 하는 것이 좋은 객체 지향인 것 같다. 객체의 상태를 변하게 함으로써 시스템이 돌아가게 하는 것이 객체지향이라고 생각한다.\n- SOLID 중에서 인상 깊었던 원칙이 있을까요?: open-closed 원칙.\n- 본인 미션에서 그런 부분을 지키고자 노력했던 순간이 있었나요?: 단일 책임 원칙을 지키려고 노력했다. 가장 작은 단위를 갖도록 노력했다. 각 객체들이 하나의 책임만을 가질 수 있게 유도할 수 있어서 최대한 단일 책임 원칙을 지키려고 했다.\n- 하나의 책임을 정의하는 본인만의 기준점이 있을까요?: 정확한 단계나 선이 없어서 찾기 힘들었다. 자신에게 꼬리 질문을 하면서 최대한 줄이려고 노력했다.\n- 체스 미션 구현 중에 단일 책임 원칙을 지키지 못한 부분이 있는 것 같습니다.\n- 체스 미션 중에 데이터 베이스 연동하면서 인상 깊었던 부분, 신경 쓴 부분이 있을까요?\n- MVC 패턴과 레이어는 어떤 차이가 있을까요?\n- 서비스를 테스트할 때 어떻게 하셨나요?\n- 컨트롤러는 테스트 하지 않은 이유가 있을까요? : 도메인과 뷰를 분리해주는 역할이라 생각해서 뷰의 테스트를 하지 않기 때문에 컨트롤러도 하지 않았다. 컨트롤러가 뷰로 보내주는 데이터들을 확인하는 테스트를 작성했다. 그러나 하면 할수록 큰 로직이 없어서 테스트를 하지 않아도 될 것 같았다.\n- 뷰를 테스트 하지 않은 이유가 있을까요? : 현업에서는 협업을 하게 되기 때문에 뷰를 구현하는 부분은 확인하지 않아도 된다고 생각했습니다.\n- 큰 로직이 아니면 테스트를 하지 않아도 되나요?\n\n### 피드백 \n\n전체적으로 말이 빨라서 말이 밀리는 경우가 있었습니다.   \n본론이 앞에 나오면 좋을 것 같다.   \n\n질문자와 눈을 맞추려고 하는 모습이 집중하고 있다는 인상을 주는 것 같습니다.   \n모르는 부분을 말하고 알고 있는 부분을 최대한 말하는 모습이 좋았습니다.   \n미션 내용과 연관지어서 말해주셔서 어떤 부분에서 사용하셨는지 이해하기 쉬웠습니다.   \n\n## 제나\n\n### 속기\n\n- 모든 하위 클래스에서 재정의했을 때 문제가 발생하신적이 있나요?: 디버깅할 때 쓰면 유용하다고 해서 작성했습니다. toString은 디버깅 용도입니다. 프로덕션 요구사항이 변경되면 도메인의 toString을 고쳐야 하기 때문입니다.\n- 왜 뷰가 변할 때 도메인이 변하면 안 될까요? : 뷰는 변화가 잦은 곳이라서 도메인도 함께 변경되면 안정적인 도메인이 아니게 됩니다.\n- 도메인이 변할 확률이 굉장히 적은 경우에서는 변경될 여지가 없는데, 도메인이 뷰에 대한 정보를 가지고 있더라도 괜찮지 않을까요?: 도메인에서 꺼내기보다는 도메인을 뷰로 전달할 때 매핑 객체를 만드는 것이 좋아보인다.\n- 기계적으로 toString을 정의하게 되면 프로덕션 코드가 변경되는 경우 디버깅 시에 오류가 생길 수 있다. 언제쯤 toString을 오버라이딩 하는 것이 좋을까?: 객체 생성시에 toString을 오버라이딩 한다.\n- Object 클래스에 있는 메소드들에 어떤 것들이 있을까요?: clone, toString, equals, hashcode 정도 알고 있습니다.\n- A가 B를 가지고 있고, B가 A를 가지고 있으면 toString 시에 문제가 생기지 않을까요?: A가 변경되었을 때 B도 재정의를 해줘야 해서 문제점이 있을 것 같습니다. \n- 실제로 테스트 코드를 도입함으로써 어떻게 시간 절감을 실감하셨나요?: 나중에 리팩토링 과정을 거치면서 코드가 안정적으로 동작하는지 테스트 코드로 검증할 수 있어서 시간이 절약되는 것을 실감할 수 있었습니다.\n- 원시값 포장과 VO의 차이는 무엇이 있을까요?: 원시값 포장은 값을 포장한 것이고, VO는 동등성과 자기 유효성 검사도 할 수 있고, 불변이어야 한다는 특징이 있습니다. \n- 원시값 포장은 동등성이 보장되지 않나요?: 동등성 주소값이 다를 때 값이 같으면 같은 것으로 판단하는 것으로 알고 있습니다.\n- 사다리 미션에서 원시값 포장을 어떻게 하셨을까요?: 사다리의 높이, 플레이어 이름 등을 원시값 포장을 해줬습니다.\n- 그 객체들은 VO는 아닌가요?: Name은 VO로 바꿔주었습니다.\n- 불변 객체로 만드는 것과 가변 객체를 나누는 기준이 있으셨나요?: 보통은 불변 객체로 만들었다. 가변 객체는 계속 바뀌는 것들을 선언했습니다.\n- 일급 컬렉션을 가변이 아닌 불변으로도 선언하실 수 있으셨을텐데 그 부분에 대해 고민해보셨나요?\n- 객체를 한 번 생성하는데 비용이 많이 드나요?: JVM을 믿고 맡기면 된다고 생각하지만, 객체 생성에 대한 오버헤드는 많이 고려하지 않아도 된다고 생각합니다. \n- Java8에 추가된 큰 변화는 어떤 것이 있을까요?\n- 기존의 for문과 stream은 어떤 차이가 있을까요? stream에 대해서 설명해주세요: 파이프라인을 지나가듯이 돌리면서 요소 하나하나에 적용하고 싶은 operator들을 적용 시켜서 원하는 것들을 만들어줍니다. 중간 operator가 있고 종단 operator로 완료해 주어야 합니다. 종단 operator가 들어오면 그때 연산이 일어나서 stream을 할 수 있습니다. 사용하는 장점은 Collection을 돌면서 필터를 걸거나 match를 사용하는 경우 편리합니다.\n- 해당 기능은 단순 for문으로도 할 수 있지 않나요?: 가독성 측면에서 stream으로 구현하는 것이 좋을 때가 있다고 생각합니다.\n- stream이 for문보다 가독성이 좋다는 근거가 있을까요?: for 문은 어떤 컬렉션 안의 객체를 정의해주고 하나씩 돌려야 하는데, stream은 stream으로만 변환해주면 알아서 실행해주니까 더 편하다고 생각합니다.\n- 속도 측면에서는 어떻게 생각하시나요?\n- 일단은 for문이 더 빠르다는 건가요?\n- 충분히 메소드 분리를 통해 개선 여지가 있지 않나요?: 이중 for문을 사용하는 경우는 메소드 분리를 진행했습니다. 학습 목적과 가독성 측면에서 stream을 많이 사용했습니다.\n- for문의 가독성이 더 좋다고 생각하는 페어라면 어떻게 하실건가요?: 가독성과 성능 비교를 해보고 페어의 의견에 맞춰줄 것 같습니다.\n- 페어에 맞춰주지 못하는 부분이 있나요?: 메서드 중간에 공백을 두는 부분은 소신을 지키고 있습니다.\n- 테스트 하실 때도 공백을 두지 않으시나요?: 프로덕션에서만 두지 않는 편입니다.\n- view가 도메인에 의존하지 않아야 하는 이유는 무엇일까요?: 도메인 객체에 접근할 수 있기 때문에 뷰에 필요하지 않은 정보에도 접근할 수 있습니다.\n- 뷰에서 값을 보여줘야 하는데 도메인에서 가져오지 않으면 어떻게 가져오나요?: 도메인의 값을 원시값으로 풀어서 전달합니다.\n- 종단 연산에 관련된 함수 몇 개만 말씀해주세요. : foreach, count, sum\n- findAny, findFirst도 종단 연산일까요?\n- findAny, findFirst는 어떤 차이가 있나요?\n- shuffle이 된다는 것은 어떤 의미인가요?\n- stream을 사용하게 되면 리스트를 구성하는 순서가 바뀌게 되나요?\n- stream에서 중간 연산을 사용할 때 주의해야 할 점이 있을까요?: 실행이 안 되고 있다가 종단 연산이 오면 실행하는 거라서 단일 스트림이 아닌 병렬로 진행하면 고려해줘야 한다.\n- map, sorted, filter가 있을 때 어떤 순서로 배열해야 효율적일까요?\n- stream을 반환값으로 사용하면 안 된다고 하는데 왜 반환값으로 사용하면 안 되는지 설명해주실 수 있나요?\n- stream의 forEach를 지양해야 하는 이유가 무엇인지 말씀해주세요.\n\n### 피드백\n\n말을 더듬지 않고 차분한 어조로 말해주셔서 하고 싶은 말이 무엇인지 잘 전달됐습니다.   \n어려운 질문이 많았는데 꼬리 질문에 잘 대답하는 부분이 좋았습니다.   \n질문 답변이 간결해서 좋았습니다. 정확하게 질문에 대한 답변이 주어져서 좋았습니다.   \n\n인터뷰어의 페이스에 말리는 부분이 있어서 조금 아쉬웠습니다.   \n준비했던 말보다 페이스에 말린 질문을 많이 받은 것 같아서 안타까웠습니다.   \n\n\n## 여우\n\n### 질문\n\n- **in-out 설계와 out-in 설계 중에서 현재는 어떤 것을 선호하시나요? out-in 방식이 좋은 경우에는 어떤 때가 있을까요?**\n- 단위 테스트를 작성하는 자신만의 기준이 있으신가요?\n- **생성자 주입을 하지 않고 내부에서 값을 생성하는 경우가 좋았던 적이 있으신가요?**\n- getter는 어떤 경우에 사용해야 한다고 생각하시나요?\n- **서비스 레이어가 필요한 경우는 어떤 경우라고 생각하시나요? 현재 미션에서 서비스 레이어를 사용해야 하는 경우가 있으셨나요?**\n- 현재는 void 메서드를 테스트하시나요?\n- 현재는 예외 발생 이유를 구분해서 테스트하고 계신가요? 보완하는 방법으로는 어떤 방법이 있을까요?\n- **어느 정도까지 단위 테스트를 작성해야 한다고 생각하시나요?**\n- **블랙잭 미션에서 생성자 주입 이야기가 나왔는데, 현재는 고정적이지만 값이 변경되는 경우의 확장성을 고려해서 생성자 주입을 하는 것이 좋지 않을까요?**\n- 딜러와 참가자 객체 사이에 유의미한 차이가 없어지도록 어떻게 하셨는지 알려주실 수 있으실까요?\n- tdd의 필요성에 대해 어떻게 생각하시나요?\n- **static은 언제 사용하는 것이 좋을까요? 객체 인스턴스 생성과 static을 사용하는 여우만의 기준이 있을까요?**\n\n### 피드백\n\n눈을 마주치면서 말한 부분이 좋았습니다.    \n쉽게 풀어서 이야기 하는 부분이 좋았고, 어떤 경험으로부터 이런 생각을 하게 되었는지 말해주셔서 좋았습니다.    \n\n제 기준에서는 말이 조금 느렸던 것 같습니다.    \n질문에 대한 대답이 뒤쪽에 있어서 아쉬웠습니다.    "},{"excerpt":"함수형 인터페이스란? 함수형 인터페이스는 1개의 추상 메소드를 갖는 인터페이스를 말한다.\nSAM(Single Abstract Method) 인터페이스라고도 한다. default method, static method는 포함되어도 상관 없다. 함수형 인터페이스 생성하기 이렇게 추상 메서드를 하나만 갖도록 만들면 된다.  어노테이션은 없어도 되지만, 인터페이…","fields":{"slug":"/functional-interface/"},"frontmatter":{"date":"2023년 03월 28일 00:03","title":"함수형 인터페이스는 무엇이고, 람다와 어떤 관계가 있나요?","tags":["우테코","레벨1","학습로그"]},"rawMarkdownBody":"\n## 함수형 인터페이스란?\n\n함수형 인터페이스는 1개의 추상 메소드를 갖는 인터페이스를 말한다.\nSAM(Single Abstract Method) 인터페이스라고도 한다.\n\ndefault method, static method는 포함되어도 상관 없다.\n\n### 함수형 인터페이스 생성하기\n\n```java\n@FunctionalInterface\npublic interface Calculator {\n\tint sum(int x, int y);\n\tpublic default void defaultMethod();\n\tpublic static void staticMethod();\n}\n```\n\n이렇게 추상 메서드를 하나만 갖도록 만들면 된다.\n\n`@FunctionalInterface` 어노테이션은 없어도 되지만, 인터페이스 검증과 유지보수를 위해 붙여주는 게 좋다. 어노테이션을 사용하면 해당 인터페이스가 1개의 함수만을 갖도록 제한하게 된다. 여러 개의 함수를 선언하면 컴파일 에러가 발생한다.\n\n## 함수형 인터페이스와 람다의 관계\n\n### 람다란?\n\n함수를 하나의 식으로 표현한 것이다. 메소드의 이름이 필요 없어 익명 함수의 한 종류로 볼 수 있다.\n\n```java\npublic void printHello() {\n\tSystem.out.println(\"Hello\");\n}\n```\n\n위의 함수를 람다식으로 변환하면 다음과 같다. \n\n```java\n() -> System.out.println(\"Hello\");\n```\n\n함수형 인터페이스의 인스턴스를 만드는 방법으로 사용될 수 있고, 코드를 줄일 수 있다.\n\n### 함수형 인터페이스 구현\n\n함수형 인터페이스를 구현하는 방법에는 클래스를 이용하는 방법과 람다를 이용한 방법이 있다.\n\n인터페이스는 구현 클래스를 만들고 만든 클래스의 인스턴스를 생성해서 사용하는 과정을 거칠 수 있다.\n\n```java\nclass NormalCalculator implements Calculator {\n\t@Override\n\tint sum(int x, int y) {\n\t\treturn x + y;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tNormalCalculator normal = new NormalCalculator();\n\t\tint value = normal.sum(2, 3);\n\t}\n}\n```\n\n다만 이 방법은 구현 클래스가 한 번만 사용되고, 다른 곳에서는 사용되지 않는 경우 클래스 파일이 계속해서 생성되는 문제가 있다.\n\n클래스를 생성하지 않고 익명 클래스를 생성하여 구현하는 방법도 있다.\n\n```java\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tCalculator anonymousCalculator = new Calculator() {\n\t\t\t@Override\n\t\t\tint sum(int x, int y) {\n\t\t\t\treturn x + y;\n\t\t\t}\n\t\t};\n\t\tint value = anonymousCalculator.sum(2, 3);\n\t}\n}\n```\n\n익명 클래스를 생성하면 클래스를 명시적으로 정의하지 않고 바로 구현체를 정의할 수 있다. 클래스 선언 비용을 줄이고 코드 간결화를 위해 익명 클래스를 사용한다.\n\n### 람다를 사용한 함수형 인터페이스 선언\n\n람다를 사용하면 더욱 간결하게 선언할 수 있다.\n\n인터페이스에 추상 메서드가 하나이므로 인터페이스 구현 자체가 하나의 메서드 구현만을 의미한다. 즉, 함수와 같은 개념으로 이해할 수 있다. \n따라서 람다 표현식을 이용하여 함수를 구현할 수 있다.\n\n```java\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tCalculator lambdaCalculator = (x, y) -> x + y;\n\t\tint value = lambdaCalculator.sum(2, 3);\n\t}\n}\n```\n\n위의 코드들과 비교했을 때 코드의 직관성과 코드 길이가 차이가 나는 것을 볼 수 있다.\n람다식은 담길 변수의 타입에 해당하는 인터페이스를 사용하도록 만들어졌다.\n해당 인터페이스의 매개변수와 리턴타입만 맞춰주면 나머지는 알아서 처리한다.\n\n## 함수형 인터페이스를 사용하는 이유\n\n행위(함수)도 하나의 값으로 취급하기 위함이다. \n함수를 하나의 값으로 취급해서, 함수들을 조립하고 배치하면서 개발하기 위해 함수형 인터페이스를 사용한다.\n\n1. 동시성 side effect를 없앨 수 있다 : 기능을 하는 함수를 이용해 Side-effect가 없도록 선언형으로 개발한다.\n2. 구조적으로 유연하고 간결해진다 : 코드 재사용 단위가 클래스였던 것이 함수 단위로 가능하게 해주어 유연한 개발이 가능하다. 클래스 사이의 복잡한 연계를 줄일 수 있어 구조적으로 간결해진다.\n\n### 이번 주 스터디 피드백\n\n<베로오>\n이해가 잘 됐다. cooool 하다.\n기본 제공하는 함수형 인터페이스를 왜 패키지로 제공하는지에 대한 내용도 있었으면 좋았겠다.\n\n<헤에나>\n화면을 좀 자주 왔다갔다 해서 집중이 잘 안 됐다.\n추상 클래스 쪽 예시가 맞는 예시였는지 모르겠다. (베로 생각)\n페이지에 숫자라도 있었으면 좋았겠다.\n\n<훛추>\n예외의 발생 비용이 뭘까? -> 예외가 발생하면 어디서부터 발생했는지 찾는 스택 추적 비용이 발생하는데 비용이 크다.\n\n꼼꼼한 사용 방법 좋았다.\n메서드 구현체 내부 보여준 거 좋았다.\n예시가 있었다면 어땠을까?\n\n<포오이>\n굉장히 꼼꼼하게 준비했다. 굉꼼. 잘 보았다. 고생했다.\n내용이 알차다."},{"excerpt":"LOG 체스 미션 PR을 보냈다. 배운 것 궁금한 것 어려웠던 것 느낀 것","fields":{"slug":"/2023-03-27/"},"frontmatter":{"date":"2023년 03월 27일 11:03","title":"2023년 03월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 체스 미션 PR을 보냈다.\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"LOG 잠실캠 와서 공부했다. 잠실 오려고 아침으로 과외 옮겼다. 일요일에 잠실을 가니까 그냥 기분은 좋았다. 요즘은 집에만 있으면 재미가 없어서 잠실 오고 싶긴 하다. 방학 때는 잘 지낼 수 있을까? 아침 과외를 하게 된 후폭풍으로 좀 피곤했다. 컨디션이 좋지는 않았다. 어제도 기절하듯이 잠들어서 오늘은 제대로 잘 자고 싶다. 사실 지금도 좀 졸리다. …","fields":{"slug":"/2023-03-26/"},"frontmatter":{"date":"2023년 03월 26일 15:03","title":"2023년 03월 26일","tags":null},"rawMarkdownBody":"## LOG\n- 잠실캠 와서 공부했다. 잠실 오려고 아침으로 과외 옮겼다. 일요일에 잠실을 가니까 그냥 기분은 좋았다. 요즘은 집에만 있으면 재미가 없어서 잠실 오고 싶긴 하다. 방학 때는 잘 지낼 수 있을까?\n- 아침 과외를 하게 된 후폭풍으로 좀 피곤했다. 컨디션이 좋지는 않았다. 어제도 기절하듯이 잠들어서 오늘은 제대로 잘 자고 싶다. 사실 지금도 좀 졸리다.\n\n## 배운 것\n- DB connection을 사용할 때 재귀는 쓰지 말자.\n\n## 궁금한 것\n- DAO 로직은 어디까지 가도 될까... 😂\n- 상태 패턴의 다양한 상태들 중에 어떤 상태만 필드를 가지고 있는 경우, 해당 클래스는 테스트를 어떻게하면 잘할 수 있을까?\n\n## 어려웠던 것\n- 컨디션 관리\n- 미루지 않는 습관\n\n## 느낀 것\n- 여러 가지 일들이 있었다. 아침부터 이것저것 일이 많았는데, 어떻게 잘 끝난 것 같기도 하고 아닌 것 같기도 하다. 어떤 부분에서는 좋을 수도 있고, 아닐 수도 있다. 지금 상황은 나중에 다시 확인해봐야 좋은지 아닌지 판단할 수 있을 거 같다.\n- 집안일을 많이 못했다. 결국 남은 건 내일의 내가 하게 됐다. 잘 부탁해~\n- 곧 레벨1이 끝난다. 내가 원하던 것을 많이 이뤘는지 궁금하다. 나는 잘 하고 있었을까? 분명 다른 사람이 된 것은 맞다. 그것만으로도 내가 많이 성장했다고 느낀다. 그럼에도 아직 나아지지 않은 부분들은 있다고 생각한다. 그것도 미래의 나에게 부탁해야겠다. 잘 부탁해~\n"},{"excerpt":"LOG 새싹교실했다. 한 분은 나보다 나이가 많았다. 편입생 두 분이랑 새내기 한 명이라 좀 머쓱한 조합이었다 ㅋㅋ 이번 새싹교실은 질문을 좀 많이 받고 싶어서 질문 많이 해달라고 자료에도 써놨다. 과연 질문을 많이 할 수 있게 될 지..? 그치만 나도 배울 때는 어떤 걸 질문해야 할 지 몰라서 그냥 없다고 말했던 적이 있다. 그렇다보니 질문이 쉬운 환경…","fields":{"slug":"/2023-03-25/"},"frontmatter":{"date":"2023년 03월 25일 14:03","title":"2023년 03월 25일","tags":null},"rawMarkdownBody":"## LOG\n- 새싹교실했다. 한 분은 나보다 나이가 많았다. 편입생 두 분이랑 새내기 한 명이라 좀 머쓱한 조합이었다 ㅋㅋ 이번 새싹교실은 질문을 좀 많이 받고 싶어서 질문 많이 해달라고 자료에도 써놨다. 과연 질문을 많이 할 수 있게 될 지..? 그치만 나도 배울 때는 어떤 걸 질문해야 할 지 몰라서 그냥 없다고 말했던 적이 있다. 그렇다보니 질문이 쉬운 환경은 아니긴 하지. 앞으로 수업할 때 열심히 해보려고 한다. 내가 시간을 얼마나 많이 낼 수 있을지는 모르겠지만...\n- 여유가 좀 있어서 바닥 청소를 좀 했다. 곧 방 점검이 있어서 깨끗하게 치워둬야 한다. 그렇지만 귀찮다... 할 것도 많고.. 할 게 많을 때 가장 뒤로 미뤄지는 게 청소인 거 같다. 오늘 집안일을 많이 해치워버릴 생각이었는데 생각보다 많이 못했다. 내일은 어떻게든 다 치워야 한다. 파이팅..!이라고 생각했는데 내일 잠실 가기로 해서 큰일났는데?\n- 과외를 10시-12시로 바꿨다. 원래 1시라서 좀 더 잤는데 주말에 잠실 가고 싶어서 앞으로 시간을 조정했다. 집에만 있다보니 별로 공부가 잘 되는 거 같지 않다.\n- 성하의 글쓰기 리뷰를 안 했다는 사실을 알게 되었다...! 너무 죄송해서 얼른 발견하자마자 달았다 ㅠ 글쓰기 리뷰는 다 한 줄 알고 확인도 안 했는데 확인하길 잘했다.\n- 점심을 먹었다고 방심했더니 저녁을 안 먹었다 ㅋㅋ 그냥 이럴거면 잠실캠 가서 밖에서 사먹는 게 나을 듯.\n\n## 배운 것\n- c++의 ```empty vector```에서 ```back()```을 호출하면 에러가 발생한다.\n- ```markdown```에 코드 블럭에 sql을 사용할 수 있다.\n\n## 궁금한 것\n- 간결합되어 있는 객체 사이에서의 양방향 의존은 괜찮은가?\n- 클래스 이름으로 데이터를 저장하는 것은 별로 좋지 않은 방법일까?\n\n## 어려웠던 것\n- 그냥 오늘은 좀 어려웠다.\n\n## 느낀 것\n- 생각이 정리가 안 된다. 뭐가 맞는걸까? 아직 생각의 양이 부족하다. 앞으로 어떻게 하고 싶은지도 아직 못 정했다. 내가 어떻게 생각하고 있는지도 잘 모르겠다. 확신이 없어서 그렇다. 내 상태는 잘 알고 있으면서도 왜 망설이는지? 알 수 없다. 나도 내가 뭘 하고 싶은 건지 알고 싶다.\n- 목표가 없다. 목표를 정하고 나아가는 사람들이 멋지다고 생각한다. 나는 뭘 하고 싶은걸까? 우테코에 와서 내가 이루고 싶은 건 뭘까? 결국 내가 뭘 하기 위해서 지금 이러고 있을까? 지금 생각해보면 나한테 중요한 게 없다. 그냥 행복하고 싶다. 그런데 행복이 장기적인 목표라고 하기에는 이룰 수 없는 것이다. 단기적으로만 존재할 수 있으니까. 그렇다고 대충 살 수 있느냐 하면 그것도 아니다. 일단은 열심히 하는 걸 좋아한다. 대충 사는 것보단 그게 나으니까. 열심히 하다보면 행복해질 수 있을 거라 생각했다. 가끔은 그렇다. 그렇지만 매일 그렇지는 않다. 오늘 저녁에도 생각한다. 나는 왜 열심히 할까? 내가 이루고 싶은 건 뭘까? 내가 하고 싶은 건 뭘까? 내가 대충 살면 안 되는 이유가 있을까? 그래서 아직 사는 이유가 없다. 미련도 딱히 없다. 아직 못 찾았다. 올해는 찾을 수 있을까?\n"},{"excerpt":"LOG 말랑과 말을 놓았다. 말랑이 실수해서 말을 놨는데 ㅋㅋㅋ 나는 말 놓는 거 좋아서 놓자고 했다. 저녁에 3단계 구현하는 거 말랑이 도와줬다. 말랑도 4단계 전까지는 상태 패턴 썼다고 해서 도움을 많이 받았다. THANK YOU, MALLANG 주노, 글렌, 포이와 깊은 대화(?)를 했다. 주노가 나랑 정말 비슷한 생각을 가지고 있어서 신기했다. 주…","fields":{"slug":"/2023-03-24/"},"frontmatter":{"date":"2023년 03월 24일 03:03","title":"2023년 03월 24일","tags":null},"rawMarkdownBody":"## LOG\n- 말랑과 말을 놓았다. 말랑이 실수해서 말을 놨는데 ㅋㅋㅋ 나는 말 놓는 거 좋아서 놓자고 했다. 저녁에 3단계 구현하는 거 말랑이 도와줬다. 말랑도 4단계 전까지는 상태 패턴 썼다고 해서 도움을 많이 받았다. THANK YOU, MALLANG\n- 주노, 글렌, 포이와 깊은 대화(?)를 했다. 주노가 나랑 정말 비슷한 생각을 가지고 있어서 신기했다. 주변 사람들을 정말 잘 챙기는 것 같아서 본받고 싶어졌다.\n- 헤나, 후추, 포이와 스터디했다. 뭔가 웃길까봐 걱정했는데 다행히 진지한 분위기를 유지할 수 있었다. 다들 대답도 잘하고 공부 많이 했다는 느낌이 들었다. 나도 이제 거기서 공부했던 내용에 대해서는 잘 말할 수 있을 거 같다!\n- 데일리 미팅 때 칭찬당했다. 이상한 말들도 많았지만 ㅋㅋㅋ 내 칭찬도 좋지만 주변 사람들 칭찬을 공식적으로 할 수 있어서 좋았다. 칭찬 안 좋아하는 사람은 없으니까~\n- 기숙사에 못 들어갈 뻔했다 ㅋㅋㅋ 내가 시간을 잘못 알고 있었어서 바깥 벤치에서 잘 뻔했다. 어떤 착한 분이 문을 열어주셔서 다행히 방에서 잘 수 있었다 ㅋㅋ 이제라도 알았으니 다행이야~\n- 브라운과 상담했다. 내 또래가 아닌 다른 입장에서 의견을 들으니 또 느낌이 달랐다. 다 비슷한 결론을 내주시긴 했지만 갈수록 확신이 드는 느낌이었다. 그래도 아직 완벽하게 생각 정리가 되지는 않았다. 좀 더 생각할 시간이 필요하다.\n\n## 배운 것\n\n## 궁금한 것\n- 테스트: stub, fake\n- Solitary Unit Test, Sociable Unit Test -> [단위 테스트](https://algopoolja.tistory.com/119)\n\n## 어려웠던 것\n- 이번 주는 새로운 사람들과 많이 말하지 못했다.\n\n## 느낀 것\n- 내가 힘든데 힘들다고 생각을 못하는 건가, 힘들지 않아서 힘든 생각이 안 드는 건지 문득 의문이 들었다. 지금 생각으로는 안 힘든게 맞는 거 같다. 힘든 것과 스트레스 받는게 같은건가? 힘들다고 생각은 안 든다. 몸은 좀 힘들다. 아직도 잠이 부족하다. 더 자고 싶다.. 😂\n- 이런 생각을 한다는 건 상황이 많이 나아져서 그렇다. 작년까지만 해도 이런 생각 자체를 할 수가 없는 상태였다. 진짜 심신미약이었다. 내가 많이 여유가 생겨서 그런가 보다. 그때는 그냥 일어나서 과제하는 것 자체가 힘들었는데 지금은 그렇지 않으니까 말이다. 자괴감과 자기 비하에서 어느정도 빠져나온 것 같아 기분이 좋다.\n\n"},{"excerpt":"3/24 면접 동등성과 동일성 동일성과 동등성의 차이는 무엇인가요?: 후추 꼬리질문- 해쉬값의 무결성이란? hashcode를 제대로 정의했다면 equals에서 문제가 발생하지 않는다는 뜻인가? : 후추 == 연산자와 equals 연산자는 어떤 차이가 있는가? 각 인스턴스가 본질적으로 고유한 경우에도  를 재정의하는 것이 좋을까요?: 헤나 enum 같은 경…","fields":{"slug":"/vepohuhemal-study-question/"},"frontmatter":{"date":"2023년 03월 24일 01:03","title":"베포후헤말 스터디 면접 질문 준비","tags":["스터디","우테코"]},"rawMarkdownBody":"\n# 3/24 면접\n\n## 동등성과 동일성\n\n- **동일성과 동등성의 차이는 무엇인가요?: 후추**\n- **꼬리질문- 해쉬값의 무결성이란? hashcode를 제대로 정의했다면 equals에서 문제가 발생하지 않는다는 뜻인가? : 후추**\n- == 연산자와 equals 연산자는 어떤 차이가 있는가?\n- **각 인스턴스가 본질적으로 고유한 경우에도 `equals` 를 재정의하는 것이 좋을까요?: 헤나**\n- **enum 같은 경우에는 `equals`를 정의하지 않나요?: 헤나**\n- 언제 `equals` 를 재정의하지 않아도 되나요?\n- 언제 재정의하면 안 되나요?\n- **`equals`를 사용자 정의한다고 했을 때, `equals` 메서드에 들어가야 할 구현은 뭐가 있을까요?: 포이**\n\n## 불변 클래스\n\n- **프로그래밍 할 때 모든 클래스는 불변 클래스로 만드는 쪽으로 설계하는 것이 좋다고 생각하시나요?: 헤나**\n- 불변성이 뭔가요?\n- **불변 객체도 리플렉션을 사용해서 불변성을 깰 수 있는데 그래도 불변 객체가 맞을까요?: 헤나**\n- **클래스 확장을 막는 경우 어떤 장단점이 있나요?: 후추**\n- 불변 클래스를 왜 써야 하나요?\n- **불변 클래스의 내부에 리스트 필드를 갖는 클래스는 불변 클래스가 될 수 있을까요? 어떻게 불변 클래스로 만들 수 있을까요?: 포이**\n\n## 접근 제어자\n\n- **`private`의 접근 범위는 어디까지일까요?: 헤나**\n- `protected`, `package-private` 이 어떻게 구분되어 사용되면 좋을까요?\n- **하위 클래스가 같은 패키지에 있을 때에도 `package-private`이 아닌 `protected` 를 쓸 필요가 있다고 생각하시나요?: 포이**\n- **생성자를 `private`으로 만들 때 예외를 던지시는 편인가요?: 후추**\n\n## 디폴트 메서드\n\n- **디폴트 메서드는 어떨 때 사용하면 좋나요?: 후추** -> 기존의 인터페이스를 수정할 일이 있을 때 사용하면 좋다. 기존에 있던 코드를 재사용할 때\n- 추상 클래스의 구현 메서드와 인터페이스의 디폴트 메서드는 어떤 점이 다른가요?\n- **디폴트 메서드의 단점은 어떤 것이 있을까요?: 헤나**  -> 남용할 가능성이 높다.\n- 디폴트 메서드를 사용하지 않는 다른 언어에서는 어떻게 해결하고 있나요? -> \n- 디폴트 메서드 사용하기 이전에는 어떤 식으로 문제를 해결했을까요?\n- 디폴트 메서드를 사용해서 실제로 발생했던 문제는 어떤 것이 있나요?\n- **거의 대부분이 같은 기능을 하고, 일부만 다른 기능을 구현할 때 `abstract`를 쓰는 것이 좋나요, 아니면 디폴트 메서드를 쓰는 게 좋나요?: 포이** -> abstract가 더 낫다. 오버라이딩에 경고가 뜨지 않는다. 하위 클래스가 이렇게 구현했다고 알 수 없기 때문에.\n\n## 피드백\n\n### 헤나\n\n- 칭찬: 쫄지 않고 잘 말했다. 대답할 때 적절한 시선 처리.\n- 성장점: 모르면 모른다고 말하자. 질문이 이해가 안 된다면 다시 물어보자. 답변에 대한 이유가 있는 게 좋을 거 같다.\n\n### 후추\n\n- 자세가 좋았다. 대답할 때 질문한 사람을 쳐다보는 게 좋았다. 겁없이 안정적인 느낌.\n- 질문이 이해가 안 된다면 다시 물어보자.\n\n### 베로\n\n- 빠르게 동의하는 게 좋았다. 이전 의견에 대한 근거 말해준 것도 좋았다. 리액션이 좋았다. 대답의 당참. 질문 이해가 안 간다고 말한 것. 자세, 말하는 톤, 행동 좋았다.\n- 성장점: 기술에 대한 부적절한 대답. 어떤 의견을 물어볼 땐 트레이드오프를 말해주는 게 좋을 거 같다.\n\n### 포이\n\n- 모르면 모른다고 말했음. 이해 안 됐을 때 말한 거, 차분하게 생각해 달라고 말한 거 좋았다. \n- 트레이드 오프 말하기. 근거는 뭔지 말하면 좋을 거 같다. 답변에 대한 이유가 있는 게 좋을 거 같다.\n\n# 4/7 면접\n\n## 면접 정리\n\n### 리소스 자동 반납\n\n- 예외가 `try`, `finally` 모두에서 발생할 수 있기 때문에 `finally` 로 자원 회수 코드를 명시해줘도 문제가 발생할 수 있다.\n- 예외가 두 곳에서 발생하는 경우 두 번째로 발생한 예외가 첫 번째 예외를 삼키게 되어 디버깅이 어려워진다.\n\n#### 추가로 알게 된 내용\n- Garbage Collector는 메모리 용량에 따라 소멸 여부를 결정한다. 데이터 제거 순서는 무작위이다.\n\n#### finalize() 는 언제 쓸까?\n- 명시적 종료 메서드 패턴에서 호출되지 않을 것을 대비하기 위한 방어 역할을 위해 `finalize()` 를 재정의한다.\n\t- `FileInputStream` 에서 명시적으로 종료 메서드를 호출하지 않았을 경우를 대비해 `finalize()` 메서드에 메모리 해제를 하도록 재정의되어 있다.\n- 네이티브 피어 리소스(다른 언어로 작성된 프로그램을 자바에서 다루기 위해 만들어 놓은 객체)를 해제할 때 사용한다. 일반 객체가 아니어서 GC가 관리하지 않기 때문이다.\n- [참고 자료](https://camel-context.tistory.com/43)\n\n### Optional\n- [참고자료](https://mangkyu.tistory.com/70)\n\n## Enum\n\n- **enum을 사용해서 singleton을 만들라는 말이 있는데, 그렇게 하면 어떤 이점이 있을까요?** : 헤나\n- enum을 사용해야 하는 이유가 있을까요?\n- **enum을 언제 사용하셨나요? 어떨 때 enum을 사용해야 한다는 기준이 있으신가요?** : 포이\n- **enum 대신 클래스를 사용하는 것이 좋은 경우는 언제인가요?** : 포이\n- enum의 컴파일 타임 안전성에 대해 알고 계시나요?\n- **enum의 ordinal 메서드를 사용해보신 적 있나요? ordinal 메서드를 사용하는 것에 대해 어떻게 생각하시나요?** : 후추\n- **ordinal 메서드는 왜 만들어졌을까요?** : 후추\n- **enum의 `name()`, `toString()` 은 어떻게 나눠서 써야할까요?** : 헤나\n- **enum의 `toString()` 을 사용자 필요에 의해 재정의하는 것에 대해 어떻게 생각하시나요?** : 헤나\n- **enum의 단점은 뭐가 있을까요?** : 헤나, 후추\n- **enum의 생성자가 private 인데, 그 이유가 뭐라고 생각하시나요?** : 후추\n\n## 함수형 인터페이스\n\n### 기본 질문\n- 함수형 인터페이스의 동시성 이슈를 없앨 수 있다는 것이 무슨 의미인가요?\n- 함수형 인터페이스의 종류에는 어떤 것이 있나요?\n- Object 객체의 메서드만 인터페이스에 선언되어 있는 경우에는 함수형 인터페이스가 맞을까요?\n- **자바의 표준 함수형 인터페이스 중에 써 본 거 말해주세요.** : 헤나\n- **람다란 무엇인가요?** : 후추\n\n### 의견 질문\n- **함수형 인터페이스에서 static method, default method를 사용하는 게 적절하다고 생각하시나요?** : 헤나\n- **익명 클래스를 썼을 때보다, 람다를 이용한 방법의 장점이 어떤 것이 있다고 생각하시나요?** : 포이\n- **클래스를 선언하는 것은 문서화 과정 중의 하나라고 생각하는데, 람다식을 쓰는 것보다 클래스를 선언하는 게 낫지 않을까요?** : 후추\n- **함수형 인터페이스 구현 시에 익명 클래스를 쓰는 것이 더 좋은 경우가 있나요?**: 포이\n- 불필요한 함수형 인터페이스를 만들지 말고 표준 함수형 인터페이스를 사용하라는 말이 있는데 왜라고 생각하시나요?\n- **함수형 인터페이스를 쓰면서 좋았던 점이 있나요?** : 헤나\n\n## try-with-resources\n\n### 기본 질문\n- try-with-resources가 garbage collector가 관리하는 방식보다 나은 점이 무엇인가요?\n- **`try/catch/finally` 문에서 메모리 누수가 일어날 가능성이 있는 이유는 무엇인가요?** : 헤나\n- `finalize()` 함수는 어디에 정의되어 있는 함수인가요?\n- **garbage collector의 수집 대상이 되는 객체는 어떤 객체인가요?** : 포이\n- `finalize()` 함수의 단점은 무엇인가요?\n- 그럼 `finalize()` 함수는 언제 사용해야 하나요?\n- **try-with-resources의 장점은 무엇인가요?** : 후추\n- **garbage collector가 자원을 해제해 줄 것인데 왜 자원 해제를 해줘야 할까요?** : 후추\n\n### 의견 질문\n- **자바에서 개발자가 garbage collector 한테 지금 당장 객체를 파괴하도록 강제할 수 없게 만든 이유가 뭐라고 생각하시나요?** : 후추\n\n## Optional\n\n### 기본 질문\n- **Java에서 Optional이 왜 등장했다고 생각하시나요?** : 후추\n- Optional의 `ofNullable()`, `of()` 의 차이점은 무엇인가요?\n- **Optional의 `orElse()` 와 `orElseGet()` 의 차이점은 무엇인가요?** : 베로\n- Optional은 어떻게 사용했을 때 가장 좋을까요?\n- **Optional을 반환타입으로만 사용해야 하는 이유가 뭘까요?** : 헤나\n\n### 의견 질문\n- null을 반환하는 것의 단점은 무엇일까요?\n- **`orElse()` 는 언제 써야 할까요?** : 후추\n- Optional을 사용하신 적이 있나요? 어떤 경우에 사용하셨었나요? 언제 사용하면 좋을까요?\n- Optional을 사용할 때 단점이 있을까요?\n- **Optional이 아닌 null을 반환해야하는 경우도 있을까요?** : 포이\n- **필드의 일부 혹은 전체가 null일 수 있는 상황에서도 Optional을 필드로 사용해서는 안 될까요?** : 헤나\n- **Optional은 언제 사용하는 것이 좋을까요?** : 헤나\n- 반환 인자가 generic으로 선언되어 있을 때, 함수형 인터페이스가 들어갈 수 있을까요?\n\n## 피드백\n\n### 헤나\n- 좋은 점: 아는 부분에 대해 예시를 들어가면서 자세하게 답변하는 모습이 좋았다. 단점 말할 때 장점도 같이 말해주는 게 좋았다. 질문을 제대로 이해했는지 다시 물어보는 부분이 좋았다.\n- 성장점: 답변하는 문장의 호흡이 길다. 문장을 마무리하는 부분을 고치면 좋을 것 같다.\n\n### 후추\n- 좋은 점: 굉장히 차분하게 잘 말한다. 잘 모르는 부분도 잘 말해서 대단하다. 어... 같은 말을 안 써서 말을 듣기 편하다. 빠른 인정 좋다. 어떻게 방금 본 내용을 그렇게 잘 말할까. 목소리 톤이 안정적이다. (감기임) \n- 성장점: \n\n### 베로\n- 좋은 점: 생각하는 부분, 아는 부분에 대해서는 잘 말했다. 질문을 잘 알아들어서 좋았다.\n- 성장점: 생각할 때 음, 어라는 말이 많았다. 답변이 길어지니 질문에서 벗어난 답변을 하는 것 같다.\n\n### 포이\n- 좋은 점: 자신감 있게 말하는 부분이 좋았다. 예시를 요구하는 부분 좋았다. GC 설명하는 거 잘했다.\n- 성장점: 짧은 답변이 많아서 좀 더 자세하게 말해줬으면 좋겠다. 덧붙여서 말해주는 게 있으면 좋겠다. \n\n# 4/20 면접\n\n## JDBC\n\nSQLException은 catch 블록으로 반드시 처리해야 하는 checked 예외이다.\n대부분의 데이터베이스 연결 생성 실패나, 작성 오류가 있는 쿼리같은 오류들은 대부분 catch로 해결할 수 없어서 상위 코드로 예외 처리를 넘겨야 한다.\n\n명령문이나 데이터베이스 연결 객체를 생성하는 코드, 객체들을 cleanup 하는 코드가 없어서 가독성이 좋다. 비즈니스 로직에 좀 더 집중할 수 있다.\n\n## GRASP\n\n- **GRASP 원칙 중에서 가장 중요하게 지켜져야 하는 규칙은 무엇이라고 생각하시나요? 그 이유는?** : 후추\n- **결합도가 극단적으로 낮으면 항상 좋은 걸까요?** : 후추\n- **낮은 결합도를 위해서는 어떠한 것들을 할 수 있을까요?** : 후추\n- **응집도가 극단적으로 높은 것은 언제나 좋은 것일까요?** : 말랑 \n- **왜 응집도를 높이면 결합도가 높아질까요?** : 말랑\n- **Pure Fabrication(순수 조립)의 단점은 어떤 것이 있나요?** : 말랑\n- (정보 전문가 패턴) **책임을 할당할 객체를 정할 때 주로 어떻게 정하는 편이신가요?** : 포이\n- 결합도가 높을 때의 장점은 없을까요? / 응집도가 낮을 때의 장점은 없을까요?\n- **클래스 분리는 어떤 기준으로 하시나요?** : 포이 / 클래스 분리는 어떤 때에 수행되어야 할까요?\n- **간접 참조를 사용하게 되면 중간 객체가 생겨 오히려 복잡한 설계가 되지 않을까요? 어떤 때에 간접 참조를 사용하면 좋을까요?** : 포이\n\n## GRASP\n\n- GRASP 원칙 중에서 가장 중요하게 지켜져야 하는 규칙은 무엇이라고 생각하시나요? 그 이유는? : 후추\n- 결합도가 극단적으로 낮으면 항상 좋은 걸까요? : 후추\n- 낮은 결합도를 위해서는 어떠한 것들을 할 수 있을까요? : 후추\n- 응집도가 극단적으로 높은 것은 언제나 좋은 것일까요? : 말랑 \n- 왜 응집도를 높이면 결합도가 높아질까요? : 말랑\n- Pure Fabrication(순수 조립)의 단점은 어떤 것이 있나요? : 말랑\n- (정보 전문가 패턴) 책임을 할당할 객체를 정할 때 주로 어떻게 정하는 편이신가요? : 포이\n\n## ArgumentResolver\n\n- ArgumentResolver 는 무엇인가요?\n- ArgumentResolver는 언제 호출이 될까요?\n- 인자가 전달되면 메서드에서 어떤 과정이 진행되는지 말해주세요\n- ArgumentResolver를 사용한 적이 있으신가요?\n- 왜 인터셉터에서 파라미터가 있는지 없는지 확인해야 할까요?\n- ArgumentResolver에서 Jwt를 변환해줄 수 있는데, 다른 위치에서 변환을 해보신 적도 있나요?\n\n## DI, Spring의 의존성 주입 방식\n\n- 양방향 의존 관계에 대해서는 어떻게 생각하시나요? : 헤나\n- 양방향 의존이 필요한 경우가 있을 수 있다고 하셨는데, 어떤 경우에 양방향 의존이 필요할까요? : 헤나\n- 의존 관계에 대해 설명해주세요 : 헤나\n- Spring한테 의존성 주입을 맡기는 것에 대한 이점이 있을까요? - scope를 자유자재로 바꿀 수 있다. 설정해야 하는 코드가 사라진다.\n\n## JDBC\n\n- 자바에서 데이터베이스에 접근하는 코드를 작성할 때 필요한 객체가 어떤 게 있었나요?: 헤나\n- 사용자가 JdbcTemplate을 사용할 때 정의해야 하는 일이 무엇이 있을까요? : 헤나\n\n# 4/28 면접\n\n## Auto-Configuration\n\n추가된 jar 의존성을 바탕으로 Spring 애플리케이션을 자동으로 구성한다. Auto-configuration은 custom configuration으로 대체될 수 있다.\n\nauto-configuration을 구현하는 클래스에 `@AutoConfiguration` 어노테이션을 달아야 한다.\n\n일반적으로 auto-configuration 클래스는 `@ConditionalOnClass` 나 `@ConditionalOnMissingBean` 어노테이션을 사용한다.\n\nSpring Boot는 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일이 있는지 확인한다. 해당 파일은 configuration 클래스가 한 줄에 하나의 클래스 이름으로 나열되어 있어야 한다.\n\nconfiguration을 특정 순서로 사용해야 하는 경우, `@AutoConfiguration` 어노테이션 또는 `@AutoConfigureBefore`, `@AutoConfigureAfter` 어노테이션을 사용할 수 있다.\n\nuser configuration, condition evaluation 등 다양한 요소의 영향을 받을 수 있다.\n\n## 질문\n\n- `AutoConfiguration` 을 사용해보신적 있으신가요?\n- `AutoConfiguration` 이 무엇인가요?\n- `WebMvcTest` 가 꼭 필요하다고 생각하시나요? : 포이\n- 기본 에러 페이지에서 url만 알면 마음대로 error 페이지에 접근할 수 있다는 단점이 있다고 하셨는데, 왜 이게 단점이라고 생각하시나요? : 포이\n- 커스텀 예외를 사용하시나요? 사용하신다면 왜 사용하시는지 궁금합니다.\n- WebMvcTest의 `excludeFilters` 에 대해 설명해주세요.\n- `@Order` 어노테이션을 사용하는 것에 대해 어떻게 생각하시나요?\n- `@ControllerAdvice` 에서 json을 리턴하는 것에 대해 어떻게 생각하시나요? : 포이\n- `@ControllerAdvice` 에서 커스텀 예외를 지정할 수도 있고, validation 어노테이션의 message를 사용하는 방법도 있는데 어떤 방법이 더 낫다고 생각하시나요? : 헤나\n- `HandlerAdapter` 의 매개변수가 왜 `HandlerMethod`가 아니라 `Object` 일까요? -> 컨트롤러로 요청을 넘겨주기 전에 처리해야 하는 인터셉터 등을 포함하기 위해서 : 헤나\n- `DispatcherServlet`이 맡는 공통 작업은 무엇인가요? : 헤나\n- `WebMvcTest` 가 `SpringBootTest` 와 비교했을 때 어떤 부분이 다른가요?\n- 통합 테스트가 어려운 상황에는 어떤 것이 있을까요? : 헤나\n- controller 테스트가 필요하다고 생각하시나요? : 말랑\n- controller 테스트에서 체크해야 하는 건 뭐가 있을까요? : 말랑\n- qualifier 랑 primary 어노테이션의 우선순위가 뭘까요? : 말랑\n- DispatcherServlet이 있을 때와 없을 때의 차이에 대해 말해주세요. : 말랑\n- DispatcherServlet에서 어떤 과정을 거쳐서 적절하게 요청을 처리하는지 설명해주세요. : 포이\n- `HandlerExecutionChain` 을 직접 실행하지 않고, `HandlerAdapter` 를 통해 실행하는 이유가 무엇일까요? -> 컨트롤러는 다양하게 구현되어 있으므로, 구현 방식에 상관 없이 요청을 위임하도록 어댑터 패턴을 사용한다. : 헤나\n- DispatcherServlet을 한 문장으로 설명해주세요. : 헤나\n\n## 알려주고 싶은 내용\n\n- DispatcherServlet의 patch 메서드 처리만 다르다. doPatch만 없음.\n\n# 5/15 면접\n\n## 쿠키와 세션, 토큰을 이용한 인증\n- 인증: 유저가 서비스에 등록된 유저인지 확인하는 것\n- 인가: 유저가 해당 요청에 대한 권한을 갖는지 확인하는 것\n\n### HTTP의 Connectionless\n클라이언트와 서버가 요청과 응답을 한 번 주고받으면 연결을 끊어버리기 때문에 항상 새로운 연결을 맺어야 한다. 이런 요청들에 대한 정보의 상태는 저장하지 않는다. \n따라서 여러 서버가 존재하는 환경에서 클라이언트 요청에 대해 어떤 서버가 응답하더라도 상관 없다. \n이런 경우 인증 정보도 유지되지 않아 계속해서 인증 정보를 보내야 한다는 문제가 있다. \n\n### 쿠키\nkey-value 형태로 저장되는 작은 데이터. 웹 서버에 요청할 때 헤더에 쿠키를 담아 전송한다.\n만료 날짜까지 유지되는 영속 쿠키, 브라우저가 종료되기 전까지 유지되는 세션 쿠키가 있다.\n쿠키는 사용자가 임의로 변경할 수 있다. \n\n세션 하이재킹: 인증이 완료된 사용자의 브라우저에서 인증 정보가 담긴 세션 쿠키를 탈취하여 로그인 없이 서버와 통신하는 것\n\n### XSS & HTTP Only 쿠키\nXSS는 공격자가 악의적인 스크립트 코드를 삽입하여 의도치 않은 명령을 실행시키거나 세션을 탈취하는 공격\nHTTP Only 쿠키는 개발자가 간단한 접미사를 쿠키 생성 코드에 추가함으로써 활성화할 수 있다.\n\n```java\nSet-Cookie: 쿠키명=쿠키값; path=/; HttpOnly\n```\n\n브라우저에서 해당 쿠키로 접근할 수 없게 되지만, 쿠키에 포함된 정보의 대부분이 브라우저에서 접근할 필요가 없어 HTTP Only Cookie는 기본적으로 적용하는 것이 좋다.\n\n그러나 여전히 네트워크를 직접 감청하는 등의 방식으로 쿠키 탈취가 가능하다. \n이를 위해 HTTPS 프로토콜을 사용하여 쿠키에 대한 정보를 암호화해서 전송할 수 있다.\n\n그럼에도 쿠키는 기본적으로 모든 요청에 포함되기 때문에 쿠키의 정보는 전달되게 된다.\nSecure 쿠키: HTTPS 프로토콜을 사용할 때만 쿠키를 전달하는 방법이 있다.\n\n### 세션\n민감한 정보들을 서버에 저장하고, 연결을 유지하는 방법이다.\n인증된 사용자의 식별자에 대응하는 임의의 문자열 session id를 생성한다.\n\n쿠키는 클라이언트에 저장되며, 세션은 서버에 저장되므로 쿠키에 비해 비교적 안전하다.\n세션은 쿠키에 비해 느리다. 서버에 동시 접속하는 사용자가 많아지면 메모리 공간이 부족해져서 서버에 부하가 걸린다.\n여러 기기에서의 로그인을 제한하기 위해 필요한 때에 로그인 되어 있는 사용자를 강제로 로그아웃을 시킬 때 사용하기도 한다. \n\n스케일 아웃으로 서버를 확장하게 되면, 서버 별로 세션을 따로 관리하기 때문에 세션 불일치 문제가 발생한다. \n\n#### Sticky Session\n동일한 클라이언트의 요청을 처음 요청이 처리된 서버로만 보내는 것. 로드밸런서 설정으로 변경할 수 있다. \n\n그러나 트래픽이 한 곳으로 몰릴 수 있고, 서버의 가용성을 최대한 활용하지 못한다는 단점도 존재한다.\n또한 하나의 서버에 장애가 발생하면 해당 서버를 사용하는 사용자는 세션 정보를 잃어버리게 된다. \n\n#### Session Clustering\n특정 서버에서 세션이 생성되는 경우, 다른 서버로 전파해서 세션을 복제하는 방식으로 세션 불일치를 해결한다.\nTomcat 에서는 All-to-all 세션 복제를 사용한다. 변경 요소가 발생하면 변경 사항이 모든 세션에 복제된다.\n\n유저가 어떤 서버에 접속하더라도 로그인 정보가 세션에 복제되어 있어 정합성 이슈가 해결된다.\n그러나 모든 서버가 동일한 세션 객체를 가져야 하므로 많은 메모리가 필요하다. 또한 서버 수에 비례하여 네트워크 트래픽이 증가한다. -> 소규모 클러스터에서 좋은 효율을 보여준다.\n\n#### Session Server 분리\n세션을 저장하는 세션 서버를 외부 서버로 분리하여 사용한다.\n세션 서버로는 입출력이 잦은 세션의 특성 상, In-Memory DB인 Redis를 사용하는 것이 일반적이다.\n\n새로운 서버를 띄우더라도 기존 서버의 수정이 발생하지 않는다.\n그러나 외부 서버를 거쳐야 하므로 성능이 조금 느려지며, 분리된 세션 서버가 죽는 순간 모든 세션이 사라지기 때문에 해당 세션 서버의 다중화와 데이터베이스의 Reflecation도 고려해야 한다. (가용성을 확보하기 위해 동일한 세션 저장소 하나를 더 구성하여 복제한다.)\n\n### 토큰\n토큰 기반 인증은 쿠키와 비슷하게 인증 정보를 클라이언트에 저장한다. 쿠키나 로컬 스토리지에 저장되게 된다.\n`Authorization` 헤더에 실어 보내고, 토큰의 위변조, 만료 시간을 확인하고 인증 정보를 확인하여 사용자를 인가한다. \nJWT 는 쉽게 복호화 가능하므로, 중요한 개인 정보를 넣어서는 안 된다.\n\n세션 방식에 비해 scale out 관점에서 별도로 처리해주어야 할 것들이 없어진다.\n세션에 비해 서버에 전송되는 데이터의 양이 훨씬 많다. 또한 바로 데이터를 확인 가능하기 때문에 민감한 데이터를 담으면 안 된다는 단점이 있다. 한 번 발행한 토큰은 유효기간이 끝나기 전까지 따로 통제할 수 없기 때문에 세션에 비해 토큰 정보를 탈취 당할 가능성이 높다.\n\n## Interceptor와 Filter의 역할과 차이점\n\nDispatcherServler에 들어가기 전과 후로 Filter와 Interceptor가 작업을 처리하는 것을 볼 수 있다.\n\n### Filter\n서블릿 컨테이너가 관리한다.\n공통 인증/인가, 로깅, 이미지/데이터 압축 및 문자열 인코딩을 수행한다. \n주로 필터는 스프링 시큐리티에서 사용한다.\n\n`doFilter`, `init`, `destroy` 메서드가 있다. 필터 체인을 사용해서 다음 필터에게 request 객체를 넘겨줄 수도 있다. 다음 필터가 존재하지 않으면 디스패처 서블릿으로 전달된다.\n\n`GenericFilterBean` 은 기존 필터에서 얻어올 수 없는 정보인 Spring의 설정 정보를 가져올 수 있게 된 추상 클래스이다. \n\n`OncePerRequestFilter` 는 모든 서블릿에 일관된 요청을 처리하기 위해 만들어진 필터이다.\n\n## Bean의 Scope 활용하기\n`Bean`은 스프링이 생성/관리하는 클래스의 인스턴스(객체) 이다.\n\n### Bean이 갖는 메타데이터\n- 실제 빈 구현이 정의된 패키지 정보와 클래스 이름\n- 빈의 컨테이너 안에서 동작을 정의한 정보\n- 다른 빈에 대한 의존 정보\n\n### Bean Scope\n특정 Bean이 어느 범위에서 존재할 것인가\n기본적으로 6개의 Scope 설정을 지원한다.\n\n#### Singleton\nIoC 컨테이너 안에서 단 하나의 Bean만 존재하게 된다.\n별도의 캐시에 저장하여 해당 bean에 대한 다음 요청부터 캐시의 빈을 제공해준다.\n\n#### Prototype\n빈 요청이 있을 때마다 새로운 빈을 만들어내는 scope이다.\n새로운 bean의 생성, 의존 관계 주입까지만 관여한 후, 더 이상 관리하지 않는다. \ngc에 의해 bean이 제거된다.\n\n#### Request\n어떤 요청 안에서 빈의 상태가 변경되어도 다른 요청에 영향이 가지 않는다.\n요청에 대한 응답이 끝나면 bean이 소멸한다.\n\n#### Session\nHTTP 세션 한 번에 하나의 빈을 만드는 scope이다.\n\n#### Application \nServletContext와 동일한 생명주기를 갖는 빈을 만든다. \n\n#### Websocket\n\n\n### 싱글톤 적합 vs 비싱글톤 적합\n#### 싱글톤으로 적합한 객체\n- 상태가 없는 공유 객체: 상태를 가지고 있지 않은 객체는 동기화 비용이 없다. 따라서 매번 이 객체를 참조하는 곳에서 새로운 객체를 생성할 이유가 없다.\n- 읽기용으로만 상태를 가진 공유 객체: 1번과 유사하게 상태를 가지고 있으나 읽기 전용이므로 여전히 동기화 비용이 들지 않는다. 매 요청마다 새로운 객체 생성할 필요가 없다.\n- 공유가 필요한 상태를 지닌 공유 객체: 객체 간의 반드시 공유해야 할 상태를 지닌 객체가 하나 있다면, 이 경우에는 해당 상태의 쓰기를 가능한 동기화 할 경우 싱글톤도 적합하다.\n- 쓰기가 가능한 상태를 지니면서도 사용빈도가 매우 높은 객체: 애플리케이션 안에서 정말로 사용빈도가 높다면, 쓰기 접근에 대한 동기화 비용을 감안하고서라도 싱글톤을 고려할만하다. 이 방법은 1. 장시간에 걸쳐 매우 많은 객체가 생성될 때, 2. 해당 객체가 매우 작은 양의 쓰기상태를 가지고 있을 때, 3. 객체 생성비용이 매우 클 때에 유용한 선택이 될 수 있다.\n#### 비싱글톤으로 적합한 객체\n- 쓰기가 가능한 상태를 지닌 객체: 쓰기가 가능한 상태가 많아서 동기화 비용이 객체 생성 비용보다 크다면 싱글톤으로 적합하지 않다.\n- 상태가 노출되지 않은 객체: 일부 제한적인 경우, 내부 상태를 외부에 노출하지 않는 빈을 참조하여 다른 의존객체와는 독립적으로 작업을 수행하는 의존 객체가 있다면 싱글톤보다 비싱글톤 객체를 사용하는 것이 더 나을 수 있다.\n출처: https://gmlwjd9405.github.io/2018/11/10/spring-beans.html\n\n## ApplicationContext\n\n## 질문\n- JWT 방식의 단점은 무엇일까요? (로그인 상태를 여러 기기에서 유지할 수 없음. stateless 하지 않다.)\n- Session Clustering의 장점 / 단점은 무엇인가요? : 포이\n- JWT는 쉽게 복호화할 수 있기 때문에 중요한 정보를 넣어서는 안 된다고 했는데, JWT 에 넣어야 되는 정보에는 무엇이 있나요? : 말랑\n\t- 식별자를 넣으면 좋지 않을까요? ID 값이나 UUID 같은 거\n- stateful한 클래스를 singleton으로 사용하면 안 되는 이유는 무엇인가요? : 헤나\n- stateful한 클래스는 무슨 scope로 빈을 생성하면 좋을까요?\n- prototype scope는 언제 사용하나요? : 포이\n- prototype의 bean은 어떻게 제거되는지 아시나요? : 포이\n- singleton scope를 사용하기 좋은 객체가 뭐라고 생각하시나요? / 비싱글톤으로 적합한 객체는 뭐라고 생각하시나요? : 말랑\n- 필터의 로깅 작업이 필요한 이유는 무엇인가요? -> HTTP 요청과 응답에 대한 정보를 수집할 수 있다. 보안상의 이유와 디버깅을 위해 : 포이\n- Filter에서 발생한 예외처리는 어떻게 할 수 있나요? : 포이\n- ControllerAdvice로 예외처리를 할 수 있나요? : 포이\n- Singleton scope와 Prototype scope를 동시에 사용했을 때 일어날 수 있는 문제점이 있을까요? : 포이\n\t- Singleton bean 내부에서 prototype bean을 사용할 수 있는 방법? -> object provider를 사용하면 된다고 하네요\n- Session Clustering 설명해주세요 : 말랑\n\t- WAS 끼리의 통신은 어떻게 하나요?\n\t- Session의 동기화 시점?\n- Scale up vs Scale out을 비교해주세요 : 말랑\n- refresh token을 추가한 JWT의 장단점을 알려주세요 : 말랑\n- interceptor의 handler를 활용할 수 있는 방법? : 말랑\n\t- 모르겠네요...\n- ApplicationContext가 뭔가요? : 말랑\n- Spring Security에서 interceptor 대신 filter를 사용하는 이유? : 말랑\n- bean이 갖는 메타 데이터에 대해 설명해주세요 : 헤나\n- Singleton, Prototype 외의 다른 스코프의 경우 어떤 설정을 해주어야 하나요? : 헤나\n\t- WebApplication에서만 사용할 수 있습니다. (MVC, WebFlux)\n- Proxy 모드란? : 헤나\n- HTTP Only 쿠키를 사용하면, 브라우저에서 쿠키에 접근할 수 없는데도 사용해도 되나요? : 헤나\n\n# 6/5\n\n## 헤나\n\n### 질문\n- Spring Container에게 객체 생성과 관리를 위임하는 것의 장단점?\n- MVC에 대해 설명해주세요.\n- 레이어를 어떻게 구분해서 작성하시는지?\n- IoC Container 란? 역할?\n- Spring Container의 생명 주기, bean 스코프 (소멸 전 콜백 메서드)\n- 의존 관계 주입은 언제 일어나나? => 의존 관계 주입이 초기화 콜백 메서드 이후에 생성되는 거면 생성될 때에는 필드가 null인데 의존 관계 주입이 가능한가요?\n\n스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → **초기화 콜백 메소드 호출** → 사용 → **소멸 전 콜백 메소드 호출** → 스프링 종료\n\n### 피드백\n- 중간에 질문과 관련 없는 내용이 답변으로 나올 때가 있었다.\n\n## 포이\n\n### 질문\n- dao의 단위 테스트란? \n- dao의 단위 테스트가 아니라 통합 테스트로 봐야 하는 거 아닌가?\n- 실제 db와 연동하는 테스트인 dao의 단위 테스트라고 한 이유?\n- vpc에 대해 설명해주세요\n- vpc 내에 서브넷의 개념이 있는데, 서브넷 개념에 대해 말해주세요. \n- vpc의 보안그룹과 서브넷의 NACL에 대해 알고 계신가요?\n- classist와 mockist에 대해 설명해주세요.\n- 본인은 주로 어떤 테스트 더블을 사용하시는지 말씀해주세요.\n- mocking과 stubing의 차이점?\n- 레이어드 아키텍처 각 계층의 역할에 대해 설명해주세요.\n- argument resolver와 interceptor를 어떻게 사용하셨나요?\n- interceptor를 사용해서 접근해보신 적 있나요? 왜 접근하셨나요?\n- spring bean scope에 대해 설명해주세요. \n- prototype 스코프는 어떤 경우에 사용하면 좋을까?\n- request 스코프와 session 스코프의 차이점이 있나요?\n- interceptor는 항상 작동할까?\n\n### 피드백\n- 한 문장의 호흡이 좀 긴 것 같습니다.\n\n## 베로\n\n### 피드백\n- 끝까지 말하긴 했지만 내용이 좀 틀린 부분이 있었다.\n\n## 말랑\n\n### 질문\n- connection이란?\n- datasource에 대해 설명해주세요. \n- connection pool은 누가 관리하나요?\n- 서브넷을 뭐라고 할 수 있을까요?\n- VPC가 없는 경우에서도 서브넷은 사용할 수 있다고 알고 있는데...\n- CIDR에 대해 설명해주세요.\n- spring event에 대해 설명해주세요.\n- 어떤 경우에 spring event를 쓰는 게 좋을까요?\n- propagation 레벨 NEVER를 사용하는 경우는 언제일까요?\n\n### 피드백\n- 설명하기 어려운 게 나왔을 때 당황했다.\n- TCP/UDP 답변은 생각을 해도 못 했다..."},{"excerpt":"스터디 주제 준비 default-method functional-interface grasp webmvctest ioc-container-and-di bean-candidate 면접 vepohuhemal-study-question","fields":{"slug":"/vepohuhyemal-study/"},"frontmatter":{"date":"2023년 03월 24일 01:03","title":"베포후헤 스터디","tags":null},"rawMarkdownBody":"\n## 스터디 주제 준비\n\n- [[default-method]]\n- [[functional-interface]]\n- [[grasp]]\n- [[webmvctest]]\n- [[ioc-container-and-di]]\n- [[bean-candidate]]\n\n## 면접\n- [[vepohuhemal-study-question]]"},{"excerpt":"LOG 브라운에게 면담 신청했다. 최근에 있던 일이 아직 해결되지 않고 있어서 스트레스 받고 있다. 어떻게든 해결해보고 싶어서 신청했다. 원래 온라인으로 하는 거 제안 주셨는데 아무리 생각해도 온라인으로 할 얘기가 아닌 것 같아 오프라인으로 하게 되었다 ㅋㅋ (저 때문에 출근하게 되신 브라운... 죄송해요 😂) 1, 2단계 PR이 머지되었다. 그런데 코드…","fields":{"slug":"/2023-03-23/"},"frontmatter":{"date":"2023년 03월 23일 14:03","title":"2023년 03월 23일","tags":null},"rawMarkdownBody":"## LOG\n- 브라운에게 면담 신청했다. 최근에 있던 일이 아직 해결되지 않고 있어서 스트레스 받고 있다. 어떻게든 해결해보고 싶어서 신청했다. 원래 온라인으로 하는 거 제안 주셨는데 아무리 생각해도 온라인으로 할 얘기가 아닌 것 같아 오프라인으로 하게 되었다 ㅋㅋ (저 때문에 출근하게 되신 브라운... 죄송해요 😂)\n- 1, 2단계 PR이 머지되었다. 그런데 코드리뷰 채널에는 알림이 오지 않아서 뭔가 이상했다. 3단계 진행해도 되는 거겠지?\n- 오늘 데일리 미팅 때 박스터가 서로 칭찬해주기라는 주제로 진행했다. 서로 칭찬하다가 5기 잡담 채널에 올리기로 결정난 뒤에는 서로 얼마나 더 엄청난(?) 칭찬을 할 지 고민하는 게 웃겼다 ㅋㅋㅋㅋ 오늘은 안 걸렸지만 걸린 사람들이 내일도 하자고 해서 ㅋㅋ... 나도 하게 될 거 같다. 곤란하다 🧨\n- 점심에 BBQ를 먹었는데 오늘따라 날씨가 굉장히 좋았다. 석촌호수 돌면서 산스장(?)도 갔다왔다. 체인저의 벤치 프레스 굉장했다. 역시 헬스인들은 대단한 거 같다. 그렇다고 내가 운동을 하게 되지는 않을 듯 ㅋㅋ\n\n## 배운 것\n- ```Map```에도 ForEach를 쓸 수 있다.\n\n## 궁금한 것\n- 양방향 의존은 별로인가? 왜 별로인가?\n- groupingby\n\n## 어려웠던 것\n- 말 예쁘게 하기.\n\n## 느낀 것\n- 나쁜 사람이 되기 싫다. 나쁜 사람이 되고 싶은 사람이 그렇게 많진 않지만. 여전히 눈치를 보고 있다. 우테코에서 눈치본다는 뜻이라기 보다는 아직도 주변을 많이 신경쓰고 있다는 뜻이다. 그래도 여기 와서는 예전보다는 눈치를 덜 보는 거 같긴 하다. 그래서 자신의 주관과 의견이 뚜렷한 사람이 멋지다. 좋은 것, 싫은 것이 확실한 사람이 신기하다. 난 아직 찾아가는 중이다.\n- 그냥 이것저것 좀 어렵다. 제대로 풀려가는 건지, 뭐가 어떻게 되어 가는건지 잘 모르겠다. 나도 내가 뭘 하고 싶은 건지 모르겠다 ㅋㅋㅋ 언제쯤 알 수 있을까? 빨리 찾을 거라는 기대 같은 건 안 한다. 23년째 찾고 있으니까. 여전히 삶의 목표가 뭘까 물어보면 대답할 수 없다. 지금 나는 일단 그냥 살고 있다. 지금 당장은 재밌는 일들을 하면서 살고 싶다. 나중의 내가 지금의 나를 원망하게 될까?\n- 오늘도 심신미약이다. 내일은 좀 더 자볼까? 하필 오늘은 더 일찍 일어났어서 그랬을지도.\n"},{"excerpt":"LOG 오늘도 긍정 말하기는 이어졌지만... 그렇다고 긍정적인 말을 많이 한 건 아닌 거 같다ㅋㅋㅋ 날이 갈수록 변질된다 ㅋㅋㅋ 긍정적으로 말하라고 다들... 포이랑 같이 커맨드 패턴, 상태 패턴 적용해봤다. 처음에는 진짜 막막했는데 하다보니까 뭔가 됐다. 근데 이렇게 쓰는 게 맞는걸까? 그래도 하고 나니까 마음에 들어서 좋았다. 낮에 많이 웃고 저녁부터…","fields":{"slug":"/2023-03-22/"},"frontmatter":{"date":"2023년 03월 22일 14:03","title":"2023년 03월 22일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘도 긍정 말하기는 이어졌지만... 그렇다고 긍정적인 말을 많이 한 건 아닌 거 같다ㅋㅋㅋ 날이 갈수록 변질된다 ㅋㅋㅋ 긍정적으로 말하라고 다들...\n- 포이랑 같이 커맨드 패턴, 상태 패턴 적용해봤다. 처음에는 진짜 막막했는데 하다보니까 뭔가 됐다. 근데 이렇게 쓰는 게 맞는걸까? 그래도 하고 나니까 마음에 들어서 좋았다.\n- 낮에 많이 웃고 저녁부터 약간 절전모드라 공감 제로맨이 되어 가고 있다. 원래 이런 사람은 맞긴 한데 앞으로는 좀 더 노력해봐야겠다. 그래도 이정도면 많이 늘어난 거 아닐까하고 위로하는 중이다.\n- 아침에 버스에서 아이묭 노래 듣는 사람을 봤다. 사실 아이묭 그렇게 막 좋아하는 가수는 아닌데 그때는 엄청 반가워서 순간적으로 말 걸까 생각했다. 역시 그건 아닌 거 같아서 그만뒀다. 점점 이상한 사람이 되어 가는 거 같기도..? 원래 이런 사람 아닙니다?\n- 토리, 포이, 박스터와 9시 반에 퇴근했다. 신림에서 내려서 박스터랑 얘기하다가 갔다. 박스터는 재밌고 나는 얘기할 사람 있어서 일석이조다~\n- 박스터, 주노, 체인저와 아침에 잠실역에서 우연히 마주쳤다. 한 번도 아침 잠실역에서 같은 크루 만나본 적 없는데 오늘 아침따라 많이 만나서 신기했다.\n\n## 배운 것\n- [[effective-java-ed3|정적 팩토리 메서드의 장단점]] -> 방금 쓰고 알았는데 단점을 안 적었다..ㅋㅋ\n- ```EnumMap<>(EnumClass.class)```: ```enum```을 ```key```로 사용하는 경우에는 ```EnumMap```의 성능이 더 좋다고 한다. 신기하다.\n\n## 궁금한 것\n- 커맨드 패턴의 ```Command```는 ```interface```로만 사용할까? ```abstract class```는 자주 사용하지 않는 편일까? 아무래도 상속을 기피하는 편이라 더 ```interface```를 사용할 것 같긴 하다.\n\n## 어려웠던 것\n- 커맨드 패턴, 상태 패턴 적용하면서 내 코드에 집중을 못했다. 나중에 내가 뭘 하고 있는지도 모르게 되어서 패턴 쓰기 전에는 충분히 공부하고 하는 게 나을 거 같다.\n- 안 좋은 기분 금방 떨쳐내기.\n\n## 느낀 것\n- 내년에 나는 뭐가 되어 있을까? 멋진 사람이 되어 있으면 좋겠지만 정말 그렇게 되어 있을지 궁금하다. 내년의 나라고 나와 그렇게 막 다를 것 같지는 않지만 기왕이면 많이 바뀌어 있으면 좋겠다.\n- 나도 사람을 좀 가리는 것 같다. 아닌 줄 알았는데 ㅋㅋ 아무나 쉽게 친해지는 성격은 역시 못 되나보다. 그렇지만 그것도 그것 나름대로 좋..을 수도 있지 않을까..? 그냥 그렇게 생각하자...\n- 신경써서 말하자. 요즘 너무 뇌를 안 거치고 나오는 말이 많다. 다른 사람들이 생각할 때 어떻게 받아들일지 생각하고 나서 말해봐야겠다.\n- 집에서 뭔가 많이 할수록 피곤하다. 진짜 잠만 자고 빨래하는 곳이 되었다. 이번 주말에는 꼭 밀린 집안일을 해야겠다. 저녁에 집에 가면 청소기를 돌릴 수 없어서 방이 더럽다. 주말에 그냥 깨끗하게 다 치워버리는 게 낫겠다. 지금 냉장고를 열기가 무섭다. 먹을 게 많아도 안 먹으니 소용이 없다. 끔찍한 모습이 되기 전에 주말에 치워버려야겠다.\n- 좋은 사람이 되고 싶다. 어떻게 하면 좋은 사람이 될 수 있을까? 요즘 많이 하는 고민이다.\n"},{"excerpt":"페어와의 규칙 이번 페어는 루카! 루카와 같이 밥을 먹으면서 말을 놓았다. 페어 회고 루카가 나에게 좋았던 점 먼저 친근하게 다가와줘서 좋았다. 규칙 정해서 한 거 좋았다. 의견을 명확하게 말해줘서 좋았다. 친화력이 좋다. 공통적으로 아쉬웠던 점 tdd를 제대로 못했다. 기능에 집중해서 기능 구현 분석을 너무 시간에 몰아쳐서 정리를 못하고 갔다. 타이머 …","fields":{"slug":"/level1-chess/"},"frontmatter":{"date":"2023년 03월 22일 01:03","title":"레벨1 체스 미션","tags":["레벨1","우테코"]},"rawMarkdownBody":"\n## 페어와의 규칙\n\n- 이번 페어는 루카!\n- 루카와 같이 밥을 먹으면서 말을 놓았다.\n\n## 페어 회고\n\n### 루카가 나에게 좋았던 점\n\n- 먼저 친근하게 다가와줘서 좋았다.\n- 규칙 정해서 한 거 좋았다.\n- 의견을 명확하게 말해줘서 좋았다.\n- 친화력이 좋다.\n\n### 공통적으로 아쉬웠던 점\n\n- tdd를 제대로 못했다. 기능에 집중해서 기능 구현 분석을 너무 시간에 몰아쳐서 정리를 못하고 갔다.\n- 타이머 깜빡하는 경우가 있었다. 좀 더 시간 확인 잘하기.\n- 너무 완벽한 코드를 짜기 위해 고려하는 시간이 길었다. -> 동작하는 프로그램 만드는 것이 1순위\n- 이런 고민은 나중에 해볼까? 의견을 좀 쳐내줬으면 좋겠다. -> 규칙 추가\n- 처음에 확실하게 잡고갈 것은 도메인의 기능. 도메인의 역할을 확실하게 정하고 가기. -> 규칙 추가\n\n### 내가 잘했다고 생각하는 것\n\n- 의견전달 확실히 한 거.\n- 말 놓은 거. 밥 먹은 거.\n- 의견 양보를 덜 했다.\n- 나를 납득시키는 코드를 작성했다.\n- 의견 교류를 잘했다.\n- 항상 칼퇴했는데 미션에 시간을 좀 더 많이 썼다.\n\n### 앞으로의 다짐\n\n- 설계를 너무 길게 하지 않을 거 같다. 어쨌든 바뀌니까 너무 오래 잡지 말자.\n- 굳이 다이어그램 안 그려도 될 거 같다.\n- 요구사항 분석을 좀 더 철저하게 할 거 같다.\n- 페어랑 헤어지고 나서도 이야기를 할 거 같다.\n- 시간이 없더라도 TDD를 좀 더 철저하게.\n\n## 앞으로 페어할 때 이렇게 해보자\n\n- 페어가 되면 밥을 같이 먹으면서 (페어가 괜찮다면) 말을 놓자.\n- 설계는 최대 1시간만 하자. 어차피 하면서 바뀐다.\n- 요구사항 분석을 좀 더 철저하게 하자. 도메인이 어떤 역할, 어떤 기능을 해야 하는지 정도는 철저하게 정하고 가자.\n- TDD를 준수하자. 시간이 없더라도 TDD 하자고 말하자.\n- 15분마다 교대하고 1시간마다 10분 동안 휴식을 취하자.\n- 둘 다 좋아요 금지\n- 모르는 거, 이해 안 되는 거는 언제든지 다시 말해달라고 하자.\n- 토론이 필요한 경우 시간을 멈추고 토론하자.\n- 페어랑 헤어지고 나서도 고민되는 부분에 대해 같이 토론하자.\n- 너무 완벽한 코드 짜려고 하지 말자.\n- 리팩토링 시간 하루는 남겨두자. (미션 제출 전날까지 구현을 완료하자)\n- 토론이 너무 길어지거나 지엽적인 부분은 나중에 말하자고 의견을 쳐내주자.\n\n## 학습 로그 말하기 피드백\n\n- 발표의 순서가 좋았다.\n- 질문에 대해서 확실히 잘 이해시켜줬다.\n- 내가 놓칠 수 있는 부분에 대해 추가적인 설명을 해주는 게 좋았다."},{"excerpt":"LOG 베포후헤 스터디 (이거 이제 이름이 되어버린건가 싶다 ㅋㅋ) 준비했다. 내가 생각해도 열심히 준비했었는데 내 생각보다 퀄리티가 많이 나온 것 같지 않아 좀 슬펐다. 후추가 정말 발표를 잘했다. 헤나도 예시 엄청 꼼꼼하게 준비해와서 이해가 잘 됐다. 다들 발표 고수들이었다. 사실 내가 최약체였던 것..! 오히려 좋아 ㅋㅋ 체스는 거의 구현 못했다. …","fields":{"slug":"/2023-03-20/"},"frontmatter":{"date":"2023년 03월 21일 15:03","title":"2023년 03월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 베포후헤 스터디 (이거 이제 이름이 되어버린건가 싶다 ㅋㅋ) 준비했다. 내가 생각해도 열심히 준비했었는데 내 생각보다 퀄리티가 많이 나온 것 같지 않아 좀 슬펐다. 후추가 정말 발표를 잘했다. 헤나도 예시 엄청 꼼꼼하게 준비해와서 이해가 잘 됐다. 다들 발표 고수들이었다. 사실 내가 최약체였던 것..! 오히려 좋아 ㅋㅋ\n- 체스는 거의 구현 못했다. 시간이 없기도 했고, 할 게 많아서. 제일 큰 이유는 스터디 때문이었다. 그래도 스터디 하니까 강제성이 부여돼서 공부가 됐다. 내가 적당히 커버할 수 있는 정도의 스터디는 정말 도움이 된다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 내 결과물과 나를 분리하는 것. 지금은 꽤 익숙해진 것 같지만 아직도 흠칫할 때가 있다. 그냥 just 피드백일 뿐인데 가끔은 나에 대한 공격으로 느껴질 때가 있다. 그래서 그 사람이 미워지는 건 절대 아니다. 나는 오히려 의연해지고 싶다. 더 나아지기 위해서 피드백을 내 성장을 위한 거름으로 여길 수 있는 사람이 되었으면 좋겠다. \n\n## 느낀 것\n- 확실히 발표가 더 늘었다. 원래 말을 더듬거나 '이거 뭐지' 라던지 당황하면 이상한 말을 했었는데 그 빈도수가 현저히 줄었다. 말을 할 일이 많아서 나아졌다고 생각하기로 했다. 페어 회고, 학습 로그 말하기, 그냥 토론 등으로 다져진 거 아닐까? 어쨌든 더 나아지고 싶다. 잘하고 있다!\n- 기억력은 안 좋아졌다. 방금 들은 말도 기억이 잘 안 난다. 사실 집중이 잘 되지 않는다. 왜 집중이 잘 되지 않는지는 여러 가지 이유가 있을 거 같은데 아직은 완벽하게 파악하지 못했다. 내 상태를 정확하게 파악해야 어떻게 할 지도 생각할 수 있는데. 찾아가는 중이다.\n- 레벨 인터뷰 때는 재택해야 한다고 해서 순간 아쉬웠다. 나는 진짜로 방학이 아쉽다. 그 때도 나오고 싶지만.. 방학 때는 캠퍼스를 안 연다고 해서. 지금은 집보다 잠실캠에 오는 시간이 더 좋다. 고등학교 때처럼 여기 있는 사람들과 엄청 오랜 시간을 보게 되니까 더 끈끈하고 빠르게 친해진 거 같다. 지금은 같이 있는 크루들 덕분에 힘들지 않다 :)\n"},{"excerpt":"LOG 드디어 맥북 아래 공간을 쓸 수 있게 됐다. 항상 dock을 올려서 쓰다보니 그대로 설정이 굳어져서 내려가지도 않았었다. 포이가 잡담방에 올려보래서 도움 요청 글을 올렸었다. 그런데 올린지 10분 지나고 브라운이 껐다 켜보라고 조언했는데 바로 돼서 굉장히 머쓱했다...ㅋㅋ 3일 연속 국밥을 먹었다. 오히려 좋았다. 아직은 국밥 쿨타임이 빨리 도는 …","fields":{"slug":"/2023-03-21/"},"frontmatter":{"date":"2023년 03월 21일 15:03","title":"2023년 03월 21일","tags":null},"rawMarkdownBody":"## LOG\n- 드디어 맥북 아래 공간을 쓸 수 있게 됐다. 항상 dock을 올려서 쓰다보니 그대로 설정이 굳어져서 내려가지도 않았었다. 포이가 잡담방에 올려보래서 도움 요청 글을 올렸었다. 그런데 올린지 10분 지나고 브라운이 껐다 켜보라고 조언했는데 바로 돼서 굉장히 머쓱했다...ㅋㅋ\n- 3일 연속 국밥을 먹었다. 오히려 좋았다. 아직은 국밥 쿨타임이 빨리 도는 편이라 자주 먹어도 괜찮다.\n- 오늘은 신림에서 내려서 집에 가봤다. 꽤 사람 많을 줄 알았는데 그렇지도 않았다. 좀 늦게 가면 사람이 많이 없는 모양이다. 그런데 그렇게 차이가 나는 지는 모르겠다. 한 7-8분..? 정도 나는 거 같다. 그때그때 상황 봐서 어디서 내릴지 결정해야겠다.\n- 잠을 얼마 못 잤지만 아침에는 피곤하진 않았다. 그런데 뒤로 갈수록 피곤해지는 걸 보니 알고보면 피곤했던 거 같기도 하다. 그냥 할 일이 많다... 뭔가 하긴 했는데 한 거 같지 않다.\n- 갑자기 체인저랑 포이가 긍정문으로 말하기 했는데 그냥 개웃겼다 ㅋㅋㅋ 처음에는 분명 좋은 취지였는데 갈수록 반례 가져오고 점수 매기기 하니까 웃기기만 했다 ㅋㅋㅋㅋㅋ 나도 오늘 좀 노력해보려고 했는데 딱히 잘 된 거 같지는 않다.\n- 박스터, 포이, 그레이, 다즐과 저녁 먹었다. 다즐은 옷을 잘 입는다. 게다가 동기를 닮아서 처음 봤지만 굉장히 친근했다. 뭘까... 왜 이렇게 닮은 사람이 많은 걸까... 내 주변에 사람이 그렇게 많지도 않은데 계속 닮은 사람이 나와서 이제는 당황스럽다;;\n- 박스터가 리뷰해줬다. 리뷰가 부족하다고 느끼고 있었는데 피드백 해줘서 고마웠다. 질문한 거, 해결 방법 모두 정말 많이 도움이 됐다. 다만 오늘까지 PR을 보낼 생각이었어서 많이 반영 못한 건 아쉽다. 내일 가서 반영 열심히 해야겠다.\n- 눈우랑 말랑 코드를 같이 봤다. 둘 다 관점이 명확해서 재밌게 읽었다. 말랑 코멘트로 볼 때는 굉장히 상냥하게 말하는 줄 알았는데 머릿속으로는 험악한 거 같다 ㅋㅋㅋㅋ 어떻게 구현할 지 힌트를 얻어서 수확이 컸다.\n\n## 배운 것\n- assertThat을 여러 번 할 때는 Junit assertAll을 쓰면 좋다고 한다. by 박에스더 (근데 왜인지는 안 물어봤네)\n- ```Consumer<T>``` : T를 인자로 받아서 void를 리턴값으로 갖는 함수형 인터페이스이다. accept로 실행한다.\n\n## 궁금한 것\n- composite 패턴 by 말랑\n- rich domain model by 눈우\n- command 패턴\n- GRASP\n\n## 어려웠던 것\n- 긍정문 말하기. 내가 굉장히 부정적으로, 독성 말투로 말하고 있다는 걸 뼈저리게 ;; 느꼈다. 말을 부드럽게 해서 안 좋을 게 없는데 앞으로도 노력해보자. 굳이 지금 내 말투가 안 좋다기 보다는 둘 다 하면 좋으니까... 라는 마인드로 해 볼 생각이다.\n\n## 느낀 것\n- 집에 가서는 자기만 하고 싶다 (이제 want로 바뀜) 오늘 집에 와서는 리팩토링을 마저 했는데 피곤하다. 이제 어느 정도 피곤함의 경지에 오르니까 피곤하지 않은 거 같은(?) 기분이 든다.\n- TIL을 보는 사람이 늘어나고 있어서 좋다. 관심 좋아하는 사람이라 내 글이 많은 사람들한테 알려지면 좋겠다. 그렇지만 내 일기 쓸 때마다 알람 울리는 건 좀..\n- todo mate 왜 하고 있는지 모르겠다 ㅋㅋㅋ 오늘은 거기다 적은 일을 70% 이상 못해서 계획을 왜 세우고 있을까하는 현타가 왔다. 계획과 나는 안 맞는 거 같다. 무엇을 할 지 생각하는 걸 정하는 것도 못하다니 쉽지 않네.\n- 많이 웃는 시간이 늘어날수록 즐겁다. 긍정문 때문에 웃겨서 눈물났는데 그 덕분인지 오늘 내내 웃겼다. 내가 조증인가 싶다 이제\n"},{"excerpt":"디폴트 메서드를 사용하는 이유 디폴트 메서드가 없던 때를 예로 들어보자. 우리가 라이브러리 설계자이고, 바퀴의 개수를 가져오는 기능을 구현해야 하는 인기 있는  인터페이스가 있다고 가정하자.\n생각해보니 해당 탈 것이 사륜구동인지 확인하는  이라는 메서드가 있으면 좋을 거 같다. 그래서 기존에 서비스되던  에  을 추가했다. 그런데 이전에 우리의 을 구현한…","fields":{"slug":"/default-method/"},"frontmatter":{"date":"2023년 03월 19일 13:03","title":"디폴트 메서드(Default method)","tags":["레벨1","우테코","학습로그","Java"]},"rawMarkdownBody":"\n## 디폴트 메서드를 사용하는 이유\n\n디폴트 메서드가 없던 때를 예로 들어보자.\n\n```java\npublic interface Vehicle {\n\tint getWheelCount();\t\n}\n```\n\n우리가 라이브러리 설계자이고, 바퀴의 개수를 가져오는 기능을 구현해야 하는 인기 있는 ```Vehicle``` 인터페이스가 있다고 가정하자.\n생각해보니 해당 탈 것이 사륜구동인지 확인하는 ```isFourWheel``` 이라는 메서드가 있으면 좋을 거 같다.  \n\n그래서 기존에 서비스되던 ```Vehicle``` 에 ```isFourWheel``` 을 추가했다. \n\n```java\npublic interface Vehicle {\n\tint getWheelCount();\n\tboolean isFourWheel();\n}\n```\n\n그런데 이전에 우리의 ```Vehicle```을 구현한 사용자에게는 문제가 생긴다.\n이전에 해당 인터페이스를 구현했던 모든 클래스의 구현을 고쳐야 한다는 것이다! \n\n이렇게 공개된 API를 수정하면 기존 버전과의 호환성 문제가 발생한다.\n\n이를 해결하기 위해 자바 8 부터는 디폴트 메서드를 지원한다.\n\n## 디폴트 메서드란?\n\n디폴트 메서드는 인터페이스에 있는 구현 메서드이다.\n\n```default``` 키워드로 시작하며, method body를 포함한다.\n\n```java\npublic interface Vehicle {\n\tint getWheelCount();\n\tdefault boolean isFourWheel() {\n\t\treturn getWheelCount() == 4;\n\t}\n}\n```\n\n이렇게 Default 메서드를 정의할 수 있다. \n위의 예제에서 앞으로 ```Vehicle``` 인터페이스를 구현하는 모든 클래스는 ```isFourWheel```을 상속받는다.\n```isFourWheel``` 을 따로 구현하지 않아도 메서드를 쓸 수 있게 된다.\n\n### 디폴트 메서드 오버라이딩\n\n디폴트 메서드는 기본 구현을 제공한다. \n인터페이스를 구현한 클래스가 디폴트 메서드의 기능을 다르게 구현하고 싶다면 오버라이딩을 사용할 수 있다.\n\n## 디폴트 메서드 활용\n\n### 선택형 메서드\n\n기존 인터페이스에서 잘 사용하지 않던 메서드를 디폴트 메서드로 작성하여 인터페이스를 구현하는 클래스에서 빈 메서드 구현을 하지 않도록 한다.\n\n```java\ninterface Iterator<T> {\n\tboolean hasNext();\n\tT next();\n\tvoid remove();\n}\n```\n\n```Iterator```의 remove는 잘 쓰이지 않는다.\n그래서 Iterator를 구현하는 많은 클래스가 remove에 빈 구현을 제공했다.\n\n```java\npublic class ListIterator<E> implement Iterator<E> {\n\tList<E> list; \n\tint cursor; \n\t\n\tpublic ListIterator(List<E> list) { \n\t\tthis.list = list; \n\t} \n\t\n\t@Override \n\tpublic boolean hasNext() { \n\t\treturn cursor < list.size(); \n\t} \n\t\n\t@Override \n\tpublic E next() { \n\t\tif (cursor == list.size()) throw new NoSuchElementException();\n\t\treturn list.get(cursor++); \n\t}\n\n\t@Override\n\tpublic void remove() {}\n}\n```\n\n잘 사용하지 않는 remove를 디폴트 메서드로 만들면 다음과 같다.\n\n```java\ninterface Iterator<T> {\n\tboolean hasNext();\n\tT next();\n\t\n\tdefault void remove() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n}\n```\n\n이렇게 구현하면 ```Iterator```를 구현하는 하위 클래스에서는 ```remove```를 따로 구현할 필요가 없다.\n\n### 동작 다중 상속\n\n자바에서 클래스는 한 개만 상속할 수 있지만 인터페이스는 여러 개 구현할 수 있다.\n\n```java\npublic interface Rotatable {\n\tvoid setRotationAngle(int angleInDegrees);\n\tint getRotationAngle();\n\tdefault void rotateBy(int angleIndegrees) {\n\t\tsetRotationAngle((getRotationAngle() + angleInDegrees) % 360);\n\t}\n}\n```\n\n```java\npublic interface Moveable {\n\tint getX();\n\tint getY();\n\tvoid setX(int x);\n\tvoid setY(int y);\n\t\n\tdefault void moveHorizontally(int distance) {\n\t\tsetX(getX() + distance);\n\t}\n\t\n\tdefault void moveVertically(int distance) {\n\t\tsetY(getY() + distance);\n\t}\n}\n```\n\n```java\npublic interface Resizable {\n\tint getWidth();\n\tint getHeight();\n\tvoid setWidth(int width);\n\tvoid setHeight(int height);\n\tvoid setAbsoluteSize(int width, int height);\n\n\tdefault void setRelativeSize(int wFactor, int hFactor) {\n\t\tsetAbsoluteSize(getWidth() / wFactor, getHeight() / hFactor);\n\t}\n}\n```\n\n인터페이스를 조합해서 다양한 클래스를 만들 수 있다.\n\n```java\npublic Monster implements Moveable, Rotatable, Resizable {\n\t...\n}\n```\n\n또한 디폴트 메서드의 구현을 더 효율적으로 고치는 경우, 해당 인터페이스를 구현하는 모든 클래스도 자동으로 변경한 코드를 상속받게 된다.\n\n즉, 인터페이스의 디폴트 메서드를 수정하는 경우 인터페이스를 구현한 클래스들의 코드를 일일이 바꿔줄 필요가 없다. (메서드가 하위 클래스에서 재정의 되지 않은 경우에 한정된다)\n\n## 디폴트 메서드를 왜 쓸까?\n\n디폴트 메서드는 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경하기 위해 고안되었다.\n기존의 코드를 최대한 수정하지 않으면서, 설계된 인터페이스에 새로운 확장을 가능하게 만든다.\n\n## 참고 자료\n\n- 모던 자바 인 액션 Ch 13"},{"excerpt":"LOG 레벨1 글쓰기 PR을 제출했다. 한 김에 다른 크루들 피드백도 했다. 다들 글을 잘 써서 그런지, 피드백 하는 게 재밌었다. 오랜만에 글을 써서 그런가 어색했지만 역시 칭찬은 베로를 춤추게 한다(?) 생일이라 놀고 왔더니 일이 너무 많이 밀렸다. 밀린 PR도 제출하고, 글쓰기 피드백도 하고, 체스 피드백도 하고 했어야 했는데 시간이 없었다. 놀랍게…","fields":{"slug":"/2023-03-19/"},"frontmatter":{"date":"2023년 03월 19일 12:03","title":"2023년 03월 19일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨1 글쓰기 PR을 제출했다. 한 김에 다른 크루들 피드백도 했다. 다들 글을 잘 써서 그런지, 피드백 하는 게 재밌었다. 오랜만에 글을 써서 그런가 어색했지만 역시 칭찬은 베로를 춤추게 한다(?)\n- 생일이라 놀고 왔더니 일이 너무 많이 밀렸다. 밀린 PR도 제출하고, 글쓰기 피드백도 하고, 체스 피드백도 하고 했어야 했는데 시간이 없었다. 놀랍게도 스터디 자료도 준비했어야 해서 결국 1시 50분에 자버렸다. 너무 체력적으로 힘들다.\n- 디폴트 메서드 발표 준비 했는데 생각보다 어려웠다. 호환성을 다루는 건 너무 많이 나간 거 같아서 뺐는데 시간이 나올지 모르겠다. 예제 만드는 게 항상 쉽지 않다. 저번에 헤나 피드백 대로 예제를 더 준비해봤는데 투머치인 거 같기도 하고.\n\n## 배운 것\n- [[default-method|디폴트 메서드]]\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 내가 모든 걸 커버하기가 쉽지 않다. 필연적으로 하나에는 소홀해질 수밖에 없다. 저번 주는 모든 걸 다 챙기지 못한 거 같다. 체력이 안 된다는 말이 이해 됐다. 앞으로는 어떻게 해야 할까... 고민이 된다. 정답은 없다. 내가 무엇을 선택할지만 결정하면 된다.\n- 지금 너무 잠을 적게 잔다. 물리적인 시간은 6-7시간 정도면 괜찮은 편인데 실제로는 너무 피곤해서 일상에 지장이 있다. 집에서 하는 일을 줄여야겠다. 집은 진짜 자는 곳으로 하자..\n- 요즘 노래가 좋다. 그냥 심심할 때, 주변이 허전할 때 노래를 틀어놓다보니 더 좋아졌다. 지하철 탈 때 들으면 가장 기분이 좋다.\n"},{"excerpt":"LOG 오늘은 놀기로 한 날이라서 한강에 놀러갔다. 날씨가 따뜻했는데 바람이 많이 불어서 산발이 되었다.. ㅎ 레벨1 글쓰기를 했다. 오랜만에 글을 써서 그런가 정말 안 써졌다. 궁금한 사람은 초안을 볼 수 있다 ->  레벨1 글쓰기 아직 많이 부족한 글이다. 쓰고 나니 너무 무겁게 썼나 해서 포이랑 글렌한테 물어봤는데 다 술마셔서 객관적인 판단을 들을 …","fields":{"slug":"/2023-03-18/"},"frontmatter":{"date":"2023년 03월 18일 16:03","title":"2023년 03월 18일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘은 놀기로 한 날이라서 한강에 놀러갔다. 날씨가 따뜻했는데 바람이 많이 불어서 산발이 되었다.. ㅎ\n- 레벨1 글쓰기를 했다. 오랜만에 글을 써서 그런가 정말 안 써졌다. 궁금한 사람은 초안을 볼 수 있다 -> [[level1-writing | 레벨1 글쓰기]] 아직 많이 부족한 글이다. 쓰고 나니 너무 무겁게 썼나 해서 포이랑 글렌한테 물어봤는데 다 술마셔서 객관적인 판단을 들을 수 없었다 ㅋㅎㅋ... 왜 다들 내 글 볼 때만 감성적인거야 ㅋㅋㅋ 그래도 술 마신 사람들한테라도 괜찮다는 말을 들어서 다행이었다.\n- 링 귀걸이를 다시 샀다. 예전 링 귀걸이는 한 짝을 잃어버려서 돌아오지 못했기 때문에 간수를 잘해야 한다. 일자로 된 귀걸이는 귀걸이 고정하는 핀?을 계속 갈아줘야 해서 귀찮은데 이건 안 그래도 돼서 좋다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부를 하고 싶다. 절대적인 시간이 부족하다고 느꼈다. 사실 할 건 정말 많은데 말이다. 나는 어디서부터 어디까지 챙길 수 있을까? 왠지 갈수록 뭔가는 놓칠 수 밖에 없을 것 같다는 생각이 든다.. 모두를 만족시킬 수는 없으니까 말이다. 그래서 아직 고민 중이다. 좋은 선택을 해야 할 텐데.\n- 예전부터 우려하던 일이 일어난 것 같다. 이럴 때 어떻게 대처해야 좋을까. 일단 내 생각부터 정리해야 한다. 아마도 최대한 빨리 하는 게 좋아 보인다. 이런 생각이 들다가도 아닌가.. 싶어서 다시 갈팡질팡하게 된다. 아직도 잘 모르겠다.\n- 할 일이 많다. 적어놓지 않아서 다 까먹었다. 역시 기록의 중요성. 다음 주에는 새싹교실도 해야 한다. 다음 주부터 많이 바쁠 거 같다. 자바.. 잘할 수 있을까? 사실상 기초라서 괜찮지만 그래도 새싹들이 많이 얻어갔으면 좋겠어서 욕심이 난다.\n- 오늘도 너무 졸리다. 잠을 해결을 못하고 있다. 월요일에도 빨리 갈 생각인데 내일은 빨리 잘 수 있을까? 편하게 푹 자고 싶다. 시간 제한, 알람 없이 잘 수 있을까."},{"excerpt":"LOG 체스 2단계 PR 보냈다. 너무 질문할 내용이 없어서 그런지 리뷰가 5개밖에 달리지 않았다 ㅋㅋㅋㅋ 좀 더 많았으면 좋았겠지만 이건 이것대로 괜찮다고 생각한다. 체인저랑 나랑 주말에 생일이어서 온보딩 조원들이 아이스크림 케익 사와서 축하해줬다. 감동이야.. 점심 같이 안 먹어 준다고 할 때 뭔가 있나 싶긴 했다. 그치만 포이랑 글렌이랑 점심 먹고 …","fields":{"slug":"/2023-03-17/"},"frontmatter":{"date":"2023년 03월 17일 14:03","title":"2023년 03월 17일","tags":null},"rawMarkdownBody":"## LOG\n- 체스 2단계 PR 보냈다. 너무 질문할 내용이 없어서 그런지 리뷰가 5개밖에 달리지 않았다 ㅋㅋㅋㅋ 좀 더 많았으면 좋았겠지만 이건 이것대로 괜찮다고 생각한다.\n- 체인저랑 나랑 주말에 생일이어서 온보딩 조원들이 아이스크림 케익 사와서 축하해줬다. 감동이야.. 점심 같이 안 먹어 준다고 할 때 뭔가 있나 싶긴 했다. 그치만 포이랑 글렌이랑 점심 먹고 전력질주 한다고 했을 때는 진짜 믿었다... ㅋㅋㅋㅋㅋ 케이크는 여러 크루와 나눠 먹었다. 많은 사람들한테 축하 받아서 기뻤다 ^ㅅ^ (포비에게 김 과자도 선물로 받았다. 맛있었다.)\n- 레벨 인터뷰가 평가에는 안 들어간다고 해서 다행이었다. 그렇지만 역시 대답 못 할 때는 많이 창피할 거 같다. 열심히 준비해야지!\n- 박스터랑 체스 둬서 2판인가 3판인가 다 이겼다. 확실히 집중이 잘 될 때 해야 잘 되는 거 같다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부를 너무 안 하고 있나... 주변 사람들이 공부 안 하게 만드는 힘이 있나 싶다. 이번 주는 열심히 했다. 그렇지만 남아서 뭔가 하긴 했는데 남는 게 있었나 싶어서 반성하는 중이다. 더 많이 남겨가기 위해 노력하자.\n- 안 그런 줄 알았는데 일주일 내내 남아 있으니 굉장히 피곤했다. 금요일 TIL을 일요일 새벽에 쓰고 있는 걸 보면 .. ㅎ 바로 잠들어 버려서 내용이 잘 기억 안 난다. 진짜 얼른 적어야 했는데 ㅠㅠ\n- 나를 탓하는 생각이 많이 줄었다. 뭔가 안 좋은 말을 들었을 때 '에휴 그러게 왜 그랬어' 이런 생각 많이 했는데 지금은 그런 생각이 잘 안 들어서 신기했다. 자존감이 높아지는 것 같다.\n- 말하는 것에 신경을 많이 못 썼다. 이번 주는 에너지가 많이 없어서 (체스도 그렇고 몸 상태도 그렇고) 그냥 머릿속으로 생각난 대로 날카롭게 말한 게 있는 거 같다. 이번 주 동안 상처받은 크루가 있을 수도 있다는 생각이 들었다 😂 다음 주부터는 신경써서 말하는 습관을 들여보자 👍\n- 금세 방학이 가까워졌다. 시간은 정말 빠르게 흐른다. 방학 때 뭘 할 지, 그 전까지 얼마나 시간을 알차게 보내야 할 지 고민이 된다. 지금까지 시간이 무의미했다는 건 아니다. 무엇보다 값진 시간이었다. 그래도 앞으로도 멋진 시간을 보내기 위해서는 제대로 계획해야 할 거다. 다음 주는 내 성장을 노리는(?) 시간이 되었으면 좋겠다."},{"excerpt":"LOG 체스 2단계까지 구현했다. 못할 거 같았는데 다 해서 다행이었다. 지금까지 안 했던 재입력도 구현했다. 오랜만이라 어떻게 했었는지 기억 안 났는데 루카가 잘 해줘서 좋았다. 주드, 리오, 채채, 포이, 체인저, 콩하나, 글렌, 그레이와 만났다. 지금까지 말 안 해본 크루들이랑 말해봐서 좋았다 ㅋㅋㅋ 그래서 다들 나이가 어떻게 돼...? 나 아직도 …","fields":{"slug":"/2023-03-16/"},"frontmatter":{"date":"2023년 03월 16일 15:03","title":"2023년 03월 16일","tags":null},"rawMarkdownBody":"## LOG\n- 체스 2단계까지 구현했다. 못할 거 같았는데 다 해서 다행이었다. 지금까지 안 했던 재입력도 구현했다. 오랜만이라 어떻게 했었는지 기억 안 났는데 루카가 잘 해줘서 좋았다.\n- 주드, 리오, 채채, 포이, 체인저, 콩하나, 글렌, 그레이와 만났다. 지금까지 말 안 해본 크루들이랑 말해봐서 좋았다 ㅋㅋㅋ 그래서 다들 나이가 어떻게 돼...? 나 아직도 모르겠어..\n- 말랑, 아마란스, 포이, 망고, 토리, 박스터랑 점심 먹었다. 찜닭 먹었는데 요즘 밥맛 없어서 많이 못 먹었다. 박스터가 맛있게 먹었다면 됐어... 박스터가 생일 기념으로 사줬다. 박스터 little hit~~ 이렇게 적는 거 맞지?\n- 드디어 훈수 없이 박스터랑 체스해서 이겼다 ㅋㅎㅋㅎㅋ 앞으로 좀 더 정진(?)해서 주드한테도 도전해야겠다.\n- 오늘 데일리 있었는데 내일 데일리 마스터로 내가 걸렸다... ㅋㅎ 내일 뭘 해야할까. 좀 재밌는 거 하고 싶다. 재밌는 게임 내일 지하철타고 가면서 생각 좀 해봐야겠다.\n\n## 배운 것\n- ```@FunctionalInterface```를 사용하면 커스텀 함수 인터페이스를 만들 수 있다. (루카와 나는 매개변수를 2개 입력받는 함수를 생성했다.)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 꾸준히 노력(?) 하면 된다. 사실 나는 내 노력을 안 믿는 편이다. 실제로 난 노력을 잘 안 하기 때문.. 다음 주 헤나, 후추, 포이랑 스터디 있는 거 준비하려면 학습 로그도 써야 한다. 잘 준비하고 발표 준비도 열심히 하자.\n- 아쉽게도 이리내가 발표한 테코톡은 보지 못했지만, 코코닥이 발표할 때쯤엔 페어 프로그래밍이 어느 정도 마무리 돼서 보러갈 수 있었다. 발표 안 떨고 잘 하는 게 멋지다고 생각했다. 코코닥 차례에 엄청 질문이 많았는데, 질문에 잘 대답하는 것도 신기했다. 역시 테코톡 하는 사람은 엄청 준비를 많이 해야 하는 구나...\n- 이번 미션 하는데 브라운이 잠깐(?) 조언 해주셨다. 우리가 어떻게 구현했는지 다시 생각해볼 수 있어서 좋았다. 지금 머리가 잘 안 돌아간다. 일단 PR 제출하고 내일 어떤지 봐야겠다. 너무 졸리다.\n"},{"excerpt":"LOG 포이랑 체스해서 이겼다. 사실 루카가 훈수둬주긴 했지만...ㅎ 근데 하면서도 내가 체스 진짜 못한다고 생각했다 ㅋㅋㅋ 10시까지 남아서 미션했다. 이번에 이야기를 많이 해서 그런가 둘다 꽤나 납득할만한 코드가 나온 거 같다. 내일 폰 동작, 말 움직이기, 리팩토링하려고 한다. 할 수 있겠지..?? 포이, 토리, 망고, 제리와 저녁 먹으러 갔다. 원…","fields":{"slug":"/2023-03-15/"},"frontmatter":{"date":"2023년 03월 15일 14:03","title":"2023년 03월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 포이랑 체스해서 이겼다. 사실 루카가 훈수둬주긴 했지만...ㅎ 근데 하면서도 내가 체스 진짜 못한다고 생각했다 ㅋㅋㅋ\n- 10시까지 남아서 미션했다. 이번에 이야기를 많이 해서 그런가 둘다 꽤나 납득할만한 코드가 나온 거 같다. 내일 폰 동작, 말 움직이기, 리팩토링하려고 한다. 할 수 있겠지..??\n- 포이, 토리, 망고, 제리와 저녁 먹으러 갔다. 원래 맥날 가기로 했는데 포이가 갑자기 춥다고 서브웨이 가자고 해서 서브웨이 갔다. 근데 오늘따라 먹기가 싫어서 한 20%는 남겼다. 아쉽.\n- 오늘 월급(?) 받았다. 좀 더 여유가 생겼다. 사실 돈 쓸 일이 그렇게 많지 않다. 점심 저녁, 교통비, 커피 이렇게만 돈 쓰는 거 같다. 어째 우테코 오기 전보다 덜 쓰는 듯.\n- 집 가서 박스터랑 체스 한 판 했는데 또 짐 ㅋㅋ 체스 너무 어렵다. 역시 그런 건 나랑 안 맞아. 심리 게임은 잘 할 자신 있는데 ㅋㅋ\n\n## 배운 것\n- Function<T, R>: T는 파라미터, 리턴값으로 R을 리턴한다.\n\n## 궁금한 것\n- 테스트할 때 .getClass()를 안 쓰고 어떻게 할까?\n- instanceof 를 안 쓰는 방법은 없을까?\n- 인터페이스는 어떨 때 쓰면 좋을까?\n\n## 어려웠던 것\n- 절대적인 시간이 부족해서 일단 구현부터 한 부분도 있는데, 이래도 되는걸까. 약간의 죄책감.\n\n## 느낀 것\n- 확실히 페어와 말을 놓고 나니 더 적극적으로 의견을 나눌 수 있었다. 초반에는 편하게 말하는 게 좀 어색했지만, 금방 편하게 말할 수 있게 됐다. 의견을 낼 때도 무겁게 질문하기보다는 가벼운 질문을 할 수 있어 좋았다. (무엇보다 다른 사람들과 반말할 때 헷갈리지 않아서 좋았다 ㅋㅋ 요즘 다른 사람들한테도 반말 나올 거 같다. 정신 똑바로 차리자)\n- 할 건 엄청 많았지만 미션 이야기는 많이 했다. 오늘 내내 미션 했으니.. 어제 생각했던 구조 괜찮아보였는데 이야기하다 보니 부족한 점이 보였다. 루카가 우려되는 점을 솔직하게 말해줘서 서로 조율하면서 고쳐갈 수 있어서 좋았다. 다음에 페어 회고 할 때 말해줘야겠다. TDD 해야 된다고 자주 말해줘서 까먹지 않고 TDD 할 수 있었다 👍\n- 일찍 나오고 늦게 가니까 컨디션이 쉽지 않다. 요즘엔 그냥 7시에 눈이 떠져서 더 자고 싶다.. 주말에 좀 더 자고 싶은데 주말에는 생일이라 그것도 안 될 것 같다.\n"},{"excerpt":"LOG 문득 포이랑 대화하다가 생각했는데 요즘 혼자 있는 시간이 없다. 오늘은 특히 페어 프로그래밍 해서 더 그렇긴 하지만 ㅋㅋ 혼자 있는 거 좋아하던 나로써는 자각 못 했던 게 신기했다. 많이 성장했구나! 박스터랑 체스 뒀다. 초보라면서 체스 왜 잘 둠? 2판 했는데 2판 다 졌다ㅋㅋㅋㅋㅋ 체스 못 두는 거 맞는 말 되어 버렸다. 앞으로 박스터랑 체스 …","fields":{"slug":"/2023-03-14/"},"frontmatter":{"date":"2023년 03월 14일 15:03","title":"2023년 03월 14일","tags":null},"rawMarkdownBody":"## LOG\n- 문득 포이랑 대화하다가 생각했는데 요즘 혼자 있는 시간이 없다. 오늘은 특히 페어 프로그래밍 해서 더 그렇긴 하지만 ㅋㅋ 혼자 있는 거 좋아하던 나로써는 자각 못 했던 게 신기했다. 많이 성장했구나!\n- 박스터랑 체스 뒀다. 초보라면서 체스 왜 잘 둠? 2판 했는데 2판 다 졌다ㅋㅋㅋㅋㅋ 체스 못 두는 거 맞는 말 되어 버렸다. 앞으로 박스터랑 체스 내기는 절대 안 해야겠다 ^^\n- 어제보다는 속이 괜찮았다. 배고픈데 음식이 잘 안 들어가는 게 화난다. 적게 먹으면 또 배고픈데 먹을 수가 없다ㅠ 뭐 어떻게 안 되나? 며칠째 이러고 있는건지 🥺\n- 루카와 페어가 되었다. 점심에 토도로끼 가서 쇼유라멘 매운 맛 먹었다. 분명 저번에 갔을 때는 별로 안 매웠던 거 같은데 오늘은 너무 매웠다 ㅋㅋㅋ 그래도 꽤 많이 먹었다. 이번 페어 때는 좀 더 편한 분위기에서 하기 위해서 밥도 먹고 아이스 브레이킹도 열심히 했다. 루카와 말 놓은 첫 크루가 되었다. 정말 기념비적인걸 :)\n- 후추, 헤나, 포이와 저녁을 먹었다. 저번에 갔던 엄마 밥상에 갔는데 1시간 걸려서 음식이 나와서 6시 반에 밥 먹으러 가서 8시에 나왔다.. 한 분 밖에 안 계셔서 많이 오래 걸린 것 같다. 사실 나는 별 상관 없었는데 페어랑 남아서 하는 사람이 많았어서 좀 미안했다. 후추와도 말을 놓았다. 약간 함부로 반말 해버릴까봐 (헤나랑은 반말해서 가끔 주변 사람들한테도 반말할까봐 의식적으로 조심했다) 걱정했는데 다행히 오늘 무사히 말을 놓게 돼서 다행이다.\n- 저녁에 돌아와서 오리, 헙크와 트리플 프로그래밍했다. 약간 다른 사람들 의견 듣는 거 재밌었는데, 들으면서 좋은 아이디어가 떠올라서 여러 명한테 설명해줬다. 그런데 지금 다시 생각해보니 좀 더 좋은 게 있을 거 같기도 하고...\n- ~~오늘 왜이렇게 LOG가 많을까~~\n\n## 배운 것\n- 페어 프로그래밍 하느라 배운 게 없어서 슬프다..\n\n## 궁금한 것\n- 포이가 쓰던 익스트랙팅\n- stream 왜 쓸까?\n- 병렬 스트림은 언제 쓸까?\n\n## 어려웠던 것\n- 휴식하지 않으면 말도 안 되는 소리가 필터링이 안 된다.\n\n## 느낀 것\n- 난 사람들과 이야기하면서 공부하는 게 맞는 거 같다... 혼자 있으면 절대 공부 안 한다. 그나마 요즘에는 오래 남아있어서 그런가 머릿속에 남는 게 많다. 그런데 늦게 집에 오면 많이 피곤해진다. 집에 올 때 쯤에 굉장히 피곤해져서 TIL 안 쓰고 자버릴까봐 걱정된다. 지금은 12시 53분. 내일 일어날 수 있겠지?\n- '우테코 전의 나와 달라지기' 미션은 매우 성공적인 것 같다. 진짜 다른 사람이 되어가고 있다. '진짜 나'가 변하고 있는 걸까, 아니면 '나'가 변하고 있는걸까? 아직 잘 모르겠다. 그런 건 모르더라도 요즘 집 밖에 있는 게 더 재밌다는 건 확실하다. 재밌게 즐기고 있다. 2월 초에 썼던 TIL 에서 긍정적인 영향을 받고 싶다고 썼던데, 엄청 긍정적인 영향을 받아서 기분이 좋다.\n- 체력적으로 좀 지친다는 생각을 했다. 요즘 밥도 잘 못 먹는데 오래 남아 있기도 해서 웃긴데 막 웃지 못하는 웃지 못할 일이 일어난다. 즐거운 건 나눠야 좋지. 나는 뭘 잘하나 생각해봤다. 일단 웃는거 하나는 잘하는 거 같다.\n- 많이 알아가지 않더라도, 어제의 나보다 더 많이 알자고 다짐했다. 남들과 비교하는 건 의미 없다. 그걸 깨달은 것만 해도 좋다. 이젠 존재하지 않는 허상을 쫓을 필요가 없다. 어제의 나라는 지표는 매우 구체적이니까. 그래서 부담이 덜하다.\n"},{"excerpt":"3/14 자바로 DB 다뤄보기 Java에서 JDBC 드라이버를 이용하여 DB와 연결하기 JDBC Java DataBase Connectivity 자바 애플리케이션에서 DB 프로그래밍을 할 수 있도록 도와주는 표준 인터페이스. 코드 option + command + F : 필드로 추출 3/17 람다와 스트림 자바에서 함수형으로 프로그래밍할 수 있게 도와주는…","fields":{"slug":"/level1-week6/"},"frontmatter":{"date":"2023년 03월 14일 02:03","title":"레벨1 6주차","tags":["레벨1","우테코"]},"rawMarkdownBody":"# 3/14\n\n## 자바로 DB 다뤄보기\nJava에서 JDBC 드라이버를 이용하여 DB와 연결하기\n\n### JDBC\n- Java DataBase Connectivity\n- 자바 애플리케이션에서 DB 프로그래밍을 할 수 있도록 도와주는 표준 인터페이스.\n\n### 코드\n\n```java\nfinal UserDao userDao = new UserDao();\nfinal Connection connection = userDao.getConnection();\n```\n\n```java\npublic final class UserDao {\n\tpublic Connection getConnection() {\n\ttry {\n\t\treturn DriverManager.getConnection(\n\t\t\t\"jbdc:mysql:localhost:13306/chess?useSSL=false&serverTimezone=UTC\",\n\t\t\t\"root\", \n\t\t\t\"root\"\n\t\t\t);\n\t\t} catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic void insert(final User user) {\n\t\tString sql = \"INSERT INTO user (user_id, name) VALUES (?, ?)\";\n\t\ttry (\n\t\tfinal Connection connection = getConection();\n\t\tfinal PreparedStatment preparedStatement = connection.prepareStatement(sql))\n\t\t{\n\t\t\tpreparedStatement.setString(1, user.userId());\n\t\t\tpreparedStatement.setString(2, user.name);\n\t\t\tpreparedStatement.executeUpdate();\n\t\t}\n\t\tcatch(final SQLException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t} \n\n\tpublic void findByUserId(final String userId) {\n\t\tString sql = \"SELECT * FROM user WHERE user_id = ?\";\n\t\ttry (\n\t\tfinal Connection connection = getConection();\n\t\tfinal PreparedStatment preparedStatement = connection.prepareStatement(sql))\n\t\t{\n\t\t\tpreparedStatement.setString(1, userId);\n\t\t\tfinal var resultSet = preparedStatement.executeQuery();\n\t\t\tif(resultSet.next()) {\n\t\t\t\treturn new User(\n\t\t\t\t\tresultSet.getString(\"user_id\"),\n\t\t\t\t\tresultSet.getString(\"name\")\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcatch(final SQLException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n```\n\noption + command + F : 필드로 추출\n\n# 3/17\n\n## 람다와 스트림\n\n- 자바에서 함수형으로 프로그래밍할 수 있게 도와주는 도구\n- 함수형 프로그래밍? 작업을 어떻게 수행할 것인지, How에 집중한다.\n\n### 무엇에 집중할 것인가\n\n### 함수란 무엇인가\n\n같은 인수값으로 함수를 호출하면 항상 같은 값을 반환한다. (랜덤 요소 X. Scanner, Random)\n함수나 메서드는 지역 변수만을 변형해야 함수형이라 할 수 있다. 함수나 메서드에서 참조하는 객체가 있다면 해당 객체는 불변해야 한다.\n\n객체의 모든 필드가 final이어야 한다. \n모든 참조 필드는 불변 객체를 직접 참조한다.\n\n---\n메서드 내에서 생성한 객체의 필드는 갱신할 수 있으나, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 한다.\n다음에 메서드를 다시 호출한 결과에 영향을 미치지 않아야 한다.\n\n함수나 메서드가 어떤 예외도 일으키지 않아야 한다.\n\n### 멀티코어와 동시성 제어\n\n자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용을 기반으로 동시성 제어를 할 수 있다.\n\n### Stream API\n\n"},{"excerpt":"LOG 오늘 빨리 갔다. 아침에 바로 눈이 떠져서 20분 억지로 더 잤다. 마음에 드는 아우터가 있는데 화장 안 하면 못 입을 거 같아서 오랜만에 화장했다. 잘 돼서 아침부터 기분 좋았다. 속이 안 좋았다. 어제 저녁에도 밥을 남겼는데 점심에도 속이 안 좋았다. 불고기 백반 먹었는데 절반을 포이가 먹었다. 포이가 배불렀다면 됐어... 근데 여전히 속이 안…","fields":{"slug":"/2023-03-13/"},"frontmatter":{"date":"2023년 03월 13일 14:03","title":"2023년 03월 13일","tags":null},"rawMarkdownBody":"## LOG\n\n- 오늘 빨리 갔다. 아침에 바로 눈이 떠져서 20분 억지로 더 잤다. 마음에 드는 아우터가 있는데 화장 안 하면 못 입을 거 같아서 오랜만에 화장했다. 잘 돼서 아침부터 기분 좋았다.\n- 속이 안 좋았다. 어제 저녁에도 밥을 남겼는데 점심에도 속이 안 좋았다. 불고기 백반 먹었는데 절반을 포이가 먹었다. 포이가 배불렀다면 됐어... 근데 여전히 속이 안 좋다.\n- 요즘 근데를 많이 쓴다. 모든 말이 근데부터 시작한다 ㅋㅋㅋㅋ 근데 그만 쓰려고 노력해야겠다.\n- 오늘은 헤나랑 얘기를 많이 했다. 학습 로그 말하기가 4시였는데 5시까지 말했다. 학습 로그 말하기 저번보다 잘 말한 것 같아서 좋다 ! 👍 저번보다 공부를 많이 하고 말해서 그런지, 말하기 전에 고민하는 시간이 많이 줄었다. 어.. 라고 말하는 빈도도 줄어서 좋았다. 나중에 학습 회고 말하기는 좀 더 예전부터 준비하고 만들어어야겠다. 너무 닥쳐서 만들다보니 시간이 없어서 예시를 많이 생략했는데 넣었어도 좋았을 거 같다.\n\n## 배운 것\n\n- IntUnaryOperator가 오토 박싱이 일어나지 않아서 성능이 좋다는 점을 알게 되었다.\n- POP, IMAP 키워드를 알게 되었다. 좀 더 알아보자.\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n\n- 아침에 주노의 기술부채를 같이 확인하는 시간을 가졌는데 매우 유익했다. 오히려 같이 찾아보니 재밌었다. 혼자서 책 볼 때는 진짜 재미없었는데.\n- 내일 페어랑은 미리 친해지고 진행해 볼 생각이다. 페어만 괜찮다면 점심 같이 먹고... 아니면 말고... 😂 편한 자리에서 의견도 잘 나오고 질문도 잘 할 수 있으니까 좋다. 이번 방식은 잘 먹혔으면 좋겠다!\n- 데일리 때 2등했다! 주말에 줌으로 만나서 열심히 했던 보람이 있다 ㅋㅋㅋ 에코의 스티커를 받았다. AWS 스티커 매우 탐났는데 받아서 좋았다. 그런데 원래 노트북에 붙일 생각이었는데 맥북이라 못 붙이겠다ㅋㅋㅋ 어딘가에 잘 써먹어야겠다. 상품 협찬해주신 에코 감사합니다 🙇‍♀️\n"},{"excerpt":"그냥 좀 하자 '그냥'은 생각보다 어렵다 사실 '그냥'이 제일 어렵다.\n용기 없는 사람은 더욱 그렇다. 그러나 두려운 마음이 내 발목을 잡는 건 싫었다.\n주변에는 언제나 시작도 하지 않고 포기한 일들이 널브러져 있다. 마음속에 부채감으로 남아 있는 일들이다. 괜히 안 될 것 같으니까, 시작하는 것도 무서워서 주저하다 시도조차 하지 않았다. 재미있게도 시간…","fields":{"slug":"/level1-writing/"},"frontmatter":{"date":"2023년 03월 13일 11:03","title":"레벨1 글쓰기","tags":["레벨1","글쓰기","우테코"]},"rawMarkdownBody":"## 그냥 좀 하자\n\n### '그냥'은 생각보다 어렵다\n\n사실 '그냥'이 제일 어렵다. \n용기 없는 사람은 더욱 그렇다. 그러나 두려운 마음이 내 발목을 잡는 건 싫었다.\n주변에는 언제나 시작도 하지 않고 포기한 일들이 널브러져 있다. 마음속에 부채감으로 남아 있는 일들이다.\n\n괜히 안 될 것 같으니까, 시작하는 것도 무서워서 주저하다 시도조차 하지 않았다.\n\n재미있게도 시간이 지나고 나면 그때의 나를 이해하지 못하는 것은 현재의 나였다.\n그때 할 걸, 그거 한다고 죽는 것도 아닌데 좀 해보지... 언제나 후회했다.\n\n갈수록 나아지는 게 아니라 오히려 뒤로 가는 것 같았다. 잘했던 일도 자신감이 없어졌다.\n진짜 잘하고 있는 게 맞을까? 사실은 다 우연이나 운 아니었을까? \n부정적인 질문들은 끝이 없었다. \n\n그렇게 2년 간 슬럼프에 빠졌다.\n아무것도 하기 싫어서 개발도 반쯤 놓았다.\n배우는 걸 좋아했던 나는 더 이상 없었다.\n흥미도 없고, 잘할 자신도 없어서 재미없게 살았다.\n\n### 처음으로 '그냥' 해 본 것\n\n우아한테크코스에 지원한 것은 처음으로 상황을 따지지 않고 해 본 일이다.\n어느 날 예전에 봤던 공고가 기억나서 우연히 들어가 봤는데 지원자를 받고 있었다.\n갑자기 오기가 생겼다. 나도 물러서지 않고 '그냥' 해 보고 싶었다.\n\n지원할 시기가 중간고사 기간이었지만 자기소개서를 썼다.\n프리코스도 팀 프로젝트가 많아 시간이 없었지만 할 수 있는 만큼 했다.\n최종 코딩테스트 날도 시험 이틀 전이었지만 '그냥 해보는 거야. 괜찮아' 라고 생각하며 갔다.\n\n합격한 날에는 그저 신기했다. 진짜 그냥 하면 될 수도 있구나!\n결심했다. 다른 곳이라면 몰라도 우테코에서만큼은 잘하고 싶었다.\n\n### 그럼에도 '그냥' 주어지는 것은 없다\n\n우테코를 시작하기 전에, '이전의 나와 다른 사람이 되기'라는 목표를 세웠다. 슬럼프에서 벗어나 더 나은 사람이 되고 싶었으니까.\n\n그렇지만 첫 주는 생각보다 힘들었다. 역시 한 번에 바뀔 수는 없었다.\n\n그런 생각이 들었다.\n앞으로 비슷한 분야의 사람들을 이렇게 많이 만날 수 있을까? 분명 아니다.\n그런데도 지금까지 살던 대로 살고 있었다. 나서기 싫어하고, 먼저 다가가길 주저했다.\n10개월 뒤에도 예전과 같은 사람이기는 싫었다. 적어도 어제의 나보다는 나아져야 했다!\n\n완전 다른 사람으로 평생 사는 건 힘들지만 10개월 동안 바뀌는 건 쉽지 않을까?\n이번 기회에 시작하기 어려웠던 것들을 망설임 없이 도전해보자고 다짐했다.\n\n사람들에게 먼저 인사하고, 말을 걸었다. 주저하지 않고 말하는 방법을 연습했다.\n다들 말 걸기 전에는 무서운(?) 사람들인 줄 알았는데 전혀 아니었다.\n크루들과 하는 토론, 이야기, 뭐든 좋았다.\n지금은 크루들과 생활하는 게 정말 재밌다. 방학이 아쉬울 정도다.\n\n무엇보다 혼자 찾아보지 않고 다른 사람의 의견을 물어보게 된 것이 가장 큰 변화였다.\n여러 사람의 의견을 듣고 판단할 수 있는 사람이 되어 가고 있어 기쁘다.\n\n한 달이 지난 지금 돌아보면, 나는 언제나 어제의 나보다 나은 사람이 되어 있었다.\n\n### Just Do It!\n\n머릿속에서 맴도는 생각들을 하지 않으면 마음이 편해진다.\n\n```이해 안 되는데 다시 말해달라고 해도 되나?``` \n```그냥 말 걸어봐도 되나?```\n```굳이 물어볼 필요가 있을까? 이유가 있겠지...```\n\n그럴 땐 생각하지 않고 그냥 해보는 것도 좋았다.\n\n잘 모를 때는 크루에게 물어보면 된다.\n지금까지는 말 걸어서 싫어하는 크루는 못 봤다.\n오히려 다른 크루에게 질문하며 의견을 나누는 건 서로에게 도움이 됐다.\n\n그냥 해도 괜찮다.\n우테코에서는 가능하다.\n\n앞으로도 망설여질 때는 Just Do It.\n계속해서 어제의 나와 경쟁할 거다.\n안 될 것 없다. 할 수 있다 :)"},{"excerpt":"스터디 개요 레벨 인터뷰 대비 겸 Prolog 글도 좀 써보자 해서 만들어진 스터디 인원: 베로, 포이, 후추, 헤나, 말랑 Repository: GitHub 스터디 시간 월요일 8시 금요일 3시 진행 4명끼리 한 명씩 10분 방학에도 할 가능성 있음. 포맷 1단계 : 이 스터디 안에서 지금까지 안 한 주제를 선정해서(안 겹치게) 조사하고, 특정 요일 전…","fields":{"slug":"/study-rule/"},"frontmatter":{"date":"2023년 03월 13일 10:03","title":"베포후헤말 스터디 규칙","tags":["레벨1","우테코"]},"rawMarkdownBody":"\n## 스터디 개요\n\n- 레벨 인터뷰 대비 겸 [Prolog](https://prolog.techcourse.co.kr/) 글도 좀 써보자 해서 만들어진 스터디\n- 인원: 베로, 포이, 후추, 헤나, 말랑\n- Repository: [GitHub](https://github.com/woowacourse-study/2023-Prolog-RoadMap)\n\n## 스터디 시간\n\n- 월요일 8시\n- 금요일 3시\n\n## 진행\n\n- 4명끼리 한 명씩 10분\n- 방학에도 할 가능성 있음.\n\n### 포맷\n\n- 1단계 : 이 스터디 안에서 지금까지 안 한 주제를 선정해서(안 겹치게) 조사하고, 특정 요일 전에 글을 쓴다.\n- 2단계 : 다른 크루의 로드맵을 보고 질문할 내용을 정리한다. (명당 2-3개 질문 할당)\n- 3단계 : 스터디 당일 날 각자 해당 크루에게 질문을 한다.\n- 4단계 : 질문 시간이 끝나면 아주 짧은 시간도 좋으니 5분 정도 피드백을 한다.\n\n### 스터디\n- 들어온 질문에 대답할 때 20-30초 안에 끝낼 수 있는 정도의 내용 준비하기\n- 분량은 상관 없음. 10분 미만으로 발표하기.\n- 짧아도 되는데, 짧을 거면 확장된 질문에 대답할 수는 있어야 한다. \n- (좀 더 생각해보기) 꼬리 질문 대비\n\n## 스터디 글 모음\n\n- [[vepohuhemal-study-question|베포후헤말 스터디 질문]]\n- [[default-method|디폴트 메서드란?]]\n- [[functional-interface|함수형 인터페이스는 무엇이고, 람다와 어떤 관계가 있나요?]]\n- [[grasp|GRASP란 무엇인가요?]]"},{"excerpt":"LOG 힘이 나는 날은 아니었다. 그냥 좀 처지는 날이었는데 미션이랑 공부를 하면서 노래 들으니 기분이 좀 나아졌다. 유튜브 뮤직 알고리즘 굉장히 노래 추천 잘 해준다 ㅋㅋ 월요일 날 빨리 가기로 했다. 월요일은 집에도 늦게 갈 생각이다. 집에 가서 딱히 할 게 없기 때문... 늦게 집 가면 어떤 일이 일어날 지 관찰해봐야겠다. 분명 배는 고픈데 입맛이 …","fields":{"slug":"/2023-03-12/"},"frontmatter":{"date":"2023년 03월 12일 15:03","title":"2023년 03월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 힘이 나는 날은 아니었다. 그냥 좀 처지는 날이었는데 미션이랑 공부를 하면서 노래 들으니 기분이 좀 나아졌다. 유튜브 뮤직 알고리즘 굉장히 노래 추천 잘 해준다 ㅋㅋ\n- 월요일 날 빨리 가기로 했다. 월요일은 집에도 늦게 갈 생각이다. 집에 가서 딱히 할 게 없기 때문... 늦게 집 가면 어떤 일이 일어날 지 관찰해봐야겠다.\n- 분명 배는 고픈데 입맛이 없다. 저녁은 냉동 볶음밥이었는데 절반 먹고 남겼다. 늦게 먹고 띄엄띄엄 먹으면 진짜 먹기 싫어진다. 원치 않은 다이어트 식단(?) 되어 버렸다.\n\n## 배운 것\n- 상태 패턴이란? [[state-pattern|상태 패턴]]\n- 싱글턴 vs 정적 메서드 -> [[singleton-vs-static]]\n\n## 궁금한 것\n\n## 어려웠던 것\n- 학습 로그 적는거 진짜 어렵다. 그냥 의견 내기면 모르겠는데 정보 전달이니 꼼꼼히 조사하고 빈틈없이 준비해야해서 부담이 된다.\n\n## 느낀 것\n- 혼자 있어서 기분이 안 좋았던 건 아닌 것 같고, 집에만 있어서 딱히 웃을 일이 없어서 그런 것 같다. 사람과대면으로 이야기 하고 싶다.\n- 다시 날씨가 추워져서 옷을 따뜻하게 입어야 한다. 분명 저번주 금요일은 엄청 따뜻했는데.. 오늘 과외 갈 때 날씨가 너무 추워서 놀랐다.\n- 새싹교실 새싹들을 배정 받았다. 21학번 편입생 2명, 23학번 1명인데 일단 사람이 적은 건 마음에 든다. 문제는 실력 차이... 정도가 될 것 같다. 실력 차이가 나면 진도를 확 뺄 수도 없고 느리게 나갈 수도 없고 애매하다. 다음 주 토요일부터 하기로 했으니까 열심히 준비해보자!\n- 내가 너무 생각없이 놀고 있나라는 생각이 들었다. 뭔가 다들 열심히 하고 있고 나만 신난 느낌? 우테코에서 뭘 가져갈 지를 좀 더 깊게 생각해봐야겠다. 사람이라면 이대로 해도 될 것 같고, 실력이라면 공부에 더 집중해야겠지. 내가 해야 하는 것 말고, 지금은 내가 하고 싶은 걸 고르고 싶다. 이유는 딱히 없고 지금은 그냥 그러고 싶어서. 레벨2 때부터는 어떻게 될 지도 모르는 거니까.\n\n"},{"excerpt":"글을 쓰게 된 배경 망고가 1단계 블랙잭 미션을 리팩터링하다 나에게 질문했다. InputView를 static method를 갖는 util 클래스로 구현하는 것과 싱글턴으로 구현하는 것의 차이는 뭘까? 나는 그 질문에 명쾌하게 답하지 못했다.\n내 1단계 블랙잭 미션은  가 util 클래스로 구현되어 있었다. 딱히 이유가 있냐고 하면... 막연히 싱글턴 패…","fields":{"slug":"/singleton-vs-static/"},"frontmatter":{"date":"2023년 03월 12일 13:03","title":"singleton vs static class","tags":["우테코","레벨1","학습로그"]},"rawMarkdownBody":"\n## 글을 쓰게 된 배경\n\n망고가 1단계 블랙잭 미션을 리팩터링하다 나에게 질문했다.\n\n> InputView를 static method를 갖는 util 클래스로 구현하는 것과 싱글턴으로 구현하는 것의 차이는 뭘까?\n\n나는 그 질문에 명쾌하게 답하지 못했다.\n내 1단계 블랙잭 미션은 ```InputView``` 가 util 클래스로 구현되어 있었다. 딱히 이유가 있냐고 하면... 막연히 싱글턴 패턴이 안티 패턴이라고 해서 안 썼던 것 뿐이었다. \n\n나중에 비슷한 구현을 하게 될 때 둘 중에 어떤 걸 쓸 지 결정하기 위해 이 글을 썼다.\n\n## Singleton(싱글턴) 패턴\n\n위키 백과에서는 다음과 같이 정의한다.\n\n> [소프트웨어 디자인 패턴](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4)에서 **싱글턴 패턴**(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 **싱글턴 패턴**이라고 한다.\n\n즉, 싱글턴 패턴이란 단 하나의 인스턴스만 생성하여 사용하는 디자인 패턴이다.\n\n가장 간단한 싱글턴 예제는 다음과 같다. \n\n```java\npublic class Singleton() {\n\t// Singleton 객체를 static으로 선언한다.\n\tprivate static Singleton instance;\n\n\t// 생성자를 private으로 선언한다.\n\tprivate Singleton() {}\n\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tthis.instance = new Singelton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n생성자를 private으로 선언하여 외부에서 객체를 생성하지 못하도록 막는다.\n객체를 생성할 수 없지만, 정적 팩토리 메서드를 통해 인스턴스를 전달받을 수 있다.\n\n그렇지만 문제가 일어날 수 있는 부분은 너무나도 잘 보인다. 바로 동시성 문제다!\n\n멀티스레드 환경에서는 두 개 이상의 스레드가 ```getInstance()```를 수행하는 경우 두 개 이상의 인스턴스가 생성되는 문제가 생길 수 있다.\n\n```java\npublic class Main {  \n    public static void main(String[] args) {  \n        Runnable runnable = () -> {  \n            Singleton singleton = Singleton.getInstance();\n            System.out.println(singleton.hashCode());  // hashcode 출력\n        };  \n  \n        for(int i = 0; i<10; i++) {  \n            Thread thread = new Thread(runnable);  \n            thread.start();  \n        }  \n    }\n}\n```\n\n```\n결과\n1448770673\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n1784999009\n```\n\n분명 싱글턴이라고 했는데 hashcode가 다르다. 왜일까?\n\n이유는 모든 스레드가 동시에 도착하여 객체가 생성되지 않은 null 임을 확인하게 되기 때문이다. 스레드가 도착했을 때 instance가 null 이므로 스레드들이 계속해서 객체를 생성하게 되는 것이다.\n\n동시성을 보장할 때 가장 자주 사용되는 방법은 Holder initialization 방법이다.\n\n```java\npublic class Singleton {  \n    private Singleton() {}  \n  \n    public static Singleton getInstance() {  \n        return LazyHolder.INSTANCE;  \n    }  \n  \n    private static class LazyHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n}\n```\n\nholder 안에 선언된 instance가 static 이기 때문에 클래스 로딩 시점에 한 번만 호출된다는 것을 이용한다. 클래스 로딩 시에는 thread-safe가 보장되기 때문에 객체가 단 한 번만 생성된다.\n\n## 정적 메서드 (static method)\n\n정적 메서드는 클래스의 인스턴스 없이 호출이 가능한 메서드이다.\n\n```java\npublic static void printValue(final String value) {\n\tSystem.out.println(value);\n}\n```\n\n클래스의 인스턴스가 아닌 클래스와 연결되므로 힙의 Permanent Generation 영역에 저장된다.\n\n\n## 싱글턴 vs 정적 메서드\n\n드디어 본론이다. 그래서 뭘 쓰는 게 좋다는 걸까?\n\n### 싱글턴 장점\n\n- 런타임 다형성을 활용할 수 있다.\n- 인터페이스를 구현할 수 있다.\n- 객체로 존재하므로 싱글턴을 매개변수로 다른 메서드에 전달할 수 있다.\n\n### 싱글턴 단점\n\n- 너무 많은 일을 위임하거나 공유하는 경우 coupling이 많아지고 결합도가 높아진다. 결합도가 높아짐에 따라 수정이 어려워지고 테스트하기 어려워진다.\n- 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖게 되어 안정성이 떨어진다.\n\n### 정적 메서드의 장점\n\n- 매번 인스턴스를 생성하기 위해 생성자를 호출하지 않아도 되므로 낭비되는 메모리를 줄일 수 있다.\n- 객체를 생성하지 않고 사용 가능하기 때문에 속도가 빠르다.\n\n### 정적 메서드의 단점\n\n- static을 사용하게 되면 프로그램 시작부터 끝까지 메모리에 할당된 채로 남아있다. static 영역은 Garbage Collector의 관리를 받지 않기 때문에 프로그램이 종료될 때까지 메모리에 존재하게 된다.\n- 오버라이드가 불가능하며, 객체와 관련이 없기 때문에 절차지향적 성향이 강하다고 볼 수 있다. 무분별한 사용이 객체 지향을 해칠 수 있다.\n\n## 결론\n\n**주관적인 결론**\n\n싱글턴은 단 하나의 클래스 인스턴스만 필요하고, 모든 곳에서 동일한 상태를 유지하고 싶은 경우 사용한다. 이후 클래스 확장을 통한 메서드 재정의가 필요한 경우에 사용한다.\n\n정적 클래스는 mocking 하기 어렵기 때문에 테스트가 어렵지만, 싱글톤은 mocking 하는 것이 쉽기 때문에 테스트 작성이 용이하다.\n\n그러나 정적 메서드는 내부 상태를 변경할 필요가 없고, 매개 변수에 대해서만 작동한다면 정적 메서드를 사용할 수 있다. 또한 다형성이 필요 없고 앞으로 객체 지향을 적용할 필요가 없을 때도 사용 가능하다.\n메서드에 대한 전역 접근만 제공하는 경우, 정적 클래스를 사용하는 것을 고려해볼 수 있다.\n\n지금까지의 미션들은 이후 view가 콘솔이 아닌 다른 것으로 변경될 수 있으므로 변경이 용이해야 한다. 얼마든지 추가적인 확장이 생길 수 있으므로 미션에서는 싱글턴을 사용하는 것이 좋을 듯 하다.\n\n## 참고 자료\n\n- https://tecoble.techcourse.co.kr/post/2020-11-07-singleton/\n- https://tecoble.techcourse.co.kr/post/2020-07-16-static-method/\n- https://javarevisited.blogspot.com/2013/03/difference-between-singleton-pattern-vs-static-class-java.html#axzz7vkYkDfOH"},{"excerpt":"상태 패턴이란? 상태 패턴을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다. 직접 상태를 체크하여 상태에 따른 행위를 호출하는 것이 아닌 상태를 객체화하여 필요에 따라 다르게 행동하도록 위임한다. 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다. 구성을 이용하여 코드 내의 조건문들을 대체한다. 상태 패턴 vs 전략 패…","fields":{"slug":"/state-pattern/"},"frontmatter":{"date":"2023년 03월 10일 02:03","title":"상태 패턴","tags":["디자인패턴","우테코","레벨1"]},"rawMarkdownBody":"\n## 상태 패턴이란?\n\n- 상태 패턴을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다.\n- 직접 상태를 체크하여 상태에 따른 행위를 호출하는 것이 아닌 상태를 객체화하여 필요에 따라 다르게 행동하도록 위임한다.\n- 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다.\n- 구성을 이용하여 코드 내의 조건문들을 대체한다.\n\n## 상태 패턴 vs 전략 패턴\n\n- 상태 패턴: 상태 객체에 일련의 행동이 캡슐화된다. Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡기게 된다. 객체의 내부 상태에 따라 현재 상태를 나타내는 객체가 바뀌고, 클라이언트는 상태 객체를 몰라도 된다.\n- 전략 패턴: 클라이언트가 Context 객체에게 어떤 전략 객체를 사용할지 지정해준다. 서브 클래스를 만드는 방법을 대신하여 유연성을 극대화하는 용도로 사용된다.\n\n### 참고 사항\n\n- State에 해당하는 클래스를 디자인할 때는 인터페이스 대신 추상 클래스 사용도 생각해보면 좋다. 구상 상태 클래스를 건드리지 않고 추상 클래스에 메소드에 추가하면 되기 때문이다.\n\n## 장단점\n\n### 장점\n\n- 새로운 상태가 추가되더라도 Context의 코드가 받는 영향이 최소화된다.\n- 클래스를 추가하더라도 기존의 메서드 코드는 그대로 유지된다.\n- 상태별 동작을 수정하기 쉽다.\n- 조건문이 줄어들어 코드가 간결해지고 가독성이 올라간다.\n\n### 단점\n\n- 상태에 따른 조건문을 대신한 상태 객체가 증가하여 관리해야 할 클래스의 수가 증가한다.\n\n## 참고 자료\n\n- 헤드 퍼스트 디자인 패턴 Ch.10\n- [tecoble](https://tecoble.techcourse.co.kr/post/2021-04-26-state-pattern/)"},{"excerpt":"LOG 박스터에게 말 걸어보기 레벨1 히든 미션 달성했다. 근데 이야기 시작하게 되자마자 바로 말을 놔버렸다..ㅋㅋㅋ 오히려 좋아. 예전부터 얘기할 각을 열심히 쟀는데 잘 돼서 뿌듯하다(?) 박스터가 젤리 사줘서 맛있게 먹었다. 끝날 때쯤에 네오와 저번에 했던 그리스 로마 신화 이야기했다. 재밌게 들어주셔서 나도 얘기하면서 재밌었다 ㅋㅋ 하마드 코드 보면…","fields":{"slug":"/2023-03-10/"},"frontmatter":{"date":"2023년 03월 10일 02:03","title":"2023년 03월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 박스터에게 말 걸어보기 레벨1 히든 미션 달성했다. 근데 이야기 시작하게 되자마자 바로 말을 놔버렸다..ㅋㅋㅋ 오히려 좋아. 예전부터 얘기할 각을 열심히 쟀는데 잘 돼서 뿌듯하다(?) 박스터가 젤리 사줘서 맛있게 먹었다.\n- 끝날 때쯤에 네오와 저번에 했던 그리스 로마 신화 이야기했다. 재밌게 들어주셔서 나도 얘기하면서 재밌었다 ㅋㅋ\n- 하마드 코드 보면서 하마드랑 이야기했다. 내 의견이 하마드한테 도움이 되어서 기뻤다 😄 코드 리뷰하는 거 재밌다.\n- 헤나가 고민하고 있는 부분에 대해서 허브, 글렌이랑 같이 생각해봤다. 헤나는 view의 함수 메서드가 도메인까지 흘러들어가는 것을 걱정하고 있으면서도 테스트하기 힘든 BlackJack에 중요한 도메인 로직이 있다는 것에 불편함을 느낀 것 같았다. 나도 헤나처럼 함수를 매개변수로 넘긴 케이스라 공감이 됐다. 나는 도메인까지 함수 인터페이스가 흘러가는 건 아닌 것 같아서 그대로 유지할 것 같다고 했다. 나중에 헤나가 어떻게 고쳤는지 봐야겠다.\n- 데일리 때 쥬니가 불러주는 년도에 어떤 걸 했는지 말하는 게임을 했다. 알게모르게 다른 사람들의 나이를 알아버렸다 ㅋㅋㅋ 데일리가 재밌어서 아침을 즐겁게 시작할 수 있는 것 같다.\n\n## 배운 것\n- 네오가 강의에서 한 내용은 상태 패턴에 대한 이야기 같다. -> [[state-pattern|상태 패턴]]\n- IntUnaryOperator\n- Fixture: 테스트 실행을 위한 베이스라인으로 사용되는 객체들의 **고정된 상태**\n- 메서드에 final: 하위 클래스가 메서드를 오버라이딩 할 수 없게 한다.\n- 패키지에서만 사용한다는 확신이 든다면 접근 제어자를 default로 설정해서 외부에서 만들 수 없도록 한다.\n- `assertThat(Double).isEqualTo` 를 사용하면 부동 소수점 때문에 제대로 계산이 되지 않을 수도 있어서 `isCloseTo` 를 사용하는 것이 좋다.\n\n## 궁금한 것\n- 상속이 안 좋은 이유가 있긴 하지만 조합이 그만큼 좋은지는 모르겠다. 여러 사람의 의견을 들어봤지만 확실하게 와닿는 게 없어서 아직은 알쏭달쏭한 상태다. 이번 미션 제출할 때 다니에게 물어봐야겠다.\n\n## 어려웠던 것\n- 글을 써보자! 하고 이펙티브 자바 읽으려고 했는데 다른 사람들과 이야기 하느라 결국 못 썼다.. 이럴거면 그냥 캠퍼스에서는 이야기를 많이 듣고, 집와서 해야 되나 싶다. 아직 레벨1이라 이런 고민도 할 수 있는 것 같다. 나중 가면 다들 바빠서 이야기 못할지도.. 오히려 지금 더 즐겨야겠다 ㅋㅋㅋ \n\n## 느낀 것\n- 이야기 하는 거 별로인 것 같았는데 구현하다보니 예전에 크루들이랑 이야기하고 고민했던 부분이 나와서 오히려 이렇게 의견 많이 들어보는 것도 좋은 듯 하다. 앞으로도 더 열심히 궁금해 하자.\n- 사실 금요일 TIL이 아니라 일요일에 적고 있다 ㅋㅋㅋ 금요일에 쓰고 자려고 했는데 역시나 너무 졸려서 그냥 자버렸다 ㅠㅠ 다음 주는 또 노력해보자.\n- 날씨가 따뜻해서 좋았다. 그렇지만 다음 주부터는 다시 추워져서 패딩을 입어야 할 거 같다. 얼른 얇은 옷을 입고 싶다. 캠퍼스는 여전히 더워서 반팔을 입고 갔었는데 시원하고 좋았다. 에어컨 틀기 전까지는 반팔을 안에 입고 가야겠다.\n- 벌써 방학이 얼마 안 남았다. 지금은 아쉽다는 생각이 드는 걸 보니 잘... 하고 있을지도...? 레벨1도 레벨 인터뷰가 있나? 좀 긴장된다.\n\n"},{"excerpt":"LOG 브라운과 커피챗 했다. 상담, 코칭 둘 다 딱히 할 게 없어서 커피챗을 골랐다. 스타벅스에 가서 커피 마시면서 이야기를 했다. 예전의 나였다면 들어보지 못했을 이야기를 듣게 되어서 많이 놀라웠다. 아직 적응하기 힘들어 하시는 분들에 비해 나는 적응을 잘한 편인 것 같다. 주간 회고 모임 조원들과 오프라인으로 만났다. 프론트엔드가 몇 분 더 있을 줄…","fields":{"slug":"/2023-03-09/"},"frontmatter":{"date":"2023년 03월 09일 05:03","title":"2023년 03월 09일","tags":null},"rawMarkdownBody":"## LOG\n- 브라운과 커피챗 했다. 상담, 코칭 둘 다 딱히 할 게 없어서 커피챗을 골랐다. 스타벅스에 가서 커피 마시면서 이야기를 했다. 예전의 나였다면 들어보지 못했을 이야기를 듣게 되어서 많이 놀라웠다. 아직 적응하기 힘들어 하시는 분들에 비해 나는 적응을 잘한 편인 것 같다.\n- 주간 회고 모임 조원들과 오프라인으로 만났다. 프론트엔드가 몇 분 더 있을 줄 알았는데 요술토끼만 프론트엔드 분이셨다. 요술토끼가 우아한테크코스 백준 단체를 만들었다고 해서 나도 들어가고 싶어졌다.\n- 블랙잭 1단계 코드 리뷰 요청을 다시 보냈다. 머지가 되어야 2단계를 진행할텐데 걱정이 많았다. 포이의 설계를 같이 보면서 머지된 후에 어떻게 구현할 지 대략적으로 생각해봤다. 그거랑은 별개긴 한데 오리랑 포이랑 한 1시간 정도 같이 2단계 미션 생각했는데 너무 웃겼다 ㅋㅋㅋ 2단계 진행에 대한 힌트도 얻어서 재밌기도 했지만 유익했다 👍\n- 어제 체인저와 공부했던 머메이드 강의?를 진행했다. 내가 생각한 건 6명 정도의 작은 규모 강의였지만 사람이 10명 넘게 왔었다. 막상 해보니 많은 것도 좋았다. (체인저 내가 칭찬 안 해줘서 슬퍼하는 거 아니지? 🥺 발표 안 떨고 잘했음 👍) 이런 강의를 여러 번 주도해보면서 다른 사람들도 정보를 좀 더 쉽게 공유할 수 있는 방향으로 바뀌었으면 좋겠다. 개인적으로 지금까지는 친한 사이에서 알음알음 전해지는 지식들이 많아서 아쉬웠다. 다른 사람들도 쉽게 공유할 수 있는 환경이 있으면 좋지 않을까 한다.\n\n## 배운 것\n- ```@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)``` : 언더바로 표시한 모든 부분이 공백으로 처리된다.  \n- mermaid 강의 자료 [노션 링크](https://bloom-okapi-d38.notion.site/Mermaid-0cbc5813e77f40dc8e3788a888f31c44)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 공부할 때는 공부하고, 이야기할 때는 이야기 하는 방식으로 해보는 건 어떤지 브라운이 의견을 내주셨다. 하나에만 집중하고 이것만 소중하다! 라고 생각하기보다는 적절하게 시간을 나눠서 쓰는게 내 생각에도 더 좋아보인다. 내가 잘하고 있다고 칭찬해주셔서 감사했다. 그렇지만 브라운과 이야기할 때도 내 말이 정리가 안 되는게 느껴졌다... ㅎ 할 말을 머릿속으로 생각해보고 말하는 연습을 하자.\n- 내가 할 수 있는 범위 내에서 할 수 있는 것을 다 하자. 우테코를 다시 할 수는 없듯이, 지나간 우테코의 시간은 다시는 돌아오지 않을 것이다. 그러니 후회없이 하고 싶은 걸 하고, 두려움 없이 나아가자. 10개월 동안 다른 사람이 되어보는건 남은 인생에서 내가 바뀌는 것보다는 쉽지 않을까? 나는 벌써 내가 달라지고 있는 걸 느꼈다. 내가 상상한 더 나은 사람이 되고 싶다. 지금이라면 할 수 있을 것 같다!\n- 편해질수록 말을 조심하자. 항상 말해놓고 후회할 때가 있다. 너무 오바하지 말고 가끔은 침묵이 나을 때도 있는 것 같다.\n- 어제 밥을 늦게 먹었는데 오히려 아침에 배가 더 고팠다. 요즘 잠도 많아졌다. 왜지? 딱히 피곤할 일이 있는 것도 아닌데 희한하다. 과외는 주말에만 하니 평일에 피곤할 일이 거의 없는데.\n- 우테코 시작한 지 벌써 1달이 지났다. 정말 내가 1달간 TIL을 꾸준히 썼다는 게 믿기지 않는다. 저번주 회고에 썼듯이 내일 금요일 회고는 꼭 쓰고 자야겠다. 점점 많은 사람들에게 내 블로그가 알려져서 좀 쉽지 않지만 ㅋㅋㅋ 관심 오히려 좋아 👀  많은 관심 부탁합니다 ^~^\n"},{"excerpt":"LOG 블랙캣과 점심을 먹었다. 역시나 신천 직화ㅋㅋ 페어 미션 재밌다. 재밌는 주제 생각해준 이리내 👍 오늘 아침에도 소파 옆쪽 자리(?)가 있어서 한 번 앉아봤다. 확실히 굿샷보다는 낫긴 한데 포이가 앉은 것처럼 의자에 앉는게 훨씬 좋은 것 같기도. 왠지 모르게 오늘 브라운과 자주 마주쳤다. 브라운한테 합성과 연관의 차이점에 대해서 물어봤다. 나랑 체…","fields":{"slug":"/2023-03-08/"},"frontmatter":{"date":"2023년 03월 08일 15:03","title":"2023년 03월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 블랙캣과 점심을 먹었다. 역시나 신천 직화ㅋㅋ 페어 미션 재밌다. 재밌는 주제 생각해준 이리내 👍\n- 오늘 아침에도 소파 옆쪽 자리(?)가 있어서 한 번 앉아봤다. 확실히 굿샷보다는 낫긴 한데 포이가 앉은 것처럼 의자에 앉는게 훨씬 좋은 것 같기도.\n- 왠지 모르게 오늘 브라운과 자주 마주쳤다. 브라운한테 합성과 연관의 차이점에 대해서 물어봤다. 나랑 체인저가 내린 결론은 연관의 특수한 경우가 합성이라는 것. 집합과 합성의 차이점을 확실하게 알게 되었다.\n- 체인저, 포이와 함께 머메이드를 배웠다. 미션에서 써먹어보려고 배웠는데 클래스 다이어그램까지는 투머치인 듯 하다. 너무 자세하니 오히려 눈에 더 안 들어왔다.\n\n## 배운 것\n- 집합은 외부에서 생성해서 주입해주는 것. 값을 외부에서 생성하므로 해당 클래스와 라이프 타임이 같지 않을 수도 있다. (외부에서 전달된 값은 복사되어 전달되기 때문에 클래스의 라이프 타임이 끝나더라도 외부의 객체는 라이프 타임이 남아있을 수 있다.)\n- 합성은 내부에서 값을 생성하는 것. 값을 내부에서 생성하기 때문에 클래스와 라이프 타임을 공유한다.\n\n## 궁금한 것\n\n## 어려웠던 것\n- 요즘 사람들과 이야기하는 게 재밌어서 혼자 공부를 많이 안 했다 🥺 미션 구현도 생각보다 좀 더 걸렸고, 2단계 미션도 아직 어떻게 구현할 지 생각하지 않은 상태라 분발해야 한다.\n\n## 느낀 것\n- 우테코 초반에 비해 새로운 사람을 만났을 때 하는 말의 주제가 늘어난 것 같다. 오늘 체험을 하게 되었는데, 성장했다는 생각에 조금 기분이 좋았다.\n- 헤나에게 알려 준 데일리 미션 뭔가 잘 된 것 같아서 기분이 좋았다.\n- 레벨2 부터는 좀 더 오래 남아있어야겠다. 집에 가면 공부를 안 하니까 ㅠ 내가 공부만 했더라면 그냥 집에 빨리 갔을텐데 침대는 강력했다.\n- 잡담이 경쟁력이다.. 라는 말을 어제 봤는데, 가끔 그 말을 느낄 때가 있다. 갑자기 불쑥 개발 이야기가 나올 때도 있고, 친밀한 관계에서 더 질문을 많이 하게 되니까 대화 하기 수월하다.\n- 요즘 사람들과 말을 많이 놓고 있는데 이거 괜찮은 건가 싶다 ㅋㅋㅋ 말을 놓는 순간 편해져서 실수할까봐 걱정되긴 한다. 항상 동갑들과 어울리다보니 가끔 '야'라는 말이 나올 때가 있어서 진짜 식겁한다... 조심해야겠다.\n- 집중력을 어떻게 하면 올릴 수 있을까. 열심히 공부하는 다른 사람 옆에 있으면 잘하는데 나를 풀어두니 너무 노는 것 같다 ㅋㅎㅋㅎ.. 좋은 공부 환경 조성을 위해 노력해보자.\n"},{"excerpt":"LOG 요즘 집중이 잘 안 된다. 오늘은 중간에 구현하다가 뛰쳐나왔다. 굿샷은 덥기도 했고.. 집중 좀 잘해보자. 브라운, 포이, 쥬니와 점심을 같이 먹었다. 연어 식당에 갔는데, 와사비를 빼고 먹기를 잘한 것 같다. 브라운이 스타트업 관련 이야기를 많이 해주셨는데, 매우 느끼는 점이 많았다. 배운 것 이 코드를 사용하면 String의 값에 따라 정렬되고…","fields":{"slug":"/2023-03-07/"},"frontmatter":{"date":"2023년 03월 07일 15:03","title":"2023년 03월 07일","tags":null},"rawMarkdownBody":"## LOG\n- 요즘 집중이 잘 안 된다. 오늘은 중간에 구현하다가 뛰쳐나왔다. 굿샷은 덥기도 했고.. 집중 좀 잘해보자.\n- 브라운, 포이, 쥬니와 점심을 같이 먹었다. 연어 식당에 갔는데, 와사비를 빼고 먹기를 잘한 것 같다. 브라운이 스타트업 관련 이야기를 많이 해주셨는데, 매우 느끼는 점이 많았다.\n\n## 배운 것\n```\nMap<String, Long> results = gameResults.stream()\n                     .collect(Collectors.groupingBy(String::valueOf, Collectors.counting()));\n```\n- 이 코드를 사용하면 String의 값에 따라 정렬되고, 값의 개수를 자동으로 세어준다. stream 좋아...\n- ```Consumer<T>``` T 하나를 매개변수로 받는 함수형 인터페이스를 전달할 수 있다. ```function.accept(매개변수)```를 사용해서 함수를 실행한다.\n- ```Predicate<T>``` T 하나를 입력 받아 boolean을 리턴하는 함수형 인터페이스를 전달할 수 있다. ```function.test(매개변수)```로 함수를 실행한다.\n- 유사한 사업 아이디어는 다른 유사 서비스의 디테일과는 다른 디테일을 중심으로 만들어나가는 것이 좋다 by 브라운\n- 스타트업에는 생각보다 필요한 프로세스가 많다. 대기업에서 프로세스를 경험해보고 스타트업에 적용하면 더욱 좋다.\n- 내가 만드는 소프트웨어에 나를 투영하지 말자. 비판을 수용하기 어려워질 수 있다.\n- ```<T extends Number> functionName(SimpleList<T> list)```의 매개변수는 명시적으로 선언되어 있기 때문에 이렇게 써도 가능하다. 그러나 ```<T> functionName(SimpleList<T extends Number> list)```는 리턴 값이 모호하다? (갑자기 쓰다보니 이해 안 됨) \n\n## 궁금한 것\n- 상속은 필요악일까? 조합이 더 좋다고는 하지만 나는 실제로 변화가 일어났을 때 전파될 필요가 있는 경우에는 상속을 해주는 게 좋은 것 같아서 잘 모르겠다.\n- dto 내부에서 ```List<dto>``` 쓰는 거 진짜 괜찮은걸까?\n\n## 어려웠던 것\n- 무의식적으로 공감하기 좀 자제하는 중인데 잘 안 된다. 내가 생각해도 가끔 성의 없는 공감을 해주는 편인데, 그런 건 차라리 안 하느니만 못하다.\n\n## 느낀 것\n- 확실히 현직자와의 커피챗은 뭔가 다르구나 싶다. 얻어가는 인사이트도 많았고, 뜬금없이 나온 이야기였는데 너무 재밌게 들었다.\n- 내가 말하면서 진짜 생각이 정리가 안 된다. 머릿속에서는 논리가 이미 있는데 말로 하면 안 나온다.. 나도 생각을 정리하면서 말하는 습관을 들여봐야겠다.\n- 지금은 늦게 가지 않고 있다. 지칠 것 같기도 하고, 다음 날을 위해서 오늘에 최선을 다하는 게 더 좋다고 생각해서 그렇다. 그런데 오늘은 최선을 다한 것 같지 않아서 좀 하루를 날린 기분이다. 내일은 꼭 열심히 해야겠다.\n- 커버할 수 있는 사람들의 수가 한정적이라는 생각을 했다. 아침에 아는 사람들과 이야기 했는데 분명 9시 10분에 도착했는데 이야기 나누고 나니 50분이 되었다... 이야기에서 얻는 인사이트도 있지만 내 일을 할 때는 좀 집중하기도 해야 하는데. 어느 정도 밸런스를 맞출 필요가 있다는 생각이 든다. 중요한 건 나의 성장이니까. 모든 사람들과 이야기 하고 싶었지만 내 몸이 하나라 한 주제에 대해 진득하게 이야기할 수 없었던 건 많이 아쉬웠다. 이렇게 많은 사람들을 알게 되었지만 내가 처리할 수 있는 건 얼마 안 된다는 게 좀 슬프기도 했다. 동시에 내가 이런 고민도 하게 되는구나, 라는 생각도 들었다. 요즘에는 사람을 만나는 게 재밌다. 먼저 말 거는 거에 맛들렸다 ㅋㅋㅋ 그게 잘 안 되는 사람도 있어서 좀 더 노력해보려고 한다.\n"},{"excerpt":"3/7 좋은 객체의 덕목 읽어보기 좋은 객체 상속과 조합 상속 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 자체가 아니다. 가상 메서드 (virtual method) 클래스와 메서드를 이나  둘 중 하나로 제한하면 문제가 발생할 가능성을 없앨 수 있다. 상위 클래스가 final이라면 상속이 불가능하다. 상위 클래스의 내부 구현이…","fields":{"slug":"/level1-week5/"},"frontmatter":{"date":"2023년 03월 07일 01:03","title":"레벨1 5주차","tags":["레벨1","우테코"]},"rawMarkdownBody":"# 3/7\n\n## 좋은 객체의 덕목\n- 읽어보기 [좋은 객체](https://codingnuri.com/seven-virtues-of-good-object/)\n\n## 상속과 조합\n\n### 상속\n- 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 자체가 아니다.\n\n#### 가상 메서드 (virtual method)\n- 클래스와 메서드를 ```final```이나 ```abstract``` 둘 중 하나로 제한하면 문제가 발생할 가능성을 없앨 수 있다. 상위 클래스가 final이라면 상속이 불가능하다.\n- 상위 클래스의 내부 구현이 달라지면 하위 클래스가 오동작할 수 있다.\n\n### 조합\n- 새로운 클래스를 만들고 기존 클래스의 인스턴스를 참조하게 하는 것\n- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. (is-a 관계)\n- 상속이 적절한 경우: 확장이 아닌, 정제를 하는 경우\n  - 확장: 새로운 행동을 덧붙여 기존의 행동을 부분적으로 보완하는 것\n  - 정제: 부분적으로 불완전한 행동을 완전하게 만드는 것\n\n## 실패 원자성\n- 호출된 메서드가 실패하더라도 호출된 메서드의 객체는 메서드 호출 전 상태를 유지해야 한다.\n- 예외가 발생하더라도 객체의 일관성이 유지되어 정상적으로 사용 가능한 상태를 유지한다.\n- 불변 객체의 특성상 원본 객체와 같은 새로운 객체를 생성하는 방법을 사용하기는 힘들다. 그러나 복구하기 힘든 예외가 발생한 경우에, 원본 객체가 불안정한 상태에 빠지는 경우는 없다.\n- 망가진 객체는 더 이상 정상적으로 사용할 수 없다. 예외를 잘 처리해도 이미 객체 내부의 값이 바뀐 경우는 재앙이 된다.\n\n## 시간적 결합\n> 메서드 A는 언제나 반드시 메서드 B보다 먼저 호출해야 한다.\n\n- 이런 방식은 유연하지 않고, 현실적이지 않다.\n- 순서에 의존하지 않는 동시성을 보장할 프로그램을 만들어야 한다.\n- 시간적 결합이 없는 작업들은 동시에 처리될 수 있다. 따라서 다양한 설계에 대한 측면을 바라볼 수 있게 된다.\n\n## 가변 객체와 불변 객체\n- 모든 클래스를 상태를 변경할 수 없는 불변 클래스로 만들면 유지 보수성이 크게 향상된다.\n- 불변 객체의 크기가 작은 이유: 생성자 안에서만 상태를 초기화할 수 있기 때문이다.\n\n### 불변 객체\n- 변경이 불가능한 객체\n- 객체를 생성 후 외부에 의해 상태를 바꿀 수 없다. (heap 영역에서 객체가 가리키고 있는 데이터 자체의 변화가 불가능하다는 뜻이다.)\n\n#### 장점\n- 생성자, 접근 메서드에 대한 방어적 복사가 필요 없다. 접근 메서드에서도 별개의 객체를 리턴하기 때문이다.\n- 멀티 스레드 환경이라면 동기화 처리 없이 객체를 공유할 수 있다. 동기화하기 위한 값이 변경되지 않기 때문이다.\n- 객체를 신뢰할 수 있다.\n\n#### 단점\n- 객체가 가지는 값마다 새로운 인스턴스를 생성해야 한다.\n\n## 라이브 코딩\n- ```assertThat(card).isSameAs(Card.of(ACE, FOUR));```\n- ```computeIfAbsent(toKey(suit, denomination), ignore -> new Card(suit, denomination));```\n  - toKey: ```return suit.name() + denomination.name();```\n\n# 3/8\n## 데이터베이스 기초\n### POST\n- 클라이언트에서 웹 서버로 어떠한 정보를 제출한다.\n- 데이터는 HTTP 바디에 담아 전송한다.\n- 데이터가 노출되지 않고, 길이 제한이 없다.\n\n### 응답 코드\n- 특정 HTTP 요청이 성공적으로 완료되었는지\n- 2xx : 성공 응답. 이 작업을 수신하여 이해했고 승낙했으며 성공적으로 처리했다.\n- 3xx : 리다이렉션. 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.\n  - 301 영구 이동 : 요청한 페이지를 새 위치로 영구적으로 이동한다.\n  - 302 임시 이동 : 다른 페이지로 이동하지만 나중에 바뀔 수 있다.\n- 4xx : 클라이언트 오류\n- 5xx : 서버 오류\n\n### 데이터 중복\n- 파일 처리 시스템은 각 파일마다 필요한 데이터를 각각 가지고 있어야 한다.\n\n### 비일관성\n- 데이터에 변경 사항이 조금만 있어도 각 파일에서 해당되는 데이터를 모두 변경해야 하며 한꺼번에 수정되지 않으면 곤란하다(?)\n\n### 보안성\n- 파일을 누구나 수정할 수 있다.\n\n### 데이터베이스\n- 데이터의 집합\n- 관리하는 시스템과 통합되어 제공되며 따라서 정확한 명칭은 데이터베이스 관리 시스템 (DBMS)\n- 관계형 데이터베이스 (RDMS)\n- 비관계형 데이터베이스 (NoSQL)\n\n#### 특징\n- 데이터 공유 : 일정한 형식을 필터링 후 저장 / 여러 명이 데이터를 동시 공유하는 것\n- 데이터 중복의 최소화 : 하나의 데이터베이스에 여러 응용 프로그램이 접근 가능할 수 있다.\n- 계속적 변화에 대한 공유 : 항상 최근의 정확한 데이터를 동적으로 유지하는 특징 존재\n- 데이터 논리적 독립성 : 응용 프로그램과 데이터 베이스를 독립 시킨다.\n\n### 관계형 데이터베이스\n- DB계의 주류\n- 컬럼과 로우로 이루어진 테이블 형태로 저장\n- 데이터의 종속성은 관계로 표현한다.\n- 스키마 : 테이블에 적재될 데이터의 구조와 형식을 정의하는 것.\n\n### SQL\n- Structured Query Language\n- 데이터를 저장하거나 얻기 위해서 사용하는 표준화된 언어\n- 질의문 혹은 쿼리\n\n### where\n- like\n\t``` select * from movie where title like '%클'```\n- %클 : 앞에는 무엇이든지 와야 하지만 뒷자리는 클이어야 한다.\n- 클% : 앞자리는 클리어야 하고, 뒷글자는 무엇이든지 가능하다.\n- %클% : 클이라는 글자를 갖는 title이 포함된 결과를 검색한다.\n\n### update\n- 테이블의 데이터를 변경한다.\n```UPDATE `tbl_name` SET `col1_name`=`값1` WHERE `col1_name`=`조건` ```\n### delete\n- 테이블의 데이터를 삭제한다.\n```DELETE FROM `tbl_name` WHERE `col1_name`=`조건` ```\n\n### group by\n- 그룹핑하여 조회한다.\n```\nSELECT *\nFROM movie\nGROUP BY title, openning_date;\n```\n\n제목 별로 나눈 다음, openning_date에 따라 다시 나눈다.\n\n### having\n- 집계 함수의 결과가 조건에 맞는 데이터를 조회한다.\n```\nSELECT\nFROM\nGROUP BY\nHAVING 집계함수(`col2_name`) >= 조건\n```\n\n- limit : 지정한 개수만큼 조회한다.\n```\nselect *\nfrom movie\nlimit row_count\n```\n\n- order by\n```\norder by `col2_name` ASC|DESC\n```\n\n### 순서\nfrom -> where -> group by -> having -> select -> order by -> limit\n\n## 키\n- 대체 키\n- 외래 키\n- 슈퍼 키\n\n### PK\n- 기본적으로 NOT NULL\n- 키는 중복될 수 없다.\n\n## 트랜잭션\n- 일련의 작업 단위\n- 데이터의 무결성을 보장받을 수 있다.\n- 성공 또는 실패 -> 트랜잭션은 원자성을 갖는다.\n\n## API\n- Application Programming Interface\n- 다양한 컴포넌트 간의 통신 방법\n\n### 인터페이스\n- 두 물체 공간, 단계 등의 공통 경계면\n- 독립되고 관계가 없는 시스템끼리 접촉하거나 통신이 일어나는 부분\n- CUI (Character User Interface)\n- GUI (Graphical User Interface)"},{"excerpt":"LOG C++ 강의를 시작했다. container, stl 관련 내용부터 시작하고 있다. 늘 그랬듯 시간에 얽매이기 보다는 무엇을 가르칠지를 생각할 것이다. 과외 하고 나서 밀린 일들을 했다. 휴학 증명서도 제출하고, 미루던 블로그 구글 애널리틱스, 서치도 등록했다. 밀린 일을 하고 나니 뿌듯하다. 나중에는 RSS도 등록해 볼 생각이다. 회고를 쓰고 다른…","fields":{"slug":"/2023-03-05/"},"frontmatter":{"date":"2023년 03월 05일 15:03","title":"2023년 03월 05일","tags":null},"rawMarkdownBody":"## LOG\n- C++ 강의를 시작했다. container, stl 관련 내용부터 시작하고 있다. 늘 그랬듯 시간에 얽매이기 보다는 무엇을 가르칠지를 생각할 것이다.\n- 과외 하고 나서 밀린 일들을 했다. 휴학 증명서도 제출하고, 미루던 블로그 구글 애널리틱스, 서치도 등록했다. 밀린 일을 하고 나니 뿌듯하다. 나중에는 RSS도 등록해 볼 생각이다.\n- 회고를 쓰고 다른 사람 회고를 구경했다. 다들 재밌게 공부하는 것처럼 보인다.\n\n## 배운 것\n\n## 궁금한 것\n\n## 어려웠던 것\n- 리팩토링할 생각을 하니 막막해졌다. 원래 복잡한 구조일수록 고치는게 오래걸려서, 지금 많이 꼬여있는 의존성들을 어떻게 풀어놓을지 궁리해야 한다. 아직 뾰족한 수는 떠오르지 않는다.\n- dto를 써야 할까? controller가 비대하니 service를 만들어야 할까?\n\n## 느낀 것\n- 나는 글을 쓰는 것을 좋아한다. 코딩도 좋아한다. 노래 듣는 것도 좋아한다. 요즘 좋아하는 것을 찾고 있다. 내가 좋아하는 것을 잘 찾아나갈 수 있을까? 23년 살도록 내가 좋아하는 걸 제대로 알지 못한다는 건 조금 웃긴 것 같다 ㅋㅋ\n- 조금 더 감정적이게 되었다. 나는 이런 변화가 좋다고 생각한다. 재작년, 작년까지만 해도 허무주의/무기력함에 빠져 살았는데 좀 더 많이 웃고 이야기하는 지금이 훨씬 좋다. 지금은 잘하는 사람들을 봐도 자괴감이 들거나 무기력해지지 않는다. 자존감이 약간 올라갔다고 생각해도 되려나?\n"},{"excerpt":"LOG 레벨1 조의 블랙캣과 페어가 되었다. 페어 미션 수행하기가 이리내의 데일리 미션이었기 때문에 블랙캣과 깃허브 맞팔도 하고 (사심 채우기) 코드 리뷰도 했다. 항상 리뷰어한테만 리뷰 받다가 같은 크루에게 리뷰를 받으니 또 신선한 기분이었다. 의외로 재밌었다 ㅋㅋㅋ 온보딩 조와 6시 끝나고 술을 마시러 갔다. 재밌는 이야기도 많이 했다. 역시 좋은 사…","fields":{"slug":"/2023-03-06/"},"frontmatter":{"date":"2023년 03월 05일 15:03","title":"2023년 03월 06일","tags":null},"rawMarkdownBody":"## LOG\n- 레벨1 조의 블랙캣과 페어가 되었다. 페어 미션 수행하기가 이리내의 데일리 미션이었기 때문에 블랙캣과 깃허브 맞팔도 하고 (사심 채우기) 코드 리뷰도 했다. 항상 리뷰어한테만 리뷰 받다가 같은 크루에게 리뷰를 받으니 또 신선한 기분이었다. 의외로 재밌었다 ㅋㅋㅋ\n- 온보딩 조와 6시 끝나고 술을 마시러 갔다. 재밌는 이야기도 많이 했다. 역시 좋은 사람들과 (좋사좋시) 재밌게 놀다보니 시간이 금방 갔다. 내일 또 잠실 가야 돼서 많이는 안 마셨지만 그냥 기분이 좋았다. 사실 다들 만난지는 1달밖에 안 됐지만 신기하게도 잘 맞는 사람들 같다.\n- 제네릭 미션을 완료했다. 어제 12시부터 했는데, 어려운 내용 같다...🥺\n\n## 배운 것\n\n## 궁금한 것\n- 브라운과의 커피챗 주제로도 한 거지만 페어와 의견이 다를 때는 어떻게 의견을 표현하는게 좋을까? 내가 강강 약약이라 자기 주장이 약한 페어를 상대로는 어떻게 내 의견을 피는게 좋을지 궁금하다.\n\n## 어려운 것\n- 어쩌다보니 오늘 크루들과 이야기하는 데에만 시간을 쓰게 되었다. 물론 사람을 만나는 것도 좋고 즐겁지만 내가 해야 하는 일도 있는 만큼 어떻게 시간을 잘 쓸 수 있을지 고민이 된다.\n\n## 느낀 것\n- 확실히 자존감이 올라간 것 같다. 지금이라면 나를 달가워하지 않는 사람이 있더라도 그러려니 하고 넘길 수 있다. 뭔가 '나는 좋은 사람이고, 나의 진가를 못 알아보는 상대방이 안타깝다 🙂' 라는 생각이 든다고 해야 하나 ㅋㅋㅋ 작은 성공부터 시작해보자는 다른 사람들의 말이 어떤 뜻인지 다시 알게 되는 시간이 되었다. 어쩌면 다른 사람 눈에는 건방져 보일 수도 있지만...🥺 나에게는 지금이 인생의 가장 큰 한 걸음을 걷는 시간이다.\n- 헤나와 페어 회고를 하면서 말을 놓았다. 나는 확실히 존댓말을 하는 사람과 반말을 하는 사람의 친밀도가 다른 것 같아서 말을 놓으면서 훨씬 더 가까워진 것 같다. 회고를 하며 내가 강강약약이라는 걸 알았다. 의견이 강한 사람에게는 강하게 주장할 수 있지만, 의견이 그렇게 강하지 않은 사람에게는 오히려 더 배려하느라 양보해버린다는 걸..! 체인저가 그럴 때는 오히려 상대방을 강한 의견을 하는 사람으로 만들라는 말이 인상 깊었다. '그 방법의 장점은 어떤 게 있나요?' 나, '왜 그 방법이 좋다고 생각하시나요?'라는 질문을 더 던지면서 서로의 토론을 일으키는 방식도 있을 것 같다. 나는 시간이 없어서 그냥 양보하고 넘어갔는데, 헤나가 그걸 느끼고 있었다는 게 괜히 미안했다. 시간이 더 많을 때 이런 이야기 많이 해볼걸 ㅠㅠ 다음 체스 미션 때는 내 의견을 적절하게 잘 말하는 게 좋을 것 같다.\n- 요즘에는 감사하는 마음, 겸손한 마음을 갖고 있다. 내가 이런 생각을 하게 될 줄이야ㅋㅋㅋ 옛날에는 대체 뭐가 감사하다는 건지, 뭐가 즐겁다는건지 이해하지 못했는데 이제는 알 것 같다는 게 다르다.\n"},{"excerpt":"LOG 테코톡 발표가 있었지만 미션 구현하느라 발표는 보지 못했다. 기능 구현 자체는 만족스럽게 됐었는데 합치는 부분이 문제였다. 생각해본 결과 추상화 자체는 좋지만 딜러와 플레이어는 분리되는게 맞는 것 같다. 네오는 포켓몬을 좋아한다고 한다. 오늘만 해서 포켓몬 트레이너를 4명 정도 봤다. 아마란스도 포켓몬을 좋아하다니 신기했다 ㅋㅋㅋ 주변에 포켓몬 트…","fields":{"slug":"/2023-03-02/"},"frontmatter":{"date":"2023년 03월 02일 10:03","title":"2023년 03월 02일","tags":null},"rawMarkdownBody":"## LOG\n- 테코톡 발표가 있었지만 미션 구현하느라 발표는 보지 못했다. 기능 구현 자체는 만족스럽게 됐었는데 합치는 부분이 문제였다. 생각해본 결과 추상화 자체는 좋지만 딜러와 플레이어는 분리되는게 맞는 것 같다.\n- 네오는 포켓몬을 좋아한다고 한다. 오늘만 해서 포켓몬 트레이너를 4명 정도 봤다. 아마란스도 포켓몬을 좋아하다니 신기했다 ㅋㅋㅋ 주변에 포켓몬 트레이너 꽤 많았구나\n- 글쓰기 미션이 시작됐다. 이제 할 거 없으면 (사실 많음) 글쓰기를 하면 되겠다.\n- 이번주 토요일부터 과외를 재개하기로 했다. 과연 주말 괜찮을까 ㅋㅋ 자료도 얼른 준비해야겠다.\n- 생각해보니 내일 시간이 많이 없다..ㅠㅠ 코수타에 미니미션까지 하면 시간이 굉장히 촉박하다. 뭐든 미션을 완성하는 게 급선무이니, 빠르게 완성해야 할 것 같다. 생각해보니 3/1이 공휴일이어서 여유있는 목요일이 아니라 금요일에 마감하는구나.. 방금 알아서 곤란해졌다 ㅋㅋ 생각보다 시간이 없던 게 맞았다. 그래도 할 수 있는 데까지 해보자!\n\n## 배운 것\n\n\n## 궁금한 것\n\n## 어려웠던 것\n- 쉬지 않고 집중 가능한 줄 알았는데 6시 되니까 헤나도 나도 좀 어지러웠다..ㅋㅋ 휴식하지 않고 페어 프로그래밍 하기는 하지 말자.\n\n## 느낀 것\n- 어쨌든 미션은 완성해야 리뷰도 받을 수 있는 거다. 고민되는 부분도 많지만 완성이 목표여야 한다. 저번 미션 때도 느꼈지만 페어 프로그래밍 때 쳐낼 건 쳐내면서 진행했어야 했는데 좋은 의견들이 많이 나와서 빠르게 진행하지 못했다. 그 부분이 아쉬운 점이다.\n- 말투가 중요하다는 걸 오늘 느꼈다. 독성말투 글을 읽고 나니 공격적으로 말하는 (의도는 그렇지 않다고 하더라도) 사람의 말투가 들렸다. 사람의 내면은 자기 자신 외에는 누구도 모르니까, 어쩔 수 없이 우리는 밖에 보여지는 모습으로 판단하게 된다. 좋은 사람으로 보이려면 내 외면이 좋은 사람이 되어야 한다. 그렇다고 해서 밖으로 보이는 것에만 집중하면 불행해진다. 뭐든 적당한 게 좋은 것 같다. 적당히 좋은 사람도 힘든 거구나.\n- 취미를 갖는다는 건 뭘까. 진짜 나는 딱히 취미라고 할 게 없는데 취미에 진심인 사람들을 보면 신기하다. 그래서 별로 재미 없게 사는 것 같기도 하다.\n"},{"excerpt":"페어 페어는 헤나였다. 헤나와 처음 만나고 나서 약 40분간 아이스 브레이킹 시간을 가졌다. 페어와 정한 규칙 20분마다 교대했다. 모르는 것은 바로바로 물어본다. 페어가 멍 때리면 괜찮냐고 물어본다. 페어가 마음 상할까 봐 하고 싶은 말을 숨기지 않는다. 페어와 프로그래밍 할 때 규칙 요구사항 분석 후에 클래스 간의 관계를 그림으로 그리면서 구현했다. …","fields":{"slug":"/level1-blackjack/"},"frontmatter":{"date":"2023년 03월 01일 15:03","title":"블랙잭 미션","tags":["레벨1","우테코"]},"rawMarkdownBody":"## 페어\n- 페어는 헤나였다.\n- 헤나와 처음 만나고 나서 약 40분간 아이스 브레이킹 시간을 가졌다.\n\n### 페어와 정한 규칙\n- 20분마다 교대했다.\n- 모르는 것은 바로바로 물어본다.\n- 페어가 멍 때리면 괜찮냐고 물어본다.\n- 페어가 마음 상할까 봐 하고 싶은 말을 숨기지 않는다.\n\n### 페어와 프로그래밍 할 때 규칙\n- 요구사항 분석 후에 클래스 간의 관계를 그림으로 그리면서 구현했다.\n- 테스트 코드 메서드 이름을 카멜 케이스로 작성했다. ```throwExceptionWhenCardDuplicated()```, ```create()```\n- 에러 메시지는 매직 스트링을 사용했다.\n- 클래스와 클래스 필드 사이에 띄어쓰기 하지 않는다.\n- 테스트 코드 클래스 선언 아래에 띄어쓰기 하지 않는다.\n- TDD 할 때 실패하는 테스트 -> 테스트 실행 -> 돌아가도록 최소한 구현 -> 테스트 실행 후 성공 확인 -> 성공하는 테스트 -> 테스트 실행 -> 돌아가도록 구현 ... 방식으로 구현한다. 실패하는 테스트가 없는 경우 작성하지 않는다.\n- Co-authored 사용했다.\n- 도메인을 먼저 구현하기 시작했다.\n- 커밋 규칙: test -> feat\n\n## 미션에서 고민한 주제들\n### 참가자의 점수를 계산하는 클래스는 어디여야 하는가?\n1. ParticipantCards: 참가자의 카드 리스트를 가지고 있고, 점수를 계산할 때 카드 리스트를 갖고 있으면 계산하기 쉽다.\n2. CardNumber(최종 채택): 다른 카드들의 합에 따라서 에이스의 값이 변경되어야 하므로, 카드 숫자의 값을 저장하고 있는 enum인 CardNumber에서 값을 계산해야 한다. 대신 계산하는 메서드의 매개변수는 ```List<CardNumber>```로 받는다. (```List<Card>```를 받게 되면 다른 클래스와의 의존성이 커질 것 같다)\n3. Optimizer(가칭): 점수를 계산하는 외부 객체를 만든다. ParticipantCards의 계산 메서드에서 Optimizer를 매개변수로 넣어 보낸다.\n\n- 결국 CardNumber를 채택했다. \n\n### 딜러의 권한은 어디까지인가? (얼마나 현실세계와 가깝게 구현해야 할까?)\n- 카드를 나눠주는 것도 딜러의 권한인가?\n- 점수를 계산하는 권한을 딜러에게 줄까 고민했지만 헤나가 너무 현실세계와 비슷하게 구현한다고 해서 기각했다.\n\n### 에이스의 값을 어떻게 가변적으로 설정할까?\n- 에이스의 값은 1, 11이 될 수 있다. 21이 넘지 않으면서 가깝게 만드는 것이 최선이지만, 21을 넘은 경우 값이 최대한 작아져야 한다.\n- CardNumber에서 계산하기로 했는데, 매개변수로 값을 받은 모든 카드 숫자를 더하고, 에이스의 개수만큼 10씩 더해가는 방식을 취했다. 대신 21이 넘지 않도록 더한다. 코드를 보는게 이해가 빠를 듯하다. \n- [코드](https:/github.com/hyena0608/java-blackjack/blob/hyena0608/src/main/java/blackjack/domain/CardNumber.java) stream과 reduce를 사용했다. 헤나 덕분에 reduce도 사용해보고 좋았다.\n\n## 페어 회고\n\n### 스스로에게 좋았던 점\n- 궁금하거나 이해가 잘 안 됐던 부분을 바로바로 물어봤다.\n- 페어의 의견을 많이 반영하려고 노력했다. 내가 해보지 않은 방법을 최대한 많이 사용해보려고 노력했다.\n\n### 스스로에게 아쉬웠던 점\n- 쉬자고 말하면서 했어야 했는데 그냥 내 페이스로 밀어붙인 것 같아서 미안했다.\n- 안 그래도 미션 시간이 없는데 내가 늦게까지 남아있지 않아서 더 시간이 없었던 것 같다.\n- 결정을 내렸어야 하는 부분에서는 의견을 확실하게 주장했어야 했는데, 내 의견도 좋고 페어 의견도 좋다는 애매한 포지션을 취해서 미션 진행이 느려지는데 기여한 것 같다.\n\n### 페어에게 좋았던 점\n- 그림으로 설계하면서 진행했던 게 좋았다. 서로의 의견을 들어보고 진행했던 게 좋았다.\n- 이상한 의견을 내도 잘 들어줘서 의견을 낼 때 머뭇거리지 않고 낼 수 있었다.\n- 페어 프로그래밍의 규칙을 미리 정해두고 해서 좋았다.\n\n### 페어에게 아쉬웠던 점\n- 나와 헤나 모두 의견이 강하지 않아서 여러 번 물어보고 진행하느라 조금 시간이 오래 걸렸던 것 같다.\n- 서로의 의견을 너무 존중하느라 ㅋㅋㅋ 사소한 의견 결정도 오래걸렸던 것 같다. \n\n### 소감 & 앞으로의 다짐\n- 뭔가 폭신폭신한 페어 프로그래밍을 했던 것 같다.\n- 가장 중요한 로직을 선정하고 중요한 순서대로 구현해야겠다.\n- 설계 시간을 정해두고 정해진 시간을 지키면서 미션을 진행해야겠다.\n- 부딪히는 부분에서 어떻게 의견을 잘 낼 수 있을지 고민해봐야겠다.\n\n## 다음 미션에서 적용할 것\n- 처음에 만났을 때 말을 놓자고 먼저 제안해 본다. 편한 분위기에서 말을 건넬 수 있어 좋은 것 같다.\n- 미션 시작 전에 간단하게 30분 정도 아이스 브레이킹을 진행한다.\n- 설계는 1시간 정도 한다. 그림을 그리면서 객체간의 관계만 생각해본다. 세부적인 필드나 메서드는 미리 생각하지 않는다.\n- 너무 내 의견을 양보하지 않는다. 어떤 게 더 좋은 건지, 왜 좋은지 물어보면서 진행한다. 주장할 때는 확실하게 하자.\n- 머릿속에서 말을 정리하고 이야기한다. 말을 하고 싶다는 생각으로 말을 시작하지 말자. 정리되지 않은 말은 오히려 페어를 헷갈리게 한다.\n- 질문도 여러 번 했고 이야기를 나눴는데도 결정이 안 나면 일단 내 의견을 밀고 나간다."},{"excerpt":"LOG 정말 일이 하나도 안 풀리는 날이었다. 헤나랑 미션 하러 가려고 11시에 나왔더니 지갑을 놓고 가서 문 안 열리는 기숙사 엘리베이터를 기다렸고, 어찌저찌 타서 지갑 가지고 버스 탔더니 타자마자 급출발/급정거 해서 머리+손등+다리 3타 맞았다. 손등 느낌이 이상해서 병원 가야겠다고 생각했는데 하필 오늘 공휴일이라 일단 잠실역에 있는 24시간 병원에 …","fields":{"slug":"/2023-03-01/"},"frontmatter":{"date":"2023년 03월 01일 13:03","title":"2023년 03월 01일","tags":null},"rawMarkdownBody":"## LOG\n- 정말 일이 하나도 안 풀리는 날이었다. 헤나랑 미션 하러 가려고 11시에 나왔더니 지갑을 놓고 가서 문 안 열리는 기숙사 엘리베이터를 기다렸고, 어찌저찌 타서 지갑 가지고 버스 탔더니 타자마자 급출발/급정거 해서 머리+손등+다리 3타 맞았다. 손등 느낌이 이상해서 병원 가야겠다고 생각했는데 하필 오늘 공휴일이라 일단 잠실역에 있는 24시간 병원에 갔는데 거기서는 엑스레이를 찍을 수 없다고 했다... 그래서 석촌역에 있는 병원 응급실에 갔다. (이쯤 되었을 때 헤나에게 무지 미안해지기 시작) 응급실에 갔더니 12시 40분이었고, 점심시간이라 2시부터 진료한다 했다. 배고파서 세븐일레븐에서 뭔가 먹으려고 갔더니 불은 켜져있는데 문이 안 열렸다 ㅋㅋㅋ ~~이쯤되니 진짜 기분이 안 좋았다~~ 그래서 그냥 중국집에 들어갔는데 하필 또 자리가 없어서 기다렸다 먹었다. 와중에 헤나한테 미안해서 매머드에서 커피 사가려고 했는데 공휴일이라 안 열음 ㅋㅋㅋㅋㅋ 그래서 옆에 있는 커피 집에서 간신히 커피 두 잔 샀다... 진짜 뭔 날이었나 싶다. 3월 액땜했다 치자...\n- 다행히 골절 같지는 않았지만 엑스레이에서 잘 안 보이는 미세골절일 수도 있다길래 일주일 뒤에도 아프면 엑스레이 다시 찍어보라고 했다. 응급실이라 돈 걱정했지만 13000원 밖에 안 나와서 다행이었다. 그때는 손가락 움직이는 것도 아팠는데 지금은 좀 괜찮다.\n- 헤나와 에이스 계산 방법에 대해 토론했다. 열띤 이야기 끝에 에이스 처리를 포함해서 점수 계산하는 로직까지 짰다. 편안하다...\n- 오늘은 새로운 사람들을 많이 만났다. 이름만 들어봤던 사람들을 실제로 만났다ㅋㅋ 말랑, 후추, 썬샷, 하마드, 우가, 리오, 베베, 헤나, 디노와 어쩌다보니 저녁을 같이 먹게 되었다. 내가 그때쯤 굉장히 지쳐있는 상황이었어서 텐션 높게 말하지는 못했지만 재밌었다. 가위바위보 해서 썬샷에게 아이스크림도 얻어먹었다 ㅋㅋ\n\n## 배운 것\n- stream에서 mapToInt -> sum 보다 reduce가 더 느리다고 한다. mapToInt를 하면 primitive 타입으로 계산되어서 그렇다고 한다. (by 말랑)\n- AutoBoxing: 원시타입의 값을 해당 wrapper 클래스의 객체로 바꾸는 과정. 자바 컴파일러는 원시타입이 wrapper 클래스의 타입이 파라미터를 받는 메서드를 통과할 때, 원시 타입이 wrapper 클래스의 변수로 할당될 때 AutoBoxing을 적용한다.\n- Auto unboxing: wrapper 클래스에서 원시 타입으로 자동으로 변환하는 것. 기본 자료형의 wrapper 객체 대입.\n\n## 궁금한 것\n\n## 어려웠던 것\n- 기분이 안 좋은 상태에서 긍정적인 생각을 하는 것은 힘들다는 걸 알았다. 무의식적으로도 긍정적인 사람이 되고 싶다.\n\n## 느낀 것\n- 어려웠던 것을 적으면서 생각했는데, 요즘엔 놀랍게도 부정적인 생각을 안 한다. 일이 잘 풀려가고 있고, 우테코 생활도 즐거워서 그런 것 같다. 원래는 일이 잘 풀릴 때도 '언젠간 힘들겠지', '잘하고 있는 건 아닌 거 같은데?', '이런 것도 못해?'라는 생각을 계속하게 됐는데 지금은 훨씬 좋아졌다. 그 분한테 이런 말을 전해줄 수 있다면 좋을텐데!\n- 좋은 사람들이 많고, 상냥한 사람들도 많다. 아직까지는 정말로 좋은 사람들만 만나고 있는 것 같다.\n- 가끔 지금 순간이 몰카인가? 싶은 때가 있다 ㅋㅋㅋ 진짜 신기한 게 우테코에 있는 사람들의 얼굴이 내 지인들과 겹치는 사람들이 많다. 사촌오빠, 친구의 남자친구, 동기 등등... 닮은 사람들이 끝도 없이 나와서 신기하다. 꼭 아는 사람이 아니더라도 어딘가에서 본 것 같은 분들이 나온다. 신기하다.\n- 포이가 이펙티브 자바 읽어보라고 했는데 처음부터 차근차근 읽을 자신은 없다. 중간중간 뒤적이는 건 할 수 있을 듯. 원래는 책 읽는 거 좋아했었는데 확실히 개발 책은 읽을 때는 재미없다. 이거 인정하기 싫었는데 ㅋㅋ 유익하긴 함.\n"},{"excerpt":"2023-03-01 2023-03-02 2023-03-05 2023-03-06 2023-03-07 2023-03-08 2023-03-09 2023-03-10 2023-03-12 2023-03-13 2023-03-14 2023-03-15 2023-03-16 2023-03-17 2023-03-18 2023-03-19 2023-03-20 2023-03-21 2…","fields":{"slug":"/2023-03/"},"frontmatter":{"date":"2023년 03월 01일 13:03","title":"2023년 03월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-03-01]]\n- [[2023-03-02]]\n- [[2023-03-05]]\n- [[2023-03-06]]\n- [[2023-03-07]]\n- [[2023-03-08]]\n- [[2023-03-09]]\n- [[2023-03-10]]\n- [[2023-03-12]]\n- [[2023-03-13]]\n- [[2023-03-14]]\n- [[2023-03-15]]\n- [[2023-03-16]]\n- [[2023-03-17]]\n- [[2023-03-18]]\n- [[2023-03-19]]\n- [[2023-03-20]]\n- [[2023-03-21]]\n- [[2023-03-22]]\n- [[2023-03-23]]\n- [[2023-03-24]]\n- [[2023-03-25]]\n- [[2023-03-26]]\n- [[2023-03-27]]\n- [[2023-03-29]]\n- [[2023-03-30]]\n- [[2023-03-31]]\n"},{"excerpt":"LOG 오늘 드디어 사다리 미션이 끝났다. 이번에 리뷰해주신 토니는 정말 좋은 리뷰어였다 👍 DM으로 편하게 질문해도 된다고 하셨는데, 막상 DM 하려니 어떤 말해야 할 지 모르겠어서... 많이 못했던 것 같다. 죄송해요 토니 😂 헤나와 페어가 되었다. 헤나는 istj인데 내가 본 사람 중에서 가장 istj 같다 ㅋㅋㅋ 뭔가 체계적으로 개발하고 기록도 잘…","fields":{"slug":"/2023-02-28/"},"frontmatter":{"date":"2023년 02월 28일 14:02","title":"2023년 02월 28일","tags":null},"rawMarkdownBody":"## LOG\n\n- 오늘 드디어 사다리 미션이 끝났다. 이번에 리뷰해주신 토니는 정말 좋은 리뷰어였다 👍 DM으로 편하게 질문해도 된다고 하셨는데, 막상 DM 하려니 어떤 말해야 할 지 모르겠어서... 많이 못했던 것 같다. 죄송해요 토니 😂\n- 헤나와 페어가 되었다. 헤나는 istj인데 내가 본 사람 중에서 가장 istj 같다 ㅋㅋㅋ 뭔가 체계적으로 개발하고 기록도 잘 남겨두시는 것 같아서 신기했다. 헤나를 본받아서 나도 기록을 열심히 해보고 싶다!\n- 점심으로 찜닭을 먹었다. 양이 너무 많아서 결국 조금 남겼다. 6명이서 찜닭으로 10만원 먹은거 실환가 ㅋㅋㅋ 그래도 맛있었으니 오케이입니다.\n- 내일도 출근하기로 했다. 아침은 너무 힘드니 1시에. 헤나와 설계 토론을 하다보니 너무 시간이 빨리 가서 어느 정도 구현을 해두려고 한다.\n\n## 배운 것\n\n- 문자열 덧셈이 굉장히 시간이 오래 걸린다. java 11부터는 StringConcatFactory.makeConcatWithconstants로 최적화를 해준다고 하는데도 느렸다. 웬만하면 StringBuilder를 사용하는 쪽으로..\n- StringBuffer는 동기화를 지원하여 멀티 스레드 환경에서도 안전하게 동작할 수 있다고 한다. 그러나 네오 말로는 멀티 스레드 환경에서 String을 구성할 일이 있나 싶다고 한다. ~~나도 그렇게 생각한다..~~ 반례를 찾으면 글로 남겨야겠다.\n\n## 궁금한 것\n\n- 강의를 그냥 듣는 게 나을지, 아니면 강의 중에 던져지는 키워드를 듣고 내가 혼자 더 찾아보는게 좋을지? 강의에서 좋은 인사이트를 얻을 수 있는 건 맞지만 맹신하지는 않아야 한다고 생각한다. 그래도 강의니까 처음부터 끝까지 놓치지 말고 듣는게 좋을지, 아니면 중간에 조금 놓치더라도 따로 더 찾아보는게 좋을지 궁금하다. 나는 그때 찾아보지 않으면 그 뒤로 절대 안 찾아봐서.. 고민이 된다.\n\n## 어려웠던 것\n\n- 중간중간에 상대방 말을 놓친다. 순간순간 다른 생각이 드는데, 그때 제대로 정신을 잡지 않으면 다른 사람이 말할 때 그 뒷부분을 아예 못 듣는다. 페어한테 이럴 때 굉장히 미안하다 😥\n\n## 느낀 것\n\n- 토리한테 ```~가 ~~라고 생각하면 어떡하지?``` 라는 말을 습관적으로 했는데 우리 그런 거 생각 안 하기로 했잖아!!🐿️  해서 그런 생각에서 빨리 벗어나올 수 있었다. 토리 말이 맞지👍\n- 데일리 때 레벨1에서 어떤 걸 이루고 싶은지에 대해 이야기 했다. 그때는 너무 횡설수설한 것 같아서 글로 써본다. 먼저 우테코 크루들과 편하게 인사하는 사이가 되고 싶다. 모두가 아니더라도 많은 사람들을 알고, 소통할 수 있었으면 좋겠다. 아직까지는 잘하고 있는 것 같다. 좀 더 바라는 것이 있다면 크루들이 나를 편하게 대해주었으면 좋겠다. 그러려면 나도 다가가기 쉬운 사람이 되어야 한다. 두 번째는 레벨1에서 사용한 Java 개념을 확실하게 알고 쓰기. 사용했던 것에 대해서는 잘 설명할 수 있는 사람이 되어 있으면 좋겠다.\n- 점심 먹다가 이야기 나왔는데, 말투도 실력이다(?) 똑같은 말도 말투에 따라 다른 뜻으로 해석될 수 있듯이 최대한 좋은 말투로 말하는 게 하나도 손해볼 게 없다. 굳이 날카로운 말투로 말할 필요가 없듯이, 나도 부드러운 말투로 말하려고 노력해야겠다. 나는 기분나쁨의 역치가 높은 편인데 그래서 오히려 다른 사람들에게 말할 때 내가 '독성 말투'로 말하고 있지 않은지 다시 돌아보게 된다. [독성말투](https://edykim.com/ko/post/tech-has-a-toxic-tone-problem-lets-fix-it/?fbclid=IwAR0YKYz45F3aNL-aMHr376RpCBjOaNo88xmbk7e9l0yKscreEk8lNwaCR-g) 라는 글을 읽어봤는데, 개발자라면 꼭 한 번쯤 읽어볼만한 글인 것 같다. 다른 사람들에게도 공유해야겠다. 웬만한 개발자들은 주변에서 이런 독성 말투를 쓰는 개발자를 본 적 있을 것이다.\n"},{"excerpt":"2/28 문자열 자바는 문자열을 위한 클래스를 제공한다. String 생성 방법 intern()을 사용하면 JVM의 최적화 StringConcatFactory.makeConcatWithconstants 로 연결해준다. StringBuilder와 StringBuffer는 생성자로 별도 설정해주지 않으면 초기 capacity가 16 characters로 세팅…","fields":{"slug":"/level1-week4/"},"frontmatter":{"date":"2023년 02월 28일 02:02","title":"레벨1 4주차","tags":["레벨1","우테코"]},"rawMarkdownBody":"# 2/28\n## 문자열\n- 자바는 문자열을 위한 클래스를 제공한다.\n### String 생성 방법\n```\nString a = \"a\";\nString b = new String(\"a\");\nString c = new String(\"a\").intern();\n```\n- intern()을 사용하면 \n  \n### JVM의 최적화\n```\nString a = \"a\";\nString b = \"b\";\nString c = \"c\";\n\nSystem.out.println(a+b+c);\n```\n\nStringConcatFactory.makeConcatWithconstants 로 연결해준다.\n- StringBuilder와 StringBuffer는 생성자로 별도 설정해주지 않으면 초기 capacity가 16 characters로 세팅된다. 작은 용량이기 때문에 재할당으로 인한 추가 비용이 발생하기 쉽다. 또한 loop와 같은 상황에서 StringBuilder 객체가 계속해서 생성되는 일이 발생하게 된다.\n- 최적화하는 방법을 알아야 하는 이유는 다른 JVM으로 내 코드가 실행될 수도 있기 때문이다. 원리를 알아야 그 때 다르게 동작할 때 이유를 알아낼 수 있다.\n- String의 + 연산은 JDK 8버전과 11버전에서 각각 다르게 처리한다.\n\n# 3/2\n## 글쓰기\n- 개발: 코드를 작성하는 일. 설계하고, 구현하고, 리팩터링하는 등의 과정. 내가 작성한 코드를 다른 사람이 봤을 때 쉽게 이해할 수 있을까?\n- 글: 나의 생각을 표현하는 일. 생각하고, 작성하고, 고치는 등의 과정. 내가 쓴 글을 다른 사람이 봤을 때 쉽게 읽을 수 있을까?\n-> 글과 개발은 비슷하다.\n\n### 글쓰기가 중요한 이유\n- 자신의 생각과 감정을 자신의 손을 통해 \"문자로\" 정리하고 표현하는 방법\n- 글로 표현하지 않은 생각과 감정은 결국 사라진다.\n- 나는 글을 쓰는 것이 두렵지 않다. 내가 잘 쓸 수 있다고 생각하기 때문이다! 글은 많이 써봐야 더 잘 쓰게 된다. 지금까지 많이 써 왔고, 지금이 완벽하게 잘 쓴다고 생각하지는 않지만 그래도 내 마음에 들게 글을 쓸 수는 있다 👍\n- 공부의 결과로 글쓰기가 나오는 것은 아니다. 공부하며 글쓰기를 해야 한다.\n- 나는 오히려 내 글에 관심 가져줬으면 좋겠다 ㅋㅋㅋ 그래서 잘 쓰려고 노력한다.\n- 습관의 힘을 활용한다. 일정 시간에, 일정한 장소에서 글을 써보려고 노력하자. 나도 TIL을 쓰는 습관을 들이려고 노력하는 중이다.\n- 생각해보니 내가 글을 쓰는 것이 자신 없었던 적이 없네...? 관심받기 좋아하는 사람이었어서 그런가 ㅋㅋㅋ\n\n### 글쓰기의 시작\n- 글쓰기 시작이 반이다. 한 줄이라도 써보자.\n\n### 진행 방식\n- 각 레벨 별 동일한 주제로 1개의 글을 쓴다.\n- 진행 방식은 온라인 코드 리뷰 방식과 동일하다.\n- Markdown 방식으로 글을 쓴 후, PR을 보낸다.\n- PR 짝은 6-7명으로, 자신의 글을 제외한 나머지 글을 읽고 피드백한다.\n- 코드 리뷰와 동일하게 계속해서 피드백을 남긴다.\n- 최종 피드백을 남길 시, 200자 내외로 정리하여 작성한다.\n- 최종 피드백이 완료되면 글 작성자는 리뷰 요청을 보낸다. 최종 merge된 글에 대해서 각 조에서 1개의 우승작을 선발한다.\n- 각 조 별 우승작 중 최종 우승작을 다 함께 선발한다.\n\n### 레벨 1 글쓰기 일정\n- 주제: 우아한테크코스 한 달 생활기\n- 진행 기간: 3/2 ~ 3/27. 3/2~3/20 1차 제출 기간. 3/21 ~ 3/26 크루간 글쓰기 리뷰, 퇴고 작업. 본인의 글을 리뷰할 크루들에게 글쓰기 리뷰 채널에서 멘션으로 리뷰 요청\n- 3/27: 크루 리뷰 반영 후 최종 제출 (LMS 리뷰 요청까지 할 것)\n\n### 레벨 1 글쓰기 규칙\n- A4 1페이지 이상의 분량으로 작성한다. 워드 1페이지 이상, 2페이지 이하. 글자 크기 10pt, 자간 1.0 기준\n- '나', '저'로 시작하는 문장은 되도록 쓰지 않는다. 지루하게 시작하는 문장을 줄이자.\n- 한 문장의 글자 수가 30자가 넘어가지 않도록 한다.\n- 한 문장에는 하나의 정보만 담도록 한다.\n- 능동형 문장을 쓰도록 한다.\n\n### 한 문장 쓰기\n- 나는 과거의 나를 부수기 위해 도전한다.\n\n# 3/3\n## 제네릭\n- 다양한 종류의 데이터를 관리하는 경우 데이터의 타입을 특정 타입으로 고정할 수 있다.\n- 장점: 특정 타입으로 제한하여 타입 안정성을 제공한다. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.\n- 제네릭을 사용하지 않을 경우, 다양한 종류의 객체 타입을 추가할 수 있다. 추가한 객체 타입을 사용하려면 다시 형변환을 해야 한다.\n- 제네릭을 사용하면 해당 타입만 추가할 수 있다. 다른 타입을 저장하면 컴파일 에러가 발생한다. 특별하게 예외상황이 아니면 Generic을 사용한다.\n"},{"excerpt":"LOG 제이슨, 홍고와 커피챗을 했다. 굉장히 현실적인 이야기를 많이했다...ㅋㅋㅋ 나도 보통 생각하고 있던 이야기였지만 제이슨의 입으로 들으니 좀 더 와닿는 부분이 있었다. 누누와 말을 놓았다. 점점 말을 놓는 사람들이 많아져서 편하게 대할 수 있어 좋은 것 같다. 하마드에게 먼저 말을 걸어보았다. 하마드 이야기는 뭔가 신기하고 놀라운 이야기들이 많았다…","fields":{"slug":"/2023-02-27/"},"frontmatter":{"date":"2023년 02월 27일 14:02","title":"2023년 02월 27일","tags":null},"rawMarkdownBody":"## LOG\n- 제이슨, 홍고와 커피챗을 했다. 굉장히 현실적인 이야기를 많이했다...ㅋㅋㅋ 나도 보통 생각하고 있던 이야기였지만 제이슨의 입으로 들으니 좀 더 와닿는 부분이 있었다.\n- 누누와 말을 놓았다. 점점 말을 놓는 사람들이 많아져서 편하게 대할 수 있어 좋은 것 같다.\n- 하마드에게 먼저 말을 걸어보았다. 하마드 이야기는 뭔가 신기하고 놀라운 이야기들이 많았다 ㅋㅋ\n- 오늘 데일리 미팅 주제는 주말에 있었던 일 영어 쓰지 않고 말하기였는데 너무 웃겼다 ㅋㅋㅋ 좀 자제하려고 노력했는데 쉽지 않았다\n- 저녁은 글렌, 포이랑 고기를 먹었다. 3명이서 7인분 먹었다 😋\n\n## 배운 것\n- 도치가 설명해준 가변 동반 클래스\n- Collection의 document에 함수를 어떻게 구현하면 좋을지에 대한 가이드라인도 나와있다는 것\n\n## 궁금한 것\n- 정말 boolean add를 추가하는 것만이 최선이었을까? 도치의 질문이었는데 정말 add의 리턴타입을 boolean으로 해야만 하는 것밖에는 방법이 없었을까?\n\n## 어려웠던 것\n- 제이슨과는 할 이야기를 생각해내는 게 쉽지 않았다. 커피챗을 하는 것은 좋지만 준비가 되지 않은 상태로 시작되었다보니 주제가 잘 생각나지 않았다. 다른 사람을 편하게 만드는 대화 주제 생각하는 것이 아직 쉽지 않은 것 같다.\n\n## 느낀 것\n- 회고 스터디 사람들 다들 좋은 사람들 같다. 이번 3주차 회고에 망고와 글렌의 회고가 올라왔는데 회고를 보면서 나와 다른 가치관, 다른 관점에서의 3주차 우테코를 돌아볼 수 있어 좋았다. 이래서 남들 회고 보는게 재밌나 싶다.\n- 주말에 푹 쉬니까 확실히 컨디션이 좋았다. 월요일 1시 출근 최고...\n- 제이슨이 말한 것 중에, 회사의 개발자들을 외부에 노출시키는 것 또한 프로모션이 될 수 있다는 것이 굉장히 와닿았다. 나도 왜 그런지 궁금할 때가 있었는데 그것 자체로도 프로모션이 될 수 있다니 충격적이었다.\n- 나보다 더 잘하는 것처럼 보이는 사람들한테 이제는 주눅들지 않는다. 원래는 내가 저 경지까지 갈 수는 있을까 싶어서 괜히 주눅들고 막막하고 그랬는데 요즘은 그렇지 않다. 내가 다다를 수 있는 경지라는게 느껴져서 그런 것 같다. 시간은 좀 걸리겠지만, 안 될 거라는 생각은 안 한다. 충분히 할 수 있다고 생각한다.\n- 주변의 모든 사람에게서 배울 점을 찾고 있다. 듣는 연습을 하고, 질문하는 연습을 하고, 좋은 답을 하는 방법을 배운다. 주변에 좋은 사람들이 많으니 배울 것도 많다.\n- 모방은 창조의 어머니이다. 단순하게 모방하는 것은 그닥 좋지 않지만, 내가 더 연구하고, 살을 붙이고, 내 것으로 체화한다면 모방 또한 좋은 '수단'이 될 수 있다. 기억하자. 처음부터 그냥 잘했던 사람은 없다.\n"},{"excerpt":"LOG 앞머리를 잘랐다. 앞머리 고데기를 하기 싫어서 앞머리 펌을 했는데, 뿌리가 휘어서 고데기가 필수가 되었다...ㅋㅋㅋ 그래도 앞머리가 거슬리지 않아 훨씬 좋다! 배운 것 연결이 빈번하지 않다면 model에서 view로 데이터를 넘겨줄 수도 있다. model 계층이 view에 영향을 최대한 덜 받게 하려면 어느 순간에는 controller라는 계층을 …","fields":{"slug":"/2023-02-26/"},"frontmatter":{"date":"2023년 02월 26일 09:02","title":"2023년 02월 26일","tags":null},"rawMarkdownBody":"## LOG\n- 앞머리를 잘랐다. 앞머리 고데기를 하기 싫어서 앞머리 펌을 했는데, 뿌리가 휘어서 고데기가 필수가 되었다...ㅋㅋㅋ 그래도 앞머리가 거슬리지 않아 훨씬 좋다!\n\n## 배운 것\n- 연결이 빈번하지 않다면 model에서 view로 데이터를 넘겨줄 수도 있다. model 계층이 view에 영향을 최대한 덜 받게 하려면 어느 순간에는 controller라는 계층을 둬서 관리하는 것이 더 깔끔한 구조를 유지할 수 있다. (by 토니의 리뷰)\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n"},{"excerpt":"함수형 인터페이스 람다 식 또는 메서드 참조에 대한 할당 대상으로 사용된다. 참고 자료 모던 자바 인 액션 [https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html]","fields":{"slug":"/Predicate/"},"frontmatter":{"date":"2023년 02월 24일 07:02","title":"Java 8 Predicate","tags":["Java","개발"]},"rawMarkdownBody":"\n## ```Interface Predicate<T>```\n\n- 함수형 인터페이스\n- 람다 식 또는 메서드 참조에 대한 할당 대상으로 사용된다.\n\n\n## 참고 자료\n- 모던 자바 인 액션\n- [https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html]\n"},{"excerpt":"LOG 점심: 신천직화🍗  저녁: 김볶밥🍚 출입증 목걸이를 받았다! 출입증까지 같이 주는 줄 알았는데 그게 아니었다.. 그래도 훨씬 카드를 갖고 다니기 좋아졌다. 빨리 퇴근했다. 포이랑 토리랑 같이 이야기하면서 갔는데 갑자기 싸피하시는 분이 말 걸어서 깜짝 놀랐다. 서류합격이 잘 안 된다 이런 이야기였던 것 같았다. 나는 원래 활동 자체가 스펙이 될 수 …","fields":{"slug":"/2023-02-23/"},"frontmatter":{"date":"2023년 02월 24일 07:02","title":"2023년 02월 23일","tags":null},"rawMarkdownBody":"## LOG\n- 점심: 신천직화🍗  저녁: 김볶밥🍚\n- 출입증 목걸이를 받았다! 출입증까지 같이 주는 줄 알았는데 그게 아니었다.. 그래도 훨씬 카드를 갖고 다니기 좋아졌다.\n- 빨리 퇴근했다. 포이랑 토리랑 같이 이야기하면서 갔는데 갑자기 싸피하시는 분이 말 걸어서 깜짝 놀랐다. 서류합격이 잘 안 된다 이런 이야기였던 것 같았다. 나는 원래 활동 자체가 스펙이 될 수 없다고 생각하는 편이라 자기가 좀 더 노력해야 한다고 생각했다. 아무튼 좀 당황스럽긴 했다 ㅋㅋ\n- 글렌의 테코톡이 있었다. 다들 테코톡 준비를 열심히 해서 그런가 질문도 잘 대답하고 발표도 잘했다. 가끔 아찔한 질문들도 있어서 내가 저런 상황에서 어떻게 대답했을지 고민을 했다.\n- 늦게 일어났다. 아침에 눈을 떠보니 이른 알람을 못 듣고 바로 7시 15분에 기상했다. 피곤이 누적된 모양이다.\n## 배운 것\n\n## 궁금한 것\n- enum에서 동일한 값을 갖는 enum을 리턴하는 메서드를 만드는 것은 해도 되는 걸까? 어떤 기준으로 해도 되는지 선택할 수 있을까?\n\n## 어려웠던 것\n\n## 느낀 것\n- 나중에 테코톡 발표를 하게 될 텐데, 나 스스로 질문에 답을 할 때 공격적으로 답한다던지 얼른 해치워버리려고 하는 답변을 하기도 해서 걱정됐다. 좀 더 답변을 잘할 수 있는 방법은 그 부분에 대해 정말 잘 아는 것밖에 없을 것 같다 ㅠ\n- 스터디, 알고리즘 등 나를 현혹하는 주제들이 많다. 나도 욕심이 많은 편이라 이것저것 하고 싶은 게 많은데 이번에는 꼭 내가 집중하고 싶은 것에만 집중할 예정이다. 내가 배우면 다 알 수 있는데 잠깐 배우는 걸 미뤄둔다는 마인드로 지내볼 예정이다 ^^ 주변에 이런 사람들이 많아서 많이 배울 수 있는 것 같다.\n- 드디어 홍실과 말을 해봤다ㅋㅋ 한 2주간 말할까 말까만 반복했었는데 그래도 큰 숙제를 해결한 느낌이다. 애쉬랑도 말해봤는데 좀 더 친해지고 싶다!\n\n"},{"excerpt":"LOG 너무 졸려서 어제 TIL도 못 쓰고 자버렸다. 그나마 오늘은 할 일이 많이 없어서 어제 TIL도 적었다. 다행히 기억이 좀 나서 적을 수 있었던 게 좋았다. 포비와 1:1 면담(?)을 했다. 간단하게 내 소개와 내가 왜 우테코에 뽑혔을지에 대한 이야기를 나눴다. 이야기를 하면서 내 마음속에서 정리되는 생각들도 있었다. 배운 것 모던 자바 인 액션에…","fields":{"slug":"/2023-02-24/"},"frontmatter":{"date":"2023년 02월 24일 03:02","title":"2023년 02월 24일","tags":null},"rawMarkdownBody":"## LOG\n- 너무 졸려서 어제 TIL도 못 쓰고 자버렸다. 그나마 오늘은 할 일이 많이 없어서 어제 TIL도 적었다. 다행히 기억이 좀 나서 적을 수 있었던 게 좋았다.\n- 포비와 1:1 면담(?)을 했다. 간단하게 내 소개와 내가 왜 우테코에 뽑혔을지에 대한 이야기를 나눴다. 이야기를 하면서 내 마음속에서 정리되는 생각들도 있었다.\n\n## 배운 것\n- 모던 자바 인 액션에서 Predicate를 알게 되었다. -> [[Predicate|java8 Predicate]]\n\n## 궁금한 것\n\n## 어려웠던 것\n\n## 느낀 것\n- 2주간 좀 익숙해졌다고 생각했는데 아직 모르는 사람들이 있었다. 좀 더 많은 사람들을 만나면서 다양한 생각을 나눠보고 싶다.\n- 포이와 토리의 리뷰어였던 찰리의 추천 책인 '객체지향의 사실과 오해'라는 책을 알게 되었다. 사실 지하철에서 틈틈이 읽고 있던 책이었는데 추천 책이라 기분 좋았다 ㅋㅋ 한 절반 정도 읽었다. 노는 시간을 줄이고 남는 시간에는 책을 읽어봐야겠다.\n- 나는 다른 사람의 의견을 궁금해하는 사람이 되고 싶다. 포비와 이야기를 하면서 \"베로는 어떤 식으로 기억하면 좋을 사람이고 싶나요?\"라는 질문을 받았다. 그 질문에 대한 대답은 \"정답이 아닌 다른 사람의 의견이 궁금한 사람\"이었다. 정답은 아무래도 좋다. 우테코에서 지내면서 알게 된 것은 잘못된 것은 없다는 것이다. 나름대로 그 사람의 철학과 가치관이 담겨 있는 의견들이었다. 그래서 함부로 남의 의견을 매도하고 싶지 않았다. 맞고 틀림이 아니라 순수하게 상대방의 의견을 들을 줄 아는 사람이 되고 싶다. 포비한테 대답한 내용이 완전하게 지금의 나와 같지는 않을 수 있다. 앞으로 더 나아지면 된다고 생각한다.\n"},{"excerpt":"LOG 점심: 시부야 저녁: 수가성 오늘은 포비의 강의가 있었다. 내일 글렌과 제이가 발표라서 리허설을 같이 봤는데, 포비가 같이 오셔서 피드백 해주셔서 신기했다. 내 발표가 아니라서 그런지 (ㅋㅋ) 질문 듣는 게 재밌었다. 의외로 저녁 밥을 먹고 나니 저녁에 공부할 시간이 많지 않았다. 그래도 오늘 저녁에 남아 있어서 미션 리팩토링을 좀 더 할 수 있었…","fields":{"slug":"/2023-02-22/"},"frontmatter":{"date":"2023년 02월 22일 01:02","title":"2023년 02월 22일","tags":null},"rawMarkdownBody":"## LOG\n- 점심: 시부야 저녁: 수가성\n- 오늘은 포비의 강의가 있었다. 내일 글렌과 제이가 발표라서 리허설을 같이 봤는데, 포비가 같이 오셔서 피드백 해주셔서 신기했다. 내 발표가 아니라서 그런지 (ㅋㅋ) 질문 듣는 게 재밌었다.\n- 의외로 저녁 밥을 먹고 나니 저녁에 공부할 시간이 많지 않았다. 그래도 오늘 저녁에 남아 있어서 미션 리팩토링을 좀 더 할 수 있었다.\n- 컨디션이 좋지는 않았다. 그래서인지 미션 구현에 집중을 많이 하지 못했다. 내일은 꼭 미션을 제출하고 집에 갈 예정이다.\n\n## 배운 것\n- LinkedHashMap을 사용하면 추가된 순서대로 저장된다.\n- nextInt()의 경우 개행이 사라지지 않아 다음에 nextLine 입력을 받을 때 버퍼에 남은 개행이 입력될 수 있다. 차라리 일괄적으로 nextLine을 사용하는 것이 좋은 것 같다.\n\n## 궁금한 것\n- 권위에 도전하기 위해 상대방에게 말을 건넬 때, 어떻게 하면 더 좋은 말로 할 수 있을까?\n- 상대방에게 상처를 주지 않고 의견을 건네는 방법은 어떤 방법이 있을까?\n- LinkedHashMap을 사용했는데, 키 값이 한글일 때 순서가 유지되지 않는 이유는 무엇일까? \n\n## 어려운 것\n- 여전히 미션에 집중하기 어렵다. 컨디션 때문인지, 이번 미션에 흥미가 떨어져서인지... 열정이 식은 건 아닌 것 같지만 집중이 잘 안 된다. 강의실에서 해 봐야 하나?\n\n## 느낀 것\n- 내가 이루고 싶은 것이 무엇인지 항상 생각하고 있어야 할 것 같다. 시간은 빠르고, 지금도 흘러가고 있다. 매일매일 생각하지 않으면 금방 잊어버린다. 내일도 더 잘하고 싶고, 무엇이든 배우는 것에 집중하고 싶다.\n- 내가 어떻게 보이는지는 마음먹기에 달렸다는 생각을 했다. 신기하게도 그때 이후로 마음을 편하게 먹을 수 있게 되었는데, 그냥 이 상태가 좋다. 오늘 포이한테도 말했지만 내가 우테코에 와서는 여기서만 할 수 있는 것들을 해보고 싶다. 딱 우테코 기간 동안 예전의 나와 다른 사람이 되어 보고 싶다. 굳이 기간을 그렇게 잡은 이유는 앞으로 그렇게 되자는 목표가 너무 거창하기 때문이다. 포비가 말했듯이 작은 것부터 도전해나가는 중이다.\n- 내일 출입증이 나온다고 한다! 토리 말로는 웰컴키트를 준다던데 궁금하다. 우형은 지금 전면 재택중이라고 한다. 조금 동기부여가 된 것 같다.\n- 모르는 주제로 테코톡을 해보려고 한다. 레벨2때 하고 싶은데 다들 그때 하고 싶어해서.. 여차하면 레벨3까지 늦춰질 수도 있을 거 같다.\n- 내일은 레벨1 조와 점심을 먹는다. 이번에는 어떤 사람들과 같이 밥을 먹을지 궁금하다. 예전에 들었던 말 같은데 밥 먹으며 하는 이야기가 중요하다는 얘기가 있었다. 확실히 그럴지도.\n- 생각해보니 집에 와서 뭘 하는 걸까 ㅋㅋㅋ TIL도 자기 10분 전에 쓰는데 그 전에는 뭘 하는거지? 분명 집에 가는 길에는 어떤 걸 하고 싶다는 생각을 했었는데 집에 들어오면 그런 생각이 사라진다. 차라리 집 가는 길에 책을 읽어보는 건 어떨까.\n"},{"excerpt":"Java 왜 ArrayList의 add는 boolean을 리턴할까? 예외가 try, finally에서 동시에 발생하면 어떻게 될까? 스택 풀기 Spring @Controller vs @RestController DAO와 Repository의 차이점 @Mock vs @MockBean SQL TEXT와 VARCHAR의 차이점이 무엇일까? 디자인 패턴 상태 패…","fields":{"slug":"/short-programming-knowledge/"},"frontmatter":{"date":"2023년 02월 21일 14:02","title":"짧은 개발 지식","tags":["개발"]},"rawMarkdownBody":"\n## Java\n\n* [[why-return-type-of-add-function-is-boolean|왜 ArrayList의 add는 boolean을 리턴할까?]]\n- [[simultaneously-throw-exception|예외가 try, finally에서 동시에 발생하면 어떻게 될까?]]\n- [[stack-unwinding|스택 풀기]]\n\n## Spring\n\n- [[controller-vs-restcontroller|@Controller vs @RestController]]\n- [[dao-vs-repository|DAO와 Repository의 차이점]]\n- [[mock-vs-mockbean|@Mock vs @MockBean]]\n\n## SQL\n\n- [[text-vs-varchar|TEXT와 VARCHAR의 차이점이 무엇일까?]]\n\n## 디자인 패턴\n\n- [[state-pattern|상태 패턴이란?]]"},{"excerpt":"틀린 내용이 있을 수 있습니다. 모든 지적을 환영합니다. ArrayList의 add 리스트 미니 미션을 수행하다가 들었던 궁금증이었다. 와 는 뭐가 다르길래 리턴 타입이 다를까? 강의에서 ArrayList의 boolean add는 항상 true를 리턴해서 왜 그렇게 구현했는지 모르겠다는 이야기를 들었다. 나도 그때 당시 그 말에 공감했다. 그런데 inde…","fields":{"slug":"/why-return-type-of-add-function-is-boolean/"},"frontmatter":{"date":"2023년 02월 21일 05:02","title":"왜 ArrayList의 add는 boolean을 리턴할까?","tags":["개발"]},"rawMarkdownBody":"\n**틀린 내용이 있을 수 있습니다. 모든 지적을 환영합니다.**\n\n## ArrayList의 add\n\n- 리스트 미니 미션을 수행하다가 들었던 궁금증이었다. ```void add(int index, String value)```와 ```boolean add(String value)```는 뭐가 다르길래 리턴 타입이 다를까?\n- 강의에서 ArrayList의 boolean add는 항상 true를 리턴해서 왜 그렇게 구현했는지 모르겠다는 이야기를 들었다. 나도 그때 당시 그 말에 공감했다. 그런데 index로 값을 추가하는 메서드의 리턴 타입은 'void'라는 것이 뭔가 이상했다.\n\n## Collection\n\n정답은 Collection 인터페이스에 존재한다.\nCollection에 ```boolean add(E e)``` 의 docs를 확인해보자.\n\n```java\nReturns {@code true} if this collection changed as a result of the call.  \nReturns {@code false} if this collection does not permit duplicates and already contains the specified element.\n```\n\n`호출의 결과로 이 컬렉션이 변경된 경우 true를 반환한다. 이 컬렉션에서 중복을 허용하지 않고 지정된 요소가 이미 포함되어 있으면 false를 반환한다.`\n\n즉, Collection의 boolean add(E e)는 중복을 허용하지 않는 하위 컬렉션의 경우를 고려해서 만든 것이다!\n\n```\nadd를 지원하는 컬렉션은 이 컬렉션에 추가할 수 있는 요소에 제한을 둘 수 있다. 특히 일부 컬렉션에서는 null 요소의 추가를 거부하고 다른 컬렉션에서는 추가할 수 있는 요소의 유형에 제한을 가한다.\nCollection 클래스는 문서에 추가할 수 있는 요소에 대한 제한 사항을 명확하게 명시해야 한다.\n\nCollection이 이미 요소를 포함하고 있다는 이유 이외의 이유로 특정 요소 추가를 거부하는 경우 false를 반환하지 않고 예외를 발생시켜야 한다. 이렇게 하면 이 호출이 반환된 후 컬렉션에 항상 지정된 요소가 포함된다는 불변성이 유지된다.\n```\n\n## ArrayList의 add 함수\n\n```java\npublic boolean add(E e) {\n         modCount++;\n         add(e, elementData, size);\n         return true;\n     }\n```\n     \n```java\npublic void add(int index, E element) {\n        rangeCheckForAdd(index);\n\tmodCount++;\n\tfinal int s;\n\tObject[] elementData;\n\tif ((s = size) == (elementData = this.elementData).length)\n\t\telementData = grow();\n\tSystem.arraycopy(elementData, index, elementData, index + 1, s - index);\t\t\t      elementData[index] = element;\t\t\t\t\t\t              \n\tsize = s + 1;\n}\n```\n\n이제 이 부분을 이해할 수 있다. ArrayList는 중복을 허용하므로 false가 리턴되는 경우가 없어 항상 true를 리턴하는 것이다.\n\n## 왜 리턴 타입이 다를까?\n\n- 아래 참고 링크를 통해 답을 유추할 수 있었다. 우리가 add 메서드를 생각할 때, 리턴 타입이 void일 것이라고 예상하는 게 당연하다. 그런데 add 메서드는 Collection 인터페이스에 포함되어 있는 함수로, ArrayList, HashSet 등 Collection 클래스들은 모두 동일한 메서드 시그니처를 오버라이딩하여 구현한다.\n- HashSet의 add 함수는 ArrayList와 달랐다. HashSet의 add는 다음과 같다.\n\n```java\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n\t    }\n```\n\n(HashSet은 HashMap을 사용해서 구현된다)\n\nArrayList와는 다르게 항상 true를 리턴하는 것이 아닌, 값의 존재 여부를 판단하고 true/false를 리턴한다. 즉, HashSet에서의 boolean add는 필요하다는 것이다. add 자체에서 값의 존재 여부를 판단한 후, 값의 삽입 여부를 호출부로 알려줘야 하기 때문이다.\n\n## contains로 확인한 다음에 add를 하면 void로 구현할 수 있지 않을까?\n\n(여기서부터는 약간의 뇌피셜이 있습니다.)\n\n- 싱글 스레드 환경에서는 괜찮을 수 있지만, 멀티 스레드 환경에서는 critical할 수 있다. 예를 들어 다른 스레드가 값을 추가하는 동시에 내 스레드에서 contains를 수행하여 값이 포함되었는지 여부를 확인할 수 있다. 이때 동시성이 제대로 체크되지 않을 가능성이 있다. (이 부분은 커널 코드를 보지 않았기 때문에 확실하지 않음)\n- 즉, 방금 값 추가를 시도해서 값이 존재할 수 있지만 동일한 자료구조에 동시에 접근하게 되어 내 스레드의 contains에서는 존재하지 않는다는 리턴값을 받을 수도 있다는 것이다. 따라서 이 경우에 set.contains와 set.add는 single/atomic한 행동이어야 한다. 그러므로 add에서 boolean을 리턴하는 것이 contains와 add를 동시에 실행하는 atomic operation 이어야 한다고 볼 수 있다.\n- HashSet과 같은 Collection의 구현체에서 boolean add의 필요성이 존재하므로, Collection의 add 함수의 리턴 타입은 boolean이 되어야 할 것이다. void를 리턴하게 되면 중복을 허용하지 않는 하위 컬렉션의 경우 위험성이 커지게 된다. ArrayList의 경우 그런 경우를 체크할 필요가 없으므로 항상 true를 리턴하는 코드를 작성한 것이다.\n\n## 그렇다면 ArrayList의 add(int index ...)의 리턴 타입은 왜 void 인가?\n\n- 해당 메서드는 index 위치에 값을 삽입하라는 메서드이다. index가 존재하는 Collection에서만 필요하므로 Collection의 메서드에는 빠져있는 것을 볼 수 있었다.\n- index를 다루는 Collection에서는 값을 넣지 못하는 경우가 존재하지 않으므로 굳이 boolean type을 쓸 이유가 없다. 따라서 리턴 타입을 void로 설정한 것으로 보인다.\n\n## 참고 링크\n- [stackoverflow 참고 자료](https://stackoverflow.com/questions/24173117/why-does-list-adde-return-boolean-while-list-addint-e-returns-void)\n"},{"excerpt":"LOG 오늘 점심은 제육이었다. 여기 와서 제육을 3번 먹었다 ㅋㅋㅋ 살면서 제육볶음을 사서 먹어본 적이 얼마 없는 것 같은데 의외로 맛있는 것 같다. 미션은 할 만한데 오늘 나온 List 과제가 진짜 하기 싫었다... 그래도 집 와서 마무리 해서 다행이다. 내일은 꼭 미션을 마무리하고 싶다. View 까지 안 된다면 핵심 로직만이라도 😭 디투가 우리 학…","fields":{"slug":"/2023-02-21/"},"frontmatter":{"date":"2023년 02월 21일 01:02","title":"2023년 02월 21일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘 점심은 제육이었다. 여기 와서 제육을 3번 먹었다 ㅋㅋㅋ 살면서 제육볶음을 사서 먹어본 적이 얼마 없는 것 같은데 의외로 맛있는 것 같다.\n- 미션은 할 만한데 오늘 나온 List 과제가 진짜 하기 싫었다... 그래도 집 와서 마무리 해서 다행이다. 내일은 꼭 미션을 마무리하고 싶다. View 까지 안 된다면 핵심 로직만이라도 😭\n- 디투가 우리 학교 선배라는 걸 알게 되었다. 선배들이 꽤 왔다고 들었는데 3명이나 있을 줄은 몰랐다. 심지어 모앱 수업은 같이 들었어서 더 신기했다 ㅋㅋㅋ 이 정도면 못 알아본게 신기하다.\n- 아마란스가 스터디 제의를 줬는데 내가 제풀에 지칠까봐 아쉽지만 거절했다 ㅠ 뭐든 하고 싶은 마음은 앞서지만 내가 감당하지 못할 걸 알고 있어서 더 아쉬운 것 같다.\n\n## 배운 것\n- 왜 배열의 add는 boolean을 리턴할까? : [[why-return-type-of-add-function-is-boolean|배열과 add 함수]]\n- checked exception을 안 쓰는 이유는? : [[effective-java-ed3|item 71]]\n\n## 궁금한 것\n- serialVersionUID가 뭘까. 강의 시간에 Exception, Error 코드(java 내부 코드)에서 나왔다.\n- 요즘 언어는 checked exception을 안 쓰는 이유는?\n\n## 어려웠던 것\n- 하기 싫은 미션을 얼른 끝내야 해서 어거지로(?) 하는 게 쉽지 않았다.\n\n## 느낀 것\n- 사람들의 생각을 알아보는 건 재밌는 것 같다. 그래서 남의 블로그 보는 게 재밌는건가 ㅋㅋ 여기 와서 예전의 나와 다르게 살아보려 하고 있는데 진짜로 주변 사람들한테 다르게 느껴지는 것 같아서 신기했다. 그렇다고 내가 잘 보이려고 연기하고 있거나 억텐을 끌어올린다기보다는 여러 가지 시도를 해보는 중이다. 이런 기회가 흔치 않으니까 이것저것 다 시도해보고 싶다.\n- 내 말투에 대해 되돌아보고 있다. 가끔 반응을 하느라 상대방의 말을 끊게 되는 경우가 있는데 사실 타이밍을 잘 못 잡겠다. 서로에게 생산적인 질문을 하는 사람이 되고 싶다.\n- 생각해보니 오늘 아침에 그렇게 피곤하지 않았다. 왜인지는 모르겠다. 커피를 마셨지만 역시나 전혀 효과가 없다. 이럴 거면 커피를 안 마셔도 되지 않을까? 그렇다고 단 걸 마시자니 탄수화물이 걱정된다.\n- 의외로 나와 이야기가 잘 통하는 모르는 사람을 만났을 때는 그닥 어색함을 느끼지 않았다는 것을 느꼈다. 내가 편안함을 느끼고 대할 수 있는 사람의 특징은 뭘까? 예전에도 알아보려고 했던 것 같은데 아직 알아내지 못했다.\n"},{"excerpt":"2/21 Checked Exception, Unchecked Exception Checked Exception Checked Exception : Exception을 상속. compiled time에 catch 가능함. try catch를 사용하지 않으면 컴파일 에러가 발생한다. exception이 발생하는 메서드가 throws 예약어로 Exception…","fields":{"slug":"/level1-week3/"},"frontmatter":{"date":"2023년 02월 21일 01:02","title":"레벨1 3주차","tags":["우테코","레벨1"]},"rawMarkdownBody":"# 2/21\n## Checked Exception, Unchecked Exception\n### Checked Exception\n- Checked Exception : Exception을 상속. compiled time에 catch 가능함. try catch를 사용하지 않으면 컴파일 에러가 발생한다.\n- exception이 발생하는 메서드가 throws 예약어로 Exception을 호출 메서드에 전달해야 한다.\n### Unchecked exception \n- Run Time Exception이라고 한다.\n- 컴파일 시점에 Exception을 catch하는지 확인하지 않는다. 컴파일 시점에 Exception이 발생할 것인지의 여부를 판단할 수 없다.\n- Exception이 발생하는 메서드에서 throws 예약어를 활용해 Exception을 처리할 필요가 없지만 처리해도 무방하다.\n### Checked Exception, Unchecked Exception 선택 방법\n- (코틀린은 checked exception이 없다고 한다)\n- 호출하는 메서드가 Exception을 활용해 뭔가 의미있는 작업을 할 수 있다면 Checked Exception을 사용하라.\n- 호출하는 메서드가 Exception을 catch해서 예외 상황을 해결하거나 문제를 해결할 수 없다면 Unchecked Exception을 사용하라.\n- 명확하지 않다면 Unchecked Exception을 사용하라.\n- 내 생각: checked Exception을 사용하지 않아도 될 것 같다. 낮은 수준에서 checked exception을 사용한 경우 그 함수를 사용하는 모든 함수에서 throws를 사용하게 되어 함수를 사용하기 어렵다. (후추의 추가 의견 : checked exception이 안정성을 완벽히 보장하는 것이 아니다. 사용하는 쪽에서 예외처리를 어떻게 하느냐에 달려있기 때문이다.)\n### Exception 처리\n- 메소드에서 여러 개의 Exception을 throw 하는 경우 쉼표로 구분할 수 있다.\n- 메서드에서 여러 개의 Exception을 throw할 때 부모 클래스로 예외를 전달하는 방법도 있다. (ObjectStreamException, UnknownHostException을 Exception으로 통합해서 던지는 것)\n- 메서드를 호출할 때 예외를 처리한 후, 예외를 재전달(rethrow)하는 것도 가능하다.\n### 복구\n- 예외가 발생한 문제를 정상 상태로 돌려놓는다. (파일 등에 저장을 해두는 등)\n- 재처리 또한 복구에 해당된다.\n```\nint readTryCount() {\n  try {\n      return Integer.parseInt(InputView.read());\n        } catch (final NumberFormatException e) {\n\t    return readTryCount();\n      }\n  }\n```\n### 회피\n- 직접 예외를 처리하지 않고 호출한 쪽으로 회피할 수 있다.\n- 고민없는 회피는 외면하는 것과 같다. 회피를 할 때는 많은 고민 후 결정한다.\n### 무시\n- catch에 아무런 로직도 없는 경우\n- 진짜 외면하는 경우도 있다. 무시를 하는 경우는 더 많은 고민이 필요하다.\n### 전환\n- Checked Exception을 Unchecked Exception으로 전환할 수 있다.\n- DbException 같은 경우 도메인 계층까지 전달되기 전에 추상화 계층에 맞는 예외로 변경 하거나 적절한 시점에 예외를 처리할 수도 있다.\n## List\n- 데이터 저장 방식: ArrayList와 LinkedList\n- ArrayList: 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해서 데이터를 복사하는 방법을 사용\n- LinkedList: 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다.\n\n# 2/22\n## 슬기로운 우테코 생활\n- 절망의 골짜기. 내가 재작년~작년에 경험했었는데 지금은 좀 더 올라가는 중인 것 같다. 아직 절망의 골짜기이지만 기울기가 양수가 되어가는 시점이 아닐까?\n- 레벨1: 경쟁의식 버리기. 옆 크루와 같이 학습하고 성장하는 방법을 찾는다. 주변과 비교하지 않고 '나의' 배움과 성장에 집중한다. 내 가장 큰 라이벌은 옆의 크루가 아니라 어제의 나라는 것을 잊지 말기.\n- 레벨2, 3: 꾸준함, 소프트스킬. 난이도가 높아지고, 성장은 더디고, 흥미는 떨어지는 단계. 자신만의 학습 방법을 찾고, 학습 속도를 유지하면서 꾸준히 학습하는 습관을 만든다. 기술적인 역량 외에 소프트스킬 역량을 향상시키는데도 관심을 가져야 한다. 특히 팀플에서 사람들 만날 때 더 어려움을 느낄 때가 많으니 소프트스킬을 향상 시킬 수 있는 좋은 기회라고 생각해보자.\n- 레벨4: 멘탈 관리. 수박 겉핥기 식의 다양한 지식 습득이 아닌 깊이 있는 지식 습득. 주변 상황 (기업 채용, 크루들의 취업 준비 등)에 휘둘리지 않고 꾸준히 학습에 집중하는 멘탈 관리. 나만의 철학 만들기.\n- 꾸준히 성장하는 크루들은 어제의 나와 경쟁하면서 꾸준히 배움과 성장에 집중한다. 기존의 학습 방법, 틀을 빨리 깨트리는, 버릴 수 있는 용기를 가진 크루가 꾸준히 성장할 수 있다. 주변에도 이런 사람이 있는데 나도 오로지 내 성장에만 집중하는 사람이 되어야겠다. 어차피 시간 들이면 내가 더 잘한다는 마인드로!\n- 뭔가 다 하는 것은 어렵지 않다. 그냥 하면 된다. 그렇지만 남들이 하고 있는데 나는 아직 할 준비가 되지 않아서, 부족하다고 생각해서 내 공부에 집중하는 것도 정말 중요하다. 그럴 수 있어야 한다. 그 길이 더 빠른 길이라는 믿음이 있어야 한다.\n- 알고리즘... 나도 해야 하긴 하는데 나 또한 지금은 아닌 것 같다. 우테코에 들어오려고 했던 건 알고리즘을 하는 게 아니라 협업과 백엔드 경험을 하기 위해 들어왔기 때문에 알고리즘은 나중으로 미루는게 좋을 것 같다.\n### 어떻게 살아야 할까\n- 필요한 것은 권위에 도전할 수 있는 용기\n- 권위에 도전하는 과정이 내가 진정 좋아하는 일, 잠재력을 찾는 과정\n- 변화를 만들려고 할 때 가장 작은 것부터라도 시작해보기. 당연시 하던 학습 방법, 책을 읽는 방법 등 내가 변화를 만들 수 있는 가장 작은 시도부터 시작해보자. 하다가 안 되어 힘들 때는 주변 사람들을 활용하자. 주변 사람에게 위로와 에너지를 받아 다시 시도해보자. 또 안 되면 잠깐 쉬어도 괜찮다. 도전했다는 것 자체가 좋은 거다.\n- 변화를 만들기 위해서는 의지력보다는 환경이 더 중요하다. 변화하기 좋은 환경을 만들자. 나도 우테코에 와서 생각보다 다른 사람과 이야기도 많이 하고, 나와 다른 사람을 일부러 만남으로써 다양한 관점으로 바라볼 수 있는 것 같다.\n- 주변 환경을 정리해서 꾸준히 학습할 시간을 확보한다.\n- 다른 사람의 경쟁/비교보다 어제의 나와 비교해서 성장했는지에 집중한다.\n# 2/24\n## 사다리 타기 피드백\n### 접근 방식\n- Out->In 접근 방식: 도메인 지식이 없거나 요구사항을 객체로 도출할 수 없는 경우. tdd 구현시 특정 상태를 분리해 시작하는 것이 중요하다. 작은 단위부터 tdd 시작하기.\n- In->Out 접근 방식: 도메인 지식이 있거나 요구사항을 객체로 도출할 수 있는 경우. 가장 작은 단위의 객체(In)부터 기능을 추가하면서 Out 방식으로 완성해나간다. 그러나 시작 단계에서 가장 작은 단위의 객체를 찾는 것이 쉽지 않다.\n- 둘 중에 하나만 사용하지는 않는다. 핑퐁하듯이 사용한다.\n- 객체 설계 사이클: 테스트 실패 -> 테스트 성공 -> 리팩터링\n### 객체 설계 방식\n- Out -> In으로 시작한다. 도메인 지식으로 설계할 수 있는 부분까지 설계\n- 요구사항을 분석한다. 도메인 설계에서 Object graph 중 가장 마지막 노드(의존성을 가지는 객체가 하나도 없는 객체)부터 구현을 시작하는 것이 TDD로 접근하기 수월하다.\n- 요구사항 기반으로 객체를 도출한다.\n"},{"excerpt":"LOG 오늘은 그 분과 만날 수 있는 (아마도) 마지막 날이었다. 그 전의 나와 지금의 나는 많이 달라진 것 같다. 어느 정도 마무리 단계일 때 괜찮아졌다고 생각했는데 아직도 괜찮지는 않은 것 같다. 그래도 앞으로는 더 마음 편하게 살려고 노력하고 싶다. 예전보다는 더 나은 내가 되고 싶다. 아침에 많이 이야기 하고 와서 그런지 오늘은 좀 더 마음 편하게…","fields":{"slug":"/2023-02-20/"},"frontmatter":{"date":"2023년 02월 20일 05:02","title":"2023년 02월 20일","tags":null},"rawMarkdownBody":"## LOG\n- 오늘은 그 분과 만날 수 있는 (아마도) 마지막 날이었다. 그 전의 나와 지금의 나는 많이 달라진 것 같다. 어느 정도 마무리 단계일 때 괜찮아졌다고 생각했는데 아직도 괜찮지는 않은 것 같다. 그래도 앞으로는 더 마음 편하게 살려고 노력하고 싶다. 예전보다는 더 나은 내가 되고 싶다.\n- 아침에 많이 이야기 하고 와서 그런지 오늘은 좀 더 마음 편하게 지낼 수 있었다. 편한 내가 훨씬 살기 편한 것 같다.\n- 체인저가 진행하는 주간 회고 모임에 들어갔다. 우테코에서 하게 된 첫 모임(?)인데 기대된다. 내가 TIL 적는게 약간 혼잣말 하는 것 같아서 동기부여가 잘 안 됐는데 같이 하면 좋지 않을까? 주간 회고 때 한 말을 블로그에 적어보는 것도 좋겠다.\n## 배운 것\n- 구현하는 프로젝트에서 사용하는 도메인 용어를 사용할 때에는 주의한다. 기존 단어의 의미와 프로젝트 내에서 사용되는 도메인적인 의미가 뒤섞이지 않도록 유의한다.\n- IllegalStateException과 IllegalArgumentException을 구분하는 것은 중요하다. 둘 중 어떤 예외가 발생하는지에 따라 외부의 값이 잘못되었는지, 프로젝트 내의 객체나 로직이 잘못되었을지를 파악하여 다르게 처리해야 하기 때문이다. IllegalArgumentException의 경우 사용자 / 클라이언트에게 올바른 값을 입력하는 것을 요청해야 하고, 후자는 서비스 로직에 문제가 있다고 파악할 수 있다. 후자의 경우는 일시적 문제일 수 있기에 이전에 사용자가 입력한 값을 재사용하여 자체적으로 재시도하는 로직을 추가할 수도 있다.\n## 궁금한 것\n- 어떻게 하면 객체에 책임을 잘 나눌 수 있을까? 오늘 미션을 계속 고민하면서 이 방향이 맞는지, 저 방향이 맞는지 생각하는데 바로 떠오르지 않았다. 어떻게 하든 뭔가 완벽하지 않은 느낌이 계속 들었다. 이런 식으로 설계하면서 미션을 진행해도 되는걸까?\n## 느낀 것\n- 나와 다른 사람들을 좀 더 잘 이해해보고 싶다. \"그냥 그런 사람\" 이라고 생각하는 것보다 상대를 이해해보려고 하는 자세가 훨씬 좋아보인다.\n- 예전의 내 태도를 반성하게 됐다. 그때는 지금보다 부정적이고 나와 다른 사람을 굳이 이해하기 위해 노력하는 사람은 아니었던 것 같아서. 지금 돌아보니 좋은 태도가 아니었다. 그래도 남아있어 준 사람들이 오히려 대단할지도 모른다.\n"},{"excerpt":"LOG 포이가 내 위키를 염탐하고 있다고 하면서 TIL이 무섭다고 했다(?) 대체 뭐가 무서운데!! 데일리 조와 같이 점심을 먹었다. 브라운이 추천했던 토도로끼에 갔는데 꽤 맛있었다. 쇼유라멘 좋아 배운 것 : github 강제 push하는 방법 IllegalStateException: 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알리…","fields":{"slug":"/2023-02-17/"},"frontmatter":{"date":"2023년 02월 18일 12:02","title":"2023년 02월 17일","tags":null},"rawMarkdownBody":"## LOG\n- 포이가 내 위키를 염탐하고 있다고 하면서 TIL이 무섭다고 했다(?) 대체 뭐가 무서운데!!\n- 데일리 조와 같이 점심을 먹었다. 브라운이 추천했던 토도로끼에 갔는데 꽤 맛있었다. 쇼유라멘 좋아\n## 배운 것\n- ```git push -u origin +master --force```: github 강제 push하는 방법\n- IllegalStateException: 호출받은 객체가 요청을 처리하기 적합하지 않은 때에 호출되었음을 알리는 예외\n- IllegalArgumentException: 메서드에 잘못되거나 부적절한 매개변수가 전달되었음을 알리는 예외\n- ```assertDoesNotThrow(() -> code ...);```: ```assertThatCode(() -> 예외 코드).doesNotThrowAnyException()``` 대신에 ```org.junit.jupiter.api.Assertions.assertDoesNotThrow```를 사용할 수 있다.\n- 회고를 잘하는 방법을 배웠다. - [[level1-week2|회고를 잘하는 방법]] 나는 개선점만 말하는게 회고인줄 알았는데 감정 회고도 중요하다고 해서 신기했다. 좋은 말로 상대의 개선하는 점을 말하는 것도 배우면 좋을 텐데 쉽지 않다.\n## 궁금한 것\n- 프리코스 때 enum static 함수로 값을 입력 받아 해당 값과 동일한 enum 객체를 리턴하는 함수를 사용했었는데, 이게 좋은 함수 형식이 맞을까? 그때는 그냥 아무 생각 없이 썼었는데 이번 미션의 라인 클래스를 리팩토링하다 고민이 되었다. ```List<Boolean>``` 형식의 line을 ```List<State>``` 이런 식으로 enum을 사용해서 리팩토링할까했는데 이 질문 때문에 결국 그만뒀다. 다음 주에 다른 사람들한테 물어봐야겠다.\n## 어려웠던 것\n- 여전히 어색한 분위기를 참기 힘들다. 어색한 분위기 속에서 불쑥 뭔가를 물어보는 게 내 입장에서는 굉장히 큰(?) 용기였는데 곰곰히 생각해보니 굳이 그럴 필요가 있나라는 생각이 든다. 심지어 딱히 아이스 브레이킹이 되는 것 같지도 않다. 침묵을 참아내는 것도 능력인 것 같다.\n## 느낀 것\n- 우테코에 와서 소프트 스킬이 정말 굉장히 매우 중요하구나... 라는 생각이 계속해서 든다. 이렇게 많은 모르는 사람들을 단시간에 만나기도 쉽지 않은데 여기에서 많이 배워가고 싶다. 주변에 사람들과 쉽게 이야기를 하는 분들이 많은데 나도 배우고 싶다 ㅋㅋ\n- 무엇보다 정말로 궁금한 것이 많은 사람들이 대단하다. 관심을 갖고 알아가고 싶은 마음이 궁금증을 자아내는게 아닐까? 공부든 뭐든 관심을 갖고 알아가려는 태도는 배울만하다.\n- prolog 써야 할 것 같다. 집 가기 전에 포이가 가변 인자에 대해서 질문한 부분이 있었는데 가변인자가 Objects[]로 변환된다는 사실은 몰랐어서 신기했다. 질문들이 다 깊은 질문들이고 내가 '그냥' 쓰는 것들에 의문을 가지는 형식이어서 정말 도움이 많이 될 것 같다. 근데 시간이 있을까...? 요즘 자꾸 TIL도 밀려서 속상하다 😢\n- 잠이 너무 많아졌다. 아침에 일찍 일어나고 출퇴근 시간에 좀 시달리다보니 몸이 피곤한 듯... 공부하고 싶은데 체력이 모자라다.\n"},{"excerpt":"LOG 도치와 페어프로그래밍 마무리 하다가 추상 팩토리 얘기 잠깐 했는데 구구가 그걸 왜 쓰냐고 해서 즉석 피드백 시간이 열렸다. 이번에 페어 프로그래밍할 때 생성자에서 매개변수를 좀 줄이고 싶어서 그 부분을 피드백 요청했다. 구구가 한 질문들이 굉장히 생각해볼만한 질문들이어서 좋았다. 우리가 쓴 것이 Controller인 것인지? Controller는 …","fields":{"slug":"/2023-02-16/"},"frontmatter":{"date":"2023년 02월 17일 04:02","title":"2023년 02월 16일","tags":null},"rawMarkdownBody":"## LOG\n- 도치와 페어프로그래밍 마무리 하다가 추상 팩토리 얘기 잠깐 했는데 구구가 그걸 왜 쓰냐고 해서 즉석 피드백 시간이 열렸다. 이번에 페어 프로그래밍할 때 생성자에서 매개변수를 좀 줄이고 싶어서 그 부분을 피드백 요청했다. 구구가 한 질문들이 굉장히 생각해볼만한 질문들이어서 좋았다. 우리가 쓴 것이 Controller인 것인지? Controller는 왜 써야 하는지? 전략 패턴을 사용한 이유는 무엇인지? 굳이 생성자의 매개변수를 줄일 필요가 있을지? LineStrategy가 util에 있는 이유는 무엇인지? 질문도 좋았지만 중간중간 구구의 인정을 받아서 기뻤다 ㅋㅋ\n- 나는 구구의 피드백을 받을 때 말투가 날카롭다고 생각하지 않았는데 확실히 관점의 차이가 있는 것 같다. 아무래도 지피에 있을 때 자주 질문을 받아서 그런지 오히려 이정도는 좋은 피드백이라고 생각했다. 내가 말을 할 때도 날카롭게 질문하는 거라고 받아들이는 사람이 있을 수도 있겠다는 생각이 들었다. 좀 더 유하게 말하는 연습을 해봐야겠다.\n## 배운 것\n- 패키지를 결정할 때 해당 클래스가 어떤 역할을 하고, 어디서 사용하는지 고려해서 패키지를 정하자.\n- 최대한 불필요한 것은 없애보자. (이건 구구의 견해일 수도 있다.)\n- mermaid를 사용하면 클래스 사이의 관계와 프로그램 구조를 한 눈에 볼 수 있다. github readme에 쉽게 붙여넣을 수 있어 더 좋다.\n## 궁금한 것\n- 지금은 안 쓰이지만 나중에 필요할 것 같은 클래스를 미리 구현해놓는 것은 굳이 할 필요가 없을까? 이런 생각이 당연하게 \"맞다/아니다\"라는 답변을 내릴 수 있는 것인지, 단순 취향 차이인지 궁금하다. 구구는 내가 아직 경험이 많이 쌓이지 않아서 나중에 구현되면 좋을 클래스의 예시도 제대로 못 드는 상태에서는 안 쓰는게 낫다고 했지만, 다른 사람들의 견해도 궁금하다. 혹시 이 TIL을 보는 사람은 생각을 댓글로 달아주세요.\n## 느낀 것\n- 이번 미션에서 기능 구현 우선순위를 정해놓는 것이 좋겠다는 생각을 했다. 처음부터 설계를 완벽하게 하기보다는 점진적으로 만들어가는 애자일 방식으로 구현하는 게 미션을 빠르게 구현할 수 있는 방법 같다. 사실 부가적으로 구현되는 부분에 집중하다보니 메인 기능에 시간을 많이 못 쏟은 것 같아서 아쉽다.\n- 지피에서 선배들, 후배들과 이야기하는 시간이 정말 많이 도움이 되었다는 생각을 새삼스럽게도 했다. 거기서 키워드도 주워 듣고, 건전한 토론을 하는 방법을 배울 수 있어 좋았던 것 같다. 앞에 나서는 연습을 했던 것도 많이 도움이 되었다. 모두 지피하세요 :)\n- 예전에는 권위있는 사람의 말을 무조건 경청하려는 습관이 있었는데, 이제는 내가 의도했던 것들/내 생각을 좀 더 자유롭게 말할 수 있는 것 같아서 성장했다고 느꼈다. 포비가 말하는 '권위에 도전하라'라는 말을 실천한 것 같아 기분이 좋다 😄\n"},{"excerpt":"LOG 웹 수업에서 HTTP, CSS, JS 배웠는데 역시 재미없다... 물건너간 풀스택의 꿈 runcat 안 되는 줄 알았는데 그냥 상태바가 자리가 없어서 안 보인 거였다... ㅎㅎ 오늘 아침에 지하철 타면서 객체지향의 사실과 오해 라는 책을 읽었다. 중간에 읽다가 졸려서 자긴 했지만ㅠ 오늘 도치랑 미션하면서 굉장히 고민을 많이했다. 지금 생각해보니 굳…","fields":{"slug":"/2023-02-15/"},"frontmatter":{"date":"2023년 02월 15일 02:02","title":"2023년 02월 15일","tags":null},"rawMarkdownBody":"## LOG\n- 웹 수업에서 HTTP, CSS, JS 배웠는데 역시 재미없다... 물건너간 풀스택의 꿈\n- runcat 안 되는 줄 알았는데 그냥 상태바가 자리가 없어서 안 보인 거였다... ㅎㅎ\n- 오늘 아침에 지하철 타면서 객체지향의 사실과 오해 라는 책을 읽었다. 중간에 읽다가 졸려서 자긴 했지만ㅠ\n- 오늘 도치랑 미션하면서 굉장히 고민을 많이했다. 지금 생각해보니 굳이 생각 안 해도 되는 걸 생각했나? 라는 생각은 든다..ㅋㅋ 너무 어렵게 생각한 것 같기도 하고.\n## 느낀 점\n- 배운 점, 궁금한 점, 어려운 점이 없는 걸 보면 쓸 말이 없는 것 같다. 한 게 없으니.. 내가 우테코를 왜 하고 싶어 했었는지 기억했으면 좋겠다.\n- 페어에게 적당히 태클을 거는 것도 필요한 것 같다. 정확하게 의견을 피력하지 않으면 그대로 반영되기 때문에 아니다 싶은 거는 제대로 토론해야 한다. 오히려 우테코에 와서 페어 프로그래밍 하면서 내가 프리코스 때 짠 것보다 오버해서 짜는 느낌이다. 그때가 잘했다기 보다는 굳이 요구사항에서 나와있지 않은 것까지 어거지로 추가하는 느낌? 뭐든지 적당히가 좋을 듯.\n- 목표에서 멀어진 느낌이 난다. 여전히 나태하다고 생각한다. 하자고 했던 건 확실하게 지키자. 그게 미래의 나를 위한 길이다. 미래의 내가 지금의 나를 원망하지 않도록 최선을 다하자. 내일은 꼭 배운 것을 쓸 수 있으면 좋겠다.\n"},{"excerpt":"2/14 TDD, 리팩터링 production 코드가 잘 돌아가는지 검증하는 코드 -> Test Code TDD란? TFD(Test First Development) + 리팩토링. 실패하는 코드를 만들고 성공하게 하는 것. 일단 코드를 성공하게 한 다음에 정말 의미를 갖는 코드인지 리팩터링한다. TDD 하는 이유: 디버깅 시간을 줄여준다. 동작하는 문서 …","fields":{"slug":"/level1-week2/"},"frontmatter":{"date":"2023년 02월 14일 01:02","title":"레벨 1 2주차","tags":["우테코","레벨1"]},"rawMarkdownBody":"# 2/14\n## TDD, 리팩터링\n- production 코드가 잘 돌아가는지 검증하는 코드 -> Test Code\n- TDD란? TFD(Test First Development) + 리팩토링. \n- 실패하는 코드를 만들고 성공하게 하는 것. 일단 코드를 성공하게 한 다음에 정말 의미를 갖는 코드인지 리팩터링한다.\n- TDD 하는 이유: 디버깅 시간을 줄여준다. 동작하는 문서 역할을 한다. (단위테스트 있으면 동일한 거 아닌가?) 변화에 대한 두려움을 줄여준다. -> 왜 TDD를 해야 하는가?\n- 이미 구현된 코드에 대한 단위테스트를 작성하면 단순히 커버리지만 높은 코드가 나올 수 있다. (구현 사항을 이미 알고 있기 때문에)\n- 심적으로 안정감을 얻을 수 있다.\n- 처음부터 완벽한 설계를 하는 것이 아니라 점진적으로 설계를 개선해 나갈 수 있다. 과도한 설계에 따른 추가 비용을 해소한다.\n- 빠른 피드백을 받을 수 있다.\n### TDD 원칙\n1. 실패하는 단위 테스트를 작성할 때까지 프로덕션 코드를 작성하지 않는다.\n2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.\n3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.\n### 빠른 피드백을 통한 개발 효율\n- 버그를 찾는 시점이 빨라진다.\n- 일정한 리듬으로 일함으로써 프로그래밍에 재미를 느낌 (?)\n- 더 많은 삽질을 할 수 있다. (?) 삽질은 더 많은 배움이다.\n- 지금 필요한 것은 새로운 접근방식에 도전할 수 있는 용기\n## 개발을 잘한다의 기준은?\n- 코드 작성 시 가장 중요한 것은? -> 성능 / 가독성 / 유지보수성\n- 개발자가 코드를 신경쓰는 이유는 비용을 절약하기 위함이다.\n- 기술부채가 쌓이는 것은 어쩔 수 없는 것. 적절한 기술부채를 쌓을 수도 있어야 한다.\n- 언제나 자신만의 기준이 필요하다.\n- 내가 코드를 작성할 때 가장 중요한 것은? : 수정이 용이한 코드. 다른 사람이 읽기 쉬운 코드. 최선의 코드를 위해 적절한 기술부채를 쌓을 줄 알고, 적절한 시점에 기술 부채를 정리할 수 있어야 한다. \n- 테스트 커버리지는 어디까지?\n- 본인이 생각하는 자바를 잘한다는 기준은 무엇인가?\n- 자바를 잘하는 사람이 되기 위해 어떠한 시도를 할 것인가?\n- 미션을 진행하며 위 시도를 하였을 때 본인이 성장하고 있는지 어떻게 측정할 수 있는가?\n## 메타인지\n- 인지에 대한 인지, 생각에 대한 생각\n- 인지: 온갖 사물을 알아보고 기억하며 추리해서 결론을 얻어내고, 그로 인해 생긴 문제를 해결하는 등의 과정\n- 메타인지: 문제를 해결하는 것에 대해 생각하기\n- 메타인지 향상을 위해 내가 무엇을 알고 모르는지 판단. 학습 기록을 남기고 학습 로드맵을 그려보기!\n## 짝 프로그래밍 메타인지\n- 어떻게 하면 불확실성이 높은 현실 세계의 요구사항을 빠르게 반영하고, 유연하게 반응하고, 빠르고, 더 일찍 고객에게 가치를 전달할 수 있을까? -> 더 빠르게, 더 자주, 더 꾸준하게 피드백을 받기 위한 방법 중에 하나로 짝 프로그래밍을 시작한 것\n### 짝 프로그래밍의 장점\n- 버그 감소, 앱을 만들고 통합하는 시간이 감소\n- 디버깅이 잘 됨 -> 문제가 있을 때 상대에게 설명하는 순간 답을 아는 경우가 많아짐\n- 전문가의 암묵지를 효과적으로 배울 수 있는 장점이 있다. -> 단축키 어떻게 하는지, 모르는 버그를 만났을 때 어떻게 구글링하는지, 디버깅은 어떻게 하는지 등\n- 새로운 신입, 주니어 개발자가 오면 시니어와 짝 프로그래밍하는 경우도 많다. 개발 도메인 지식 뿐만 아니라 시니어가 갖고 있는 프로그래밍에 대한 전문성\n- 팀워크 향상: 갈등이 생기는 건 당연하다. 갈등을 더 작은 단위로 빠르게 만나고 빠르고 해소하는 경험을 할 수 있기 때문에 짝 프로그래밍이 팀워크 향상에도 도움이 된다.\n- 짝 용기: 같이 하기 때문에 혼자서 하기 어렵거나 두렵거나, 귀찮은 것들을 같이 해낼 수 있는 용기가 생긴다.\n# 2/15\n## 웹 기초\n### 인터넷이란?\n- 전 세계적으로 연결된 컴퓨터 네트워크\n- 네트워크의 네트워크\n### 웹이란?\n- 월드 와이드 웹 (WWW)\n- 인터넷에 연결된 컴퓨터를 이용해 사람들과 정보를 공유할 수 있는 공간\n### 하이퍼텍스트\n- 하이퍼링크를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트\n- 하이퍼텍스트는 링크에 따라 그 차례가 바뀌는 임의적이면서 나열형인 구조\n### 웹의 기능\n- URL : Uniform Resource Locator\n- HTTP : HyperText Transfer Protocol\n- HTML\n### URI vs URL\n- URI : 통합 자원 식별자. 인터넷에 있는 자원을 나타내는 유일한 주소. URI의 하위 개념으로 URL, URN이 있다.\n- URL : 흔히 웹 사이트 주소로 알고 있지만, URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크상의 자원을 모두 나타낼 수 있다.\n### HTTP\n- 웹 상에서 정보를 주고받을 수 있는 프로토콜\n- 주로 HTML 문서를 주고받는 데에 쓰인다.\n- HTTP는 요청과 응답으로 구성되어 있고, 클라이언트가 요청을 하면 서버가 응답하는 구조로 되어있다.\n- http:// 는 이 프로토콜을 사용해서 정보를 교환하겠다는 표시\n### HTML\n- 웹 페이지의 모습을 기술하기 위한 마크업 언어 (규약)\n- HTML 태그 : HTML을 기술하기 위해 사용하는 명령어의 집합. 여는 태그 + 닫는 태그로 구성되며 닫는 태그 없이 사용하는 태그도 있다. (element, attribute...)\n- ```<!DOCTYPE html>``` : 웹 브라우저가 HTML을 올바르게 표시할 수 있도록 버전 표시\n- p 태그 : 단락/문단을 구분\n- br 태그 : p 태그 없이 강제 개행\n- h# 태그 : 섹션의 제목을 나타내는 태그. 숫자들은 제목의 등급을 나타낸다.\n- a 태그: 하이퍼링크를 걸어주는 태그\n- img 태그: 이미지를 삽입하는 태그\n\n### CSS\n- 마크업 언어가 실제 표시되는 방법을 기술하는 언어\n- 디자인적 요소를 HTML과 분리해보자!\n\n# 2/16\n## 좋은 코드\n- 코드를 줄여쓰지 않는다. 코드 자체로 설명이 되도록 코드를 작성하면 유지 및 관리의 비용이 줄어든다. 주석을 달지 않아도 잘 읽히는 코드가 좋다.\n- 원시값을 포장하면 확실하게 의도를 코드를 통해 전달할 수 있다.\n- 일관된 코드 스타일을 가져야 동료 개발자의 혼동을 줄일 수 있다.\n- 하나의 역할만을 담당하라. 하나의 함수가 많은 일을 하면 추상화 계층이 나빠진다.\n- 추상화 계층: 특정한 집합의 기능의 자세한 부분을 숨기는 한 방법이다. (출처 - 위키백과) 추상화할 부분은 사람마다 다르다.\n- 매개변수를 명확히 해라. 매개변수는 함수를 부르는 곳에서 이해하기 어렵다. \n- 내 생각: 주석은 관리가 힘들기 때문에 최대한 자제하는 것이 좋다. 코드가 변경되었을 때 연관된 주석까지 바꾸기는 힘들기 때문이다.\n- 명확하지 않은 것도 문제가 되지만, 과한 설계도 독이 된다. 정답은 없으니 상황에 맞게 판단하자.\n- 적절한 API를 사용하면 견고한 코드를 작성할 수 있다.\n- 적절한 자료구조를 사용하는 것도 좋다. (중복을 허용하지 않는 set을 쓰는 등)\n- API를 위한 코드는 작성하지 말자. (stream이 주가 되는 경우 등)\n### 예측 가능한 코드\n- 의미있는 값을 반환하라. (값이 존재하지 않으면 -1을 응답하는 등) 차라리 예외를 반환하는 것이 좋을 듯. magic number를 사용하지 않도록 조심하기.\n- 값이 올바르지 않는 경우 외부에서 처리하도록 위임한다.\n- 정답은 없고, 설계를 할 때 문제\n- Collection은 값이 없다면 null이 아닌 빈 Collection으로 작성한다. 객체도 동일하게 Null Object라는 것을 사용한다. 시작되지 않은 위치일 때의 상황도 하나의 객체로 바라보자. \n- 부수효과를 제거하라. 명령과 조회가 같이 존재하지 않도록 하자.\n- 중요한 입력/비즈니스 로직에 대해 무시하지 마라. 아무것도 리턴하지 않는 대신에 사용자가 정보를 알 수 있게 확인하라.\n- 원시값을 포장하면 의도를 전달할 수 있고, 잘못 사용하기 어렵다. 상태가 불변한 경우 상태의 변화에서도 자유로울 수 있다. \n- 변경 가능성을 최소화한다. 매개변수를 변경하며 생길 수 있는 버그와 성능 중 무엇이 더 중요할 지 생각한다.\n- 객체의 값을 외부에 노출할 때 또한 방어적 복사(새로운 객체를 따로 생성하는 등)를 통해 보호해야 한다. 불변 구조(unmodifiableList)를 통해 외부로부터 방어할 수도 있다.\n- 가독성 높은 코드를 작성하기 위해 어떠한 노력을 했는가?: 어떤 메서드에서 다른 메서드를 사용할 때, 해당 메서드가 사용된 위치 바로 밑에 두어 잘 읽힐 수 있도록 코드를 작성했다. 또한 생성자에 들어가는 매개변수를 최대한 줄이기 위해 책임을 여러 클래스로 분산했다. \n- 예측 가능한 코드를 작성하기 위해 어떠한 노력을 했는가?: 최대한 주석을 제외하고, 변수 이름과 메소드 이름으로 동료 개발자가 이해할 수 있도록 노력했다. 사회적으로 통용되는(?) 단어를 사용하려고 노력했다.\n- 실수를 방지하는 코드를 작성하기 위해 어떠한 노력을 해봤는가?: 예외를 꼼꼼하게 처리했다. \n## 좋은 회고란?\n- 나를 돌아보고 다음에 더 개선할 부분이 있는지 생각하기 위해서\n### 감정 회고\n- 감정적으로 소통하는 것\n- 회고를 통해 꼭 구체적인 action plan이 없어도 된다. 감정 공유만으로도 가치가 있다.\n- 좋은 이야기만 할 경우 학습 개선도 행복도 얻기 힘들다. 좋았던 점, 개선할 점, 감정 회고가 적절히 섞여야 한다.\n- 상대방을 진정 위한다면 개선점이나 감정적인 부분에 대해서도 피드백을 해주면 성장하는데 많은 도움이 될 수 있다.\n- 감정을 표현할 때는 상대방이 주어가 되기 보다 '나'를 주어로 하는 문장을 쓴다.\n- 구체적인 행동과 상황을 공유하고 그 순간 느낀 감정에 대해 언급을 하는 것이 중요하다.\n- 큰 변화를 만드는 것이 중요한 것이 아니라 내가 작은 변화로 개선되는 것이 중요하기 때문에 우선순위에 따라 하나씩 개선해나가자.\n- todo 리스트를 작성해보고 시간 날 때 도전해보는 것도 좋다.\n"},{"excerpt":"LOG 세진, 용우를 만났다. 설입에서 잠깐 하이볼 마셨다. 피치 하이볼은 내 스타일은 아니었다. 1단계 merge가 되었다. 숨 돌릴틈도 없이 2단계를 해야 한다. 월요일에는 아마 내내 연극 준비할 거 같아서, 바로 2단계 PR을 보낼 생각이다. 배운 점 getter를 지양하지 않아도 되는 이유를 알게 되었다! 리뷰어 분의 아주 정성들인 리뷰 덕분이다.…","fields":{"slug":"/2023-02-12/"},"frontmatter":{"date":"2023년 02월 12일 09:02","title":"2023년 02월 12일","tags":null},"rawMarkdownBody":"## LOG\n- 세진, 용우를 만났다. 설입에서 잠깐 하이볼 마셨다. 피치 하이볼은 내 스타일은 아니었다.\n- 1단계 merge가 되었다. 숨 돌릴틈도 없이 2단계를 해야 한다. 월요일에는 아마 내내 연극 준비할 거 같아서, 바로 2단계 PR을 보낼 생각이다.\n\n## 배운 점\n- getter를 지양하지 않아도 되는 이유를 알게 되었다! 리뷰어 분의 아주 정성들인 리뷰 덕분이다. 도메인에서 getter로 값을 뽑아낸 후 비즈니스 로직을 수행하는 것은 지양해야 한다. 그러나 미션에서 ```전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다.``` 같은 요구사항이 존재하므로 getter도 비즈니스 로직을 수행한다고 볼 수 있을 것 같다. getter를 지금까지 지양한 이유가 없어졌다..ㅋㅋ\n\n## 느낀 점\n- 내일이 월요일이라니...! 연극을 해야 한다는 게 매우 긴장된다. 대사 까먹지 않고 잘할 수 있었으면 좋겠다. 🥹\n- 오늘 친구들을 만나고 오면서, 새로운 사람들을 대할 때 내 방식대로 하는 게 나을지 아니면 방식을 바꿔보는게 좋을지 생각하게 되었다.\n"},{"excerpt":"LOG 자동차 경주 미션 코드 리뷰가 달렸다! 기대하고 있었는데 굉장히 상세하게 작성해주셨고, 어떤 부분을 고민해야 할 지 꼼꼼히 알려주셔서 많은 도움이 되었다. 연극을 열심히 준비하고 있다. 😎  아무래도 여기서 연극에 진심인 조는 우리 조 밖에 없는 것 같다...ㅋㅋ 배운 것 리뷰 DTO 내부에서 DTO를 사용해도 되는가? : 도메인과 DTO 사이에 …","fields":{"slug":"/2023-02-10/"},"frontmatter":{"date":"2023년 02월 11일 14:02","title":"2023년 02월 10일","tags":null},"rawMarkdownBody":"## LOG\n- 자동차 경주 미션 코드 리뷰가 달렸다! 기대하고 있었는데 굉장히 상세하게 작성해주셨고, 어떤 부분을 고민해야 할 지 꼼꼼히 알려주셔서 많은 도움이 되었다.\n- 연극을 열심히 준비하고 있다. 😎  아무래도 여기서 연극에 진심인 조는 우리 조 밖에 없는 것 같다...ㅋㅋ\n\n## 배운 것\n### 리뷰\n- DTO 내부에서 DTO를 사용해도 되는가? : 도메인과 DTO 사이에 의존이 생기게 되면 DTO 변화에 따라 도메인이 영향을 받게 되어 좋지 않은 설계 같다. 특히 도메인의 변경보다는 View의 변경이 더 빈번한 만큼 DTO의 변경 또한 자주 일어나는데 그럴 때마다 도메인을 신경 써줘야 하므로 생각해보니 확실히 별로인 설계였다.\n- 테스트만을 위한 코드는 필요한가? : 해당 테스트 코드가 내 불안함을 해소하기 위한 것이라면 짤 수도 있다. 다만 jar 파일이 생성될 때 test 패키지 자체가 빠지기도 해서 전혀 사용되지 않는 코드가 덩그러니 남을 수도 있다. 역할과 책임을 분리하고 의존성을 부여하면 좀 더 쉬운 테스트 작성이 가능할 것이다.\n- 코드의 마지막 라인을 비워두는 것이 좋은 이유 : 줄 바꿈이 없으면 파일을 올바르게 처리하지 못하는 프로그램들이 있다. + POSIX에서 줄바꿈이 하나의 행을 정의하는 표준으로 정하고 있다.\n- 인텔리제이에서 메뉴 -> preference -> editor -> general 로 이동 -> Ensure every saved file ends with a line break 옵션 켜면 알아서 파일을 저장할 때마다 개행 문자를 추가해준다.\n- 페어 프로그래밍 : [[pair-programming-rule|좋은 페어 프로그래밍을 위한 규칙들]]\n\n## 궁금한 점\n- 의견을 걸러서 듣는 방법은 무엇일까? 특히 상대방이 나보다 훨씬 많이 알고, 전문가인 경우에 내 의견을 표출하는 방법은 무엇이 있을까?\n\n## 어려웠던 점\n- 별 것 아닌 거에 의미부여하는 것. 좀 더 근본적인 문제가 있는 것 같다.\n\n## 느낀 점\n- 무지성 공감이 별로 좋지 않다는 걸 알게 되었다. 내 주관을 제대로 정립하고 살아가는게 좋겠다는 생각을 했다.\n- 연극 잘할 수 있을까... 남들 앞에서 준비 안 된 채로 서면 말을 금방 까먹는 경향이 있어서 연습을 많이 해야겠다.\n"},{"excerpt":"주관적인 프로그래밍 원칙입니다. 페어와 조율할 예정입니다! 주의 사항 컴퓨터는 정확히 가운데에 두기 (주체, 객체의 형식이면 도움이 안 된다. 서로 수평인 관계, 공동이 주인인 관계를 만든다.) 관계가 비대칭인 경우 (전문가-비전문가), 전문가는 자신의 파워를 낮추고 비전문가에게 질문을 자주해야 한다. 비전문가가 진행할 수 있도록 유도한다. (답답해하기 …","fields":{"slug":"/pair-programming-rule/"},"frontmatter":{"date":"2023년 02월 10일 07:02","title":"페어 프로그래밍 원칙","tags":["개발","우테코"]},"rawMarkdownBody":"*주관적인 프로그래밍 원칙입니다. 페어와 조율할 예정입니다!*\n\n## 주의 사항\n\n1. 컴퓨터는 정확히 가운데에 두기 (주체, 객체의 형식이면 도움이 안 된다. 서로 수평인 관계, 공동이 주인인 관계를 만든다.)\n2. 관계가 비대칭인 경우 (전문가-비전문가), 전문가는 자신의 파워를 낮추고 비전문가에게 질문을 자주해야 한다. 비전문가가 진행할 수 있도록 유도한다. (답답해하기 금지!)\n3. 빈번하게 왔다갔다한다. 알람을 10분 정도로 맞추고, 타자를 다 안 쳤어도 시간이 지나면 바로 페어에게 키보드를 넘긴다.\n4. 키보드를 독점하지 않는다. Driver가 답답하다고 Navigator에게서 키보드를 뺏어가지 않는다.\n5. 페어가 생각할 여지를 남겨두지 않고 지시를 계속하지 않는다. (ex. print문 작성하세요. 새 클래스 만들어야 합니다 등등)\n\n## 역할 정의\n\n- Driver : 키보드를 잡은 사람\n- Navigator : 옆에서 보고 있는 사람\n- Driver는 혼자서 자신의 사고 과정을 중얼거리면서 코딩한다. 의도를 설명하라는게 아니라 중얼거리면서 자신의 생각 과정을 읊는 것이다.\n- Driver는 Navigator가 흥미를 잃지 않도록 항상 자신이 하고 있는 일에 대해 이야기한다.\n- Navigator는 문제 해결 방법을 논리적으로 생각하고, 그 과정을 상대에게 말로 설명하는 역할이다. Navigator가 Driver의 잘못된 부분을 발견한 경우 바로 지적하지 않고 5초 정도 잠깐 기다린다.\n"},{"excerpt":"AssertJ의 공식 문서를 정리한 문서이다. 공식 문서 사이트 @assertThatCode testing that no exception is thrown 어떤 exception도 던지지 않는 코드를 테스트할 수 있다. 비슷하게 사용하기 나는 주로 아래 방법을 사용한다.","fields":{"slug":"/assertj/"},"frontmatter":{"date":"2023년 02월 10일 05:02","title":"AssertJ","tags":["assertj","test","개발"]},"rawMarkdownBody":"* AssertJ의 공식 문서를 정리한 문서이다.\n* [공식 문서 사이트](https://assertj.github.io/doc/#assertj-core)\n\n## @assertThatCode\n- testing that no exception is thrown\n- 어떤 exception도 던지지 않는 코드를 테스트할 수 있다.\n```\n// standard style\nassertThatNoException().isThrownBy(() -> System.out.println(\"OK\"));\n// BDD style\nthenNoException().isThrownBy(() -> System.out.println(\"OK\"));\n```\n\n- 비슷하게 사용하기\n```\n// standard style\nassertThatCode(() -> System.out.println(\"OK\")).doesNotThrowAnyException();\n// BDD style\nthenCode(() -> System.out.println(\"OK\")).doesNotThrowAnyException();\n```\n나는 주로 아래 방법을 사용한다.\n"},{"excerpt":"assertj","fields":{"slug":"/test/"},"frontmatter":{"date":"2023년 02월 10일 05:02","title":"Test 정리","tags":["개발","test","assertj"]},"rawMarkdownBody":"\n* [[assertj]]"},{"excerpt":"LOG 자동차 경주 미션을 빠르게 제출했다. 1시간 정도 빨리 제출했는데 페어 프로그래밍이라 그런가 정신력이 좀 더 빠르게 소모된 것 같다. 리뷰가 어떻게 달릴지 궁금하다. 단축키를 많이 기억했다. 몇몇 단축키는 외운 것 같다! 지하철 타고 가면서 객체지향의 사실과 오해를 읽었다. 20% 읽긴 했는데 중간 중간 집중이 안 되는 부분이 있었다. 요즘 책을 …","fields":{"slug":"/2023-02-09/"},"frontmatter":{"date":"2023년 02월 09일 08:02","title":"2023년 02월 09일","tags":null},"rawMarkdownBody":"## LOG\n- 자동차 경주 미션을 빠르게 제출했다. 1시간 정도 빨리 제출했는데 페어 프로그래밍이라 그런가 정신력이 좀 더 빠르게 소모된 것 같다. 리뷰가 어떻게 달릴지 궁금하다. \n- 단축키를 많이 기억했다. 몇몇 단축키는 외운 것 같다!\n- 지하철 타고 가면서 객체지향의 사실과 오해를 읽었다. 20% 읽긴 했는데 중간 중간 집중이 안 되는 부분이 있었다. 요즘 책을 안 읽다 보니 집중력이 떨어진 것 같다. 의도적으로 책을 읽자.\n- 연극에서 조보아씨 역할을 맡게 되었다. 어쩌면 진짜 찰떡인 배역이었을지도?\n\n## 배운 것\n### Test\n- assertThat(list).hasSize(크기)를 사용해서 리스트의 크기를 확인할 수 있다.\n- @MethodSource를 사용하면 리스트를 입력으로 사용할 수 있다.\n- assertThatCode().doesNotThrowAnyException 을 사용하면 정상 작동을 테스트할 수 있다.\n- View를 인터페이스로 구현하면 MockView를 만들기 쉽다.\n- private 생성자를 사용해서 싱글턴을 유지할 수 있다. 싱글턴은 안티패턴이라던데 이렇게 써도 되는지 의문이긴 하다.\n\n## 궁금한 점\n- 코드의 마지막 라인은 비워두는게 좋다고 하는데 왜일까?\n- getter를 무조건 지양하는 게 맞는 설계일까?\n- DTO 내부에서 DTO를 써도 될까?\n- 한 줄로 축약해서 코드를 작성해도 괜찮을까?\n- 테스트만을 위한 메서드가 존재해도 괜찮을까?\n\n## 어려웠던 점\n- 부정적인 생각 덜 하기. 한 번 부정적인 생각이 들면 꼬리에 꼬리를 무는 것 같다.\n- 눈치 덜 보기. 하고 싶은 대로 살기. 머뭇거리지 않기.\n\n## 느낀 점\n- 굉장히 피곤한 하루였다. 아침에도 조금 피곤했는데 회의하느라 집에 늦게 도착해서 많이 피곤하다. TIL을 대강 쓰고 자려고 한다.\n- 이번 미션이 제일 쉬운 거였을텐데 이렇게 힘들어서는 곤란하지 않을까.\n- 사회성이 좀 떨어지나 싶다. 지금 상태가 그렇게 좋지 않은 것도 한 몫하는 것 같다. 지금이 좀 심하다 싶을 정도인 것 같다... 너무 스트레스 받지 않을 정도만 하자.\n"},{"excerpt":"2/9 assertj assertThatCode assertj assertThatThrown DTO 내부에 DTO 로직을 사용해도 되는가? 도메인 객체의 getter는 무조건 나쁜 것인가? View 클래스를 인터페이스로 작성하는 이유 - MockView를 만들기 위해 모든 컬렉션은 일급 컬렉션이 되어야 하는가? 3/17 스레드 풀 Concurrent Co…","fields":{"slug":"/inbox/"},"frontmatter":{"date":"2023년 02월 09일 06:02","title":"Inbox","tags":["임시"]},"rawMarkdownBody":"## 2/9\n- assertj assertThatCode\n- assertj assertThatThrown\n- DTO 내부에 DTO 로직을 사용해도 되는가?\n- 도메인 객체의 getter는 무조건 나쁜 것인가?\n- View 클래스를 인터페이스로 작성하는 이유 - MockView를 만들기 위해\n- 모든 컬렉션은 일급 컬렉션이 되어야 하는가?\n\n## 3/17\n- 스레드 풀\n- Concurrent Collection\n\n## 3/19\n- 바이너리 호환성, 소스 호환성, 동작 호환성 (모던 자바 416p)"},{"excerpt":"차례대로 보지 않을 예정이라 순서대로 쓰지 않는다. Item 1. 생성자 대신 정적 팩토리 메서드를 고려하라 정적 팩토리 메서드: 클래스의 인스턴스를 반환하는 단순한 정적 메서드 장점 이름을 가질 수 있어 반환될 객체의 특정을 쉽게 묘사할 수 있다. 시그니처가 같은 생성자가 여러 개 필요할 것 같을 때 생성자를 정적 팩토리 메서드로 변경하고 차이를 잘 드…","fields":{"slug":"/effective-java-ed3/"},"frontmatter":{"date":"2023년 02월 09일 00:02","title":"Effective Java 3/E","tags":["책"]},"rawMarkdownBody":"차례대로 보지 않을 예정이라 순서대로 쓰지 않는다.\n\n## Item 1. 생성자 대신 정적 팩토리 메서드를 고려하라\n- 정적 팩토리 메서드: 클래스의 인스턴스를 반환하는 단순한 정적 메서드\n- 장점\n\t1. 이름을 가질 수 있어 반환될 객체의 특정을 쉽게 묘사할 수 있다. 시그니처가 같은 생성자가 여러 개 필요할 것 같을 때 생성자를 정적 팩토리 메서드로 변경하고 차이를 잘 드러내는 이름을 지어주는 것이 좋다.\n\t2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 불변 클래스의 경우 인스턴스를 미리 만들거나 새로 생성한 인스턴스를 캐싱하여 활용하는 식으로 불필요한 객체 생성을 막을 수 있다.\n\t\t- 인스턴스 통제 클래스: 반복되는 요청에 같은 객체를 반환하는 식으로 인스턴스를 통제할 수 있다. 인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가한 클래스로 만들 수도 있다. 또한 동치인 인스턴스가 단 하나뿐임을 보장 가능하다.\n\t3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 반환할 객체의 클래스를 자유롭게 선택할 수 있게 한다.\n\t4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관 없다.\n\t5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.\n- 단점\n\t1. \n## Item 71.  필요 없는 검사 예외 사용은 피하라\n- 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게 해준다. (과하게 사용하면 쓰기 불편한 API가 된다. 호출하는 쪽에서 try catch로 처리하거나 바깥으로 던져 전파해야 하므로 부담을 준다.)\n- 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없어서 자바 8부터는 부담이 커졌다.\n- API를 제대로 사용해도 발생할 수 있는 예외이거나 프로그래머가 의미 있는 조치를 취할 수 있는 경우는 받아들일 수 있다. 그러나 둘 중 어디에도 해당되지 않는다면 비검사 예외를 사용하는 것이 좋다.\n- 검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 가장 크다.\n- 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 Optional을 반환하는 것이다. 대신 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.\n"},{"excerpt":"Java 이펙티브 자바","fields":{"slug":"/programming-book/"},"frontmatter":{"date":"2023년 02월 09일 00:02","title":"개발 책","tags":["개발","책"]},"rawMarkdownBody":"\n## Java\n\n- [[effective-java-ed3|이펙티브 자바]]\n"},{"excerpt":"LOG 연극 주제를 정했다. 주제 정하는게 많이 고민이었는데 순조롭게 잘 되어서 다행이다. 6시 40분에 일어났더니 9시에 도착했다. 언제 일어나는 게 좋을지... 좀 더 고민해봐야겠다. 그래도 지각하면 안 되니 아무리 늦어도 7시 10분에는 일어나야 할 것 같다. 아직 vim이 어렵다. vim 매크로 때문에 옵시디언 대신 vim으로 필기 중인데 여전히 …","fields":{"slug":"/2023-02-08/"},"frontmatter":{"date":"2023년 02월 08일 12:02","title":"2023년 02월 08일","tags":null},"rawMarkdownBody":"## LOG\n- 연극 주제를 정했다. 주제 정하는게 많이 고민이었는데 순조롭게 잘 되어서 다행이다. 6시 40분에 일어났더니 9시에 도착했다. 언제 일어나는 게 좋을지... 좀 더 고민해봐야겠다. 그래도 지각하면 안 되니 아무리 늦어도 7시 10분에는 일어나야 할 것 같다.\n- 아직 vim이 어렵다. vim 매크로 때문에 옵시디언 대신 vim으로 필기 중인데 여전히 단축키가 어렵다. 한 번에 기억을 못하니 아직도 버벅거린다. 아침에 단축키 외우는 것도 좋을지도\n- 오는 길의 지하철이 매우 덥다. 내일은 옷을 따로 챙겨가야 할 것 같다. 사람이 많고 비좁다 보니까 더 그런 것 같다.\n- TDD로 미션 구현해 봤다. 오히려 구현하는 시간은 더 오래 걸릴지도 모르겠다. 그래도 신선한 경험이었다.\n- 우형에 붙게 된다면 한 학기 기다려준다고 한다. 남은 학점을 계산해보니 캡스톤 포함 20학점이다. 쉽지 않다...\n\n## 배운 것\n### 단축키\n- 오늘도 글렌에게 단축키를 배웠다. 근데 배워도 까먹는다... 쓰다 보니 몇 개 기억이 안 나는게 슬프다ㅠ\n- command + alt + m : 메서드 추출\n- iter : 향상된 for 문\n- fori : 일반 for 문\n- command + shift + t : 테스트 클래스 생성 (자동으로 해당 패키지까지 고려해서 만들어준다. 신기)\n### Test\n- @CsvSource : 문자열로 입력값, 정답을 함께 입력하여 사용하였다. 주로 @ParameterizedTest와 함께 쓰이는 듯 하다. delimeter로 구분자를 지정할 수 있다. 테스트 메서드의 매개변수를 int, boolean 같은 형으로 지정하면 해당 문자열을 알아서 변환해준다.\n- @BeforeEach : Test를 시작하기 전에 각 테스트 메서드마다 실행된다.\n\n## 어려웠던 점\n- 마음 편하게 먹기. 쉬워보였는데 쉽지 않다.\n- 긍정적으로 생각하기.\n\n## 궁금한 점\n- 구조를 다 생각하고 나서 개발하는 게 좋을까? 아니면 뼈대만 세워두고 개발하면서 차근차근 세우는게 나을까? 쓰고 나니 waterfall과 agile 같기도 하다.\n\n## 느낀 점\n- 다들 잘하는 것 같다. 특히 글렌은 아는게 정말 많다! 페어 프로그래밍 하면서 많이 배운다.\n- TDD 해보고 싶다고만 했지 해본적은 없었는데 의외로 괜찮은 개발 방식인 것 같다.\n- 페어 프로그래밍 힘들긴 한데 내 의견을 설득시켰을 때 좋은 것 같다.\n\n## 내일 할 일\n- 방금 알았는데 브랜치 이름이 깃허브 아이디여야 하는데 racing_car 브랜치에서 작업했다. 글렌한테 알려줘야 할 것  같다.\n- 내일 TIL 쓰기.\n- 밝은 표정과 긍정적인 마인드, 가벼운 마음가짐 갖고 살아보기\n"},{"excerpt":"2/8 단위 테스트 동작 확인을 위해 테스트 메서드를 테스트할 때 잘못된 로직의 메서드는 어떻게 검증할까? -> 실패하는 테스트 먼저 만들기 테스트를 만들기 전에 검증하고자 하는 메서드가 어떤 기능인지, 어떤 상황에서 문제가 될 수 있을지를 고민해본다. 경계값을 잘 찾아본다. 경계값 찾기 : 내가 검증하고자 하는 값의 끝단을 찾는다. 단위 테스트가 있다고…","fields":{"slug":"/onboarding-week1/"},"frontmatter":{"date":"2023년 02월 08일 01:02","title":"온보딩 1주차","tags":null},"rawMarkdownBody":"## 2/8\n### 단위 테스트\n- 동작 확인을 위해 테스트\n- 메서드를 테스트할 때 잘못된 로직의 메서드는 어떻게 검증할까? -> 실패하는 테스트 먼저 만들기\n- 테스트를 만들기 전에 검증하고자 하는 메서드가 어떤 기능인지, 어떤 상황에서 문제가 될 수 있을지를 고민해본다. 경계값을 잘 찾아본다.\n- 경계값 찾기 : 내가 검증하고자 하는 값의 끝단을 찾는다.\n- 단위 테스트가 있다고 모든 경우를 테스트할 수 있는 것도 아니다. 어느 선까지 테스트를 할 것인지 기준을 정해보자.\n- 나의 테스트 기준 : 내가 처한 상황에서 구문이 제대로 동작한다는 확신이 들 때까지!\n- 내가 단위 테스트를 작성하는 이유 : 여러 가지 케이스를 편리하게 실행시킬 수 있어서\n- 내가 작성한 좋은 단위 테스트는 어떤 부분에서 좋은 단위 테스트였을까? : 여러 가지 테스트 케이스를 생각해볼 수 있고, 빼놓은 케이스가 있는지 확인해볼 수 있었다.\n- 좋은 단위 테스트를 작성하기 위해 어떠한 시도를 해볼 수 있는가? : 단위 테스트의 단위, 로직 검증은 어떻게 할 수 있을지, 읽기 쉬운 코드인지, 경계값이 포함된 케이스가 있는지 확인하기. 로직이 좋은 코드로 되어 있어서 테스트 코드를 작성하기 쉬운가? \n- [private 메서드의 코드는 어떻게 테스트할 수 있을까?](https://yearnlune.github.io/java/java-private-method-test/#)\n\n### 코드 품질\n- 코드는 잘 동작해야 한다. 코드에 매몰되어 놓치지 않아야 한다.\n- 코드는 읽기 쉬워야 한다. 의도를 드러내고 유지보수하기 좋은 것은 매우 중요하다. 미래의 나를 위해 예쁘게 짜자.\n- 코드는 보기 좋아야 한다. 심미성의 부분. 컨벤션이나 들여쓰기, 줄바꿈 등인 듯하다.\n- 코드는 관리하기 쉬워야 한다. 아무리 잘 작성해도 예상과 다르게 동작할 수 있다. 개발 이후가 가장 중요하고, 2,3차 사용자들이 관여하는 점에서 매우 중요한 항목이다. 계속 유지보수 되어야 한다.\n- 코드는 테스트 가능해야 한다. 자동화 테스트가 가능해야 하고, 설계 의도에 맞게 올바르게 동작하는지 확인한다.\n- 코드는 변경하기 쉬워야 한다. 기능의 변경, 확장, 재사용은 매우 빈번하다. 최소한의 노력으로 변경 가능해야 하며, 부작용은 최소화해야 한다.\n- 코드는 효율적으로 동작해야 한다. 코드의 동작이 아닌 산업적인 관점에서 효율적인 것이 중요하다. 최소의 개발 리소스를 투입하여 결과물이 나올 수 있어야 한다. (인적 리소스 포함)\n- 좋은 코드는 한 순간에 만들어지지 않는다.\n\n### 최소한의 안전장치\n1. 하고자 하는 내용을 README에 정리한다.\n2. 함께하는 팀원, 크루에게 먼저 의도를 드러내면서 의사소통한다.\n3. 구조를 잡고 시작한다. 머리 속에 그려지는 내용에 대한 구조를 잡는다.\n4. 매번 최선으로 작성할 수는 없겠지만, 일관성 있게 작성한다.\n5. 여러 상황을 고려하여 최적의 코드를 작성한다.\n\n## 2/9\n[[../private/wooteco-secret|들었던 공지사항]]\n### 요구사항 정리하기\n- 자동차는 전진하거나 / 멈출 수 있다.\n- 자동차는 이름이 있다.\n- 자동차 이름은 5자 이하만 가능하다.\n- 자동차는 n번 이동이 가능하다.\n- 자동차가 전진하는 조건은 0부터 9 사이다. \n- 자동차의 전진 조건은 랜덤으로 정해진다.\n- 자동차는 4 이상일 경우 전진한다.\n- 자동차는 3 이하일 경우 멈춘다.\n- 자동차 경주 게임은 완료 후 우승자를 구할 수 있다.\n- 자동차 경주 게임의 우승자는 한 명 이상일 수 있다.\n\n요구 사항은 따로 정하지는 않았는데, 이런 식으로 객체의 역할을 분리해보는 방식도 좋은 것 같다.\n\n### 테스트만을 위한 코드는 어떤가?\n- 잘 생각해봐야 한다. 정말로 테스트만을 위한 코드인지 생각해본다. 내가 설계한 프로그램에서 어색한 부분을 맡지는 않는가?\n\n\n"},{"excerpt":"LOG 우테코 OT가 있었다. 아침에 일찍 나왔다고 생각했는데 지하철도 늦게 오고 하다보니.. 늦었다 ㅠ 11층에서 내려서 계단으로 가려고 했는데 계단이 안 열려서 더 늦었다. 다음부터는 그냥 14층으로 가는 엘리베이터를 타야겠다. 내일은 9시 45분까지 가야해서 6시 50분에는 일어나야 할 판이다. 글렌, 토리, 체인저, 망고, 포이와 온보딩 팀이 되었…","fields":{"slug":"/2023-02-07/"},"frontmatter":{"date":"2023년 02월 07일 09:02","title":"2023년 02월 07일","tags":null},"rawMarkdownBody":"## LOG\n* 우테코 OT가 있었다. 아침에 일찍 나왔다고 생각했는데 지하철도 늦게 오고 하다보니.. 늦었다 ㅠ 11층에서 내려서 계단으로 가려고 했는데 계단이 안 열려서 더 늦었다. 다음부터는 그냥 14층으로 가는 엘리베이터를 타야겠다. 내일은 9시 45분까지 가야해서 6시 50분에는 일어나야 할 판이다.\n* 글렌, 토리, 체인저, 망고, 포이와 온보딩 팀이 되었다. 연극이 굉장히 두렵다. \n* 오늘은 출석을 안 해서 다행이었다. OT라 설명만 할 줄 알았는데 페어 프로그래밍을 시작했다. 글렌과 자동차 경주 미션 페어가 되었다. 오늘 해야 하는 분량은 난이도가 높지 않아서 마무리할 수 있었다.\n  \n## 배운 것\n* 글렌이 인텔리제이 단축키나 템플릿을 많이 알려줬다. 단축키 잘 못 외우는데 이번에 꽤 신기한 것들을 배웠다.\n * command + alt + v : 변수 추출 (선언 뒷부분만 쓰면 알아서 변수 이름을 만들어준다!)\n * command + e : 이전 문서로 이동\n * control + shift + r : 실행\n * 테스트 코드 템플릿 만들어 둔 거 신기했다.\n * given, when, then : given은 주어진 것 (값 같은거?), when은 어떤 것을 했는지, then은 확인해야 하는 것. 주관적으로 해석했는데 맞는지는 모르겠다.\n\n## 어려웠던 점\n* 새로운 사람들과 만난게 그렇게 오래되지도 않은 것 같은데 쉽지 않았다. 그래도 다들 좋은 사람들이라 슬쩍 끼어서 이야기할 수 있었다.\n* 모르는 사이에서 대화 주제를 생각해내는게 여전히 어려운 것 같다.\n\n## 느낀 점\n* 다양한 사람들이 있는 것 같았다. 팀원분들 나이는 안 물어보는게 불문율인 것 같아서 여쭤보지 않았다.\n* 그래도 인간 관계에 스트레스 받지는 말자. 너무 깊게 생각하지 않는게 중요하다. 조급하게 생각하지 말고 좀 마음을 편하게 먹어야겠다.\n\n## 내일 해야 하는 것\n* 연극 주제 정하기\n"},{"excerpt":"교육 과정 프로그래밍 코스 레벨1 : 간단한 언어 - 이번주부터 8주간 레벨1 레벨2부터 스프링 진행 레벨3 유지보수 경험 레벨5는 4주. 취업 준비 기간 레벨 시작은 화요일부터 레벨 1 방학기간 : 3/31 ~ 4/10 방학 기간 중 캠퍼스는 열지 않음 레벨3 팀프로젝트는 과정을 섞어서 진행 (캠퍼스도 섞을 예정 - 몇 주 간격) 글쓰기 각 레벨별 글쓰…","fields":{"slug":"/wooteco-ot/"},"frontmatter":{"date":"2023년 02월 07일 01:02","title":"우아한테크코스 OT","tags":["우테코"]},"rawMarkdownBody":"\n## 교육 과정\n\n### 프로그래밍 코스\n\n* 레벨1 : 간단한 언어 - 이번주부터 8주간 레벨1\n* 레벨2부터 스프링 진행\n* 레벨3 유지보수 경험\n* 레벨5는 4주. 취업 준비 기간\n* 레벨 시작은 화요일부터\n* 레벨 1 방학기간 : 3/31 ~ 4/10\n* 방학 기간 중 캠퍼스는 열지 않음\n* 레벨3 팀프로젝트는 과정을 섞어서 진행 (캠퍼스도 섞을 예정 - 몇 주 간격)\n\n### 글쓰기\n\n* 각 레벨별 글쓰기 한 편씩\n* 리뷰 요청, 회의록 작성 등 많은 글쓰기 경험\n* 장문의 글쓰기\n\n### 말하기\n\n* 10분 내외로 발표하는 테코톡 - 10개월 전까지 반드시 발표해야 함. 수료 조건\n* 각 레벨별 학습 내용을 점검하는 레벨 인터뷰\n* 데일리 미팅, 짝 프로그래밍, 팀 프로젝트\n* 관심 주제로 이야기하는 것은 어렵지 않을 것\n\n## 생활 가이드\n\n* 지각 3회당 결석 1회로 간주\n* 전체 과정 중 3번 이상 무단결석 시 퇴소\n* 조퇴가 불가피할 경우 최소 3일 전에 공유\n* 캠퍼스 시간 : am 8:00 ~ pm 11:00\n\n## 온보딩 미션\n\n* 프로그래밍과 관련된 주제로 연극\n* 사람들이 보고 싶게, 듣고 싶게 구성\n* 최대 6명이 한 팀 - 4~5분\n* 무대에 모두가 나올 수 있게 역할 부여\n* 사람들의 기억에 남을 유행어를 만들고 사용\n\n## 데일리 미팅\n\n* 하루 시작 전 20분\n* 하루를 시작하는 현재 감정 공유 등\n* 어려움이 있으면 이야기하기\n* Done / to do / problem\n\n## 추천 도서\n\n* 좋은 코드, 나쁜 코드 - 레벨1 끝나고 읽는 것 추천\n* SQL 첫걸음 - 4장까지 읽는 것 추천\n* 본인이 부족하다 생각하는 부분이 있으면 읽기\n\n## KDT\n\n* 개강일은 내일. 내일부터 출결 신경쓰기\n* 훈련 장려금은 월 최대 31만 6천원 지급 (출석률 80% 이상이어야 받을 수 있음)\n  * 2/8 ~ 3/7 같이 단위 기간 형성\n* 출결은 공휴일 / 방학기간 제외. 출결 시간은 우테코에 있는 시간과 동일\n  * 10시 이전에 한 번, 18시 이후에 한 번 각자 체크\n* 불가피하게 출석하기 힘든 경우 리사에게 공지 - 꼭 전날까지 말하기\n* 2/8 9시 45분에 Zoom에 접속\n"},{"excerpt":"온보딩 우테코-OT 온보딩 1주차 레벨1 레벨1 2주차 레벨1 3주차 레벨1 4주차 레벨1 5주차 레벨1 6주차 레벨1 미션들 자동차 경주 사다리 게임 블랙잭 블랙잭 미션에서 고민한 것들 체스 체스 미션 기록 레벨1 학습로그 default-method singleton-vs-static functional-interface 레벨1에서 한 것들 why-re…","fields":{"slug":"/wooteco/"},"frontmatter":{"date":"2023년 02월 07일 01:02","title":"우아한테크코스","tags":["우테코"]},"rawMarkdownBody":"## 온보딩\n\n* [[wooteco-OT|우테코-OT]]\n* [[onboarding-week1|온보딩 1주차]]\n\n## 레벨1\n\n* [[level1-week2|레벨1 2주차]]\n* [[level1-week3|레벨1 3주차]]\n* [[level1-week4|레벨1 4주차]]\n* [[level1-week5|레벨1 5주차]]\n* [[level1-week6|레벨1 6주차]]\n\n### 레벨1 미션들\n\n* [자동차 경주](https://github.com/Cyma-s/java-racingcar)\n* [사다리 게임](https://github.com/Cyma-s/java-ladder)\n* [블랙잭](https://github.com/Cyma-s/java-blackjack)\n  * [[level1-blackjack|블랙잭 미션에서 고민한 것들]]\n* [체스](https://github.com/Cyma-s/java-chess)\n  * [[level1-chess|체스 미션 기록]]\n\n### 레벨1 학습로그\n\n* [[default-method]]\n* [[singleton-vs-static]]\n* [[functional-interface]]\n\n### 레벨1에서 한 것들\n\n- [[why-return-type-of-add-function-is-boolean]]\n- [[level1-level-log|레벨1 레벨인터뷰]]\n- [[vepohuhyemal-study|베포후헤 스터디]]\n\n## 레벨2\n\n- [[level2-week1]]\n- [[level2-week2]]\n- [[level2-week3]]\n- [[level2-week4]]\n- [[level2-week5]]\n- [[level2-week6]]\n- [[level2-seventh-retrospect]]\n- [[level2-cart]]\n- [[level2-subway]]\n- [[level2-shopping-order]]\n- [[level2-review-mosquito]]\n- [[level2-writing]]\n\n## 레벨3\n\n## 레벨4\n\n## 레벨5\n"},{"excerpt":"2023-02-06 2023-02-07 2023-02-08 2023-02-09 2023-02-10 2023-02-12 2023-02-15 2023-02-16 2023-02-17 2023-02-20 2023-02-21 2023-02-22 2023-02-23 2023-02-24 2023-02-26 2023-02-27 2023-02-28","fields":{"slug":"/2023-02/"},"frontmatter":{"date":"2023년 02월 06일 14:02","title":"2023년 02월","tags":["TIL"]},"rawMarkdownBody":"- [[2023-02-06]]\n- [[2023-02-07]]\n- [[2023-02-08]]\n- [[2023-02-09]]\n- [[2023-02-10]]\n- [[2023-02-12]]\n- [[2023-02-15]]\n- [[2023-02-16]]\n- [[2023-02-17]]\n- [[2023-02-20]]\n- [[2023-02-21]]\n- [[2023-02-22]]\n- [[2023-02-23]]\n- [[2023-02-24]]\n- [[2023-02-26]]\n- [[2023-02-27]]\n- [[2023-02-28]]\n"},{"excerpt":"2023년 1분기 2023-02 2023-03 2023년 2분기 2023-04 2023-05 2023-06 2023년 3분기 2023-07 2023-08 2023-09 2023년 4분기 2023-10 2023-11 2023-12","fields":{"slug":"/2023/"},"frontmatter":{"date":"2023년 02월 06일 14:02","title":"2023년","tags":null},"rawMarkdownBody":"# 2023년 1분기\n* [[2023-02]]\n* [[2023-03]]\n\n# 2023년 2분기\n* [[2023-04]]\n* [[2023-05]]\n* [[2023-06]]\n\n# 2023년 3분기\n- [[2023-07]]\n- [[2023-08]]\n- [[2023-09]]\n\n# 2023년 4분기\n- [[2023-10]]\n- [[2023-11]]\n- [[2023-12]]\n"},{"excerpt":"TIL TIL을 하기로 했다. 블로그 시작을 하게 된 이유가 TIL이었으니 얼른 개시해야지.\n시작하게 된 이유는 우테코 때문이다. 10개월의 긴 시간 동안 기록 없이는 너무 허망하게 시간이 흘러갈 것 같아서. 실제로 그런 적도 많기도 했고 말이다.\n또 다른 목적은 나를 사랑해보기 위해서이다. 계속되는 실패(진짜 실패일지, 내 머릿속으로만 그렇게 생각하는 …","fields":{"slug":"/2023-02-06/"},"frontmatter":{"date":"2023년 02월 06일 13:02","title":"2023년 02월 06일","tags":null},"rawMarkdownBody":"\n## TIL\nTIL을 하기로 했다. 블로그 시작을 하게 된 이유가 TIL이었으니 얼른 개시해야지.\n시작하게 된 이유는 우테코 때문이다. 10개월의 긴 시간 동안 기록 없이는 너무 허망하게 시간이 흘러갈 것 같아서. 실제로 그런 적도 많기도 했고 말이다.\n또 다른 목적은 나를 사랑해보기 위해서이다. 계속되는 실패(진짜 실패일지, 내 머릿속으로만 그렇게 생각하는 건지도 모르겠다) 때문에 나를 온전히 보기 쉽지 않다. 차라리 진짜 객관적인 문서로 남겨서 내가 지금 어떻게 살고 있는지 내가 봤으면 좋겠다는 생각이다. 최대한 꾸준히 쓰고 싶다.\n말이 TIL이지 배운것이 추가된 일일 회고 느낌으로 쓸 것 같다. 템플릿을 만들려다 포기했다. 글을 쓸 때 채우지 못하는 부분이 있으면 자괴감을 느낄 것 같아서 자유 형식으로 쓰려 한다. 익숙해지면 템플릿을 만들어야겠다.\n\n## 우아한테크코스\n사실 조금 걱정이 된다. 지금 마음가짐이 어떤지 모르겠다. 의욕도, 목적도, 목표도 모호한 상태라 그냥 잘 모르겠다. 우테코에서 찾을 수 있지 않을까라는 안일한 마음가짐으로 내일 등교(?)할 예정이다.\n내 마음대로 안 되는 상황에 스트레스를 받는 편인데, 과연 우아한테크코스가 나에게 어떤 영향을 끼칠지 궁금하다. 기왕이면 좋은 영향이었으면 좋겠다.\n\n## 고민\n최근 상담에서도 이야기했었지만 하나가 어느정도 해결되니 다른 하나가 드러나서 쉽지 않다. 생각할수록 생각이 많아진다. 그래서인지 나태해진 것 같다. 우테코에서 자극을 받을 수 있을지...\n이런 이야기는 많이 쓸수록 어두워지니까 그만해야겠다.\n"},{"excerpt":"개발 개발 책 짧은 개발 지식 shook TIL 2023 우테코","fields":{"slug":"/wiki-index/"},"frontmatter":{"date":"2023년 01월 30일 16:01","title":"Wiki Index","tags":null},"rawMarkdownBody":"\n## 개발\n\n  * [[programming-book|개발 책]]\n  * [[short-programming-knowledge|짧은 개발 지식]]\n  * [[shook]]\n  \n## TIL\n\n  * [[2023]]\n  * [[wooteco|우테코]]\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}