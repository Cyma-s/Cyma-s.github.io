/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FontsourcePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian3 = require("obsidian");

// src/modal.ts
var import_obsidian2 = require("obsidian");

// src/import.ts
var import_obsidian = require("obsidian");

// node_modules/.pnpm/@fontsource-utils+generate@0.4.0/node_modules/@fontsource-utils/generate/dist/index.mjs
var getVariableWght = (axes) => {
  if (!axes)
    return "400";
  if (axes.min === axes.max)
    return `${axes.min}`;
  return `${axes.min} ${axes.max}`;
};
var generateFontFace = (font) => {
  const {
    family,
    style,
    display,
    weight,
    variable,
    src,
    unicodeRange,
    comment,
    spacer = "\n  "
  } = font;
  const { wght, stretch, slnt } = variable != null ? variable : {};
  let result = "@font-face {";
  result += `${spacer}font-family: '${family}';`;
  result += `${spacer}font-style: ${slnt ? `oblique ${Number(slnt.max) * -1}deg ${Number(slnt.min) * -1}deg` : style};`;
  result += `${spacer}font-display: ${display};`;
  result += `${spacer}font-weight: ${wght ? getVariableWght(wght) : weight};`;
  if (stretch)
    result += `${spacer}font-stretch: ${stretch.min}% ${stretch.max}%;`;
  result += `${spacer}src: ${src.map(({ url, format }) => `url(${url}) format('${format}')`).join(", ")};`;
  if (unicodeRange)
    result += `${spacer}unicode-range: ${unicodeRange};`;
  if (comment)
    result = `/* ${comment} */
${result}`;
  return `${result}
}`;
};

// src/css.ts
var generateCss = (metadata) => {
  let css = "";
  let subsets = Object.keys(metadata.unicodeRange);
  if (subsets.length === 0) {
    subsets = metadata.subsets;
  }
  if (metadata.variable) {
    for (const style of metadata.styles) {
      for (const subset of subsets) {
        const font = {
          family: metadata.family,
          style,
          weight: 400,
          display: "auto",
          src: [
            {
              url: `data:font/woff2;base64,${metadata.base64[`${subset}-${style}`]}`,
              format: "woff2-variations"
            }
          ],
          unicodeRange: metadata.unicodeRange[subset],
          variable: {
            wght: metadata.variable.wght,
            stretch: metadata.variable.stretch,
            slnt: metadata.variable.slnt
          },
          comment: `${metadata.id}-variable-${style}`
        };
        css += generateFontFace(font);
      }
    }
  } else {
    for (const style of metadata.styles) {
      for (const weight of metadata.weights) {
        for (const subset of subsets) {
          const font = {
            family: metadata.family,
            style,
            display: "auto",
            weight,
            src: [
              {
                url: `data:font/woff2;base64,${metadata.base64[`${subset}-${weight}-${style}`]}`,
                format: "woff2"
              }
            ],
            unicodeRange: metadata.unicodeRange[subset],
            comment: `${metadata.id}-${weight}-${style}`
          };
          css += generateFontFace(font);
        }
      }
    }
  }
  return css;
};
var applyCss = async (id, plugin) => {
  const existing = document.getElementById(`fontsource-${id}`);
  const css = await plugin.app.vault.adapter.read(
    `${plugin.app.vault.configDir}/fonts/${id}.css`
  );
  if (existing) {
    existing.replaceWith(css);
  } else {
    const style = document.createElement("style");
    style.id = `fontsource-${id}`;
    style.textContent = css;
    document.head.appendChild(style);
  }
};
var removeCss = (id) => {
  const existing = document.getElementById(`fontsource-${id}`);
  if (existing) {
    existing.remove();
  }
};
var extractFontFamilies = (fonts) => fonts.sort((a, b) => {
  if (a.precedence === b.precedence) {
    return a.family.localeCompare(b.family);
  }
  return a.precedence - b.precedence;
}).map((font) => `'${font.family}'`).join(", ");
var updateCssVariables = (plugin) => {
  const id = "fontsource-css-variables";
  const { interfaceFonts, textFonts, monospaceFonts } = plugin.settings;
  const interfaceFont = extractFontFamilies(interfaceFonts);
  const textFont = extractFontFamilies(textFonts);
  const monospaceFont = extractFontFamilies(monospaceFonts);
  const cssText = `
		${interfaceFont ? `--font-interface-override: ${interfaceFont};` : ""}
		${textFont ? `--font-text-override: ${textFont};` : ""}
		${textFont ? `--font-print-override: ${textFont};` : ""}
		${monospaceFont ? `--font-monospace-override: ${monospaceFont};` : ""}
	`;
  let style = document.getElementById(id);
  if (cssText.trim() === "") {
    if (style) {
      style.remove();
    }
    return;
  }
  if (!style) {
    style = document.createElement("style");
    style.id = id;
    document.head.appendChild(style);
  }
  style.textContent = `body { ${cssText} }`;
};

// node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/.pnpm/p-timeout@6.1.2/node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message != null ? message : `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

// node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/priority-queue.js
var _queue;
var PriorityQueue = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __privateGet(this, _queue)[this.size - 1].priority >= options.priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index = lowerBound(__privateGet(this, _queue), element, (a, b) => b.priority - a.priority);
    __privateGet(this, _queue).splice(index, 0, element);
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options) {
    return __privateGet(this, _queue).filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();

// node_modules/.pnpm/p-queue@8.0.1/node_modules/p-queue/dist/index.js
var _carryoverConcurrencyCount, _isIntervalIgnored, _intervalCount, _intervalCap, _interval, _intervalEnd, _intervalId, _timeoutId, _queue2, _queueClass, _pending, _concurrency, _isPaused, _throwOnTimeout, _doesIntervalAllowAnother, doesIntervalAllowAnother_get, _doesConcurrentAllowAnother, doesConcurrentAllowAnother_get, _next, next_fn, _onResumeInterval, onResumeInterval_fn, _isIntervalPaused, isIntervalPaused_get, _tryToStartAnother, tryToStartAnother_fn, _initializeIntervalIfNeeded, initializeIntervalIfNeeded_fn, _onInterval, onInterval_fn, _processQueue, processQueue_fn, _throwOnAbort, throwOnAbort_fn, _onEvent, onEvent_fn;
var PQueue = class extends import_index.default {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    __privateAdd(this, _doesIntervalAllowAnother);
    __privateAdd(this, _doesConcurrentAllowAnother);
    __privateAdd(this, _next);
    __privateAdd(this, _onResumeInterval);
    __privateAdd(this, _isIntervalPaused);
    __privateAdd(this, _tryToStartAnother);
    __privateAdd(this, _initializeIntervalIfNeeded);
    __privateAdd(this, _onInterval);
    /**
    Executes all queued functions until it reaches the limit.
    */
    __privateAdd(this, _processQueue);
    __privateAdd(this, _throwOnAbort);
    __privateAdd(this, _onEvent);
    __privateAdd(this, _carryoverConcurrencyCount, void 0);
    __privateAdd(this, _isIntervalIgnored, void 0);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap, void 0);
    __privateAdd(this, _interval, void 0);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _intervalId, void 0);
    __privateAdd(this, _timeoutId, void 0);
    __privateAdd(this, _queue2, void 0);
    __privateAdd(this, _queueClass, void 0);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency, void 0);
    __privateAdd(this, _isPaused, void 0);
    __privateAdd(this, _throwOnTimeout, void 0);
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    __publicField(this, "timeout");
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) == null ? void 0 : _a.toString()) != null ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) == null ? void 0 : _c.toString()) != null ? _d : ""}\` (${typeof options.interval})`);
    }
    __privateSet(this, _carryoverConcurrencyCount, options.carryoverConcurrencyCount);
    __privateSet(this, _isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0);
    __privateSet(this, _intervalCap, options.intervalCap);
    __privateSet(this, _interval, options.interval);
    __privateSet(this, _queue2, new options.queueClass());
    __privateSet(this, _queueClass, options.queueClass);
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __privateSet(this, _throwOnTimeout, options.throwOnTimeout === true);
    __privateSet(this, _isPaused, options.autoStart === false);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _processQueue, processQueue_fn).call(this);
  }
  async add(function_, options = {}) {
    options = {
      timeout: this.timeout,
      throwOnTimeout: __privateGet(this, _throwOnTimeout),
      ...options
    };
    return new Promise((resolve, reject) => {
      __privateGet(this, _queue2).enqueue(async () => {
        var _a;
        __privateWrapper(this, _pending)._++;
        __privateWrapper(this, _intervalCount)._++;
        try {
          (_a = options.signal) == null ? void 0 : _a.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, __privateMethod(this, _throwOnAbort, throwOnAbort_fn).call(this, options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __privateMethod(this, _next, next_fn).call(this);
        }
      }, options);
      this.emit("add");
      __privateMethod(this, _tryToStartAnother, tryToStartAnother_fn).call(this);
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _processQueue, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue2, new (__privateGet(this, _queueClass))());
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _onEvent, onEvent_fn).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__privateGet(this, _queue2).size < limit) {
      return;
    }
    await __privateMethod(this, _onEvent, onEvent_fn).call(this, "next", () => __privateGet(this, _queue2).size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _onEvent, onEvent_fn).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue2).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return __privateGet(this, _queue2).filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
};
_carryoverConcurrencyCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_queue2 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_throwOnTimeout = new WeakMap();
_doesIntervalAllowAnother = new WeakSet();
doesIntervalAllowAnother_get = function() {
  return __privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
_doesConcurrentAllowAnother = new WeakSet();
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
_next = new WeakSet();
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  __privateMethod(this, _tryToStartAnother, tryToStartAnother_fn).call(this);
  this.emit("next");
};
_onResumeInterval = new WeakSet();
onResumeInterval_fn = function() {
  __privateMethod(this, _onInterval, onInterval_fn).call(this);
  __privateMethod(this, _initializeIntervalIfNeeded, initializeIntervalIfNeeded_fn).call(this);
  __privateSet(this, _timeoutId, void 0);
};
_isIntervalPaused = new WeakSet();
isIntervalPaused_get = function() {
  const now = Date.now();
  if (__privateGet(this, _intervalId) === void 0) {
    const delay = __privateGet(this, _intervalEnd) - now;
    if (delay < 0) {
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
    } else {
      if (__privateGet(this, _timeoutId) === void 0) {
        __privateSet(this, _timeoutId, setTimeout(() => {
          __privateMethod(this, _onResumeInterval, onResumeInterval_fn).call(this);
        }, delay));
      }
      return true;
    }
  }
  return false;
};
_tryToStartAnother = new WeakSet();
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue2).size === 0) {
    if (__privateGet(this, _intervalId)) {
      clearInterval(__privateGet(this, _intervalId));
    }
    __privateSet(this, _intervalId, void 0);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__privateGet(this, _isPaused)) {
    const canInitializeInterval = !__privateGet(this, _isIntervalPaused, isIntervalPaused_get);
    if (__privateGet(this, _doesIntervalAllowAnother, doesIntervalAllowAnother_get) && __privateGet(this, _doesConcurrentAllowAnother, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue2).dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _initializeIntervalIfNeeded, initializeIntervalIfNeeded_fn).call(this);
      }
      return true;
    }
  }
  return false;
};
_initializeIntervalIfNeeded = new WeakSet();
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _onInterval, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
_onInterval = new WeakSet();
onInterval_fn = function() {
  if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
  __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
  __privateMethod(this, _processQueue, processQueue_fn).call(this);
};
_processQueue = new WeakSet();
processQueue_fn = function() {
  while (__privateMethod(this, _tryToStartAnother, tryToStartAnother_fn).call(this)) {
  }
};
_throwOnAbort = new WeakSet();
throwOnAbort_fn = async function(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(signal.reason);
    }, { once: true });
  });
};
_onEvent = new WeakSet();
onEvent_fn = async function(event, filter) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter && !filter()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};

// src/import.ts
var fetchMetadata = async (id) => {
  const metadata = await (0, import_obsidian.requestUrl)(`https://api.fontsource.org/v1/fonts/${id}`).json;
  let variable;
  if (metadata.variable) {
    const variableResponse = await (0, import_obsidian.requestUrl)(
      `https://api.fontsource.org/v1/variable/${id}`
    ).json;
    variable = variableResponse.axes;
  }
  const font = {
    id: metadata.id,
    family: metadata.family,
    subsets: metadata.subsets,
    styles: metadata.styles,
    weights: metadata.weights,
    variable,
    base64: {},
    unicodeRange: metadata.unicodeRange
  };
  return font;
};
var getAxes = (variable) => {
  var _a;
  const axes = Object.keys(variable).filter((axis) => axis !== "ital");
  if (axes.length === 1 && (variable == null ? void 0 : variable.wght)) {
    return "wght";
  }
  if (axes.length === 2 && (variable == null ? void 0 : variable.wght)) {
    return (_a = axes.find((axis) => axis !== "wght")) != null ? _a : "wght";
  }
  const isStandard = axes.every(
    (axis) => ["wght", "wdth", "slnt", "opsz"].includes(axis)
  );
  if (isStandard) {
    return "standard";
  }
  return "full";
};
var queue = new PQueue({ concurrency: 12 });
var downloadFileToBase64 = async (url) => {
  const response = await (0, import_obsidian.requestUrl)(url).arrayBuffer;
  return (0, import_obsidian.arrayBufferToBase64)(response);
};
var populateBase64 = async (metadata) => {
  let subsets = Object.keys(metadata.unicodeRange);
  if (subsets.length === 0) {
    subsets = metadata.subsets;
  }
  const generateKey = (oldSubset, style, weight) => {
    const subset = oldSubset.replace(/\[|\]/g, "");
    if (metadata.variable) {
      const axesKey = getAxes(metadata.variable);
      return `${subset}-${axesKey}-${style}`;
    }
    return `${subset}-${weight}-${style}`;
  };
  const promises = [];
  for (const style of metadata.styles) {
    if (metadata.variable) {
      for (const subset of subsets) {
        const key = generateKey(subset, style);
        const url = `https://cdn.jsdelivr.net/fontsource/fonts/${metadata.id}:vf@latest/${key}.woff2`;
        promises.push(
          queue.add(
            () => downloadFileToBase64(url).then((base64) => {
              metadata.base64[`${subset}-${style}`] = base64;
            })
          )
        );
      }
    } else {
      for (const weight of metadata.weights) {
        for (const subset of subsets) {
          const key = generateKey(subset, style, weight);
          const url = `https://cdn.jsdelivr.net/fontsource/fonts/${metadata.id}@latest/${key}.woff2`;
          promises.push(
            queue.add(
              () => downloadFileToBase64(url).then((base64) => {
                metadata.base64[key] = base64;
              })
            )
          );
        }
      }
    }
  }
  await Promise.all(promises);
  return metadata;
};
queue.on("error", () => {
  queue.clear();
});
var importFont = async (id, plugin) => {
  const metadata = await fetchMetadata(id);
  const metadataWithBase64 = await populateBase64(metadata);
  const css = generateCss(metadataWithBase64);
  const vault = plugin.app.vault;
  const path = `${vault.configDir}/fonts/${id}.css`;
  await vault.adapter.mkdir(`${vault.configDir}/fonts`);
  await vault.adapter.write(path, css);
  return {
    id: metadata.id,
    family: metadata.family,
    subsets: metadata.subsets,
    styles: metadata.styles,
    weights: metadata.weights,
    variable: metadata.variable,
    isActive: false
  };
};

// src/modal.ts
var getFontlist = async () => {
  const response = await (0, import_obsidian2.requestUrl)(
    "https://api.fontsource.org/fontlist?family"
  ).json;
  return Object.entries(response).map(([id, family]) => ({ id, family }));
};
var SearchModal = class extends import_obsidian2.SuggestModal {
  constructor(app, plugin, refresh) {
    super(app);
    this.plugin = plugin;
    this.refresh = refresh;
    this.inputEl.placeholder = "Select to import a font...";
    this.emptyStateText = "No fonts found.";
    this.limit = 2500;
  }
  filterFonts(query) {
    return this.listCache.filter(
      (font) => font.family.toLowerCase().includes(query.toLowerCase())
    );
  }
  async getSuggestions(query) {
    if (!this.listCache) {
      const fonts = await getFontlist();
      this.listCache = fonts;
      return this.filterFonts(query);
    }
    return this.filterFonts(query);
  }
  renderSuggestion(item, el) {
    el.setText(item.family);
  }
  async onChooseSuggestion(font, _evt) {
    new import_obsidian2.Notice(`Importing ${font.family}...`);
    try {
      const metadata = await importFont(font.id, this.plugin);
      const fonts = this.plugin.settings.fonts.filter((f) => f.id !== metadata.id).concat(metadata);
      this.plugin.settings.fonts = fonts;
      await this.plugin.saveSettings();
      this.refresh();
      new import_obsidian2.Notice(`Imported ${font.family}.`);
    } catch (error) {
      console.error("Error importing font:", error);
      new import_obsidian2.Notice(`Unable to import ${font.family}.`);
    }
  }
};
var SearchActiveModal = class extends import_obsidian2.SuggestModal {
  constructor(app, plugin, type, refresh) {
    super(app);
    this.checkExists = (id, fonts) => {
      return fonts.some((font) => font.id === id);
    };
    this.addFontToSettings = (fonts, font) => {
      if (!this.checkExists(font.id, fonts)) {
        fonts.push({
          id: font.id,
          family: font.family,
          precedence: 0
        });
        return true;
      }
      return false;
    };
    this.plugin = plugin;
    this.type = type;
    this.refresh = refresh;
    this.inputEl.placeholder = "Select a font...";
    this.emptyStateText = "No fonts found.";
    this.limit = 2e3;
  }
  getSuggestions(query) {
    return this.plugin.settings.fonts.filter(
      (font) => font.family.toLowerCase().includes(query.toLowerCase()) && font.isActive
    );
  }
  renderSuggestion(item, el) {
    el.setText(item.family);
  }
  onChooseSuggestion(font, _evt) {
    let changed = false;
    switch (this.type) {
      case "interface":
        changed = this.addFontToSettings(
          this.plugin.settings.interfaceFonts,
          font
        );
        break;
      case "text":
        changed = this.addFontToSettings(this.plugin.settings.textFonts, font);
        break;
      case "monospace":
        changed = this.addFontToSettings(
          this.plugin.settings.monospaceFonts,
          font
        );
        break;
    }
    this.plugin.saveSettings();
    this.refresh();
    this.close();
    if (changed) {
      new import_obsidian2.Notice(`Selected ${font.family}.`);
    } else {
      new import_obsidian2.Notice(`${font.family} is already selected.`);
    }
  }
};
var SelectModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, type, refresh) {
    super(app);
    this.plugin = plugin;
    this.type = type;
    this.refresh = refresh;
  }
  rerender() {
    this.refresh();
    this.contentEl.empty();
    this.onOpen();
  }
  onOpen() {
    const { contentEl } = this;
    const typeTitle = this.type.charAt(0).toUpperCase() + this.type.slice(1);
    contentEl.createEl("h1", { text: `${typeTitle} font` });
    new import_obsidian2.Setting(contentEl).setName("Add font").setDesc(
      "To support additional languages, you can select multiple fonts in order of precedence."
    ).addButton((button) => {
      button.setIcon("plus");
      button.setTooltip("Select font");
      button.onClick(() => {
        new SearchActiveModal(this.app, this.plugin, this.type, () => {
          this.rerender();
        }).open();
      });
    });
    contentEl.createEl("h3", { text: "Selected fonts" });
    let fonts = this.plugin.settings.interfaceFonts;
    switch (this.type) {
      case "text":
        fonts = this.plugin.settings.textFonts;
        break;
      case "monospace":
        fonts = this.plugin.settings.monospaceFonts;
        break;
    }
    if (fonts.length === 0) {
      contentEl.createEl("p", { text: "No fonts selected." });
    }
    fonts.sort((a, b) => {
      if (a.precedence === b.precedence) {
        return a.family.localeCompare(b.family);
      }
      return a.precedence - b.precedence;
    });
    for (const font of fonts) {
      new import_obsidian2.Setting(contentEl).setName(font.family).addText((text) => {
        text.setValue(String(font.precedence));
        text.setPlaceholder("Precedence");
        text.onChange((value) => {
          if (/^\d+$/.test(value)) {
            font.precedence = Number.parseInt(value);
            fonts.sort((a, b) => a.precedence - b.precedence);
            this.plugin.saveSettings();
            this.rerender();
          } else {
            text.setValue("0");
          }
        });
      }).addButton((button) => {
        button.setIcon("x");
        button.setTooltip("Remove font");
        button.onClick(() => {
          const index = fonts.findIndex((f) => f.id === font.id);
          fonts.splice(index, 1);
          this.plugin.saveSettings();
          this.rerender();
        });
      });
    }
  }
};

// src/settings.ts
var FontsourceSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const addFontSetting = (name, desc, type) => {
      new import_obsidian3.Setting(containerEl).setName(name).setDesc(desc).addButton((button) => {
        button.setButtonText("Manage");
        button.onClick(() => {
          new SelectModal(this.app, this.plugin, type, () => {
            this.display();
            updateCssVariables(this.plugin);
          }).open();
        });
      });
    };
    addFontSetting(
      "Interface font",
      "Set base font for all of Obsidian.",
      "interface"
    );
    addFontSetting(
      "Text font",
      "Set font for editing and reading views.",
      "text"
    );
    addFontSetting(
      "Monospace font",
      "Set font for places like code blocks and frontmatter.",
      "monospace"
    );
    new import_obsidian3.Setting(containerEl).setName("Imported fonts").setHeading();
    const removeFromSettings = (settings, id) => {
      return settings.filter((f) => f.id !== id);
    };
    const removeFromAppliedFonts = (id) => {
      this.plugin.settings.interfaceFonts = removeFromSettings(
        this.plugin.settings.interfaceFonts,
        id
      );
      this.plugin.settings.textFonts = removeFromSettings(
        this.plugin.settings.textFonts,
        id
      );
      this.plugin.settings.monospaceFonts = removeFromSettings(
        this.plugin.settings.monospaceFonts,
        id
      );
      updateCssVariables(this.plugin);
    };
    new import_obsidian3.Setting(containerEl).setName("Select fonts").setDesc("Add a font from the Fontsource directory.").addButton((button) => {
      button.setIcon("plus");
      button.setTooltip("Import font");
      button.onClick(() => {
        new SearchModal(this.app, this.plugin, () => this.display()).open();
      });
    });
    const fonts = this.plugin.settings.fonts.sort(
      (a, b) => a.family.localeCompare(b.family)
    );
    for (const font of fonts) {
      const desc = new DocumentFragment();
      desc.createSpan({
        text: `Weights: ${font.weights.join(", ")}`
      });
      desc.createEl("br");
      desc.createSpan({
        text: `Styles: ${font.styles.join(", ")}`
      });
      desc.createEl("br");
      desc.createSpan({
        text: `Subsets: ${font.subsets.join(", ")}`
      });
      new import_obsidian3.Setting(containerEl).setName(font.family).setDesc(desc).addToggle((toggle) => {
        toggle.setValue(font.isActive).onChange((value) => {
          if (value) {
            applyCss(font.id, this.plugin);
          } else {
            removeCss(font.id);
            removeFromAppliedFonts(font.id);
          }
          font.isActive = value;
          this.plugin.saveSettings();
        });
      }).addButton((button) => {
        button.setIcon("trash-2");
        button.setTooltip("Remove font");
        button.onClick(async () => {
          const vault = this.plugin.app.vault;
          try {
            await vault.adapter.remove(
              `${vault.configDir}/fonts/${font.id}.css`
            );
            removeCss(font.id);
            this.plugin.settings.fonts = removeFromSettings(
              this.plugin.settings.fonts,
              font.id
            );
            removeFromAppliedFonts(font.id);
            this.plugin.saveSettings();
            new import_obsidian3.Notice(`Deleted ${font.family}.`);
            this.display();
          } catch (error) {
            console.error("Error deleting font:", error);
            new import_obsidian3.Notice(`Unable to delete ${font.id}.css from Vault.`);
          }
        });
      });
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  fonts: [],
  interfaceFonts: [],
  textFonts: [],
  monospaceFonts: []
};
var FontsourcePlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new FontsourceSettingsTab(this.app, this));
    for (const font of this.settings.fonts) {
      if (font.isActive) {
        applyCss(font.id, this);
      }
    }
    updateCssVariables(this);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async onunload() {
    const existing = document.getElementById("fontsource-css-variables");
    if (existing) {
      existing.remove();
    }
    for (const font of this.settings.fonts) {
      const existing2 = document.getElementById(`fontsource-${font.id}`);
      if (existing2) {
        existing2.remove();
      }
    }
  }
};
