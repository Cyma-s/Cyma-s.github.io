---
title: 3. 트랜스포트 계층
date: 2023-12-14 23:58:25 +0900
updated: 2024-01-08 16:50:40 +0900
tags:
  - 컴퓨터-네트워킹-하향식-접근
---

## 트랜스포트 계층 서비스 및 개요

트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 **논리적 통신**을 제공한다. 논리적 통신은 애플리케이션의 관점에서 보면 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보인다는 것을 의미한다.  

트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다. 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지를 **트랜스포트 계층 세그먼트** 라고 알려진 트랜스포트 계층 패킷으로 변환한다. 
트랜스포트 계층은 송신 종단 시스템에 있는 네트워크 계층으로 세그먼트를 전달하고, 여기서 세그먼트가 네트워크 계층 패킷 안에 캡슐화되어 목적지로 전달된다.  

네트워크 라우터는 오로지 데이터그램의 네트워크 계층 필드에 대해 동작한다는 것을 유념해야 한다. (즉, 라우터는 데이터그램 안에 캡슐화된 트랜스포트 계층 세그먼트의 필드를 검사하지 않는다.)

네트워크 애플리케이션에는 하나 이상의 트랜스포트 계층 프로토콜을 사용할 수 있다. 이러한 프로토콜은 서비스를 요청하는 애플리케이션에게 트랜스포트 계층에서 각기 다른 서비스 집합을 제공한다. 

### 트랜스포트 계층과 네트워크 계층 사이의 관계

트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 *프로세스*들 사이의 논리적 통신을 제공하지만, 네트워크 계층 프로토콜은 *호스트들*사이의 논리적 통신을 제공한다. 

트랜스포트 계층 프로토콜들은 종단 시스템에 존재한다. 종단 시스템 안에서 트랜스포트 프로토콜은 애플리케이션 프로세스에서 네트워크 경계까지 메시지를 운반하며, 반대 방향으로 네트워크 계층에서 애플리케이션 프로세스로 메시지를 운반한다. 그러나 트랜스포트 프로토콜은 메시지가 네트워크 계층 내부에서 어떻게 이동하는지는 언급하지 않는다.  

컴퓨터 네트워크는 애플리케이션에서 서로 다른 서비스를 제공하도록 하는 개별 프로토콜을 갖는 다양한 트랜스포트 프로토콜을 만들 수 있게 한다. 

트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토콜의 서비스 모델에 의해 제약받는다. 네트워크 계층 프로토콜이 호스트 사이에서 전송되는 트랜스포트 계층 세그먼트에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메시지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다. 

하위 네트워크 프로토콜이 상응하는 서비스를 제공하지 못할 때도, 특정 서비스는 트랜스포트 프로토콜에 의해 제공될 수 있다. 트랜스포트 프로토콜은 네트워크 계층을 트랜스포트 계층 세그먼트의 기밀성을 보장할 수 없을 때도 침입자가 애플리케이션 메시지를 읽지 못하도록 암호화를 사용할 수 있다. 

### 인터넷 트랜스포트 계층의 개요

인터넷은 애플리케이션 계층에게 두 가지 구별되는 트랜스포트 계층 프로토콜을 제공한다. 하나는 비신뢰적이고 비연결형인 서비스를 요청한 애플리케이션에게 제공하는 **UDP(User Datagram Protocol)** 이고, 다른 하나는 신뢰적이고 연결지향형 서비스를 요청한 애플리케이션에게 제공하는 **TCP(Transmission Control Protocol)** 다. 네트워크 애플리케이션을 설계할 때 애플리케이션 개발자는 이 두 가지 트랜스포트 프로토콜 중 하나를 명시해야 한다. 

인터넷에서 트랜스포트 계층 패킷을 **세그먼트**라고 한다. 그러나 인터넷 문서에서는 TCP 에 대한 트랜스포트 계층 패킷을 세그먼트로 나타내면서, UDP에 대한 패킷을 데이터그램으로 표현하기도 한다. 

인터넷의 네트워크 계층 프로토콜은 인터넷 프로토콜 (Internet Protocol, IP) 이라는 이름을 갖는다. IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 **최선형 전달 서비스**이다. 이것은 IP 가 통신하는 호스트들 간에 세그먼트를 전달하기 위해 최대한 노력하지만, 어떠한 보장도 하지 않는 것을 의미한다. 특히, IP 는 세그먼트의 전달을 보장하지 않고 세그먼트가 순서대로 전달되는 것을 보장하지 않는다. 또한 IP 는 세그먼트 내부 데이터의 무결성을 보장하지 않는다. 이러한 이유로 IP 를 **비신뢰적인 서비스** 라고 부른다. 또한 모든 호스트가 적어도 하나의 IP 주소로 불리는 네트워크 계층 주소를 갖는다. 

UDP와 TCP의 가장 기본적인 기능은 종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다. 호스트 대 호스트 전달을 프로세스 대 프로세스 전달로 확장하는 것을 **트랜스포트 계층 다중화**와 **역다중화**라고 부른다. UDP와 TCP는 헤더에 오류 검출 필드를 포함함으로써 무결성 검사를 제공한다. 이러한 최소한의 두 가지 트랜스포트 계층 서비스 (프로세스 대 프로세스 데이터 전달과 오류 검출)가 UDP가 제공하는 유일한 두 가지 서비스다. 여기서 UDP는 IP와 마찬가지로 비신뢰적인 서비스다. UDP는 하나의 프로세스에 의해 전송된 데이터가 손상되지 않고 목적지 프로세스에 도착한다는 것을 보장하지 않는다. 

반면, TCP는 애플리케이션에 몇 가지 추가적인 서비스를 제공한다. 가장 먼저 TCP는 **신뢰적인 데이터 전송**을 제공한다. 흐름 제어, 순서 번호, 확인 응답, 타이머를 사용함으로써 TCP는 송신하는 프로세스로부터 수신하는 프로세스에게 데이터가 순서대로 정확하게 전달되도록 확실하게 한다. 이처럼 TCP는 종단 시스템 간에 IP의 비신뢰적인 서비스를 프로세스 사이의 신뢰적인 데이터 전송 서비스로 만들어준다. 또한 TCP는 **혼잡 제어**를 사용한다. 혼잡 제어는 인터넷에 대한 통상적인 서비스처럼 야기한 애플리케이션에게 제공되는 특정 서비스가 아니라, 전체를 위한 일반 서비스다. 즉, 한 TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 혼잡하게 하는 것을 방지하는 것이 TCP 혼잡 제어다. TCP는 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하도록 해준다. 이것은 송신 측의 TCP가 네트워크에 보낼 수 있는 트래픽을 조절함으로써 수행된다. 반면, UDP 트래픽은 조절되지 않는다. UDP 트랜스포트 프로토콜을 사용하는 애플리케이션은 허용이 되는 한 그것이 만족하는 어떤 속도로든 전송할 수 있다. 

## 다중화와 역다중화

네트워크 계층이 제공하는 호스트 대 호스트 전달 서비스에서 호스트에서 동작하는 애플리케이션에 대한 프로세스 대 프로세스 전달 서비스로 확장하는 것을 살펴본다.  

목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신한다. 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 진다. 컴퓨터의 트랜스포트 계층이 하위의 네트워크 계층으로부터 데이터를 수신할 때, 트랜스포트 계층은 프로세스 중 하나에게 수신한 데이터를 전달할 필요가 있다.  

먼저, 네트워크 애플리케이션의 한 부분으로서 프로세스는 **소켓**을 갖고 있다. 이를 통해 네트워크에서 프로세스로 데이터를 전달하고, 또한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 한다. 그러므로 수신 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않고, 중간 매개자인 소켓에게 전달한다. 어떤 주어진 시간에 수신 측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 하나의 유일한 식별자를 갖는다. 식별자의 포맷은 UDP, TCP 소켓인지에 따라 달라진다. 

수신측 호스트가 수신한 트랜스포트 계층 세그먼트를 어떻게 적절한 소켓으로 향하게 하는지를 생각해보자. 각각의 트랜스포트 계층 세그먼트는 이러한 목적을 위해 세그먼트에 필드 집합을 갖고 있다. 수신 측의 트랜스포트 계층은 수신 소켓을 식별하기 위해 이러한 필드를 검사한다. 그리고 이 세그먼트를 해당 소켓으로 보낸다. 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 **역다중화(demultiplexing)** 이라고 한다. 출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 **다중화(multiplexing)** 이라고 한다. 

![[transport-multiplexing.jpeg]]

중간 호스트의 트랜스포트 계층은 네트워크 계층 아래로부터 수신한 세그먼트를 위쪽의 프로세스 $P_1$ 또는 $P_2$ 로 반드시 역다중화해야 한다. 이는 도착한 세그먼트의 데이터가 이에 상응하는 프로세스의 소켓으로 전달되도록 해서 이루어진다.  
또한 중간 호스트의 트랜스포트 계층은 프로세스의 소켓으로부터 외부로 나가는 데이터를 모으고, 다음에 트랜스포트 계층 세그먼트들로 만들고, 이 세그먼트들을 아래 네트워크 계층으로 전달해야만 한다.  

트랜스포트 계층 다중화에는 다음 두 가지 요구사항이 있다.  
1. 소켓은 유일한 식별자를 갖는다. 
2. 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다. 

이 특별한 필드라는 것은 **출발지 포트 번호 필드 (source port number field)** 와 **목적지 포트 번호 필드 (destination port number field)** 이다. 각각의 포트 번호는 0~65535까지의 16비트 정수다. 그중에서 0~1023까지의 포트 번호를 **잘 알려진 포트 번호 (well-known port number)** 라고 하여 사용을 엄격하게 제한하고 있다. 새 애플리케이션을 개발할 때는 애플리케이션에 포트 번호를 반드시 할당해야 한다. 

호스트의 각 소켓은 포트 번호를 할당 받으며, 세그먼트가 호스트에 도착하면 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하고 상응하는 소켓으로 세그먼트를 보내게 된다. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다. 이것은 UDP의 기본적인 동작 방식이며 TCP의 다중화/역다중화는 좀 더 많은 의미를 갖고 있다. 

#### 비연결형 다중화와 역다중화

Python 에서는 다음과 같이 UDP 소켓을 생성할 수 있다.

```python
clientSocket = socket(AF_INET, SOCK_DGRAM)
```

이 방법으로 UDP 소켓이 생성될 때 트랜스포트 계층은 포트 번호를 소켓에게 자동으로 할당한다. 특히 트랜스포트 계층은 현재 호스트에서 UDP 포트로 사용하지 않는 1024~65535 사이의 포트 번호를 할당한다. 다른 방법으로는 우리가 소켓을 생성한 뒤에, 소켓 `bind()` 방식을 사용하여 특정 포트 번호를 UDP 소켓에 할당하기 위해 다음과 같이 작성할 수 있다. 

```python
clientSocket.bind(('', 19157))
```

만약 코드를 작성하는 애플리케이션 개발자가 ‘잘 알려진 프로토콜’ 의 서버 측을 구현하고 있다면, 개발자는 상응하는 ‘잘 알려진 포트 번호’를 할당해야만 한다. 일반적으로 애플리케이션의 서버 측이 특정 포트 번호를 할당하는 것에 반해, 애플리케이션의 클라이언트 측은 트랜스포트 계층이 포트 번호를 자동으로 할당한다. 

UDP 소켓으로 할당된 포트 번호로 UDP 다중화/역다중화는 다음과 같다.  
UDP 소켓 19157 을 가진 호스트 A의 프로세스가 호스트 B의 UDP 소켓 46428을 가진 프로세스에게 애플리케이션 데이터 전송을 원한다고 가정하자. 호스트 A의 트랜스포트 계층은 애플리케이션 데이터, 출발지 포트 번호(19157), 목적지 포트 번호(46428), 그리고 2개의 다른 값을 포함하는 트랜스포트 계층 세그먼트를 생성한다. 트랜스포트 계층은 만들어진 세그먼트를 네트워크 계층으로 전달한다. 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하고 최선형 전달 서비스로 세그먼트를 수신 호스트로 전달한다. 세그먼트가 수신 호스트 B에 도착하면, 수신 호스트는 세그먼트 안의 목적지 포트 번호 (46428)을 검사하고 그 세그먼트를 포트 46428로 식별되는 소켓에 전달한다. 네트워크로부터 UDP 세그먼트들이 도착하면, 호스트 B는 세그먼트의 목적지 포트를 검사하여 세그먼트를 적절한 소켓으로 보낸다. (역다중화)

출발지 IP 주소와 출발지 포트 번호가 모두 다르거나 출발지 IP 주소와 출발지 포트 번호 중 어느 하나가 다를지라도, 같은 목적지 IP 주소와 목적지 포트 번호를 가지면 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다. 

```ad-question
왜 UDP 는 출발지 IP 주소와 출발지 포트 번호로 호스트를 식별하지 않을까?

(GPT 답변)
UDP (User Datagram Protocol)는 인터넷 프로토콜 스위트의 핵심 멤버 중 하나로, 주로 간단하고 낮은 지연시간을 요구하는 애플리케이션에서 사용됩니다. UDP가 출발지 IP 주소와 출발지 포트 번호로 호스트를 식별하지 않는 것이 아니라, UDP는 이러한 정보를 포함하지만, 연결 상태를 유지하거나 세션을 관리하지 않는 비연결형 프로토콜입니다. 이로 인해 UDP의 특성과 사용 사례가 결정됩니다:

1. **비연결성**: UDP는 연결을 설정하거나 종료하는 과정이 없습니다. 각 UDP 데이터그램은 독립적으로 처리되며, 이전 또는 이후의 데이터그램과 연관되지 않습니다. 이것은 네트워크 오버헤드를 줄여주고 데이터 전송 속도를 높입니다.
    
2. **상태 비저장**: UDP는 상태나 세션 정보를 유지하지 않습니다. 따라서 UDP는 각 데이터그램이 독립적으로 송수신되는 특성을 가집니다. 이는 서버가 동시에 많은 클라이언트와 통신할 때 유리합니다.
    
3. **간소화된 오류 처리**: UDP는 패킷 손실, 순서 변경, 중복 패킷 등에 대해 복구하지 않습니다. 오류 복구 및 순서 보장은 애플리케이션 레벨에서 처리됩니다. 이것은 리소스를 적게 소모하지만, 신뢰성이 중요한 애플리케이션에는 적합하지 않을 수 있습니다.
    
4. **비신뢰성과 단순성**: UDP는 패킷을 보낸 후 수신 여부를 확인하지 않으며, 데이터 전송에 대한 확인 응답(ACK) 또한 없습니다. 이로 인해 구현이 간단하고, 실시간 스트리밍, 온라인 게임, DNS 조회와 같은 실시간 특성이 요구되는 애플리케이션에서 선호됩니다.
    

UDP는 출발지 IP 주소와 출발지 포트 번호를 사용하여 송신자를 식별할 수 있지만, TCP와 달리 이러한 정보를 기반으로 한 연결 상태를 유지하거나 관리하지 않습니다. 따라서 UDP는 효율적이고 빠른 데이터 전송을 제공하지만, 신뢰성과 데이터 순서 보장이 필요한 애플리케이션에는 적합하지 않을 수 있습니다.
```

출발지 포트 번호는 ‘회신 주소’ 의 한 부분으로 사용된다. 즉, B가 세그먼트를 다시 A에게 보내기를 원할 때, B에서 A로 가는 세그먼트의 목적지 포트 번호는 A로부터 B로 가는 세그먼트의 출발지 포트 번호로부터 가져온다. 

```ad-question
포트 번호가 모두 할당되었을 때는 어떻게 할까?

모든 포트 번호가 할당되었다는 것은 시스템에서 사용 가능한 UDP 포트가 모두 다른 프로세스나 서비스에 의해 사용 중이라는 것을 의미하므로, 이런 상황에서는 더 이상 새로운 소켓을 열 수 없다. 이러한 상황은 매우 드물지만, 이런 일이 발생하는 경우 다음과 같은 방법을 사용할 수 있다. 

1. 필요하지 않은 소켓이나 프로세스를 종료하여 포트를 해제한다. 
2. 특정 애플리케이션에서는 포트를 공유하거나 동적으로 포트를 할당받는 방식을 고려할 수도 있다. 
```

```ad-question
목적지의 포트 번호는 어떻게 알아낼 수 있을까?

목적지가 서버인 경우, 서버에서 정의한 포트 번호로 세그먼트를 전달한다. nginx 같은 리버스 프록시 서버에서 포트 번호를 변경해줄 수도 있다. 반대로 서버가 데이터를 다시 돌려보낼 때는 처음에 보냈던 출발지 IP 와 출발지 포트 번호를 사용해서 데이터를 전달할 수 있을 것이다. 
```

#### 연결지향형 다중화와 역다중화

TCP 역다중화를 수행하기 위해서는 TCP 소켓과 TCP 연결 설정을 살펴봐야 한다 .TCP 소켓과 UDP 소켓의 다른 점은 TCP 소켓은 4개 요소의 집합, 즉, 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별된다는 것이다. 그러므로 네트워크로부터 호스트에 TCP 세그먼트가 도착하면, 호스트는 해당하는 소켓으로 세그먼트를 전달하기 위해 4개의 값을 모두 사용한다.  
특히 UDP 와는 다르게, 다른 출발 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향하게 된다. 

- TCP 서버 애플리케이션은 ‘환영 소켓’ 을 갖고 있다. 이 소켓은 포트 번호 12000을 가진 TCP 클라이언트로부터 연결 설정 요청을 기다린다. 
- TCP 클라이언트는 다음과 같은 명령으로 소켓을 생성하고 연결 설정 요청 세그먼트를 보낸다. 
```python
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, 12000))
```
- 연결 설정 요청은 목적지 포트 번호 12000과 TCP 헤더에 설정된 특별한 연결 설정 비트를 가진 TCP 세그먼트에 지나지 않는다. 또한 그 세그먼트는 출발지 포트 번호를 포함하는데, 이 출발지 포트 번호는 클라이언트가 선택한 번호다. 
- 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트 12000을 포함하는 연결 요청 세그먼트를 수신하면, 이 세그먼트를 포트 번호 12000으로 연결 수락을 기다리는 서버 프로세스로 보낸다. 
```python
connectionSocket, addr = serverSocket.accept()
```
- 서버는 연결 요청 세그먼트의 출발지 포트 번호, 출발지 호스트의 IP 주소, 세그먼트 안의 목적지 포트 번호, 목적지 IP 주소에 주목하고, 새롭게 생성된 연결 소켓은 이 값들로 식별된다. 그 다음에 도착하는 모든 세그먼트의 출발지 포트, 출발지 IP 주소, 목적지 포트, 목적지 IP 주소가 이 네 가지 값과 일치하면 세그먼트는 해당 소켓으로 역다중화될 것이다. 

서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다. 해당 소켓은 프로세스에 접속되어 있으며, 소켓은 4개 요소의 집합에 의해 식별된다. 

#### 웹 서버와 TCP

아파치 웹 서버 같은 웹 서버가 포트 번호 80 상에서 동작하는 호스트를 고려해보자. 클라이언트가 서버로 세그먼트를 보내면, 모든 세그먼트는 목적지 포트 번호 80을 가지고 있을 것이다. 특히, 초기 연결 설정 세그먼트들과 HTTP 요청 메시지를 전달하는 모든 세그먼트는 목적지 포트 80을 가질 것이다. 앞에서 살펴본 것처럼, 서버는 각기 다른 클라이언트가 보낸 세그먼트를 출발지 IP 주소와 출발지 포트 번호로 구별한다.  

웹 서버는 각각의 연결에 대해 새로운 프로세스를 만들고, 해당 프로세스들은 각자 연결 소켓을 가지며 이 연결 소켓을 통해 HTTP 요청을 수신하고, HTTP 응답을 전송한다.  
그러나 연결 소켓과 프로세스 사이에 항상 1:1 대응이 이루어지는 것은 아니다. 실제로 오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다. 그러면서, 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드를 생성한다. 그런 웹 서버에서는 하나의 같은 프로세스에 붙어 있는 많은 연결 소켓들이 동시에 존재할 수도 있다. 

만약 클라이언트와 서버가 지속적인 HTTP 를 사용한다면, 지속적인 연결의 존속 기간에 클라이언트와 서버는 같은 서버 소켓을 통해 HTTP 메시지를 교환할 것이다. 그러나 만약 클라이언트와 서버가 비지속적인 HTTP를 사용한다면, 모든 요청/응답 마다 새로운 TCP 연결이 생성되고 종료될 것이다. 이 빈번하게 발생하는 소켓 생성과 종료는 웹 서버 성능에 심한 부담을 준다. 

## 비연결형 트랜스포트: UDP

UDP 는 트랜스포트 계층 프로토콜이 할 수 있는 최소 기능으로 동작한다. UDP 는 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다. UDP 는 애플리케이션 프로세스로부터 메시지를 가져와서 다중화/역다중화 서비스에 대한 출발지 포트 번호 필드와 목적지 포트 번호 필드를 첨부하고 다른 두 필드를 추가한 후에 최종 세그먼트를 네트워크 계층으로 넘겨준다. 네트워크 계층은 트랜스포트 계층 세그먼트를 IP 데이터그램으로 캡슐화하고, 세그먼트를 수신 호스트에 전달하기 위해 최선을 다한다. 만약 세그먼트가 수신 호스트에 도착한다면, UDP 는 세그먼트의 데이터를 해당하는 애플리케이션 프로세스로 전달하기 위해 목적지 포트 번호를 사용한다. UDP 는 세그먼트를 송신하기 전에 송신 트랜스포트 계층 개체들과 수신 트랜스포트 계층 개체들 사이에 핸드 셰이크를 사용하지 않는다. 이런 이유로 UDP 를 *비연결형* 이라고 한다. 

DNS 는 전형적으로 UDP 를 사용하는 애플리케이션 계층 프로토콜이다. 호스트의 DNS 애플리케이션이 질의를 생성할 때, DNS 질의 메시지를 작성하고 UDP에게 메시지를 넘겨준다. 목적지 종단 시스템 상에서 동작하는 UDP 개체와 호스트 측 UDP 는 어떠한 핸드셰이크도 수행하지 않고 메시지에 헤더 필드를 추가한 후에 최종 세그먼트를 네트워크 계층에 넘겨준다. 네트워크 계층은 UDP 세그먼트를 데이터그램으로 캡슐화하고 네임 서버에 데이터그램을 송신한다. 이때 질의 호스트에서의 DNS 애플리케이션은 질의에 대한 응답을 기다린다. 만약 질의 호스트가 응답을 수신하지 못하면, 질의를 다른 네임 서버로 송신하거나 이를 야기한 애플리케이션에게 응답을 수신할 수 없음을 통보한다.  

많은 애플리케이션은 다음과 같은 이유로 UDP 에 더 적합하다. 

- 무슨 데이터를 언제 보낼지에 대해 애플리케이션 레벨에서 더 정교한 제어를 할 수 있다: 애플리케이션 프로세스가 데이터를 UDP 에 전달하자마자 UDP 는 데이터를 UDP 세그먼트로 만들고, 그 세그먼트를 즉시 네트워크 계층으로 전달한다. 이에 반해 TCP 는 혼잡 제어 메커니즘을 갖고 있다. 이 혼잡 제어 메커니즘은 목적지 호스트들과 출발지 호스트들 사이에서 하나 이상의 링크가 과도하게 혼잡해지면, 트랜스포트 계층 TCP 송신자를 제한한다. 또한 TCP 는 신뢰적인 전달이 얼마나 오래 걸리는지에 관계없이 목적지가 세그먼트의 수신 여부를 확인, 응답할 때까지 데이터의 세그먼트 재전송을 계속할 것이다. 실시간 애플리케이션은 최소 전송률을 요구할 때도 있고, 지나치게 지연되는 세그먼트 전송을 원하지 않으며, 조금의 데이터 손실은 허용할 수도 있으므로 TCP 의 서비스 모델은 이러한 애플리케이션의 요구와는 맞지 않는다. 
- 연결 설정이 없음: UDP 는 연결을 설정하기 위한 어떤 지연도 없다. 
- 연결 상태가 없음: UDP 는 연결 상태를 유지하지 않으며 파라미터 중 어떤 것도 기록하지 않는다. 이러한 이유로 일반적으로 특정 애플리케이션 전용 서버는 애플리케이션 프로그램이 TCP보다 UDP에서 동작할 때 일반적으로 좀 더 많은 액티브 클라이언트를 수용할 수 있다. 
- 작은 패킷 헤더 오버헤드: TCP 는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP 는 단지 8바이트의 오버헤드를 갖는다. 

### UDP 세그먼트 구조

애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치한다. UDP 헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다. 포트 번호는 목적지 호스트가 목적지 종단 시스템에서 동작하는 정확한 프로세스에게 애플리케이션 데이터를 넘기게 해준다. 체크섬은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용한다. 길이 필드는 헤더를 포함하는 UDP 세그먼트의 길이를 나타낸다. 

### UDP 체크섬

UDP 체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때, UDP 세그먼트 안의 비트에 대한 변경 사항이 있는지 검사하는 것이다. 송신자는 체크섬 안에 있는 모든 16비트 워드의 합산에 대해 다시 1의 보수를 수행하며, 합산 과정에서 발생하는 오버플로는 윤회식 자리 올림(wrap around)을 한다.  

만약 패킷에 어떤 오류도 없다면 수신자에서의 합은 모든 자리가 1이 될 것이다. 비트 중에 하나라도 0이 있다면 패킷에 오류가 발생했음을 알 수 있다.  

UDP 가 체크섬을 제공하는 이유는 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공한다는 보장이 없기 떄문이다. 그러므로 세그먼트들이 정확하게 링크를 통해 전송되었을지라도, 세그먼트가 라우터의 메모리에 저장될 때 비트 오류가 발생할 수 있다. 주어진 링크 간의 신뢰성과 메모리의 오류 검사가 보장되지도 않고, 종단 간의 데이터 전송 서비스가 오류 검사를 제공해야 한다면, UDP 는 *종단 기반으로* 트랜스포트 계층에서 오류 검사를 제공해야만 한다. 이것이 시스템 설계에서의 **종단과 종단의 원칙 (end-end principle)** 이다. 

IP는 어떠한 2계층 프로토콜에서도 동작해야 하므로, 트랜스포트 계층은 안전장치로서 오류 검사를 제공하는 것이 유용하다. UDP 는 오류 검사를 제공하지만, 오류를 회복하기 위한 어떠한 일도 하지 않는다. 

## 신뢰적인 데이터 전송의 원리

신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않는다. 그리고 모든 데이터는 전송된 순서 그대로 전달된다. 이것이 TCP가 인터넷 애플리케이션에게 제공하는 서비스 모델이다.  

이러한 서비스 추상화를 구현하는 것이 **신뢰적인 데이터 전송 프로토콜 (reliable data transfer protocol)** 의 의무이다. 이 작업은 신뢰적인 전송 프로토콜의 아래에 있는 계층이 신뢰적이지 않을 수 있어서 어려워진다. 

여기서는 **단방향 데이터 전송** 의 경우인 송신 측으로부터 수신 측까지의 데이터 전송만을 고려한다. 

### 신뢰적인 데이터 전송 프로토콜의 구축

#### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송: rdt1.0

먼저, 하위 채널이 완전히 신뢰적인 가장 간단한 경우를 고려한다.  

![[all-reliable-channel.jpeg]]

이러한 간단한 프로토콜에서는 데이터 단위와 패킷의 차이점이 없다. 또한 모든 패킷의 흐름은 송신자로부터 수신자까지다. 즉, 완전히 신뢰적인 채널에서는 오류가 생길 수 없으므로 수신 측이 송신측에게 어떤 피드백도 제공할 필요가 없다. 또한 수신자는 송신자가 데이터를 송신하자마자 데이터를 수신할 수 있다고 가정했으므로 수신자가 송신자에게 천천히 보내라는 것을 요청할 필요가 없다. 

#### 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송: rdt2.0

패킷 안의 비트들이 하위 채널에서 손상되는 모델이다. 전송된 모든 패킷이 송신된 순서대로 수신된다고 계속 가정한다. 

컴퓨터 네트워크 설정에서 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 **자동 재전송 요구 (Automatic Repeat reQuest, ARQ) 프로토콜** 로 알려져 있다. 

다음과 같은 세 가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다. 

- 오류 검출: 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능이 필요하다. 
- 수신자 피드백: rdt2.0 프로토콜은 수신자로부터 송신자 쪽으로 ACK 와 NAK 패킷들을 전송할 것이다. 
- 재전송: 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송된다. 

![[bit-error-channel.jpeg]]

가장 왼쪽 상태에서 송신 측 프로토콜은 상위 계층에서 데이터가 전달되기를 기다린다. `rdt_send` 이벤트가 발생하면 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷을 생성하고, 패킷을 `udt_send` 로 전송할 것이다. 가장 오른쪽 상태에서 송신자 프로토콜은 수신자로부터의 ACK, NAK 패킷을 기다린다. ACK 패킷이 수신된다면 송신자는 가장 최근에 전송된 패킷이 정확하게 수신되었음을 알게 된다. NAK 가 수신되면 프로토콜은 마지막 패킷을 재전송하고 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK, NAK 를 기다린다. 송신자는 수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지 새로운 데이터를 전달하지 않을 것이다. 이러한 행동 때문에 rdt2.0과 같은 프로토콜은 **전송 후 대기 (stop-and-wait)** 프로토콜로 알려져 있다.  
수신자 측 FSM 은 아직 단일 상태를 갖는다. 

프로토콜 rdt2.0은 잘 동작하는 것 같지만 실제로는 치명적인 결함이 있다.  
ACK, NAK 패킷이 손상되는 경우는 어떻게 해야 할까? 최소한 그런 오류를 검출하기 위해 ACK, NAK 패킷에 대한 체크섬 비트를 추가할 필요가 있다. 더 어려운 점은 어떻게 프로토콜이 ACK 또는 NAK 패킷 오류로부터 복구되는가이다. ACK, NAK가 손상된다면 송신자는 수신자가 전송된 데이터의 마지막 부분을 올바르게 수신했는지를 알 방법이 없다.  

다음과 같은 세 가지 가능성을 고려해보자.  

1. 수신자의 응답을 이해하지 못했을 때를 위한 새로운 송신자-수신자 패킷을 도입한다.
2. 송신자가 검출뿐만 아니라 비트 오류로부터 회복할 수 있도록 충분한 체크섬 비트들을 추가한다. 
3. 송신자가 왜곡된 ACK, NAK 패킷을 수신할 때 현재 데이터 패킷을 단순히 다시 송신하는 것이다. 그러나 이 방식은 송신자에서 수신자 간의 채널로 중복 패킷을 전송하게 된다. 이 경우, 마지막으로 전송된 ACK, NAK가 송신자에게 정확히 수신되었는지를 알 수 없다. 그러므로 도착하는 패킷이 새로운 데이터를 포함하고 있는 것인지 재전송인지를 사전에 알 수 없다. 

이 문제의 간단한 해결책은 데이터 패킷에 새로운 필드를 추가하고 이 필드 안에 순서 번호를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙이는 것이다. 일반적으로 패킷을 손실하지 않는 채널을 가정하고 있으므로, ACK와 NAK 패킷 자체는 확인 중인 패킷의 순서 번호를 나타낼 필요는 없다. 송신자는 수신된 ACK와 NAK 패킷이 가장 최근에 전송된 데이터 패킷에 대한 응답으로 발생한 것임을 알 수 있다. 

![[bit-error-numbering-sender.jpeg]]

![[bit-error-numbering-receiver.jpeg]]

프로토콜 rdt2.1은 수신자로부터 송신자까지의 긍정 확인 응답과 부정 확인응답을 모두 포함한다. 순서가 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인응답을 전송한다. 손상된 패킷이 수신되면, 수신자는 부정 확인응답을 전송한다. NAK를 송신하는 것 대신에, 가장 최근에 정확하게 수신된 패킷에 대해 ACK를 송신함으로써 NAK 를 송신한 것과 같은 효과를 얻을 수 있다.  

비트 오류를 갖는 채널을 위한 NAK 없는 신뢰적인 데이터 전송 프로토콜은 rdt2.2이다.  
rtd2.1과 rtd2.2의 미묘한 차이는 수신자가 반드시 ACK 메시지에 의해 확인 응답되는 패킷의 순서 번호를 포함해야 한다는 점이다. 그리고 송신자는 수신된 ACK 메시지에 의해 확인응답된 패킷의 순서 번호를 반드시 검사해야만 한다. 

![[bit-error-absent-nak.jpeg]]

#### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송: rdt3.0

비트가 손상되는 것 외에도 인터넷을 포함하는 오늘날의 컴퓨터 네트워크처럼 하위 채널이 패킷을 손실하는 경우를 생각해보자.  

1. 어떻게 패킷 손실을 검출할 것인가
2. 패킷 손실이 발생했을 때 어떤 행동을 할 것인가

패킷 손실을 다룰 때 여러 가지 접근이 가능하지만, 송신자에게 손실된 패킷의 검출과 회복 책임을 부여해보자.  
송신자가 데이터 패킷을 전송하고 패킷 또는 수신자의 패킷에 대한 ACK 를 손실했다고 가정해보자. 만약 송신자가 패킷을 잃어버렸다고 확신할 정도의 충분한 시간을 기다릴 수만 있다면 데이터 패킷은 간단히 재전송될 수 있다.  

그러나 송신자가 어떤 패킷을 손실했다는 것을 확신하기 위해 얼마나 오랫동안 기다려야 할까? 송신자는 적어도 송신자와 수신자 사이의 왕복 시간 지연에 수신 측에서 패킷을 처리하는 데 필요한 시간을 더한 만큼 기다린다. 많은 네트워크에서는 이 최악의 최대 지연 시간은 예측하기조차도 매우 어렵다. 실제 상황에서 채택한 접근 방식은 송신자가 패킷 손실이 일어났다는 보장은 없지만 손실이 일어났을 만한 그런 시간을 현명하게 선택하는 것이다.  
만약 패킷이 유별나게 큰 지연을 갖는다면, 송신자는 비록 데이터 패킷이나 그 패킷에 대한 ACK가 손실되지 않았다고 하더라도 패킷을 재전송할 수 있다. 이것은 송신자 대 수신자 채널에서 중복 데이터 패킷의 가능성을 포함한다. 

시간 기반의 재전송 메커니즘을 구현하기 위해, 주어진 시간이 지난 후에 송신자를 인터럽트할 수 있는 **카운트 다운 타이머** 가 필요하다.  

1. 매 패킷 (첫 번째 또는 재전송 패킷)이 송신된 시간에 타이머를 시작함
2. 타이머 인터럽트에 반응함(적당한 행동을 취함)
3. 타이머를 멈춤

![[bit-error-alternating-bit.jpeg]]

패킷에 대한 수신 시간은 전송 지연과 전파 지연 때문에 패킷 전송 시간보다 더 늦다. 패킷의 순서 번호가 0과 1이 번갈아 일어나므로, 프로토콜 rdt3.0은 **얼터네이팅 비트 프로토콜 (alternating-bit protocol)** 이라고 부른다.  

### 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

