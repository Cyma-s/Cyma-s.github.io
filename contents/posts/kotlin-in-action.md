---
title: Kotlin In Action
date: 2024-08-24 15:40:31 +0200
updated: 2024-08-26 21:06:06 +0200
tags:
  - kotlin
  - book
---

## 2장 코틀린 기초

- 코틀린의 if 는 statement 가 아니고 expression 이다.
- 식이 본문인 함수의 반환 타입은 생략할 수 있다. 
- `val` 참조 자체는 불변이더라도 참조가 가리키는 객체의 내부 값은 변경될 수 있다. (Java 와 동일)
- 여러 클래스를 한 파일에 넣을 수 있고 파일의 이름도 마음대로 정할 수 있다. 어느 디렉터리에 소스코드 파일을 위치시키든지 상관없다. (그러나 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다)
- `when` 문의 분기의 끝에 `break` 를 넣지 않아도 된다.
- `when` 식의 인자로는 어떤 객체든 사용할 수 있다.
- 어떤 변수가 원하는 타입인지 검사하고 나면 변수를 원하는 타입으로 캐스팅하지 않아도 원하는 타입으로 선언된다. (스마트 캐스트)
- `throw`  는 식이다.
- 체크 예외가 존재하지 않는다.

## 3장 함수 정의와 호출

- 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스다.
- 유틸리티 클래스 이름 없이 함수를 선언할 수 있다.
- 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.
- 확장함수 안에서는 클래스 내부에서만 사용할 수 있는 private 멤버나 protected 멤버를 사용할 수 없다. 단 확장 함수는 단지 정적 메서드 호출에 대한 문법적 편의일 뿐이다.
	- 확장 함수가 정적 메서드와 같은 특징을 가지므로 확장 함수를 하위 클래스에서 오버라이드할 수는 없다.
- 코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다.
- 함수를 중위 호출에 사용하게 허용하고 싶으면 `infix` 변경자를 함수 선언 앞에 추가해야 한다.

## 4장 클래스, 객체, 인터페이스

- `sealed` 변경자는 클래스 상속을 제한한다.
- 코틀린에서는 `override` 변경자를 꼭 사용해야 한다.
- 코틀린의 클래스와 메서드는 기본적으로 `final` 이다.
- 어떤 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 한다.
	- 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메서드는 기본적으로 열려있기 때문에 오버라이드하지 못하게 막으려면 `final` 을 명시해야 한다.
- 코틀린의 기본 가시성은 `public` 이다.
- 코틀린의 `protected` 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.
- `sealed` 클래스는 자동으로 `open` 이다.
- 부 생성자는 `constructor` 키워드로 시작한다.
- 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다. 또한 게터와 세터가 있는 프로퍼티를 선언할 수도 있다.
- == 가 두 객체를 비교하는 기본적인 방법이다. 내부적으로 `equals` 호출함.
	- 참조 비교를 위해서는 === 연산자를 사용할 수 있다.
- 싱글턴을 ‘객체 선언’ 이라는 기능으로 제공한다.