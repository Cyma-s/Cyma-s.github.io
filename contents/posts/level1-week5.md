---
title   : 레벨1 5주차
date    : 2023-03-07 10:42:20 +0900
updated : 2023-03-08 11:55:16 +0900
tags     : 
- 레벨1
- 우테코
---
# 3/7

## 좋은 객체의 덕목
- 읽어보기 [좋은 객체](https://codingnuri.com/seven-virtues-of-good-object/)

## 상속과 조합

### 상속
- 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 자체가 아니다.

#### 가상 메서드 (virtual method)
- 클래스와 메서드를 ```final```이나 ```abstract``` 둘 중 하나로 제한하면 문제가 발생할 가능성을 없앨 수 있다. 상위 클래스가 final이라면 상속이 불가능하다.
- 상위 클래스의 내부 구현이 달라지면 하위 클래스가 오동작할 수 있다.

### 조합
- 새로운 클래스를 만들고 기존 클래스의 인스턴스를 참조하게 하는 것
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. (is-a 관계)
- 상속이 적절한 경우: 확장이 아닌, 정제를 하는 경우
  - 확장: 새로운 행동을 덧붙여 기존의 행동을 부분적으로 보완하는 것
  - 정제: 부분적으로 불완전한 행동을 완전하게 만드는 것

## 실패 원자성
- 호출된 메서드가 실패하더라도 호출된 메서드의 객체는 메서드 호출 전 상태를 유지해야 한다.
- 예외가 발생하더라도 객체의 일관성이 유지되어 정상적으로 사용 가능한 상태를 유지한다.
- 불변 객체의 특성상 원본 객체와 같은 새로운 객체를 생성하는 방법을 사용하기는 힘들다. 그러나 복구하기 힘든 예외가 발생한 경우에, 원본 객체가 불안정한 상태에 빠지는 경우는 없다.
- 망가진 객체는 더 이상 정상적으로 사용할 수 없다. 예외를 잘 처리해도 이미 객체 내부의 값이 바뀐 경우는 재앙이 된다.

## 시간적 결합
> 메서드 A는 언제나 반드시 메서드 B보다 먼저 호출해야 한다.

- 이런 방식은 유연하지 않고, 현실적이지 않다.
- 순서에 의존하지 않는 동시성을 보장할 프로그램을 만들어야 한다.
- 시간적 결합이 없는 작업들은 동시에 처리될 수 있다. 따라서 다양한 설계에 대한 측면을 바라볼 수 있게 된다.

## 가변 객체와 불변 객체
- 모든 클래스를 상태를 변경할 수 없는 불변 클래스로 만들면 유지 보수성이 크게 향상된다.
- 불변 객체의 크기가 작은 이유: 생성자 안에서만 상태를 초기화할 수 있기 때문이다.

### 불변 객체
- 변경이 불가능한 객체
- 객체를 생성 후 외부에 의해 상태를 바꿀 수 없다. (heap 영역에서 객체가 가리키고 있는 데이터 자체의 변화가 불가능하다는 뜻이다.)

#### 장점
- 생성자, 접근 메서드에 대한 방어적 복사가 필요 없다. 접근 메서드에서도 별개의 객체를 리턴하기 때문이다.
- 멀티 스레드 환경이라면 동기화 처리 없이 객체를 공유할 수 있다. 동기화하기 위한 값이 변경되지 않기 때문이다.
- 객체를 신뢰할 수 있다.

#### 단점
- 객체가 가지는 값마다 새로운 인스턴스를 생성해야 한다.

## 라이브 코딩
- ```assertThat(card).isSameAs(Card.of(ACE, FOUR));```
- ```computeIfAbsent(toKey(suit, denomination), ignore -> new Card(suit, denomination));```
  - toKey: ```return suit.name() + denomination.name();```

# 3/8
## 데이터베이스 기초
### POST
- 클라이언트에서 웹 서버로 어떠한 정보를 제출한다.
- 데이터는 HTTP 바디에 담아 전송한다.
- 데이터가 노출되지 않고, 길이 제한이 없다.

### 응답 코드
- 특정 HTTP 요청이 성공적으로 완료되었는지
- 2xx : 성공 응답. 이 작업을 수신하여 이해했고 승낙했으며 성공적으로 처리했다.
- 3xx : 리다이렉션. 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
  - 301 영구 이동 : 요청한 페이지를 새 위치로 영구적으로 이동한다.
  - 302 임시 이동 : 다른 페이지로 이동하지만 나중에 바뀔 수 있다.
- 4xx : 클라이언트 오류
- 5xx : 서버 오류

### 데이터 중복
- 파일 처리 시스템은 각 파일마다 필요한 데이터를 각각 가지고 있어야 한다.

### 비일관성
- 데이터에 변경 사항이 조금만 있어도 각 파일에서 해당되는 데이터를 모두 변경해야 하며 한꺼번에 수정되지 않으면 곤란하다(?)

### 보안성
- 파일을 누구나 수정할 수 있다.

### 데이터베이스
- 데이터의 집합
- 관리하는 시스템과 통합되어 제공되며 따라서 정확한 명칭은 데이터베이스 관리 시스템 (DBMS)
- 관계형 데이터베이스 (RDMS)
- 비관계형 데이터베이스 (NoSQL)

#### 특징
- 데이터 공유 : 일정한 형식을 필터링 후 저장 / 여러 명이 데이터를 동시 공유하는 것
- 데이터 중복의 최소화 : 하나의 데이터베이스에 여러 응용 프로그램이 접근 가능할 수 있다.
- 계속적 변화에 대한 공유 : 항상 최근의 정확한 데이터를 동적으로 유지하는 특징 존재
- 데이터 논리적 독립성 : 응용 프로그램과 데이터 베이스를 독립 시킨다.

### 관계형 데이터베이스
- DB계의 주류
- 컬럼과 로우로 이루어진 테이블 형태로 저장
- 데이터의 종속성은 관계로 표현한다.
- 스키마 : 테이블에 적재될 데이터의 구조와 형식을 정의하는 것.

### SQL
- Structured Query Language
- 데이터를 저장하거나 얻기 위해서 사용하는 표준화된 언어
- 질의문 혹은 쿼리

### where
- like
	``` select * from movie where title like '%클'```
- %클 : 앞에는 무엇이든지 와야 하지만 뒷자리는 클이어야 한다.
- 클% : 앞자리는 클리어야 하고, 뒷글자는 무엇이든지 가능하다.
- %클% : 클이라는 글자를 갖는 title이 포함된 결과를 검색한다.

### update
- 테이블의 데이터를 변경한다.
```UPDATE `tbl_name` SET `col1_name`=`값1` WHERE `col1_name`=`조건` ```
### delete
- 테이블의 데이터를 삭제한다.
```DELETE FROM `tbl_name` WHERE `col1_name`=`조건` ```

### group by
- 그룹핑하여 조회한다.
```
SELECT *
FROM movie
GROUP BY title, openning_date;
```

제목 별로 나눈 다음, openning_date에 따라 다시 나눈다.

### having
- 집계 함수의 결과가 조건에 맞는 데이터를 조회한다.
```
SELECT
FROM
GROUP BY
HAVING 집계함수(`col2_name`) >= 조건
```

- limit : 지정한 개수만큼 조회한다.
```
select *
from movie
limit row_count
```

- order by
```
order by `col2_name` ASC|DESC
```

### 순서
from -> where -> group by -> having -> select -> order by -> limit

## 키
- 대체 키
- 외래 키
- 슈퍼 키

### PK
- 기본적으로 NOT NULL
- 키는 중복될 수 없다.

## 트랜잭션
- 일련의 작업 단위
- 데이터의 무결성을 보장받을 수 있다.
- 성공 또는 실패 -> 트랜잭션은 원자성을 갖는다.

## API
- Application Programming Interface
- 다양한 컴포넌트 간의 통신 방법

### 인터페이스
- 두 물체 공간, 단계 등의 공통 경계면
- 독립되고 관계가 없는 시스템끼리 접촉하거나 통신이 일어나는 부분
- CUI (Character User Interface)
- GUI (Graphical User Interface)