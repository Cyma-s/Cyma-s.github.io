---
title: 10장. 실행 계획
date: 2023-11-03 15:31:56 +0900
updated: 2023-11-03 16:30:15 +0900
tags:
  - mysql
  - database
  - real-my-sql
---

## 통계 정보

테이블 및 인덱스에 대한 통계 정보를 뜻한다.

### MySQL 서버의 통계 정보

MySQL 5.6 버전부터 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선되었다. 즉, MySQL 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 되었다. 

`innodb_stats_auto_recalc` 시스템 설정 변수의 값을 OFF 로 설정해서 통계 정보가 자동으로 갱신되는 것을 막을 수 있다. `innodb_stats_auto_recalc` 시스템 설정 변수의 기본값은 ON 이므로 영구적인 통계 정보를 이용하고자 한다면 해당 설정을 OFF 로 변경할 수 있다. 

## 히스토그램

5.7 버전까지 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. 이를 메우기 위해 실행 게획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다. 

8.0 버전부터 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

### 히스토그램 정보 수집 및 삭제

히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령을 수행해 수동으로 수집 및 관리된다. 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 information_schema 데이터베이스의 column_statistics 테이블로 로드한다. 

다음과 같은 두 종류의 히스토그램 타입이 지원된다. 

- singleton: 컬럼값 개별로 레코드 건수를 관리하는 히스토그램. Value-based 히스토그램이나 도수 분포라고도 불린다.
- Equi-Height: 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로 Height-Balanced 히스토그램이라고도 불린다. 

히스토그램은 버킷 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리된다. 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며, 높이 균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다. 

싱글톤 히스토그램은 각 버킷이 컬럼의 값과 발생 빈도 비율, 2개 값을 갖는다.  
반면 높이 균형 히스토그램은 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 4개의 값을 갖는다. 

싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 (히스토그램의 버킷 수보다 적은) 경우 사용된다. 
- [!] 히스토그램의 모든 레코드 건수 비율은 누적으로 표시된다. 

높이 균형 히스토그램은 컬럼값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다. 히스토그램의 버킷 범위가 뒤로 갈수록 비율이 높아지는 것으로 보이지만, 사실은 범위별로 비율이 같은 수준에서 hire_date 컬럼의 범위가 선택된 것이다. (즉, 그래프의 기울기가 일정하면 각 범위가 비슷한 값을 갖는다는 것을 알 수 있다.)

생성된 히스토그램은 `DROP HISTOGRAM ON 컬럼 이름` 으로 삭제할 수 있다. 히스토그램의 삭제 작업은 테이블의 데이터를 참조하는 것이 아닌, 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주지 않고 즉시 완료된다. 그러나 히스토그램이 사라지면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다. 

히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 하려면 `optimizer_switch` 시스템 변수의 값을 변경하면 된다. 

```sql
SET GLOBAL optimizer_switch='condition_fanout_filter=off';
```

`optimizer_switch` 시스템 변수의 값을 글로벌로 변경하면 MySQL 서버의 모든 쿼리가 히스토그램을 사용하지 않는다. 또한 `condition_fanout_filter` 옵션에 의해 영향받는 다른 최적화 기능들이 사용되지 않을 수도 있으니 주의하자.

특정 커넥션 또는 특정 쿼리에서만 히스토그램을 사용하지 않고자 한다면 다음과 같은 방법을 사용하면 된다. 

```sql
-- // 현재 커넥션에서 실행되는 쿼리만 히스토그램을 사용하지 않도록 설정

SET SESSION optimizer_switch='condition_fanout_filter=off';

-- // 현재 쿼리만 히스토그램을 사용하지 않도록 설정

SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */ *
FROM ...
```

### 히스토그램의 용도

기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 컬럼이 갖는 유니크한 값의 개수 정도였다. 예를 들면 테이블의 레코드가 1000건이고 어떤 컬럼의 유니크한 값 개수가 100개였다면 MySQL 서버는 해당 컬럼에 대해 다음과 같은 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측한다. 

그러나 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는데, 이전 MySQL 서버의 기존 통게 정보는 이런 정보를 고려하지 못했다. 이를 보완하기 위해 히스토그램이 도입되었다. 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 버킷 별로 레코드의 건수와 유니크한 값의 개수 정보를 갖기 때문에 훨씬 정확한 예측을 할 수 있다.

히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것이라고 예측한다. 하지만 히스토그램 정보가 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다. 

인덱싱되지 않은 컬럼들에 히스토그램이 없다면 옵티마이저는 컬럼들의 데이터 분포를 전혀 알지 못하고 실행 계획을 수립하게 된다. 상황에 따라 어떤 테이블이라도 조인의 드라이빙 테이블이 될 수 있는 것이다. 

이런 차이로 인해 쿼리의 성능은 10배 정도 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아서 디스크에서 데이터를 읽어야 하는 경우라면 몇 배의 차이가 발생할 수도 있다. 각 컬럼에 대해 히스토그램 정보가 있다면 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있을지 옵티마이저가 더 정확히 판단할 수 있다.

### 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이므로 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 점에서 어느 정도 공통점을 가진다고 볼 수 있다. 

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree 를 샘플링해서 살펴본다. 이 작업을 인덱스 다이브 (Index Dive) 라고 표현한다.

쿼리의 검색 조건으로 많이 사용되는 컬럼에 대해서는 일반적으로 인덱스를 생성한다. 그런데 이렇게 인덱스된 컬럼에 대해 히스토그램 정보를 수집해두는 것이 좋은지 고민스러울 수 있다. 

MySQL 8.0 서버에서는 인덱스된 컬럼을 검색 조건으로 사용하는 경우, 그 컬럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다. 이는 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다. 즉, MySQL 8.0 버전에서 히스토그램은 주로 인덱스되지 않은 컬럼에 대한 데이터 분포도를 참조하는 용도로 사용된다. 

그러나 인덱스 다이브 작업은 어느 정도의 비용이 필요하며, 때로는 (IN 절에 값이 많이 명시된 경우) 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하고 비용도 그만큼 커진다.

### 코스트 모델

MySQL 서버가 쿼리를 처리하려면 다양한 작업이 필요하다.

- 디스크로부터 데이터 페이지 읽기
- 메모리 (InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
- 인덱스 키 비료
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

MySQL 서버는 사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다. 이렇게 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용을 코스트 모델이라고 한다. 

MySQL 5.7 버전부터 MySQL 서버의 소스 코드에 상수화되어 있던 각 단위 작업의 비용을 DBMS 관리자가 조정할 수 있도록 개선되었다. 그러나 인덱스되지 않은 컬럼의 데이터 분포나 메모리에 상주 중인 페이지의 비율 등 비용 계산과 연관된 부분의 정보가 부족한 상태였다. MySQL 8.0 버전으로 업그레이드 되면서 비로소 컬럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다. 

MySQL 8.0 서버의 코스트 모델은 다음 2개 테이블에 저장돼 있는 설정 값을 사용한다. 두 테이블 모두 `mysql` DB 에 존재한다.

- `server_cost`: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- `engine_cost`: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리

두 테이블은 공통적으로 다음의 5개 컬럼을 가지고 있다. `last_updated` 와 `comment` 컬럼의 값은 MySQL 서버 옵티마이저에 영향을 미치는 정보는 아니고, 단순 정보성으로 관리되는 컬럼이다.

- `cost_name`: 코스트 모델의 각 단위 작업
- `default_value`: 각 단위 작업의 비용(기본값이며, 이 값은 MySQL 서버 소스 코드에 설정된 값)
- `cost_value`: DBMS 관리자가 설정한 값 (이 값이 NULL 이면 MySQL 서버는 `default_value` 컬럼의 비용을 사용한다.)
- `last_updated`: 단위 작업의 비용이 변경된 시점
- `comment`: 비용에 대한 추가 설명

`engine_cost` 테이블은 위의 5개 컬럼에 추가로 다음 컬럼들을 더 가지고 있다. 

- `engine_name`: 비용이 적용된 스토리지 엔진
- `device_type`: 디스크 타입

`engine_name` 컬럼은 스토리지 엔진별로 각 단위 작업의 비용을 설정할 수 있는데, 기본값은 `default` 이다. MEMORY 스토리지 엔진, 그리고 MyISAM 과 InnoDB 스토리지 엔진에 대해 단위 작업의 비용을 달리 설정하고 싶다면 `engine_name` 컬럼을 이용하면 된다. `device_type` 은 디스크의 타입을 설정할 수 있는데, MySQL 8.0 에서는 아직 이 컬럼의 값을 활용하지 않아 "0" 만 설정할 수 있다. 

