---
title: Transactional
date: 2023-05-29 19:38:14 +0900
updated: 2023-09-19 13:28:58 +0900
tags:
  - spring
---

## 트랜잭션이란

DBMS에서 수행되는 논리적인 작업의 단위를 말한다. 
하나 이상의 데이터베이스 조작 (INSERT, UPDATE, DELETE 등)을 묶어 하나의 작업으로 처리한다.

### 트랜잭션의 특성 (ACID)

1. 원자성: 트랜잭션의 모든 연산은 하나의 원자적 작업 단위로 간주된다. 모든 연산이 성공적으로 수행되면 트랜잭션은 커밋되어 영구적으로 적용되고, 하나라도 실패하면 트랜잭션은 롤백되어 이전 상태로 복원된다. -> 트랜잭션의 연산은 전부 수행되거나 전혀 수행되지 않아야 한다.
2. 일관성: 트랜잭션이 수행되기 전, 후의 데이터베이스 상태는 일관된 상태를 유지해야 한다. 즉, 데이터베이스에 저장된 데이터의 제약 조건, 규칙, 관계 등이 모두 만족되어야 한다. 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 된다.
3. 격리성: 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다. 각 트랜잭션은 시스템 내에서 독립적으로 실행되는 것처럼 보여야 한다.
4. 지속성: 트랜잭션이 커밋된 후에는 해당 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장되어야 한다. 시스템 장애나 복구 작업 같은 예외 상황이 발생하더라도 트랜잭션이 커밋되었으면 결과는 영구적으로 보존되어야 한다.

### 트랜잭션의 과정

1. 트랜잭션 시작: 트랜잭션을 시작할 수 있는 레벨을 설정하고, 해당 레벨에서 동작하는 새로운 트랜잭션을 시작한다.
2. 데이터베이스 조작: 새로 생성된 트랜잭션 내에서 데이터 조회, 입력, 수정, 삭제 등의 조작을 수행한다.
3. 데이터 검증: 데이터 조작이 모두 성공적으로 처리되었다면, COMMIT을 수행한다. 그러나 데이터 조작 오류가 발생하면 ROLLBACK 명령을 실행하여 이전 상태로 되돌린다.
4. 트랜잭션 종료: 트랜잭션을 완료하고, 해당 레벨의 트랜잭션을 종료한다. 

### 트랜잭션 레벨

동시에 실행중인 여러 트랜잭션 간의 데이터 일관성과 격리 수준을 조절하는데 사용된다.

### 트랜잭션 격리 수준

#### Read Uncommitted (레벨 0)
- 트랜잭션에서 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
- SELECT 문장이 수행되는 동안 해당 데이터에 shared lock이 걸리지 않는다.
- 데이터 부정합 문제가 발생할 확률이 높으나, 성능은 가장 빠르다.
- DirtyRead, Non-Repeatable Read, Phantom Read 현상이 발생한다.
- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많다. MySQL을 사용한다면 Read Committed 이상의 격리 수준을 사용하자.

#### Read Committed (레벨 1)
- 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용한다. 
- SELECT 문장이 수행되는 동안 해당 데이터에 shared lock이 걸린다. 따라서 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없고, 대기한다. 즉, data 10을 50으로 변경하는 동안 다른 사용자는 바뀐 데이터에 접근할 수 없다. (data 50에 접근할 수 없다.)
- 실제 테이블 값을 가져오는 것이 아닌, Undo 영역에 백업된 레코드에서 값을 가져온다. Undo 영역은 트랜잭션의 롤백 대비를 위해, 트랜잭션의 격리 수준을 유지하며 높은 동시성을 제공하기 위해 사용된다.
![[transacion-read-committed.png]]
- Non-Repeatable Read, Phantom Read 문제가 발생한다.
- 일반적인 웹 애플리케이션에서는 크게 문제가 되지 않지만, 입출금 같은 금전과 관련이 된다면 문제가 될 수 있다. 

#### Repeatable Read (레벨 2)
- 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 같음을 보장한다. Undo 영역에 백업된 이전 데이터를 사용한다.
- 실행되는 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 undo 영역의 데이터는 삭제할 수 없다.
- 즉, 10번 트랜잭션에서 실행되는 모든 SELECT 쿼리는 10번보다 작은 트랜잭션 번호에서 변경한 내용만 보게 된다. 10번 트랜잭션이 실행되는 도중에 12번 트랜잭션이 UPDATE 쿼리를 수행해도 12번 트랜잭션의 변경 사항은 10번 트랜잭션 SELECT 쿼리에 영향을 줄 수 없다.
- 하나의 레코드에 대해 백업이 하나 이상 존재할 수 있다. 따라서 한 사용자가 트랜잭션을 시작한 후 장기간 트랜잭션을 종료하지 않는 경우에는 Undo 영역이 계속해서 확장되고, 백업 레코드가 많아질수록 MySQL 서버의 처리 성능이 떨어질 수 있다.
- Phantom Read 문제가 발생한다. (그러나 MySQL InnoDB는 MVCC 다중 버전 제어를 통해 Phantom Read 문제를 해결한다.)

#### Serializable (레벨 3)
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 접근할 수 없다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.
- 동시 처리 성능이 다른 트랜잭션 격리 수준에 비해 현저히 떨어진다.
- `SERIALIZABLE` 격리 수준에서 

#### MySQL InnoDB가 Phantom Read를 해결하는 방법 - MVCC 다중 버전 제어

MVCC(Multi Version Concurrency Control) -> 잠금을 사용하지 않는 일관된 읽기를 제공한다.
동시성 제어를 위한 기술로, 여러 개의 버전을 생성하여 트랜잭션간 충돌을 방지한다.

각각의 트랜잭션은 일련번호를 할당받고, 트랜잭션의 시작 지점이 빠른 트랜잭션은 숫자가 작다.
데이터베이스의 각 레코드는 변경 이력을 추적하기 위해 여러 버전으로 관리되는데, 이때 해당 레코드를 변경한 트랜잭션의 일련번호가 함께 저장된다.

트랜잭션의 시작 시점에 따라서 해당 시점 이전에 커밋된 트랜잭션들의 변경 내역만을 볼 수 있도록 설정된다. 
즉, 10번 트랜잭션의 경우 10보다 작은 일련 번호를 갖는 트랜잭션이 변경한 내역들만 볼 수 있다. 
다른 트랜잭션이 트랜잭션 실행 중에 데이터를 변경하더라도 실행 중인 트랜잭션은 변경 내용을 알 수 없다.

##### 트랜잭션 ID 할당 시점

MySQL 의 InnoDB 스토리지 엔진에서 DB_TRX_ID 는 특정 레코드를 마지막으로 수정한 트랜잭션 ID를 나타낸다.      

**트랜잭션이 시작되는 즉시 트랜잭션 ID 를 부여받는 것은 아니다.** InnoDB 가 경합을 줄이고 동시성을 향상시키기 위해서 lazy 한 방식으로 동작하기 때문이다.     

트랜잭션이 데이터를 수정하려고 시도할 때만 트랜잭션 ID 가 할당된다.       
트랜잭션에 의해 행이 수정되면 해당 행의 DB_TRX_ID 필드에 트랜잭션 ID 가 저장된다. 해당 ID는 InnoDB가 마지막으로 수정한 트랜잭션을 추적하는 데 도움이 된다. 

트랜잭션이 종료되고 트랜잭션이 커밋되면 변경 사항이 디스크에 기록되고 이후 모든 트랜잭션에서 변경 사항을 볼 수 있다. 트랜잭션이 롤백되면 해당 트랜잭션에 의해 변경된 내용은 undo log의 정보를 사용하여 실행 취소된다.     

트랜잭션 ID가 lazy 할당 되기 때문에 읽기 전용 트랜잭션이나 데이터베이스를 수정하지 않는 트랜잭션이 불필요하게 트랜잭션 ID를 사용하지 않도록 한다.     

#### 예시

1. 격리수준 serializable 트랜잭션 A가 먼저 시작된다. 이후 트랜잭션 B가 시작된다. 그 다음 트랜잭션 B가 table1 에 12를 insert 하고 commit 해서 트랜잭션 A보다 먼저 종료되었다. 이 경우, 트랜잭션 B가 트랜잭션 A보다 먼저 처리된 것으로 간주하여 A는 B의 반영사항을 그대로 읽을 수 있다.
2. 격리수준 repeatable read 트랜잭션 A가 먼저 시작된다. 이후 트랜잭션 B가 시작된다. 그 다음 트랜잭션 B가 table1 에 12를 insert 하고 commit 해서 트랜잭션 A보다 먼저 종료되었다. 이 경우, 트랜잭션 A는 B가 반영한 정보(12)를 볼 수 없다. 이유는 undo 영역의 snapshot 을 사용하여 트랜잭션 A가 유지되는 기간 동안 동일한 데이터를 읽어오기 때문이다.

### 트랜잭션 격리 수준에서 발생할 수 있는 문제점

#### Dirty Read
특정 트랜잭션에 의해 데이터가 변경되었으나, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 트랜잭션 내부에서 발생한 변경 사항을 조회할 수 있는 문제이다. 

A 트랜잭션에서 데이터를 변경하고 커밋하지 않은 시점에 B 트랜잭션이 변경된 데이터를 읽은 상황에서 A 트랜잭션이 롤백하게 되면 치명적일 수 있다. B 트랜잭션은 롤백으로 무효가 된 데이터를 가지고 처리를 진행하기 때문에 문제가 발생한다.

#### Non-Repetable Read
같은 트랜잭션 내에서 같은 데이터를 여러 번 조회했을 때 읽어온 데이터가 다른 경우를 의미한다.

#### Phantom Read
Non-Repeatable Read의 한 종류로, 조회해온 결과의 행이 새로 생기거나 없어지는 현상이다.

**참고**
- https://hudi.blog/transaction-isolation-level/
- https://mysqldba.tistory.com/334
- https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation

### Lock

## 선언적 트랜잭션이란

트랜잭션의 동작을 명시적으로 정의하지 않고, 선언적인 방식으로 트랜잭션을 처리하는 개념이다. 주로 프레임워크나 라이브러리 수준에서 정의된다.

개발자가 명시적으로 트랜잭션을 관리하는 대신, 프레임워크에게 책임을 위임하여 간단한 설정이나 어노테이션으로 트랜잭션을 선언하고 처리한다. 

## `@Transactional` 이란

Spring의 선언적 트랜잭션 방식 중 하나이다. 

트랜잭션을 적용하고자 하는 클래스나 메서드 위에 `@Transactional` 을 선언하면 트랜잭션 기능이 적용된 프록시 객체가 생성되고, `@Transactional` 이 포함된 메서드가 호출되는 경우 `PlatformTransactionManager` 를 사용하여 트랜잭션을 시작한다.

### propagation 옵션

트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할 지 결정하는 것을 트랜잭션의 전파 설정이라고 한다.

#### 물리 트랜잭션 vs 논리 트랜잭션

1개의 트랜잭션을 사용한다는 것은 하나의 Connection 객체를 사용한다는 것이다. 
트랜잭션이 실제 데이터베이스의 트랜잭션을 사용한다는 점에서 **물리 트랜잭션**이라고 한다. 
커넥션을 통해 커밋/롤백하는 단위이다.

전파 속성에 따라 외부 트랜잭션과 내부 트랜잭션이 동일한 트랜잭션을 사용할 수도 있다.
스프링에서는 실제 데이터베이스 트랜잭션과 스프링이 처리하는 트랜잭션을 구분하기 위해 **논리 트랜잭션**이라는 개념이 등장했다.

트랜잭션 전파 없이 1개의 트랜잭션만 사용되면 물리 트랜잭션만 존재하고, 트랜잭션 전파가 사용될 때 논리 트랜잭션 개념이 사용된다. 

#### 종류

- `REQUIRED` : 기본값. 부모 트랜잭션이 존재하는 경우 참여하고, 존재하지 않는 경우 트랜잭션을 새롭게 생성한다.
- `SUPPORTS` : 부모 트랜잭션이 존재하는 경우 참여하고, 없는 경우 non-transactional 상태로 실행한다.
- `MANDATORY` : 부모 트랜잭션이 있으면 참여하고, 없는 경우 예외를 발생시킨다.
- `REQUIRES_NEW`
	- 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션을 생성한다. 
	- 부모/자식 트랜잭션의 롤백 여부는 서로 영향을 주지 않는다.
	- 내부 트랜잭션이 롤백되는 경우는 실제 Connection에 롤백을 호출하는 경우이므로 트랜잭션이 종료된다.
	- 
- `NOT_SUPPORTED` : non-transactional 상태로 실행하며, 부모 트랜잭션이 존재하는 경우 일시 정지 시킨다.
- `NEVER` : non-transactional 상태로 실행하며, 부모 트랜잭션이 존재하는 경우 예외를 발생시킨다.
- `NESTED`
	- 부모 트랜잭션과는 별개의 중첩된 트랜잭션을 만든다. 
	- 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자식 트랜잭션의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다. 
	- 부모 트랜잭션이 없는 경우에는 새로운 트랜잭션을 생성한다.

**참고**
- https://hwannny.tistory.com/98

### readOnly 옵션

기본적으로는 false로 설정되어 있다.

**true로 설정하는 경우**: 데이터에 대해 Lock을 적용할 필요가 없고, 접근할 수 있는 데이터(스냅샷, 튜플 등)가 변경되지 않기 때문에 일관적인 데이터를 읽어오고 제공할 수 있다.

조회 작업만 수행한다는 것을 명시적으로 나타낼 수 있다.

#### MySQL에서의 readOnly

SELECT 문에 대해서만 기능을 지원하고, Transaction ID 설정에 대한 오버헤드를 해결할 수 있다. (MVCC) 
즉, Read Only 트랜잭션에 대해서는 Transaction ID가 부여되지 않는다.

별도의 스냅샷을 통해 데이터를 조회하기 때문에 데이터 일관성을 보장할 수 있다. 
데이터 변경과 같이 조회가 아닌 작업을 하는 경우 에러를 발생시킨다.

- 스냅샷 : 데이터 수정 요청이 전달되었을 때, 변경되는 데이터를 따로 저장해두는 것.

### isolation 옵션

- `DEFAULT`: 기본적으로 `DEFAULT` 옵션이 적용되어 있다. 사용하는 DB의 기본 격리 수준을 따른다.
- `READ_UNCOMMITTED` : 커밋되지 않은 데이터를 다른 트랜잭션에서 접근 가능하다.
- `READ_COMMITTED` : 매 조회가 이루어질 때마다 새로운 스냅샷을 뜨기 때문에 다른 트랜잭션이 커밋하면 (변경 사항이 존재하면) 변경된 데이터를 볼 수 있다. 즉, B 트랜잭션이 끝나기 전에 A 트랜잭션에 의해 데이터가 변경되면 다시 조회할 때 변경된 데이터를 읽게 된다.
- `REPEATABLE__READ` : 조회한 데이터에 대해 Shared Lock이 걸려서 다른 트랜잭션이 새로운 데이터를 추가할 수 있다. A 트랜잭션이 시작하고 처음 조회한 데이터의 스냅샷을 저장하고, 이후에 동일한 쿼리를 호출하면 해당 스냅샷에서 데이터를 가져온다. 즉, B 트랜잭션이 새로 커밋해도 (변경 사항이 있어도) A 트랜잭션이 조회하는 데이터는 변하지 않는다.
- `SERIALIZED` : 읽기 작업에도 락을 걸어 여러 트랜잭션이 동시에 같은 데이터에 접근할 수 없다. 가장 안전하지만 성능 저하가 크기 때문에 자주 사용되지 않는다.

### ProxyMode

프록시를 생성하는 방식을 제어하는데 사용되는 옵션이다. 

1. ProxyMode.DEFAULT
	- 스프링이 프록시 모드를 결정한다.
	- 인터페이스를 구현하고 있는 경우에는 ProxyMode.PROXY를, 구현하지 않는 경우에는 ProxyMode.TARGET_CLASS를 사용한다.
2. ProxyMode.PROXY
	- JDK 기반의 다이나믹 프록시를 생성한다.
	- 대상 객체가 인터페이스를 구현하고 있어야 한다.
	- 대상 객체의 인터페이스 메서드 호출 시 프록시를 거쳐 AOP 동작을 호출한다.
3. ProxyMode.ASPECTJ
	- AspectJ를 사용하여 프록시를 생성한다.
	- 인터페이스를 구현하고 있지 않아도 된다.
	- 컴파일 타임에 AspectJ 

**갑자기 무슨 인터페이스라는 말인가...**

> 스프링 AOP에서 ProxyMode.PROXY를 사용하는 경우, 대상 객체는 인터페이스를 구현하고 있어야 합니다. 이는 JDK 다이나믹 프록시를 사용하여 프록시 객체를 생성하기 때문입니다. 다이나믹 프록시는 인터페이스의 구현을 바탕으로 프록시 객체를 생성하므로, 대상 객체가 인터페이스를 구현하지 않으면 프록시를 생성할 수 없습니다. **by G-선생**

