---
title   : 레벨1 5주차
date    : 2023-03-07 10:42:20 +0900
updated : 2023-03-07 11:33:33 +0900
tags     : 
- 레벨1
- 우테코
---
# 3/7

## 좋은 객체의 덕목
- 읽어보기 [좋은 객체](https://codingnuri.com/seven-virtues-of-good-object/)

## 상속과 조합

### 상속
- 객체 사이의 관계를 너무 복잡하게 만들기도 하지만 근본적인 원인은 상속 자체가 아니다.

#### 가상 메서드 (virtual method)
- 클래스와 메서드를 ```final```이나 ```abstract``` 둘 중 하나로 제한하면 문제가 발생할 가능성을 없앨 수 있다. 상위 클래스가 final이라면 상속이 불가능하다.
- 상위 클래스의 내부 구현이 달라지면 하위 클래스가 오동작할 수 있다.

### 조합
- 새로운 클래스를 만들고 기존 클래스의 인스턴스를 참조하게 하는 것
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. (is-a 관계)
- 상속이 적절한 경우: 확장이 아닌, 정제를 하는 경우
  - 확장: 새로운 행동을 덧붙여 기존의 행동을 부분적으로 보완하는 것
  - 정제: 부분적으로 불완전한 행동을 완전하게 만드는 것

## 실패 원자성
- 호출된 메서드가 실패하더라도 호출된 메서드의 객체는 메서드 호출 전 상태를 유지해야 한다.
- 예외가 발생하더라도 객체의 일관성이 유지되어 정상적으로 사용 가능한 상태를 유지한다.
- 불변 객체의 특성상 원본 객체와 같은 새로운 객체를 생성하는 방법을 사용하기는 힘들다. 그러나 복구하기 힘든 예외가 발생한 경우에, 원본 객체가 불안정한 상태에 빠지는 경우는 없다.
- 망가진 객체는 더 이상 정상적으로 사용할 수 없다. 예외를 잘 처리해도 이미 객체 내부의 값이 바뀐 경우는 재앙이 된다.

## 시간적 결합
> 메서드 A는 언제나 반드시 메서드 B보다 먼저 호출해야 한다.

- 이런 방식은 유연하지 않고, 현실적이지 않다.
- 순서에 의존하지 않는 동시성을 보장할 프로그램을 만들어야 한다.
- 시간적 결합이 없는 작업들은 동시에 처리될 수 있다. 따라서 다양한 설계에 대한 측면을 바라볼 수 있게 된다.

## 가변 객체와 불변 객체
- 모든 클래스를 상태를 변경할 수 없는 불변 클래스로 만들면 유지 보수성이 크게 향상된다.
- 불변 객체의 크기가 작은 이유: 생성자 안에서만 상태를 초기화할 수 있기 때문이다.

### 불변 객체
- 변경이 불가능한 객체
- 객체를 생성 후 외부에 의해 상태를 바꿀 수 없다. (heap 영역에서 객체가 가리키고 있는 데이터 자체의 변화가 불가능하다는 뜻이다.)

#### 장점
- 생성자, 접근 메서드에 대한 방어적 복사가 필요 없다. 접근 메서드에서도 별개의 객체를 리턴하기 때문이다.
- 멀티 스레드 환경이라면 동기화 처리 없이 객체를 공유할 수 있다. 동기화하기 위한 값이 변경되지 않기 때문이다.
- 객체를 신뢰할 수 있다.

#### 단점
- 객체가 가지는 값마다 새로운 인스턴스를 생성해야 한다.

## 라이브 코딩
- ```assertThat(card).isSameAs(Card.of(ACE, FOUR));```
- ```computeIfAbsent(toKey(suit, denomination), ignore -> new Card(suit, denomination));```
  - toKey: ```return suit.name() + denomination.name();```

